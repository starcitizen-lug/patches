From bbc33d7ac10ce39ad846cbbf72c1e8d71918991b Mon Sep 17 00:00:00 2001
From: mactan-sc <77816662+mactan-sc@users.noreply.github.com>
Date: Mon, 26 Jan 2026 19:10:44 -0600
Subject: [PATCH] wineopenxr

---
 dlls/wineopenxr/Makefile.in            |   11 +
 dlls/wineopenxr/dxvk-interop.h         |  366 +
 dlls/wineopenxr/loader_structs.h       |   30 +
 dlls/wineopenxr/loader_thunks.c        | 4947 +++++++++++++
 dlls/wineopenxr/loader_thunks.h        | 3517 +++++++++
 dlls/wineopenxr/make_openxr            | 3583 +++++++++
 dlls/wineopenxr/openxr.c               |  409 ++
 dlls/wineopenxr/openxr_loader.c        | 2015 ++++++
 dlls/wineopenxr/openxr_loader.h        |  127 +
 dlls/wineopenxr/openxr_private.h       |   60 +
 dlls/wineopenxr/openxr_thunks.c        | 5448 ++++++++++++++
 dlls/wineopenxr/openxr_thunks.h        |  839 +++
 dlls/wineopenxr/vkd3d-proton-interop.h |  308 +
 dlls/wineopenxr/wineopenxr.h           | 9266 ++++++++++++++++++++++++
 dlls/wineopenxr/wineopenxr.json        |    7 +
 dlls/wineopenxr/wineopenxr.spec        |    5 +
 dlls/wineopenxr/wineopenxr64.json      |    6 +
 17 files changed, 30944 insertions(+)
 create mode 100644 dlls/wineopenxr/Makefile.in
 create mode 100644 dlls/wineopenxr/dxvk-interop.h
 create mode 100644 dlls/wineopenxr/loader_structs.h
 create mode 100644 dlls/wineopenxr/loader_thunks.c
 create mode 100644 dlls/wineopenxr/loader_thunks.h
 create mode 100755 dlls/wineopenxr/make_openxr
 create mode 100644 dlls/wineopenxr/openxr.c
 create mode 100644 dlls/wineopenxr/openxr_loader.c
 create mode 100644 dlls/wineopenxr/openxr_loader.h
 create mode 100644 dlls/wineopenxr/openxr_private.h
 create mode 100644 dlls/wineopenxr/openxr_thunks.c
 create mode 100644 dlls/wineopenxr/openxr_thunks.h
 create mode 100644 dlls/wineopenxr/vkd3d-proton-interop.h
 create mode 100644 dlls/wineopenxr/wineopenxr.h
 create mode 100644 dlls/wineopenxr/wineopenxr.json
 create mode 100644 dlls/wineopenxr/wineopenxr.spec
 create mode 100644 dlls/wineopenxr/wineopenxr64.json

diff --git a/dlls/wineopenxr/Makefile.in b/dlls/wineopenxr/Makefile.in
new file mode 100644
index 00000000000..05583209bba
--- /dev/null
+++ b/dlls/wineopenxr/Makefile.in
@@ -0,0 +1,11 @@
+MODULE     = wineopenxr.dll
+UNIXLIB    = wineopenxr.so
+IMPORTS    = advapi32 user32 dxgi winevulkan
+
+EXTRADEFS  = -DWINE_NO_LONG_TYPES
+
+SOURCES = \
+	openxr.c \
+	openxr_loader.c \
+	openxr_thunks.c \
+	loader_thunks.c \
diff --git a/dlls/wineopenxr/dxvk-interop.h b/dlls/wineopenxr/dxvk-interop.h
new file mode 100644
index 00000000000..946aa1e1203
--- /dev/null
+++ b/dlls/wineopenxr/dxvk-interop.h
@@ -0,0 +1,366 @@
+/*** Autogenerated by WIDL 3.5 from /home/yorha-2b/Valve/Proton/wine/include/wine/dxvk-interop.idl - Do not edit ***/
+
+#ifndef __REQUIRED_RPCNDR_H_VERSION__
+#define __REQUIRED_RPCNDR_H_VERSION__ 475
+#endif
+
+#include <rpc.h>
+#include <rpcndr.h>
+
+#ifndef COM_NO_WINDOWS_H
+#include <windows.h>
+#include <ole2.h>
+#endif
+
+#ifndef __dxvk_interop_h__
+#define __dxvk_interop_h__
+
+/* Forward declarations */
+
+#ifndef __IDXGIVkInteropSurface_FWD_DEFINED__
+#define __IDXGIVkInteropSurface_FWD_DEFINED__
+typedef interface IDXGIVkInteropSurface IDXGIVkInteropSurface;
+#ifdef __cplusplus
+interface IDXGIVkInteropSurface;
+#endif /* __cplusplus */
+#endif
+
+#ifndef __IDXGIVkInteropDevice_FWD_DEFINED__
+#define __IDXGIVkInteropDevice_FWD_DEFINED__
+typedef interface IDXGIVkInteropDevice IDXGIVkInteropDevice;
+typedef interface IDXGIVkInteropDevice2 IDXGIVkInteropDevice2;
+#ifdef __cplusplus
+interface IDXGIVkInteropDevice;
+interface IDXGIVkInteropDevice2;
+#endif /* __cplusplus */
+#endif
+
+/* Headers for imported files */
+
+#include <d3d11.h>
+#ifdef __WINESRC__
+#include "wine/vulkan.h"
+#else
+#include <vulkan/vulkan.h>
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*****************************************************************************
+ * IDXGIVkInteropSurface interface
+ */
+#ifndef __IDXGIVkInteropSurface_INTERFACE_DEFINED__
+#define __IDXGIVkInteropSurface_INTERFACE_DEFINED__
+
+DEFINE_GUID(IID_IDXGIVkInteropSurface, 0x5546cf8c, 0x77e7, 0x4341, 0xb0,0x5d, 0x8d,0x4d,0x50,0x00,0xe7,0x7d);
+#if defined(__cplusplus) && !defined(CINTERFACE)
+MIDL_INTERFACE("5546cf8c-77e7-4341-b05d-8d4d5000e77d")
+IDXGIVkInteropSurface : public IUnknown
+{
+    virtual HRESULT STDMETHODCALLTYPE GetDevice(
+        IDXGIVkInteropDevice**  ppDevice) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE GetVulkanImageInfo(
+        VkImage *pHandle,
+        VkImageLayout *pLayout,
+        VkImageCreateInfo *pInfo) = 0;
+
+};
+#ifdef __CRT_UUID_DECL
+__CRT_UUID_DECL(IDXGIVkInteropSurface, 0x5546cf8c, 0x77e7, 0x4341, 0xb0,0x5d, 0x8d,0x4d,0x50,0x00,0xe7,0x7d)
+#endif
+#else
+typedef struct IDXGIVkInteropSurfaceVtbl {
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IDXGIVkInteropSurface *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        IDXGIVkInteropSurface *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        IDXGIVkInteropSurface *This);
+
+    /*** IDXGIVkInteropSurface methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetDevice)(
+        IDXGIVkInteropSurface *This,
+        IDXGIVkInteropDevice **ppDevice);
+
+    HRESULT (STDMETHODCALLTYPE *GetVulkanImageInfo)(
+        IDXGIVkInteropSurface *This,
+        VkImage *pHandle,
+        VkImageLayout *pLayout,
+        VkImageCreateInfo *pInfo);
+
+    END_INTERFACE
+} IDXGIVkInteropSurfaceVtbl;
+
+interface IDXGIVkInteropSurface {
+    CONST_VTBL IDXGIVkInteropSurfaceVtbl* lpVtbl;
+};
+
+#ifdef COBJMACROS
+#ifndef WIDL_C_INLINE_WRAPPERS
+/*** IUnknown methods ***/
+#define IDXGIVkInteropSurface_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
+#define IDXGIVkInteropSurface_AddRef(This) (This)->lpVtbl->AddRef(This)
+#define IDXGIVkInteropSurface_Release(This) (This)->lpVtbl->Release(This)
+/*** IDXGIVkInteropSurface methods ***/
+#define IDXGIVkInteropSurface_GetVulkanImageInfo(This,pHandle,pLayout,pInfo) (This)->lpVtbl->GetVulkanImageInfo(This,pHandle,pLayout,pInfo)
+#else
+/*** IUnknown methods ***/
+static FORCEINLINE HRESULT IDXGIVkInteropSurface_QueryInterface(IDXGIVkInteropSurface* This,REFIID riid,void **ppvObject) {
+    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
+}
+static FORCEINLINE ULONG IDXGIVkInteropSurface_AddRef(IDXGIVkInteropSurface* This) {
+    return This->lpVtbl->AddRef(This);
+}
+static FORCEINLINE ULONG IDXGIVkInteropSurface_Release(IDXGIVkInteropSurface* This) {
+    return This->lpVtbl->Release(This);
+}
+/*** IDXGIVkInteropSurface methods ***/
+static FORCEINLINE HRESULT IDXGIVkInteropSurface_GetVulkanImageInfo(IDXGIVkInteropSurface* This,VkImage *pHandle,VkImageLayout *pLayout,VkImageCreateInfo *pInfo) {
+    return This->lpVtbl->GetVulkanImageInfo(This,pHandle,pLayout,pInfo);
+}
+#endif
+#endif
+
+#endif
+
+
+#endif  /* __IDXGIVkInteropSurface_INTERFACE_DEFINED__ */
+
+/*****************************************************************************
+ * IDXGIVkInteropDevice interface
+ */
+#ifndef __IDXGIVkInteropDevice_INTERFACE_DEFINED__
+#define __IDXGIVkInteropDevice_INTERFACE_DEFINED__
+
+DEFINE_GUID(IID_IDXGIVkInteropDevice, 0xe2ef5fa5, 0xdc21, 0x4af7, 0x90,0xc4, 0xf6,0x7e,0xf6,0xa0,0x93,0x23);
+DEFINE_GUID(IID_IDXGIVkInteropDevice2, 0xe2ef5fa5, 0xdc21, 0x4af7, 0x90,0xc4, 0xf6,0x7e,0xf6,0xa0,0x93,0x24);
+#if defined(__cplusplus) && !defined(CINTERFACE)
+MIDL_INTERFACE("e2ef5fa5-dc21-4af7-90c4-f67ef6a09323")
+IDXGIVkInteropDevice : public IUnknown
+{
+    virtual void STDMETHODCALLTYPE GetVulkanHandles(
+        VkInstance *pInstance,
+        VkPhysicalDevice *pPhysDev,
+        VkDevice *pDevice) = 0;
+
+    virtual void STDMETHODCALLTYPE GetSubmissionQueue(
+        VkQueue *pQueue,
+        uint32_t *pQueueFamilyIndex) = 0;
+
+    virtual void STDMETHODCALLTYPE TransitionSurfaceLayout(
+        IDXGIVkInteropSurface *pSurface,
+        const VkImageSubresourceRange *pSubresources,
+        VkImageLayout OldLayout,
+        VkImageLayout NewLayout) = 0;
+
+    virtual void STDMETHODCALLTYPE FlushRenderingCommands(
+        ) = 0;
+
+    virtual void STDMETHODCALLTYPE LockSubmissionQueue(
+        ) = 0;
+
+    virtual void STDMETHODCALLTYPE ReleaseSubmissionQueue(
+        ) = 0;
+
+};
+MIDL_INTERFACE("e2ef5fa5-dc21-4af7-90c4-f67ef6a09324")
+IDXGIVkInteropDevice2 : public IDXGIVkInteropDevice
+{
+    virtual void STDMETHODCALLTYPE GetSubmissionQueue2(
+        VkQueue *pQueue,
+        uint32_t *pQueueIndex,
+        uint32_t *pQueueFamilyIndex) = 0;
+
+    virtual HRESULT STDMETHODCALLTYPE CreateTexture2DFromVkImage(
+        const D3D11_TEXTURE2D_DESC1 *pDesc,
+        VkImage vkImage,
+        ID3D11Texture2D **ppTexture2D) = 0;
+};
+#ifdef __CRT_UUID_DECL
+__CRT_UUID_DECL(IDXGIVkInteropDevice, 0xe2ef5fa5, 0xdc21, 0x4af7, 0x90,0xc4, 0xf6,0x7e,0xf6,0xa0,0x93,0x23)
+__CRT_UUID_DECL(IDXGIVkInteropDevice2, 0xe2ef5fa5, 0xdc21, 0x4af7, 0x90,0xc4, 0xf6,0x7e,0xf6,0xa0,0x93,0x24)
+#endif
+#else
+typedef struct IDXGIVkInteropDeviceVtbl {
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IDXGIVkInteropDevice *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        IDXGIVkInteropDevice *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        IDXGIVkInteropDevice *This);
+
+    /*** IDXGIVkInteropDevice methods ***/
+    void (STDMETHODCALLTYPE *GetVulkanHandles)(
+        IDXGIVkInteropDevice *This,
+        VkInstance *pInstance,
+        VkPhysicalDevice *pPhysDev,
+        VkDevice *pDevice);
+
+    void (STDMETHODCALLTYPE *GetSubmissionQueue)(
+        IDXGIVkInteropDevice *This,
+        VkQueue *pQueue,
+        uint32_t *pQueueFamilyIndex);
+
+    void (STDMETHODCALLTYPE *TransitionSurfaceLayout)(
+        IDXGIVkInteropDevice *This,
+        IDXGIVkInteropSurface *pSurface,
+        const VkImageSubresourceRange *pSubresources,
+        VkImageLayout OldLayout,
+        VkImageLayout NewLayout);
+
+    void (STDMETHODCALLTYPE *FlushRenderingCommands)(
+        IDXGIVkInteropDevice *This);
+
+    void (STDMETHODCALLTYPE *LockSubmissionQueue)(
+        IDXGIVkInteropDevice *This);
+
+    void (STDMETHODCALLTYPE *ReleaseSubmissionQueue)(
+        IDXGIVkInteropDevice *This);
+
+    END_INTERFACE
+} IDXGIVkInteropDeviceVtbl;
+
+interface IDXGIVkInteropDevice {
+    CONST_VTBL IDXGIVkInteropDeviceVtbl* lpVtbl;
+};
+
+typedef struct IDXGIVkInteropDevice2Vtbl {
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        IDXGIVkInteropDevice2 *This,
+        REFIID riid,
+        void **ppvObject);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        IDXGIVkInteropDevice2 *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        IDXGIVkInteropDevice2 *This);
+
+    /*** IDXGIVkInteropDevice methods ***/
+    void (STDMETHODCALLTYPE *GetVulkanHandles)(
+        IDXGIVkInteropDevice2 *This,
+        VkInstance *pInstance,
+        VkPhysicalDevice *pPhysDev,
+        VkDevice *pDevice);
+
+    void (STDMETHODCALLTYPE *GetSubmissionQueue)(
+        IDXGIVkInteropDevice2 *This,
+        VkQueue *pQueue,
+        uint32_t *pQueueFamilyIndex);
+
+    void (STDMETHODCALLTYPE *TransitionSurfaceLayout)(
+        IDXGIVkInteropDevice2 *This,
+        IDXGIVkInteropSurface *pSurface,
+        const VkImageSubresourceRange *pSubresources,
+        VkImageLayout OldLayout,
+        VkImageLayout NewLayout);
+
+    void (STDMETHODCALLTYPE *FlushRenderingCommands)(
+        IDXGIVkInteropDevice2 *This);
+
+    void (STDMETHODCALLTYPE *LockSubmissionQueue)(
+        IDXGIVkInteropDevice2 *This);
+
+    void (STDMETHODCALLTYPE *ReleaseSubmissionQueue)(
+        IDXGIVkInteropDevice2 *This);
+
+    void (STDMETHODCALLTYPE *GetSubmissionQueue2)(
+        IDXGIVkInteropDevice2 *This,
+        VkQueue *pQueue,
+        uint32_t *pQueueIndex,
+        uint32_t *pQueueFamilyIndex);
+
+    HRESULT (STDMETHODCALLTYPE *CreateTexture2DFromVkImage)(
+        IDXGIVkInteropDevice2 *This,
+        const D3D11_TEXTURE2D_DESC1 *pDesc,
+        VkImage vkImage,
+        ID3D11Texture2D **ppTexture2D);
+
+    END_INTERFACE
+} IDXGIVkInteropDevice2Vtbl;
+
+interface IDXGIVkInteropDevice2 {
+    CONST_VTBL IDXGIVkInteropDevice2Vtbl* lpVtbl;
+};
+
+#ifdef COBJMACROS
+#ifndef WIDL_C_INLINE_WRAPPERS
+/*** IUnknown methods ***/
+#define IDXGIVkInteropDevice_QueryInterface(This,riid,ppvObject) (This)->lpVtbl->QueryInterface(This,riid,ppvObject)
+#define IDXGIVkInteropDevice_AddRef(This) (This)->lpVtbl->AddRef(This)
+#define IDXGIVkInteropDevice_Release(This) (This)->lpVtbl->Release(This)
+/*** IDXGIVkInteropDevice methods ***/
+#define IDXGIVkInteropDevice_GetVulkanHandles(This,pInstance,pPhysDev,pDevice) (This)->lpVtbl->GetVulkanHandles(This,pInstance,pPhysDev,pDevice)
+#define IDXGIVkInteropDevice_GetSubmissionQueue(This,pQueue,pQueueFamilyIndex) (This)->lpVtbl->GetSubmissionQueue(This,pQueue,pQueueFamilyIndex)
+#define IDXGIVkInteropDevice_TransitionSurfaceLayout(This,pSurface,pSubresources,OldLayout,NewLayout) (This)->lpVtbl->TransitionSurfaceLayout(This,pSurface,pSubresources,OldLayout,NewLayout)
+#define IDXGIVkInteropDevice_FlushRenderingCommands(This) (This)->lpVtbl->FlushRenderingCommands(This)
+#define IDXGIVkInteropDevice_LockSubmissionQueue(This) (This)->lpVtbl->LockSubmissionQueue(This)
+#define IDXGIVkInteropDevice_ReleaseSubmissionQueue(This) (This)->lpVtbl->ReleaseSubmissionQueue(This)
+#else
+/*** IUnknown methods ***/
+static FORCEINLINE HRESULT IDXGIVkInteropDevice_QueryInterface(IDXGIVkInteropDevice* This,REFIID riid,void **ppvObject) {
+    return This->lpVtbl->QueryInterface(This,riid,ppvObject);
+}
+static FORCEINLINE ULONG IDXGIVkInteropDevice_AddRef(IDXGIVkInteropDevice* This) {
+    return This->lpVtbl->AddRef(This);
+}
+static FORCEINLINE ULONG IDXGIVkInteropDevice_Release(IDXGIVkInteropDevice* This) {
+    return This->lpVtbl->Release(This);
+}
+/*** IDXGIVkInteropDevice methods ***/
+static FORCEINLINE void IDXGIVkInteropDevice_GetVulkanHandles(IDXGIVkInteropDevice* This,VkInstance *pInstance,VkPhysicalDevice *pPhysDev,VkDevice *pDevice) {
+    This->lpVtbl->GetVulkanHandles(This,pInstance,pPhysDev,pDevice);
+}
+static FORCEINLINE void IDXGIVkInteropDevice_GetSubmissionQueue(IDXGIVkInteropDevice* This,VkQueue *pQueue,uint32_t *pQueueFamilyIndex) {
+    This->lpVtbl->GetSubmissionQueue(This,pQueue,pQueueFamilyIndex);
+}
+static FORCEINLINE void IDXGIVkInteropDevice_TransitionSurfaceLayout(IDXGIVkInteropDevice* This,IDXGIVkInteropSurface *pSurface,const VkImageSubresourceRange *pSubresources,VkImageLayout OldLayout,VkImageLayout NewLayout) {
+    This->lpVtbl->TransitionSurfaceLayout(This,pSurface,pSubresources,OldLayout,NewLayout);
+}
+static FORCEINLINE void IDXGIVkInteropDevice_FlushRenderingCommands(IDXGIVkInteropDevice* This) {
+    This->lpVtbl->FlushRenderingCommands(This);
+}
+static FORCEINLINE void IDXGIVkInteropDevice_LockSubmissionQueue(IDXGIVkInteropDevice* This) {
+    This->lpVtbl->LockSubmissionQueue(This);
+}
+static FORCEINLINE void IDXGIVkInteropDevice_ReleaseSubmissionQueue(IDXGIVkInteropDevice* This) {
+    This->lpVtbl->ReleaseSubmissionQueue(This);
+}
+#endif
+#endif
+
+#endif
+
+
+#endif  /* __IDXGIVkInteropDevice_INTERFACE_DEFINED__ */
+
+/* Begin additional prototypes for all interfaces */
+
+
+/* End additional prototypes */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __dxvk_interop_h__ */
diff --git a/dlls/wineopenxr/loader_structs.h b/dlls/wineopenxr/loader_structs.h
new file mode 100644
index 00000000000..8a4ba66df1d
--- /dev/null
+++ b/dlls/wineopenxr/loader_structs.h
@@ -0,0 +1,30 @@
+typedef struct WINE_XR_STRUCT_NAME(XrNegotiateLoaderInfo) {
+    XrLoaderInterfaceStructs structType;  // XR_LOADER_INTERFACE_STRUCT_LOADER_INFO
+    uint32_t structVersion;               // XR_LOADER_INFO_STRUCT_VERSION
+    size_t structSize;                    // sizeof(XrNegotiateLoaderInfo)
+    uint32_t minInterfaceVersion;
+    uint32_t maxInterfaceVersion;
+    XrVersion minApiVersion;
+    XrVersion maxApiVersion;
+} WINE_XR_STRUCT_ATTR WINE_XR_STRUCT_NAME(XrNegotiateLoaderInfo);
+
+typedef struct WINE_XR_STRUCT_NAME(XrNegotiateRuntimeRequest) {
+    XrLoaderInterfaceStructs structType;  // XR_LOADER_INTERFACE_STRUCT_RUNTIME_REQUEST
+    uint32_t structVersion;               // XR_RUNTIME_INFO_STRUCT_VERSION
+    size_t structSize;                    // sizeof(XrNegotiateRuntimeRequest)
+    uint32_t runtimeInterfaceVersion;     // CURRENT_LOADER_RUNTIME_VERSION
+    XrVersion runtimeApiVersion;
+    PFN_xrGetInstanceProcAddr getInstanceProcAddr;
+} WINE_XR_STRUCT_ATTR WINE_XR_STRUCT_NAME(XrNegotiateRuntimeRequest);
+
+/*
+typedef struct WINE_XR_STRUCT_NAME(XrNegotiateApiLayerRequest) {
+    XrLoaderInterfaceStructs structType;
+    uint32_t structVersion;
+    size_t structSize;
+    uint32_t layerInterfaceVersion;
+    XrVersion layerApiVersion;
+    PFN_xrGetInstanceProcAddr getInstanceProcAddr;
+    PFN_xrCreateApiLayerInstance createApiLayerInstance;
+} WINE_XR_STRUCT_ATTR WINE_XR_STRUCT_NAME(XrNegotiateApiLayerRequest);
+*/
diff --git a/dlls/wineopenxr/loader_thunks.c b/dlls/wineopenxr/loader_thunks.c
new file mode 100644
index 00000000000..253d84b9ffb
--- /dev/null
+++ b/dlls/wineopenxr/loader_thunks.c
@@ -0,0 +1,4947 @@
+/* Automatically generated from Vulkan xr.xml; DO NOT EDIT!
+ *
+ * This file is generated from Vulkan xr.xml file covered
+ * by the following copyright and permission notice:
+ *
+ * Copyright (c) 2017-2025 The Khronos Group Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0 OR MIT
+ *
+ * ------------------------------------------------------------------------
+ *
+ * This file, xr.xml, is the OpenXR API Registry. It is a critically important
+ * and normative part of the OpenXR Specification, including a canonical
+ * machine-readable definition of the API, parameter and member validation
+ * language incorporated into the Specification and reference pages, and other
+ * material which is registered by Khronos, such as tags used by extension and
+ * layer authors. The only authoritative version of xr.xml is the one
+ * maintained in the default branch of the Khronos OpenXR GitHub project.
+ *
+ */
+
+#include "openxr_loader.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(openxr);
+
+XrResult WINAPI xrAcquireEnvironmentDepthImageMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider, const XrEnvironmentDepthImageAcquireInfoMETA *acquireInfo, XrEnvironmentDepthImageMETA *environmentDepthImage)
+{
+    struct xrAcquireEnvironmentDepthImageMETA_params params;
+    NTSTATUS _status;
+    params.environmentDepthProvider = environmentDepthProvider;
+    params.acquireInfo = acquireInfo;
+    params.environmentDepthImage = environmentDepthImage;
+    _status = UNIX_CALL(xrAcquireEnvironmentDepthImageMETA, &params);
+    assert(!_status && "xrAcquireEnvironmentDepthImageMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrAllocateWorldMeshBufferML(XrWorldMeshDetectorML detector, const XrWorldMeshBufferSizeML *size, XrWorldMeshBufferML *buffer)
+{
+    struct xrAllocateWorldMeshBufferML_params params;
+    NTSTATUS _status;
+    params.detector = detector;
+    params.size = size;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrAllocateWorldMeshBufferML, &params);
+    assert(!_status && "xrAllocateWorldMeshBufferML");
+    return params.result;
+}
+
+XrResult WINAPI xrApplyForceFeedbackCurlMNDX(XrHandTrackerEXT handTracker, const XrForceFeedbackCurlApplyLocationsMNDX *locations)
+{
+    struct xrApplyForceFeedbackCurlMNDX_params params;
+    NTSTATUS _status;
+    params.handTracker = handTracker;
+    params.locations = locations;
+    _status = UNIX_CALL(xrApplyForceFeedbackCurlMNDX, &params);
+    assert(!_status && "xrApplyForceFeedbackCurlMNDX");
+    return params.result;
+}
+
+XrResult WINAPI xrApplyHapticFeedback(XrSession session, const XrHapticActionInfo *hapticActionInfo, const XrHapticBaseHeader *hapticFeedback)
+{
+    struct xrApplyHapticFeedback_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.hapticActionInfo = hapticActionInfo;
+    params.hapticFeedback = hapticFeedback;
+    _status = UNIX_CALL(xrApplyHapticFeedback, &params);
+    assert(!_status && "xrApplyHapticFeedback");
+    return params.result;
+}
+
+XrResult WINAPI xrAttachSessionActionSets(XrSession session, const XrSessionActionSetsAttachInfo *attachInfo)
+{
+    struct xrAttachSessionActionSets_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.attachInfo = attachInfo;
+    _status = UNIX_CALL(xrAttachSessionActionSets, &params);
+    assert(!_status && "xrAttachSessionActionSets");
+    return params.result;
+}
+
+XrResult WINAPI xrBeginPlaneDetectionEXT(XrPlaneDetectorEXT planeDetector, const XrPlaneDetectorBeginInfoEXT *beginInfo)
+{
+    struct xrBeginPlaneDetectionEXT_params params;
+    NTSTATUS _status;
+    params.planeDetector = planeDetector;
+    params.beginInfo = beginInfo;
+    _status = UNIX_CALL(xrBeginPlaneDetectionEXT, &params);
+    assert(!_status && "xrBeginPlaneDetectionEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrBeginSession(XrSession session, const XrSessionBeginInfo *beginInfo)
+{
+    struct xrBeginSession_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.beginInfo = beginInfo;
+    _status = UNIX_CALL(xrBeginSession, &params);
+    assert(!_status && "xrBeginSession");
+    return params.result;
+}
+
+XrResult WINAPI xrCancelFutureEXT(XrInstance instance, const XrFutureCancelInfoEXT *cancelInfo)
+{
+    struct xrCancelFutureEXT_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.cancelInfo = cancelInfo;
+    _status = UNIX_CALL(xrCancelFutureEXT, &params);
+    assert(!_status && "xrCancelFutureEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCaptureSceneAsyncBD(XrSenseDataProviderBD provider, const XrSceneCaptureInfoBD *info, XrFutureEXT *future)
+{
+    struct xrCaptureSceneAsyncBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.info = info;
+    params.future = future;
+    _status = UNIX_CALL(xrCaptureSceneAsyncBD, &params);
+    assert(!_status && "xrCaptureSceneAsyncBD");
+    return params.result;
+}
+
+XrResult WINAPI xrCaptureSceneCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrFutureCompletionEXT *completion)
+{
+    struct xrCaptureSceneCompleteBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrCaptureSceneCompleteBD, &params);
+    assert(!_status && "xrCaptureSceneCompleteBD");
+    return params.result;
+}
+
+XrResult WINAPI xrChangeVirtualKeyboardTextContextMETA(XrVirtualKeyboardMETA keyboard, const XrVirtualKeyboardTextContextChangeInfoMETA *changeInfo)
+{
+    struct xrChangeVirtualKeyboardTextContextMETA_params params;
+    NTSTATUS _status;
+    params.keyboard = keyboard;
+    params.changeInfo = changeInfo;
+    _status = UNIX_CALL(xrChangeVirtualKeyboardTextContextMETA, &params);
+    assert(!_status && "xrChangeVirtualKeyboardTextContextMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrClearSpatialAnchorStoreMSFT(XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore)
+{
+    struct xrClearSpatialAnchorStoreMSFT_params params;
+    NTSTATUS _status;
+    params.spatialAnchorStore = spatialAnchorStore;
+    _status = UNIX_CALL(xrClearSpatialAnchorStoreMSFT, &params);
+    assert(!_status && "xrClearSpatialAnchorStoreMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrComputeNewSceneMSFT(XrSceneObserverMSFT sceneObserver, const XrNewSceneComputeInfoMSFT *computeInfo)
+{
+    struct xrComputeNewSceneMSFT_params params;
+    NTSTATUS _status;
+    params.sceneObserver = sceneObserver;
+    params.computeInfo = computeInfo;
+    _status = UNIX_CALL(xrComputeNewSceneMSFT, &params);
+    assert(!_status && "xrComputeNewSceneMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateAction(XrActionSet actionSet, const XrActionCreateInfo *createInfo, XrAction *action)
+{
+    struct xrCreateAction_params params;
+    NTSTATUS _status;
+    params.actionSet = actionSet;
+    params.createInfo = createInfo;
+    params.action = action;
+    _status = UNIX_CALL(xrCreateAction, &params);
+    assert(!_status && "xrCreateAction");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateActionSet(XrInstance instance, const XrActionSetCreateInfo *createInfo, XrActionSet *actionSet)
+{
+    struct xrCreateActionSet_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.createInfo = createInfo;
+    params.actionSet = actionSet;
+    _status = UNIX_CALL(xrCreateActionSet, &params);
+    assert(!_status && "xrCreateActionSet");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateActionSpace(XrSession session, const XrActionSpaceCreateInfo *createInfo, XrSpace *space)
+{
+    struct xrCreateActionSpace_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.space = space;
+    _status = UNIX_CALL(xrCreateActionSpace, &params);
+    assert(!_status && "xrCreateActionSpace");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateAnchorSpaceANDROID(XrSession session, const XrAnchorSpaceCreateInfoANDROID *createInfo, XrSpace *anchorOutput)
+{
+    struct xrCreateAnchorSpaceANDROID_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.anchorOutput = anchorOutput;
+    _status = UNIX_CALL(xrCreateAnchorSpaceANDROID, &params);
+    assert(!_status && "xrCreateAnchorSpaceANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateAnchorSpaceBD(XrSession session, const XrAnchorSpaceCreateInfoBD *createInfo, XrSpace *space)
+{
+    struct xrCreateAnchorSpaceBD_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.space = space;
+    _status = UNIX_CALL(xrCreateAnchorSpaceBD, &params);
+    assert(!_status && "xrCreateAnchorSpaceBD");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateBodyTrackerBD(XrSession session, const XrBodyTrackerCreateInfoBD *createInfo, XrBodyTrackerBD *bodyTracker)
+{
+    struct xrCreateBodyTrackerBD_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.bodyTracker = bodyTracker;
+    _status = UNIX_CALL(xrCreateBodyTrackerBD, &params);
+    assert(!_status && "xrCreateBodyTrackerBD");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateBodyTrackerFB(XrSession session, const XrBodyTrackerCreateInfoFB *createInfo, XrBodyTrackerFB *bodyTracker)
+{
+    struct xrCreateBodyTrackerFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.bodyTracker = bodyTracker;
+    _status = UNIX_CALL(xrCreateBodyTrackerFB, &params);
+    assert(!_status && "xrCreateBodyTrackerFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateBodyTrackerHTC(XrSession session, const XrBodyTrackerCreateInfoHTC *createInfo, XrBodyTrackerHTC *bodyTracker)
+{
+    struct xrCreateBodyTrackerHTC_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.bodyTracker = bodyTracker;
+    _status = UNIX_CALL(xrCreateBodyTrackerHTC, &params);
+    assert(!_status && "xrCreateBodyTrackerHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateDeviceAnchorPersistenceANDROID(XrSession session, const XrDeviceAnchorPersistenceCreateInfoANDROID *createInfo, XrDeviceAnchorPersistenceANDROID *outHandle)
+{
+    struct xrCreateDeviceAnchorPersistenceANDROID_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.outHandle = outHandle;
+    _status = UNIX_CALL(xrCreateDeviceAnchorPersistenceANDROID, &params);
+    assert(!_status && "xrCreateDeviceAnchorPersistenceANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateEnvironmentDepthProviderMETA(XrSession session, const XrEnvironmentDepthProviderCreateInfoMETA *createInfo, XrEnvironmentDepthProviderMETA *environmentDepthProvider)
+{
+    struct xrCreateEnvironmentDepthProviderMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.environmentDepthProvider = environmentDepthProvider;
+    _status = UNIX_CALL(xrCreateEnvironmentDepthProviderMETA, &params);
+    assert(!_status && "xrCreateEnvironmentDepthProviderMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateEnvironmentDepthSwapchainMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider, const XrEnvironmentDepthSwapchainCreateInfoMETA *createInfo, XrEnvironmentDepthSwapchainMETA *swapchain)
+{
+    struct xrCreateEnvironmentDepthSwapchainMETA_params params;
+    NTSTATUS _status;
+    params.environmentDepthProvider = environmentDepthProvider;
+    params.createInfo = createInfo;
+    params.swapchain = swapchain;
+    _status = UNIX_CALL(xrCreateEnvironmentDepthSwapchainMETA, &params);
+    assert(!_status && "xrCreateEnvironmentDepthSwapchainMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateExportedLocalizationMapML(XrSession session, const XrUuidEXT *mapUuid, XrExportedLocalizationMapML *map)
+{
+    struct xrCreateExportedLocalizationMapML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.mapUuid = mapUuid;
+    params.map = map;
+    _status = UNIX_CALL(xrCreateExportedLocalizationMapML, &params);
+    assert(!_status && "xrCreateExportedLocalizationMapML");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateEyeTrackerFB(XrSession session, const XrEyeTrackerCreateInfoFB *createInfo, XrEyeTrackerFB *eyeTracker)
+{
+    struct xrCreateEyeTrackerFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.eyeTracker = eyeTracker;
+    _status = UNIX_CALL(xrCreateEyeTrackerFB, &params);
+    assert(!_status && "xrCreateEyeTrackerFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateFaceTracker2FB(XrSession session, const XrFaceTrackerCreateInfo2FB *createInfo, XrFaceTracker2FB *faceTracker)
+{
+    struct xrCreateFaceTracker2FB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.faceTracker = faceTracker;
+    _status = UNIX_CALL(xrCreateFaceTracker2FB, &params);
+    assert(!_status && "xrCreateFaceTracker2FB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateFaceTrackerFB(XrSession session, const XrFaceTrackerCreateInfoFB *createInfo, XrFaceTrackerFB *faceTracker)
+{
+    struct xrCreateFaceTrackerFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.faceTracker = faceTracker;
+    _status = UNIX_CALL(xrCreateFaceTrackerFB, &params);
+    assert(!_status && "xrCreateFaceTrackerFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateFacialExpressionClientML(XrSession session, const XrFacialExpressionClientCreateInfoML *createInfo, XrFacialExpressionClientML *facialExpressionClient)
+{
+    struct xrCreateFacialExpressionClientML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.facialExpressionClient = facialExpressionClient;
+    _status = UNIX_CALL(xrCreateFacialExpressionClientML, &params);
+    assert(!_status && "xrCreateFacialExpressionClientML");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateFacialTrackerHTC(XrSession session, const XrFacialTrackerCreateInfoHTC *createInfo, XrFacialTrackerHTC *facialTracker)
+{
+    struct xrCreateFacialTrackerHTC_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.facialTracker = facialTracker;
+    _status = UNIX_CALL(xrCreateFacialTrackerHTC, &params);
+    assert(!_status && "xrCreateFacialTrackerHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateFoveationProfileFB(XrSession session, const XrFoveationProfileCreateInfoFB *createInfo, XrFoveationProfileFB *profile)
+{
+    struct xrCreateFoveationProfileFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.profile = profile;
+    _status = UNIX_CALL(xrCreateFoveationProfileFB, &params);
+    assert(!_status && "xrCreateFoveationProfileFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateGeometryInstanceFB(XrSession session, const XrGeometryInstanceCreateInfoFB *createInfo, XrGeometryInstanceFB *outGeometryInstance)
+{
+    struct xrCreateGeometryInstanceFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.outGeometryInstance = outGeometryInstance;
+    _status = UNIX_CALL(xrCreateGeometryInstanceFB, &params);
+    assert(!_status && "xrCreateGeometryInstanceFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateHandMeshSpaceMSFT(XrHandTrackerEXT handTracker, const XrHandMeshSpaceCreateInfoMSFT *createInfo, XrSpace *space)
+{
+    struct xrCreateHandMeshSpaceMSFT_params params;
+    NTSTATUS _status;
+    params.handTracker = handTracker;
+    params.createInfo = createInfo;
+    params.space = space;
+    _status = UNIX_CALL(xrCreateHandMeshSpaceMSFT, &params);
+    assert(!_status && "xrCreateHandMeshSpaceMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateHandTrackerEXT(XrSession session, const XrHandTrackerCreateInfoEXT *createInfo, XrHandTrackerEXT *handTracker)
+{
+    struct xrCreateHandTrackerEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.handTracker = handTracker;
+    _status = UNIX_CALL(xrCreateHandTrackerEXT, &params);
+    assert(!_status && "xrCreateHandTrackerEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateKeyboardSpaceFB(XrSession session, const XrKeyboardSpaceCreateInfoFB *createInfo, XrSpace *keyboardSpace)
+{
+    struct xrCreateKeyboardSpaceFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.keyboardSpace = keyboardSpace;
+    _status = UNIX_CALL(xrCreateKeyboardSpaceFB, &params);
+    assert(!_status && "xrCreateKeyboardSpaceFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateMarkerDetectorML(XrSession session, const XrMarkerDetectorCreateInfoML *createInfo, XrMarkerDetectorML *markerDetector)
+{
+    struct xrCreateMarkerDetectorML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.markerDetector = markerDetector;
+    _status = UNIX_CALL(xrCreateMarkerDetectorML, &params);
+    assert(!_status && "xrCreateMarkerDetectorML");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateMarkerSpaceML(XrSession session, const XrMarkerSpaceCreateInfoML *createInfo, XrSpace *space)
+{
+    struct xrCreateMarkerSpaceML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.space = space;
+    _status = UNIX_CALL(xrCreateMarkerSpaceML, &params);
+    assert(!_status && "xrCreateMarkerSpaceML");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateMarkerSpaceVARJO(XrSession session, const XrMarkerSpaceCreateInfoVARJO *createInfo, XrSpace *space)
+{
+    struct xrCreateMarkerSpaceVARJO_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.space = space;
+    _status = UNIX_CALL(xrCreateMarkerSpaceVARJO, &params);
+    assert(!_status && "xrCreateMarkerSpaceVARJO");
+    return params.result;
+}
+
+XrResult WINAPI xrCreatePassthroughColorLutMETA(XrPassthroughFB passthrough, const XrPassthroughColorLutCreateInfoMETA *createInfo, XrPassthroughColorLutMETA *colorLut)
+{
+    struct xrCreatePassthroughColorLutMETA_params params;
+    NTSTATUS _status;
+    params.passthrough = passthrough;
+    params.createInfo = createInfo;
+    params.colorLut = colorLut;
+    _status = UNIX_CALL(xrCreatePassthroughColorLutMETA, &params);
+    assert(!_status && "xrCreatePassthroughColorLutMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrCreatePassthroughFB(XrSession session, const XrPassthroughCreateInfoFB *createInfo, XrPassthroughFB *outPassthrough)
+{
+    struct xrCreatePassthroughFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.outPassthrough = outPassthrough;
+    _status = UNIX_CALL(xrCreatePassthroughFB, &params);
+    assert(!_status && "xrCreatePassthroughFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreatePassthroughHTC(XrSession session, const XrPassthroughCreateInfoHTC *createInfo, XrPassthroughHTC *passthrough)
+{
+    struct xrCreatePassthroughHTC_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.passthrough = passthrough;
+    _status = UNIX_CALL(xrCreatePassthroughHTC, &params);
+    assert(!_status && "xrCreatePassthroughHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrCreatePassthroughLayerFB(XrSession session, const XrPassthroughLayerCreateInfoFB *createInfo, XrPassthroughLayerFB *outLayer)
+{
+    struct xrCreatePassthroughLayerFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.outLayer = outLayer;
+    _status = UNIX_CALL(xrCreatePassthroughLayerFB, &params);
+    assert(!_status && "xrCreatePassthroughLayerFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreatePersistedAnchorSpaceANDROID(XrDeviceAnchorPersistenceANDROID handle, const XrPersistedAnchorSpaceCreateInfoANDROID *createInfo, XrSpace *anchorOutput)
+{
+    struct xrCreatePersistedAnchorSpaceANDROID_params params;
+    NTSTATUS _status;
+    params.handle = handle;
+    params.createInfo = createInfo;
+    params.anchorOutput = anchorOutput;
+    _status = UNIX_CALL(xrCreatePersistedAnchorSpaceANDROID, &params);
+    assert(!_status && "xrCreatePersistedAnchorSpaceANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrCreatePlaneDetectorEXT(XrSession session, const XrPlaneDetectorCreateInfoEXT *createInfo, XrPlaneDetectorEXT *planeDetector)
+{
+    struct xrCreatePlaneDetectorEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.planeDetector = planeDetector;
+    _status = UNIX_CALL(xrCreatePlaneDetectorEXT, &params);
+    assert(!_status && "xrCreatePlaneDetectorEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateReferenceSpace(XrSession session, const XrReferenceSpaceCreateInfo *createInfo, XrSpace *space)
+{
+    struct xrCreateReferenceSpace_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.space = space;
+    _status = UNIX_CALL(xrCreateReferenceSpace, &params);
+    assert(!_status && "xrCreateReferenceSpace");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateRenderModelAssetEXT(XrSession session, const XrRenderModelAssetCreateInfoEXT *createInfo, XrRenderModelAssetEXT *asset)
+{
+    struct xrCreateRenderModelAssetEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.asset = asset;
+    _status = UNIX_CALL(xrCreateRenderModelAssetEXT, &params);
+    assert(!_status && "xrCreateRenderModelAssetEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateRenderModelEXT(XrSession session, const XrRenderModelCreateInfoEXT *createInfo, XrRenderModelEXT *renderModel)
+{
+    struct xrCreateRenderModelEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.renderModel = renderModel;
+    _status = UNIX_CALL(xrCreateRenderModelEXT, &params);
+    assert(!_status && "xrCreateRenderModelEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateRenderModelSpaceEXT(XrSession session, const XrRenderModelSpaceCreateInfoEXT *createInfo, XrSpace *space)
+{
+    struct xrCreateRenderModelSpaceEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.space = space;
+    _status = UNIX_CALL(xrCreateRenderModelSpaceEXT, &params);
+    assert(!_status && "xrCreateRenderModelSpaceEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSceneMSFT(XrSceneObserverMSFT sceneObserver, const XrSceneCreateInfoMSFT *createInfo, XrSceneMSFT *scene)
+{
+    struct xrCreateSceneMSFT_params params;
+    NTSTATUS _status;
+    params.sceneObserver = sceneObserver;
+    params.createInfo = createInfo;
+    params.scene = scene;
+    _status = UNIX_CALL(xrCreateSceneMSFT, &params);
+    assert(!_status && "xrCreateSceneMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSceneObserverMSFT(XrSession session, const XrSceneObserverCreateInfoMSFT *createInfo, XrSceneObserverMSFT *sceneObserver)
+{
+    struct xrCreateSceneObserverMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.sceneObserver = sceneObserver;
+    _status = UNIX_CALL(xrCreateSceneObserverMSFT, &params);
+    assert(!_status && "xrCreateSceneObserverMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSenseDataProviderBD(XrSession session, const XrSenseDataProviderCreateInfoBD *createInfo, XrSenseDataProviderBD *provider)
+{
+    struct xrCreateSenseDataProviderBD_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.provider = provider;
+    _status = UNIX_CALL(xrCreateSenseDataProviderBD, &params);
+    assert(!_status && "xrCreateSenseDataProviderBD");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpaceUserFB(XrSession session, const XrSpaceUserCreateInfoFB *info, XrSpaceUserFB *user)
+{
+    struct xrCreateSpaceUserFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.user = user;
+    _status = UNIX_CALL(xrCreateSpaceUserFB, &params);
+    assert(!_status && "xrCreateSpaceUserFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorAsyncBD(XrSenseDataProviderBD provider, const XrSpatialAnchorCreateInfoBD *info, XrFutureEXT *future)
+{
+    struct xrCreateSpatialAnchorAsyncBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.info = info;
+    params.future = future;
+    _status = UNIX_CALL(xrCreateSpatialAnchorAsyncBD, &params);
+    assert(!_status && "xrCreateSpatialAnchorAsyncBD");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrSpatialAnchorCreateCompletionBD *completion)
+{
+    struct xrCreateSpatialAnchorCompleteBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrCreateSpatialAnchorCompleteBD, &params);
+    assert(!_status && "xrCreateSpatialAnchorCompleteBD");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorEXT(XrSpatialContextEXT spatialContext, const XrSpatialAnchorCreateInfoEXT *createInfo, XrSpatialEntityIdEXT *anchorEntityId, XrSpatialEntityEXT *anchorEntity)
+{
+    struct xrCreateSpatialAnchorEXT_params params;
+    NTSTATUS _status;
+    params.spatialContext = spatialContext;
+    params.createInfo = createInfo;
+    params.anchorEntityId = anchorEntityId;
+    params.anchorEntity = anchorEntity;
+    _status = UNIX_CALL(xrCreateSpatialAnchorEXT, &params);
+    assert(!_status && "xrCreateSpatialAnchorEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorFB(XrSession session, const XrSpatialAnchorCreateInfoFB *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrCreateSpatialAnchorFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrCreateSpatialAnchorFB, &params);
+    assert(!_status && "xrCreateSpatialAnchorFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorFromPersistedNameMSFT(XrSession session, const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT *spatialAnchorCreateInfo, XrSpatialAnchorMSFT *spatialAnchor)
+{
+    struct xrCreateSpatialAnchorFromPersistedNameMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.spatialAnchorCreateInfo = spatialAnchorCreateInfo;
+    params.spatialAnchor = spatialAnchor;
+    _status = UNIX_CALL(xrCreateSpatialAnchorFromPersistedNameMSFT, &params);
+    assert(!_status && "xrCreateSpatialAnchorFromPersistedNameMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorHTC(XrSession session, const XrSpatialAnchorCreateInfoHTC *createInfo, XrSpace *anchor)
+{
+    struct xrCreateSpatialAnchorHTC_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.anchor = anchor;
+    _status = UNIX_CALL(xrCreateSpatialAnchorHTC, &params);
+    assert(!_status && "xrCreateSpatialAnchorHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorMSFT(XrSession session, const XrSpatialAnchorCreateInfoMSFT *createInfo, XrSpatialAnchorMSFT *anchor)
+{
+    struct xrCreateSpatialAnchorMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.anchor = anchor;
+    _status = UNIX_CALL(xrCreateSpatialAnchorMSFT, &params);
+    assert(!_status && "xrCreateSpatialAnchorMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorSpaceMSFT(XrSession session, const XrSpatialAnchorSpaceCreateInfoMSFT *createInfo, XrSpace *space)
+{
+    struct xrCreateSpatialAnchorSpaceMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.space = space;
+    _status = UNIX_CALL(xrCreateSpatialAnchorSpaceMSFT, &params);
+    assert(!_status && "xrCreateSpatialAnchorSpaceMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorStoreConnectionMSFT(XrSession session, XrSpatialAnchorStoreConnectionMSFT *spatialAnchorStore)
+{
+    struct xrCreateSpatialAnchorStoreConnectionMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.spatialAnchorStore = spatialAnchorStore;
+    _status = UNIX_CALL(xrCreateSpatialAnchorStoreConnectionMSFT, &params);
+    assert(!_status && "xrCreateSpatialAnchorStoreConnectionMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorsAsyncML(XrSession session, const XrSpatialAnchorsCreateInfoBaseHeaderML *createInfo, XrFutureEXT *future)
+{
+    struct xrCreateSpatialAnchorsAsyncML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrCreateSpatialAnchorsAsyncML, &params);
+    assert(!_status && "xrCreateSpatialAnchorsAsyncML");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorsCompleteML(XrSession session, XrFutureEXT future, XrCreateSpatialAnchorsCompletionML *completion)
+{
+    struct xrCreateSpatialAnchorsCompleteML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrCreateSpatialAnchorsCompleteML, &params);
+    assert(!_status && "xrCreateSpatialAnchorsCompleteML");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialAnchorsStorageML(XrSession session, const XrSpatialAnchorsCreateStorageInfoML *createInfo, XrSpatialAnchorsStorageML *storage)
+{
+    struct xrCreateSpatialAnchorsStorageML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.storage = storage;
+    _status = UNIX_CALL(xrCreateSpatialAnchorsStorageML, &params);
+    assert(!_status && "xrCreateSpatialAnchorsStorageML");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialContextAsyncEXT(XrSession session, const XrSpatialContextCreateInfoEXT *createInfo, XrFutureEXT *future)
+{
+    struct xrCreateSpatialContextAsyncEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrCreateSpatialContextAsyncEXT, &params);
+    assert(!_status && "xrCreateSpatialContextAsyncEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialContextCompleteEXT(XrSession session, XrFutureEXT future, XrCreateSpatialContextCompletionEXT *completion)
+{
+    struct xrCreateSpatialContextCompleteEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrCreateSpatialContextCompleteEXT, &params);
+    assert(!_status && "xrCreateSpatialContextCompleteEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialDiscoverySnapshotAsyncEXT(XrSpatialContextEXT spatialContext, const XrSpatialDiscoverySnapshotCreateInfoEXT *createInfo, XrFutureEXT *future)
+{
+    struct xrCreateSpatialDiscoverySnapshotAsyncEXT_params params;
+    NTSTATUS _status;
+    params.spatialContext = spatialContext;
+    params.createInfo = createInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrCreateSpatialDiscoverySnapshotAsyncEXT, &params);
+    assert(!_status && "xrCreateSpatialDiscoverySnapshotAsyncEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialDiscoverySnapshotCompleteEXT(XrSpatialContextEXT spatialContext, const XrCreateSpatialDiscoverySnapshotCompletionInfoEXT *createSnapshotCompletionInfo, XrCreateSpatialDiscoverySnapshotCompletionEXT *completion)
+{
+    struct xrCreateSpatialDiscoverySnapshotCompleteEXT_params params;
+    NTSTATUS _status;
+    params.spatialContext = spatialContext;
+    params.createSnapshotCompletionInfo = createSnapshotCompletionInfo;
+    params.completion = completion;
+    _status = UNIX_CALL(xrCreateSpatialDiscoverySnapshotCompleteEXT, &params);
+    assert(!_status && "xrCreateSpatialDiscoverySnapshotCompleteEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialEntityAnchorBD(XrSenseDataProviderBD provider, const XrSpatialEntityAnchorCreateInfoBD *createInfo, XrAnchorBD *anchor)
+{
+    struct xrCreateSpatialEntityAnchorBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.createInfo = createInfo;
+    params.anchor = anchor;
+    _status = UNIX_CALL(xrCreateSpatialEntityAnchorBD, &params);
+    assert(!_status && "xrCreateSpatialEntityAnchorBD");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialEntityFromIdEXT(XrSpatialContextEXT spatialContext, const XrSpatialEntityFromIdCreateInfoEXT *createInfo, XrSpatialEntityEXT *spatialEntity)
+{
+    struct xrCreateSpatialEntityFromIdEXT_params params;
+    NTSTATUS _status;
+    params.spatialContext = spatialContext;
+    params.createInfo = createInfo;
+    params.spatialEntity = spatialEntity;
+    _status = UNIX_CALL(xrCreateSpatialEntityFromIdEXT, &params);
+    assert(!_status && "xrCreateSpatialEntityFromIdEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialGraphNodeSpaceMSFT(XrSession session, const XrSpatialGraphNodeSpaceCreateInfoMSFT *createInfo, XrSpace *space)
+{
+    struct xrCreateSpatialGraphNodeSpaceMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.space = space;
+    _status = UNIX_CALL(xrCreateSpatialGraphNodeSpaceMSFT, &params);
+    assert(!_status && "xrCreateSpatialGraphNodeSpaceMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialPersistenceContextAsyncEXT(XrSession session, const XrSpatialPersistenceContextCreateInfoEXT *createInfo, XrFutureEXT *future)
+{
+    struct xrCreateSpatialPersistenceContextAsyncEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrCreateSpatialPersistenceContextAsyncEXT, &params);
+    assert(!_status && "xrCreateSpatialPersistenceContextAsyncEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialPersistenceContextCompleteEXT(XrSession session, XrFutureEXT future, XrCreateSpatialPersistenceContextCompletionEXT *completion)
+{
+    struct xrCreateSpatialPersistenceContextCompleteEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrCreateSpatialPersistenceContextCompleteEXT, &params);
+    assert(!_status && "xrCreateSpatialPersistenceContextCompleteEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateSpatialUpdateSnapshotEXT(XrSpatialContextEXT spatialContext, const XrSpatialUpdateSnapshotCreateInfoEXT *createInfo, XrSpatialSnapshotEXT *snapshot)
+{
+    struct xrCreateSpatialUpdateSnapshotEXT_params params;
+    NTSTATUS _status;
+    params.spatialContext = spatialContext;
+    params.createInfo = createInfo;
+    params.snapshot = snapshot;
+    _status = UNIX_CALL(xrCreateSpatialUpdateSnapshotEXT, &params);
+    assert(!_status && "xrCreateSpatialUpdateSnapshotEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateTrackableTrackerANDROID(XrSession session, const XrTrackableTrackerCreateInfoANDROID *createInfo, XrTrackableTrackerANDROID *trackableTracker)
+{
+    struct xrCreateTrackableTrackerANDROID_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.trackableTracker = trackableTracker;
+    _status = UNIX_CALL(xrCreateTrackableTrackerANDROID, &params);
+    assert(!_status && "xrCreateTrackableTrackerANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateTriangleMeshFB(XrSession session, const XrTriangleMeshCreateInfoFB *createInfo, XrTriangleMeshFB *outTriangleMesh)
+{
+    struct xrCreateTriangleMeshFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.outTriangleMesh = outTriangleMesh;
+    _status = UNIX_CALL(xrCreateTriangleMeshFB, &params);
+    assert(!_status && "xrCreateTriangleMeshFB");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateVirtualKeyboardMETA(XrSession session, const XrVirtualKeyboardCreateInfoMETA *createInfo, XrVirtualKeyboardMETA *keyboard)
+{
+    struct xrCreateVirtualKeyboardMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.keyboard = keyboard;
+    _status = UNIX_CALL(xrCreateVirtualKeyboardMETA, &params);
+    assert(!_status && "xrCreateVirtualKeyboardMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateVirtualKeyboardSpaceMETA(XrSession session, XrVirtualKeyboardMETA keyboard, const XrVirtualKeyboardSpaceCreateInfoMETA *createInfo, XrSpace *keyboardSpace)
+{
+    struct xrCreateVirtualKeyboardSpaceMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.keyboard = keyboard;
+    params.createInfo = createInfo;
+    params.keyboardSpace = keyboardSpace;
+    _status = UNIX_CALL(xrCreateVirtualKeyboardSpaceMETA, &params);
+    assert(!_status && "xrCreateVirtualKeyboardSpaceMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrCreateWorldMeshDetectorML(XrSession session, const XrWorldMeshDetectorCreateInfoML *createInfo, XrWorldMeshDetectorML *detector)
+{
+    struct xrCreateWorldMeshDetectorML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.detector = detector;
+    _status = UNIX_CALL(xrCreateWorldMeshDetectorML, &params);
+    assert(!_status && "xrCreateWorldMeshDetectorML");
+    return params.result;
+}
+
+XrResult WINAPI xrDeleteSpatialAnchorsAsyncML(XrSpatialAnchorsStorageML storage, const XrSpatialAnchorsDeleteInfoML *deleteInfo, XrFutureEXT *future)
+{
+    struct xrDeleteSpatialAnchorsAsyncML_params params;
+    NTSTATUS _status;
+    params.storage = storage;
+    params.deleteInfo = deleteInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrDeleteSpatialAnchorsAsyncML, &params);
+    assert(!_status && "xrDeleteSpatialAnchorsAsyncML");
+    return params.result;
+}
+
+XrResult WINAPI xrDeleteSpatialAnchorsCompleteML(XrSpatialAnchorsStorageML storage, XrFutureEXT future, XrSpatialAnchorsDeleteCompletionML *completion)
+{
+    struct xrDeleteSpatialAnchorsCompleteML_params params;
+    NTSTATUS _status;
+    params.storage = storage;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrDeleteSpatialAnchorsCompleteML, &params);
+    assert(!_status && "xrDeleteSpatialAnchorsCompleteML");
+    return params.result;
+}
+
+XrResult WINAPI xrDeserializeSceneMSFT(XrSceneObserverMSFT sceneObserver, const XrSceneDeserializeInfoMSFT *deserializeInfo)
+{
+    struct xrDeserializeSceneMSFT_params params;
+    NTSTATUS _status;
+    params.sceneObserver = sceneObserver;
+    params.deserializeInfo = deserializeInfo;
+    _status = UNIX_CALL(xrDeserializeSceneMSFT, &params);
+    assert(!_status && "xrDeserializeSceneMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyAction(XrAction action)
+{
+    struct xrDestroyAction_params params;
+    NTSTATUS _status;
+    params.action = action;
+    _status = UNIX_CALL(xrDestroyAction, &params);
+    assert(!_status && "xrDestroyAction");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyActionSet(XrActionSet actionSet)
+{
+    struct xrDestroyActionSet_params params;
+    NTSTATUS _status;
+    params.actionSet = actionSet;
+    _status = UNIX_CALL(xrDestroyActionSet, &params);
+    assert(!_status && "xrDestroyActionSet");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyAnchorBD(XrAnchorBD anchor)
+{
+    struct xrDestroyAnchorBD_params params;
+    NTSTATUS _status;
+    params.anchor = anchor;
+    _status = UNIX_CALL(xrDestroyAnchorBD, &params);
+    assert(!_status && "xrDestroyAnchorBD");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyBodyTrackerBD(XrBodyTrackerBD bodyTracker)
+{
+    struct xrDestroyBodyTrackerBD_params params;
+    NTSTATUS _status;
+    params.bodyTracker = bodyTracker;
+    _status = UNIX_CALL(xrDestroyBodyTrackerBD, &params);
+    assert(!_status && "xrDestroyBodyTrackerBD");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyBodyTrackerFB(XrBodyTrackerFB bodyTracker)
+{
+    struct xrDestroyBodyTrackerFB_params params;
+    NTSTATUS _status;
+    params.bodyTracker = bodyTracker;
+    _status = UNIX_CALL(xrDestroyBodyTrackerFB, &params);
+    assert(!_status && "xrDestroyBodyTrackerFB");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyBodyTrackerHTC(XrBodyTrackerHTC bodyTracker)
+{
+    struct xrDestroyBodyTrackerHTC_params params;
+    NTSTATUS _status;
+    params.bodyTracker = bodyTracker;
+    _status = UNIX_CALL(xrDestroyBodyTrackerHTC, &params);
+    assert(!_status && "xrDestroyBodyTrackerHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyDeviceAnchorPersistenceANDROID(XrDeviceAnchorPersistenceANDROID handle)
+{
+    struct xrDestroyDeviceAnchorPersistenceANDROID_params params;
+    NTSTATUS _status;
+    params.handle = handle;
+    _status = UNIX_CALL(xrDestroyDeviceAnchorPersistenceANDROID, &params);
+    assert(!_status && "xrDestroyDeviceAnchorPersistenceANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyEnvironmentDepthProviderMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider)
+{
+    struct xrDestroyEnvironmentDepthProviderMETA_params params;
+    NTSTATUS _status;
+    params.environmentDepthProvider = environmentDepthProvider;
+    _status = UNIX_CALL(xrDestroyEnvironmentDepthProviderMETA, &params);
+    assert(!_status && "xrDestroyEnvironmentDepthProviderMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyEnvironmentDepthSwapchainMETA(XrEnvironmentDepthSwapchainMETA swapchain)
+{
+    struct xrDestroyEnvironmentDepthSwapchainMETA_params params;
+    NTSTATUS _status;
+    params.swapchain = swapchain;
+    _status = UNIX_CALL(xrDestroyEnvironmentDepthSwapchainMETA, &params);
+    assert(!_status && "xrDestroyEnvironmentDepthSwapchainMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyExportedLocalizationMapML(XrExportedLocalizationMapML map)
+{
+    struct xrDestroyExportedLocalizationMapML_params params;
+    NTSTATUS _status;
+    params.map = map;
+    _status = UNIX_CALL(xrDestroyExportedLocalizationMapML, &params);
+    assert(!_status && "xrDestroyExportedLocalizationMapML");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyEyeTrackerFB(XrEyeTrackerFB eyeTracker)
+{
+    struct xrDestroyEyeTrackerFB_params params;
+    NTSTATUS _status;
+    params.eyeTracker = eyeTracker;
+    _status = UNIX_CALL(xrDestroyEyeTrackerFB, &params);
+    assert(!_status && "xrDestroyEyeTrackerFB");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyFaceTracker2FB(XrFaceTracker2FB faceTracker)
+{
+    struct xrDestroyFaceTracker2FB_params params;
+    NTSTATUS _status;
+    params.faceTracker = faceTracker;
+    _status = UNIX_CALL(xrDestroyFaceTracker2FB, &params);
+    assert(!_status && "xrDestroyFaceTracker2FB");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyFaceTrackerFB(XrFaceTrackerFB faceTracker)
+{
+    struct xrDestroyFaceTrackerFB_params params;
+    NTSTATUS _status;
+    params.faceTracker = faceTracker;
+    _status = UNIX_CALL(xrDestroyFaceTrackerFB, &params);
+    assert(!_status && "xrDestroyFaceTrackerFB");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyFacialExpressionClientML(XrFacialExpressionClientML facialExpressionClient)
+{
+    struct xrDestroyFacialExpressionClientML_params params;
+    NTSTATUS _status;
+    params.facialExpressionClient = facialExpressionClient;
+    _status = UNIX_CALL(xrDestroyFacialExpressionClientML, &params);
+    assert(!_status && "xrDestroyFacialExpressionClientML");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyFacialTrackerHTC(XrFacialTrackerHTC facialTracker)
+{
+    struct xrDestroyFacialTrackerHTC_params params;
+    NTSTATUS _status;
+    params.facialTracker = facialTracker;
+    _status = UNIX_CALL(xrDestroyFacialTrackerHTC, &params);
+    assert(!_status && "xrDestroyFacialTrackerHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyFoveationProfileFB(XrFoveationProfileFB profile)
+{
+    struct xrDestroyFoveationProfileFB_params params;
+    NTSTATUS _status;
+    params.profile = profile;
+    _status = UNIX_CALL(xrDestroyFoveationProfileFB, &params);
+    assert(!_status && "xrDestroyFoveationProfileFB");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyGeometryInstanceFB(XrGeometryInstanceFB instance)
+{
+    struct xrDestroyGeometryInstanceFB_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    _status = UNIX_CALL(xrDestroyGeometryInstanceFB, &params);
+    assert(!_status && "xrDestroyGeometryInstanceFB");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyHandTrackerEXT(XrHandTrackerEXT handTracker)
+{
+    struct xrDestroyHandTrackerEXT_params params;
+    NTSTATUS _status;
+    params.handTracker = handTracker;
+    _status = UNIX_CALL(xrDestroyHandTrackerEXT, &params);
+    assert(!_status && "xrDestroyHandTrackerEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyMarkerDetectorML(XrMarkerDetectorML markerDetector)
+{
+    struct xrDestroyMarkerDetectorML_params params;
+    NTSTATUS _status;
+    params.markerDetector = markerDetector;
+    _status = UNIX_CALL(xrDestroyMarkerDetectorML, &params);
+    assert(!_status && "xrDestroyMarkerDetectorML");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyPassthroughColorLutMETA(XrPassthroughColorLutMETA colorLut)
+{
+    struct xrDestroyPassthroughColorLutMETA_params params;
+    NTSTATUS _status;
+    params.colorLut = colorLut;
+    _status = UNIX_CALL(xrDestroyPassthroughColorLutMETA, &params);
+    assert(!_status && "xrDestroyPassthroughColorLutMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyPassthroughFB(XrPassthroughFB passthrough)
+{
+    struct xrDestroyPassthroughFB_params params;
+    NTSTATUS _status;
+    params.passthrough = passthrough;
+    _status = UNIX_CALL(xrDestroyPassthroughFB, &params);
+    assert(!_status && "xrDestroyPassthroughFB");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyPassthroughHTC(XrPassthroughHTC passthrough)
+{
+    struct xrDestroyPassthroughHTC_params params;
+    NTSTATUS _status;
+    params.passthrough = passthrough;
+    _status = UNIX_CALL(xrDestroyPassthroughHTC, &params);
+    assert(!_status && "xrDestroyPassthroughHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyPassthroughLayerFB(XrPassthroughLayerFB layer)
+{
+    struct xrDestroyPassthroughLayerFB_params params;
+    NTSTATUS _status;
+    params.layer = layer;
+    _status = UNIX_CALL(xrDestroyPassthroughLayerFB, &params);
+    assert(!_status && "xrDestroyPassthroughLayerFB");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyPlaneDetectorEXT(XrPlaneDetectorEXT planeDetector)
+{
+    struct xrDestroyPlaneDetectorEXT_params params;
+    NTSTATUS _status;
+    params.planeDetector = planeDetector;
+    _status = UNIX_CALL(xrDestroyPlaneDetectorEXT, &params);
+    assert(!_status && "xrDestroyPlaneDetectorEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyRenderModelAssetEXT(XrRenderModelAssetEXT asset)
+{
+    struct xrDestroyRenderModelAssetEXT_params params;
+    NTSTATUS _status;
+    params.asset = asset;
+    _status = UNIX_CALL(xrDestroyRenderModelAssetEXT, &params);
+    assert(!_status && "xrDestroyRenderModelAssetEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyRenderModelEXT(XrRenderModelEXT renderModel)
+{
+    struct xrDestroyRenderModelEXT_params params;
+    NTSTATUS _status;
+    params.renderModel = renderModel;
+    _status = UNIX_CALL(xrDestroyRenderModelEXT, &params);
+    assert(!_status && "xrDestroyRenderModelEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySceneMSFT(XrSceneMSFT scene)
+{
+    struct xrDestroySceneMSFT_params params;
+    NTSTATUS _status;
+    params.scene = scene;
+    _status = UNIX_CALL(xrDestroySceneMSFT, &params);
+    assert(!_status && "xrDestroySceneMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySceneObserverMSFT(XrSceneObserverMSFT sceneObserver)
+{
+    struct xrDestroySceneObserverMSFT_params params;
+    NTSTATUS _status;
+    params.sceneObserver = sceneObserver;
+    _status = UNIX_CALL(xrDestroySceneObserverMSFT, &params);
+    assert(!_status && "xrDestroySceneObserverMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySenseDataProviderBD(XrSenseDataProviderBD provider)
+{
+    struct xrDestroySenseDataProviderBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    _status = UNIX_CALL(xrDestroySenseDataProviderBD, &params);
+    assert(!_status && "xrDestroySenseDataProviderBD");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySenseDataSnapshotBD(XrSenseDataSnapshotBD snapshot)
+{
+    struct xrDestroySenseDataSnapshotBD_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    _status = UNIX_CALL(xrDestroySenseDataSnapshotBD, &params);
+    assert(!_status && "xrDestroySenseDataSnapshotBD");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySpace(XrSpace space)
+{
+    struct xrDestroySpace_params params;
+    NTSTATUS _status;
+    params.space = space;
+    _status = UNIX_CALL(xrDestroySpace, &params);
+    assert(!_status && "xrDestroySpace");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySpaceUserFB(XrSpaceUserFB user)
+{
+    struct xrDestroySpaceUserFB_params params;
+    NTSTATUS _status;
+    params.user = user;
+    _status = UNIX_CALL(xrDestroySpaceUserFB, &params);
+    assert(!_status && "xrDestroySpaceUserFB");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySpatialAnchorMSFT(XrSpatialAnchorMSFT anchor)
+{
+    struct xrDestroySpatialAnchorMSFT_params params;
+    NTSTATUS _status;
+    params.anchor = anchor;
+    _status = UNIX_CALL(xrDestroySpatialAnchorMSFT, &params);
+    assert(!_status && "xrDestroySpatialAnchorMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySpatialAnchorStoreConnectionMSFT(XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore)
+{
+    struct xrDestroySpatialAnchorStoreConnectionMSFT_params params;
+    NTSTATUS _status;
+    params.spatialAnchorStore = spatialAnchorStore;
+    _status = UNIX_CALL(xrDestroySpatialAnchorStoreConnectionMSFT, &params);
+    assert(!_status && "xrDestroySpatialAnchorStoreConnectionMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySpatialAnchorsStorageML(XrSpatialAnchorsStorageML storage)
+{
+    struct xrDestroySpatialAnchorsStorageML_params params;
+    NTSTATUS _status;
+    params.storage = storage;
+    _status = UNIX_CALL(xrDestroySpatialAnchorsStorageML, &params);
+    assert(!_status && "xrDestroySpatialAnchorsStorageML");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySpatialContextEXT(XrSpatialContextEXT spatialContext)
+{
+    struct xrDestroySpatialContextEXT_params params;
+    NTSTATUS _status;
+    params.spatialContext = spatialContext;
+    _status = UNIX_CALL(xrDestroySpatialContextEXT, &params);
+    assert(!_status && "xrDestroySpatialContextEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySpatialEntityEXT(XrSpatialEntityEXT spatialEntity)
+{
+    struct xrDestroySpatialEntityEXT_params params;
+    NTSTATUS _status;
+    params.spatialEntity = spatialEntity;
+    _status = UNIX_CALL(xrDestroySpatialEntityEXT, &params);
+    assert(!_status && "xrDestroySpatialEntityEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySpatialGraphNodeBindingMSFT(XrSpatialGraphNodeBindingMSFT nodeBinding)
+{
+    struct xrDestroySpatialGraphNodeBindingMSFT_params params;
+    NTSTATUS _status;
+    params.nodeBinding = nodeBinding;
+    _status = UNIX_CALL(xrDestroySpatialGraphNodeBindingMSFT, &params);
+    assert(!_status && "xrDestroySpatialGraphNodeBindingMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySpatialPersistenceContextEXT(XrSpatialPersistenceContextEXT persistenceContext)
+{
+    struct xrDestroySpatialPersistenceContextEXT_params params;
+    NTSTATUS _status;
+    params.persistenceContext = persistenceContext;
+    _status = UNIX_CALL(xrDestroySpatialPersistenceContextEXT, &params);
+    assert(!_status && "xrDestroySpatialPersistenceContextEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroySpatialSnapshotEXT(XrSpatialSnapshotEXT snapshot)
+{
+    struct xrDestroySpatialSnapshotEXT_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    _status = UNIX_CALL(xrDestroySpatialSnapshotEXT, &params);
+    assert(!_status && "xrDestroySpatialSnapshotEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyTrackableTrackerANDROID(XrTrackableTrackerANDROID trackableTracker)
+{
+    struct xrDestroyTrackableTrackerANDROID_params params;
+    NTSTATUS _status;
+    params.trackableTracker = trackableTracker;
+    _status = UNIX_CALL(xrDestroyTrackableTrackerANDROID, &params);
+    assert(!_status && "xrDestroyTrackableTrackerANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyTriangleMeshFB(XrTriangleMeshFB mesh)
+{
+    struct xrDestroyTriangleMeshFB_params params;
+    NTSTATUS _status;
+    params.mesh = mesh;
+    _status = UNIX_CALL(xrDestroyTriangleMeshFB, &params);
+    assert(!_status && "xrDestroyTriangleMeshFB");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyVirtualKeyboardMETA(XrVirtualKeyboardMETA keyboard)
+{
+    struct xrDestroyVirtualKeyboardMETA_params params;
+    NTSTATUS _status;
+    params.keyboard = keyboard;
+    _status = UNIX_CALL(xrDestroyVirtualKeyboardMETA, &params);
+    assert(!_status && "xrDestroyVirtualKeyboardMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrDestroyWorldMeshDetectorML(XrWorldMeshDetectorML detector)
+{
+    struct xrDestroyWorldMeshDetectorML_params params;
+    NTSTATUS _status;
+    params.detector = detector;
+    _status = UNIX_CALL(xrDestroyWorldMeshDetectorML, &params);
+    assert(!_status && "xrDestroyWorldMeshDetectorML");
+    return params.result;
+}
+
+XrResult WINAPI xrDiscoverSpacesMETA(XrSession session, const XrSpaceDiscoveryInfoMETA *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrDiscoverSpacesMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrDiscoverSpacesMETA, &params);
+    assert(!_status && "xrDiscoverSpacesMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrDownloadSharedSpatialAnchorAsyncBD(XrSenseDataProviderBD provider, const XrSharedSpatialAnchorDownloadInfoBD *info, XrFutureEXT *future)
+{
+    struct xrDownloadSharedSpatialAnchorAsyncBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.info = info;
+    params.future = future;
+    _status = UNIX_CALL(xrDownloadSharedSpatialAnchorAsyncBD, &params);
+    assert(!_status && "xrDownloadSharedSpatialAnchorAsyncBD");
+    return params.result;
+}
+
+XrResult WINAPI xrDownloadSharedSpatialAnchorCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrFutureCompletionEXT *completion)
+{
+    struct xrDownloadSharedSpatialAnchorCompleteBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrDownloadSharedSpatialAnchorCompleteBD, &params);
+    assert(!_status && "xrDownloadSharedSpatialAnchorCompleteBD");
+    return params.result;
+}
+
+XrResult WINAPI xrEnableLocalizationEventsML(XrSession session, const XrLocalizationEnableEventsInfoML *info)
+{
+    struct xrEnableLocalizationEventsML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    _status = UNIX_CALL(xrEnableLocalizationEventsML, &params);
+    assert(!_status && "xrEnableLocalizationEventsML");
+    return params.result;
+}
+
+XrResult WINAPI xrEnableUserCalibrationEventsML(XrInstance instance, const XrUserCalibrationEnableEventsInfoML *enableInfo)
+{
+    struct xrEnableUserCalibrationEventsML_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.enableInfo = enableInfo;
+    _status = UNIX_CALL(xrEnableUserCalibrationEventsML, &params);
+    assert(!_status && "xrEnableUserCalibrationEventsML");
+    return params.result;
+}
+
+XrResult WINAPI xrEndSession(XrSession session)
+{
+    struct xrEndSession_params params;
+    NTSTATUS _status;
+    params.session = session;
+    _status = UNIX_CALL(xrEndSession, &params);
+    assert(!_status && "xrEndSession");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateApiLayerProperties(uint32_t propertyCapacityInput, uint32_t *propertyCountOutput, XrApiLayerProperties *properties)
+{
+    struct xrEnumerateApiLayerProperties_params params;
+    NTSTATUS _status;
+    params.propertyCapacityInput = propertyCapacityInput;
+    params.propertyCountOutput = propertyCountOutput;
+    params.properties = properties;
+    _status = UNIX_CALL(xrEnumerateApiLayerProperties, &params);
+    assert(!_status && "xrEnumerateApiLayerProperties");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateBoundSourcesForAction(XrSession session, const XrBoundSourcesForActionEnumerateInfo *enumerateInfo, uint32_t sourceCapacityInput, uint32_t *sourceCountOutput, XrPath *sources)
+{
+    struct xrEnumerateBoundSourcesForAction_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.enumerateInfo = enumerateInfo;
+    params.sourceCapacityInput = sourceCapacityInput;
+    params.sourceCountOutput = sourceCountOutput;
+    params.sources = sources;
+    _status = UNIX_CALL(xrEnumerateBoundSourcesForAction, &params);
+    assert(!_status && "xrEnumerateBoundSourcesForAction");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateColorSpacesFB(XrSession session, uint32_t colorSpaceCapacityInput, uint32_t *colorSpaceCountOutput, XrColorSpaceFB *colorSpaces)
+{
+    struct xrEnumerateColorSpacesFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.colorSpaceCapacityInput = colorSpaceCapacityInput;
+    params.colorSpaceCountOutput = colorSpaceCountOutput;
+    params.colorSpaces = colorSpaces;
+    _status = UNIX_CALL(xrEnumerateColorSpacesFB, &params);
+    assert(!_status && "xrEnumerateColorSpacesFB");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateDisplayRefreshRatesFB(XrSession session, uint32_t displayRefreshRateCapacityInput, uint32_t *displayRefreshRateCountOutput, float *displayRefreshRates)
+{
+    struct xrEnumerateDisplayRefreshRatesFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.displayRefreshRateCapacityInput = displayRefreshRateCapacityInput;
+    params.displayRefreshRateCountOutput = displayRefreshRateCountOutput;
+    params.displayRefreshRates = displayRefreshRates;
+    _status = UNIX_CALL(xrEnumerateDisplayRefreshRatesFB, &params);
+    assert(!_status && "xrEnumerateDisplayRefreshRatesFB");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateEnvironmentBlendModes(XrInstance instance, XrSystemId systemId, XrViewConfigurationType viewConfigurationType, uint32_t environmentBlendModeCapacityInput, uint32_t *environmentBlendModeCountOutput, XrEnvironmentBlendMode *environmentBlendModes)
+{
+    struct xrEnumerateEnvironmentBlendModes_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.viewConfigurationType = viewConfigurationType;
+    params.environmentBlendModeCapacityInput = environmentBlendModeCapacityInput;
+    params.environmentBlendModeCountOutput = environmentBlendModeCountOutput;
+    params.environmentBlendModes = environmentBlendModes;
+    _status = UNIX_CALL(xrEnumerateEnvironmentBlendModes, &params);
+    assert(!_status && "xrEnumerateEnvironmentBlendModes");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateEnvironmentDepthSwapchainImagesMETA(XrEnvironmentDepthSwapchainMETA swapchain, uint32_t imageCapacityInput, uint32_t *imageCountOutput, XrSwapchainImageBaseHeader *images)
+{
+    struct xrEnumerateEnvironmentDepthSwapchainImagesMETA_params params;
+    NTSTATUS _status;
+    params.swapchain = swapchain;
+    params.imageCapacityInput = imageCapacityInput;
+    params.imageCountOutput = imageCountOutput;
+    params.images = images;
+    _status = UNIX_CALL(xrEnumerateEnvironmentDepthSwapchainImagesMETA, &params);
+    assert(!_status && "xrEnumerateEnvironmentDepthSwapchainImagesMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateExternalCamerasOCULUS(XrSession session, uint32_t cameraCapacityInput, uint32_t *cameraCountOutput, XrExternalCameraOCULUS *cameras)
+{
+    struct xrEnumerateExternalCamerasOCULUS_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.cameraCapacityInput = cameraCapacityInput;
+    params.cameraCountOutput = cameraCountOutput;
+    params.cameras = cameras;
+    _status = UNIX_CALL(xrEnumerateExternalCamerasOCULUS, &params);
+    assert(!_status && "xrEnumerateExternalCamerasOCULUS");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateInstanceExtensionProperties(const char *layerName, uint32_t propertyCapacityInput, uint32_t *propertyCountOutput, XrExtensionProperties *properties)
+{
+    struct xrEnumerateInstanceExtensionProperties_params params;
+    NTSTATUS _status;
+    params.layerName = layerName;
+    params.propertyCapacityInput = propertyCapacityInput;
+    params.propertyCountOutput = propertyCountOutput;
+    params.properties = properties;
+    _status = UNIX_CALL(xrEnumerateInstanceExtensionProperties, &params);
+    assert(!_status && "xrEnumerateInstanceExtensionProperties");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateInteractionRenderModelIdsEXT(XrSession session, const XrInteractionRenderModelIdsEnumerateInfoEXT *getInfo, uint32_t renderModelIdCapacityInput, uint32_t *renderModelIdCountOutput, XrRenderModelIdEXT *renderModelIds)
+{
+    struct xrEnumerateInteractionRenderModelIdsEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.getInfo = getInfo;
+    params.renderModelIdCapacityInput = renderModelIdCapacityInput;
+    params.renderModelIdCountOutput = renderModelIdCountOutput;
+    params.renderModelIds = renderModelIds;
+    _status = UNIX_CALL(xrEnumerateInteractionRenderModelIdsEXT, &params);
+    assert(!_status && "xrEnumerateInteractionRenderModelIdsEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumeratePerformanceMetricsCounterPathsMETA(XrInstance instance, uint32_t counterPathCapacityInput, uint32_t *counterPathCountOutput, XrPath *counterPaths)
+{
+    struct xrEnumeratePerformanceMetricsCounterPathsMETA_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.counterPathCapacityInput = counterPathCapacityInput;
+    params.counterPathCountOutput = counterPathCountOutput;
+    params.counterPaths = counterPaths;
+    _status = UNIX_CALL(xrEnumeratePerformanceMetricsCounterPathsMETA, &params);
+    assert(!_status && "xrEnumeratePerformanceMetricsCounterPathsMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumeratePersistedAnchorsANDROID(XrDeviceAnchorPersistenceANDROID handle, uint32_t anchorIdCapacityInput, uint32_t *anchorIdCountOutput, XrUuidEXT *anchorIds)
+{
+    struct xrEnumeratePersistedAnchorsANDROID_params params;
+    NTSTATUS _status;
+    params.handle = handle;
+    params.anchorIdCapacityInput = anchorIdCapacityInput;
+    params.anchorIdCountOutput = anchorIdCountOutput;
+    params.anchorIds = anchorIds;
+    _status = UNIX_CALL(xrEnumeratePersistedAnchorsANDROID, &params);
+    assert(!_status && "xrEnumeratePersistedAnchorsANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumeratePersistedSpatialAnchorNamesMSFT(XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore, uint32_t spatialAnchorNameCapacityInput, uint32_t *spatialAnchorNameCountOutput, XrSpatialAnchorPersistenceNameMSFT *spatialAnchorNames)
+{
+    struct xrEnumeratePersistedSpatialAnchorNamesMSFT_params params;
+    NTSTATUS _status;
+    params.spatialAnchorStore = spatialAnchorStore;
+    params.spatialAnchorNameCapacityInput = spatialAnchorNameCapacityInput;
+    params.spatialAnchorNameCountOutput = spatialAnchorNameCountOutput;
+    params.spatialAnchorNames = spatialAnchorNames;
+    _status = UNIX_CALL(xrEnumeratePersistedSpatialAnchorNamesMSFT, &params);
+    assert(!_status && "xrEnumeratePersistedSpatialAnchorNamesMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateRaycastSupportedTrackableTypesANDROID(XrInstance instance, XrSystemId systemId, uint32_t trackableTypeCapacityInput, uint32_t *trackableTypeCountOutput, XrTrackableTypeANDROID *trackableTypes)
+{
+    struct xrEnumerateRaycastSupportedTrackableTypesANDROID_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.trackableTypeCapacityInput = trackableTypeCapacityInput;
+    params.trackableTypeCountOutput = trackableTypeCountOutput;
+    params.trackableTypes = trackableTypes;
+    _status = UNIX_CALL(xrEnumerateRaycastSupportedTrackableTypesANDROID, &params);
+    assert(!_status && "xrEnumerateRaycastSupportedTrackableTypesANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateReferenceSpaces(XrSession session, uint32_t spaceCapacityInput, uint32_t *spaceCountOutput, XrReferenceSpaceType *spaces)
+{
+    struct xrEnumerateReferenceSpaces_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.spaceCapacityInput = spaceCapacityInput;
+    params.spaceCountOutput = spaceCountOutput;
+    params.spaces = spaces;
+    _status = UNIX_CALL(xrEnumerateReferenceSpaces, &params);
+    assert(!_status && "xrEnumerateReferenceSpaces");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateRenderModelPathsFB(XrSession session, uint32_t pathCapacityInput, uint32_t *pathCountOutput, XrRenderModelPathInfoFB *paths)
+{
+    struct xrEnumerateRenderModelPathsFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.pathCapacityInput = pathCapacityInput;
+    params.pathCountOutput = pathCountOutput;
+    params.paths = paths;
+    _status = UNIX_CALL(xrEnumerateRenderModelPathsFB, &params);
+    assert(!_status && "xrEnumerateRenderModelPathsFB");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateRenderModelSubactionPathsEXT(XrRenderModelEXT renderModel, const XrInteractionRenderModelSubactionPathInfoEXT *info, uint32_t pathCapacityInput, uint32_t *pathCountOutput, XrPath *paths)
+{
+    struct xrEnumerateRenderModelSubactionPathsEXT_params params;
+    NTSTATUS _status;
+    params.renderModel = renderModel;
+    params.info = info;
+    params.pathCapacityInput = pathCapacityInput;
+    params.pathCountOutput = pathCountOutput;
+    params.paths = paths;
+    _status = UNIX_CALL(xrEnumerateRenderModelSubactionPathsEXT, &params);
+    assert(!_status && "xrEnumerateRenderModelSubactionPathsEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateReprojectionModesMSFT(XrInstance instance, XrSystemId systemId, XrViewConfigurationType viewConfigurationType, uint32_t modeCapacityInput, uint32_t *modeCountOutput, XrReprojectionModeMSFT *modes)
+{
+    struct xrEnumerateReprojectionModesMSFT_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.viewConfigurationType = viewConfigurationType;
+    params.modeCapacityInput = modeCapacityInput;
+    params.modeCountOutput = modeCountOutput;
+    params.modes = modes;
+    _status = UNIX_CALL(xrEnumerateReprojectionModesMSFT, &params);
+    assert(!_status && "xrEnumerateReprojectionModesMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateSceneComputeFeaturesMSFT(XrInstance instance, XrSystemId systemId, uint32_t featureCapacityInput, uint32_t *featureCountOutput, XrSceneComputeFeatureMSFT *features)
+{
+    struct xrEnumerateSceneComputeFeaturesMSFT_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.featureCapacityInput = featureCapacityInput;
+    params.featureCountOutput = featureCountOutput;
+    params.features = features;
+    _status = UNIX_CALL(xrEnumerateSceneComputeFeaturesMSFT, &params);
+    assert(!_status && "xrEnumerateSceneComputeFeaturesMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateSpaceSupportedComponentsFB(XrSpace space, uint32_t componentTypeCapacityInput, uint32_t *componentTypeCountOutput, XrSpaceComponentTypeFB *componentTypes)
+{
+    struct xrEnumerateSpaceSupportedComponentsFB_params params;
+    NTSTATUS _status;
+    params.space = space;
+    params.componentTypeCapacityInput = componentTypeCapacityInput;
+    params.componentTypeCountOutput = componentTypeCountOutput;
+    params.componentTypes = componentTypes;
+    _status = UNIX_CALL(xrEnumerateSpaceSupportedComponentsFB, &params);
+    assert(!_status && "xrEnumerateSpaceSupportedComponentsFB");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateSpatialCapabilitiesEXT(XrInstance instance, XrSystemId systemId, uint32_t capabilityCapacityInput, uint32_t *capabilityCountOutput, XrSpatialCapabilityEXT *capabilities)
+{
+    struct xrEnumerateSpatialCapabilitiesEXT_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.capabilityCapacityInput = capabilityCapacityInput;
+    params.capabilityCountOutput = capabilityCountOutput;
+    params.capabilities = capabilities;
+    _status = UNIX_CALL(xrEnumerateSpatialCapabilitiesEXT, &params);
+    assert(!_status && "xrEnumerateSpatialCapabilitiesEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateSpatialCapabilityComponentTypesEXT(XrInstance instance, XrSystemId systemId, XrSpatialCapabilityEXT capability, XrSpatialCapabilityComponentTypesEXT *capabilityComponents)
+{
+    struct xrEnumerateSpatialCapabilityComponentTypesEXT_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.capability = capability;
+    params.capabilityComponents = capabilityComponents;
+    _status = UNIX_CALL(xrEnumerateSpatialCapabilityComponentTypesEXT, &params);
+    assert(!_status && "xrEnumerateSpatialCapabilityComponentTypesEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateSpatialCapabilityFeaturesEXT(XrInstance instance, XrSystemId systemId, XrSpatialCapabilityEXT capability, uint32_t capabilityFeatureCapacityInput, uint32_t *capabilityFeatureCountOutput, XrSpatialCapabilityFeatureEXT *capabilityFeatures)
+{
+    struct xrEnumerateSpatialCapabilityFeaturesEXT_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.capability = capability;
+    params.capabilityFeatureCapacityInput = capabilityFeatureCapacityInput;
+    params.capabilityFeatureCountOutput = capabilityFeatureCountOutput;
+    params.capabilityFeatures = capabilityFeatures;
+    _status = UNIX_CALL(xrEnumerateSpatialCapabilityFeaturesEXT, &params);
+    assert(!_status && "xrEnumerateSpatialCapabilityFeaturesEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateSpatialEntityComponentTypesBD(XrSenseDataSnapshotBD snapshot, XrSpatialEntityIdBD entityId, uint32_t componentTypeCapacityInput, uint32_t *componentTypeCountOutput, XrSpatialEntityComponentTypeBD *componentTypes)
+{
+    struct xrEnumerateSpatialEntityComponentTypesBD_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.entityId = entityId;
+    params.componentTypeCapacityInput = componentTypeCapacityInput;
+    params.componentTypeCountOutput = componentTypeCountOutput;
+    params.componentTypes = componentTypes;
+    _status = UNIX_CALL(xrEnumerateSpatialEntityComponentTypesBD, &params);
+    assert(!_status && "xrEnumerateSpatialEntityComponentTypesBD");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateSpatialPersistenceScopesEXT(XrInstance instance, XrSystemId systemId, uint32_t persistenceScopeCapacityInput, uint32_t *persistenceScopeCountOutput, XrSpatialPersistenceScopeEXT *persistenceScopes)
+{
+    struct xrEnumerateSpatialPersistenceScopesEXT_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.persistenceScopeCapacityInput = persistenceScopeCapacityInput;
+    params.persistenceScopeCountOutput = persistenceScopeCountOutput;
+    params.persistenceScopes = persistenceScopes;
+    _status = UNIX_CALL(xrEnumerateSpatialPersistenceScopesEXT, &params);
+    assert(!_status && "xrEnumerateSpatialPersistenceScopesEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateSupportedAnchorTrackableTypesANDROID(XrInstance instance, XrSystemId systemId, uint32_t trackableTypeCapacityInput, uint32_t *trackableTypeCountOutput, XrTrackableTypeANDROID *trackableTypes)
+{
+    struct xrEnumerateSupportedAnchorTrackableTypesANDROID_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.trackableTypeCapacityInput = trackableTypeCapacityInput;
+    params.trackableTypeCountOutput = trackableTypeCountOutput;
+    params.trackableTypes = trackableTypes;
+    _status = UNIX_CALL(xrEnumerateSupportedAnchorTrackableTypesANDROID, &params);
+    assert(!_status && "xrEnumerateSupportedAnchorTrackableTypesANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateSupportedPersistenceAnchorTypesANDROID(XrInstance instance, XrSystemId systemId, uint32_t trackableTypeCapacityInput, uint32_t *trackableTypeCountOutput, XrTrackableTypeANDROID *trackableTypes)
+{
+    struct xrEnumerateSupportedPersistenceAnchorTypesANDROID_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.trackableTypeCapacityInput = trackableTypeCapacityInput;
+    params.trackableTypeCountOutput = trackableTypeCountOutput;
+    params.trackableTypes = trackableTypes;
+    _status = UNIX_CALL(xrEnumerateSupportedPersistenceAnchorTypesANDROID, &params);
+    assert(!_status && "xrEnumerateSupportedPersistenceAnchorTypesANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateSupportedTrackableTypesANDROID(XrInstance instance, XrSystemId systemId, uint32_t trackableTypeCapacityInput, uint32_t *trackableTypeCountOutput, XrTrackableTypeANDROID *trackableTypes)
+{
+    struct xrEnumerateSupportedTrackableTypesANDROID_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.trackableTypeCapacityInput = trackableTypeCapacityInput;
+    params.trackableTypeCountOutput = trackableTypeCountOutput;
+    params.trackableTypes = trackableTypes;
+    _status = UNIX_CALL(xrEnumerateSupportedTrackableTypesANDROID, &params);
+    assert(!_status && "xrEnumerateSupportedTrackableTypesANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateViewConfigurationViews(XrInstance instance, XrSystemId systemId, XrViewConfigurationType viewConfigurationType, uint32_t viewCapacityInput, uint32_t *viewCountOutput, XrViewConfigurationView *views)
+{
+    struct xrEnumerateViewConfigurationViews_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.viewConfigurationType = viewConfigurationType;
+    params.viewCapacityInput = viewCapacityInput;
+    params.viewCountOutput = viewCountOutput;
+    params.views = views;
+    _status = UNIX_CALL(xrEnumerateViewConfigurationViews, &params);
+    assert(!_status && "xrEnumerateViewConfigurationViews");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateViewConfigurations(XrInstance instance, XrSystemId systemId, uint32_t viewConfigurationTypeCapacityInput, uint32_t *viewConfigurationTypeCountOutput, XrViewConfigurationType *viewConfigurationTypes)
+{
+    struct xrEnumerateViewConfigurations_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.viewConfigurationTypeCapacityInput = viewConfigurationTypeCapacityInput;
+    params.viewConfigurationTypeCountOutput = viewConfigurationTypeCountOutput;
+    params.viewConfigurationTypes = viewConfigurationTypes;
+    _status = UNIX_CALL(xrEnumerateViewConfigurations, &params);
+    assert(!_status && "xrEnumerateViewConfigurations");
+    return params.result;
+}
+
+XrResult WINAPI xrEnumerateViveTrackerPathsHTCX(XrInstance instance, uint32_t pathCapacityInput, uint32_t *pathCountOutput, XrViveTrackerPathsHTCX *paths)
+{
+    struct xrEnumerateViveTrackerPathsHTCX_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.pathCapacityInput = pathCapacityInput;
+    params.pathCountOutput = pathCountOutput;
+    params.paths = paths;
+    _status = UNIX_CALL(xrEnumerateViveTrackerPathsHTCX, &params);
+    assert(!_status && "xrEnumerateViveTrackerPathsHTCX");
+    return params.result;
+}
+
+XrResult WINAPI xrEraseSpaceFB(XrSession session, const XrSpaceEraseInfoFB *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrEraseSpaceFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrEraseSpaceFB, &params);
+    assert(!_status && "xrEraseSpaceFB");
+    return params.result;
+}
+
+XrResult WINAPI xrEraseSpacesMETA(XrSession session, const XrSpacesEraseInfoMETA *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrEraseSpacesMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrEraseSpacesMETA, &params);
+    assert(!_status && "xrEraseSpacesMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrFreeWorldMeshBufferML(XrWorldMeshDetectorML detector, const XrWorldMeshBufferML *buffer)
+{
+    struct xrFreeWorldMeshBufferML_params params;
+    NTSTATUS _status;
+    params.detector = detector;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrFreeWorldMeshBufferML, &params);
+    assert(!_status && "xrFreeWorldMeshBufferML");
+    return params.result;
+}
+
+XrResult WINAPI xrGeometryInstanceSetTransformFB(XrGeometryInstanceFB instance, const XrGeometryInstanceTransformFB *transformation)
+{
+    struct xrGeometryInstanceSetTransformFB_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.transformation = transformation;
+    _status = UNIX_CALL(xrGeometryInstanceSetTransformFB, &params);
+    assert(!_status && "xrGeometryInstanceSetTransformFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetActionStateBoolean(XrSession session, const XrActionStateGetInfo *getInfo, XrActionStateBoolean *state)
+{
+    struct xrGetActionStateBoolean_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.getInfo = getInfo;
+    params.state = state;
+    _status = UNIX_CALL(xrGetActionStateBoolean, &params);
+    assert(!_status && "xrGetActionStateBoolean");
+    return params.result;
+}
+
+XrResult WINAPI xrGetActionStateFloat(XrSession session, const XrActionStateGetInfo *getInfo, XrActionStateFloat *state)
+{
+    struct xrGetActionStateFloat_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.getInfo = getInfo;
+    params.state = state;
+    _status = UNIX_CALL(xrGetActionStateFloat, &params);
+    assert(!_status && "xrGetActionStateFloat");
+    return params.result;
+}
+
+XrResult WINAPI xrGetActionStatePose(XrSession session, const XrActionStateGetInfo *getInfo, XrActionStatePose *state)
+{
+    struct xrGetActionStatePose_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.getInfo = getInfo;
+    params.state = state;
+    _status = UNIX_CALL(xrGetActionStatePose, &params);
+    assert(!_status && "xrGetActionStatePose");
+    return params.result;
+}
+
+XrResult WINAPI xrGetActionStateVector2f(XrSession session, const XrActionStateGetInfo *getInfo, XrActionStateVector2f *state)
+{
+    struct xrGetActionStateVector2f_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.getInfo = getInfo;
+    params.state = state;
+    _status = UNIX_CALL(xrGetActionStateVector2f, &params);
+    assert(!_status && "xrGetActionStateVector2f");
+    return params.result;
+}
+
+XrResult WINAPI xrGetAllTrackablesANDROID(XrTrackableTrackerANDROID trackableTracker, uint32_t trackableCapacityInput, uint32_t *trackableCountOutput, XrTrackableANDROID *trackables)
+{
+    struct xrGetAllTrackablesANDROID_params params;
+    NTSTATUS _status;
+    params.trackableTracker = trackableTracker;
+    params.trackableCapacityInput = trackableCapacityInput;
+    params.trackableCountOutput = trackableCountOutput;
+    params.trackables = trackables;
+    _status = UNIX_CALL(xrGetAllTrackablesANDROID, &params);
+    assert(!_status && "xrGetAllTrackablesANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrGetAnchorPersistStateANDROID(XrDeviceAnchorPersistenceANDROID handle, const XrUuidEXT *anchorId, XrAnchorPersistStateANDROID *persistState)
+{
+    struct xrGetAnchorPersistStateANDROID_params params;
+    NTSTATUS _status;
+    params.handle = handle;
+    params.anchorId = anchorId;
+    params.persistState = persistState;
+    _status = UNIX_CALL(xrGetAnchorPersistStateANDROID, &params);
+    assert(!_status && "xrGetAnchorPersistStateANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrGetAnchorUuidBD(XrAnchorBD anchor, XrUuidEXT *uuid)
+{
+    struct xrGetAnchorUuidBD_params params;
+    NTSTATUS _status;
+    params.anchor = anchor;
+    params.uuid = uuid;
+    _status = UNIX_CALL(xrGetAnchorUuidBD, &params);
+    assert(!_status && "xrGetAnchorUuidBD");
+    return params.result;
+}
+
+XrResult WINAPI xrGetAudioInputDeviceGuidOculus(XrInstance instance, wchar_t buffer[])
+{
+    struct xrGetAudioInputDeviceGuidOculus_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetAudioInputDeviceGuidOculus, &params);
+    assert(!_status && "xrGetAudioInputDeviceGuidOculus");
+    return params.result;
+}
+
+XrResult WINAPI xrGetAudioOutputDeviceGuidOculus(XrInstance instance, wchar_t buffer[])
+{
+    struct xrGetAudioOutputDeviceGuidOculus_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetAudioOutputDeviceGuidOculus, &params);
+    assert(!_status && "xrGetAudioOutputDeviceGuidOculus");
+    return params.result;
+}
+
+XrResult WINAPI xrGetBodySkeletonFB(XrBodyTrackerFB bodyTracker, XrBodySkeletonFB *skeleton)
+{
+    struct xrGetBodySkeletonFB_params params;
+    NTSTATUS _status;
+    params.bodyTracker = bodyTracker;
+    params.skeleton = skeleton;
+    _status = UNIX_CALL(xrGetBodySkeletonFB, &params);
+    assert(!_status && "xrGetBodySkeletonFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetBodySkeletonHTC(XrBodyTrackerHTC bodyTracker, XrSpace baseSpace, uint32_t skeletonGenerationId, XrBodySkeletonHTC *skeleton)
+{
+    struct xrGetBodySkeletonHTC_params params;
+    NTSTATUS _status;
+    params.bodyTracker = bodyTracker;
+    params.baseSpace = baseSpace;
+    params.skeletonGenerationId = skeletonGenerationId;
+    params.skeleton = skeleton;
+    _status = UNIX_CALL(xrGetBodySkeletonHTC, &params);
+    assert(!_status && "xrGetBodySkeletonHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrGetControllerModelKeyMSFT(XrSession session, XrPath topLevelUserPath, XrControllerModelKeyStateMSFT *controllerModelKeyState)
+{
+    struct xrGetControllerModelKeyMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.topLevelUserPath = topLevelUserPath;
+    params.controllerModelKeyState = controllerModelKeyState;
+    _status = UNIX_CALL(xrGetControllerModelKeyMSFT, &params);
+    assert(!_status && "xrGetControllerModelKeyMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetControllerModelPropertiesMSFT(XrSession session, XrControllerModelKeyMSFT modelKey, XrControllerModelPropertiesMSFT *properties)
+{
+    struct xrGetControllerModelPropertiesMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.modelKey = modelKey;
+    params.properties = properties;
+    _status = UNIX_CALL(xrGetControllerModelPropertiesMSFT, &params);
+    assert(!_status && "xrGetControllerModelPropertiesMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetControllerModelStateMSFT(XrSession session, XrControllerModelKeyMSFT modelKey, XrControllerModelStateMSFT *state)
+{
+    struct xrGetControllerModelStateMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.modelKey = modelKey;
+    params.state = state;
+    _status = UNIX_CALL(xrGetControllerModelStateMSFT, &params);
+    assert(!_status && "xrGetControllerModelStateMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetCurrentInteractionProfile(XrSession session, XrPath topLevelUserPath, XrInteractionProfileState *interactionProfile)
+{
+    struct xrGetCurrentInteractionProfile_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.topLevelUserPath = topLevelUserPath;
+    params.interactionProfile = interactionProfile;
+    _status = UNIX_CALL(xrGetCurrentInteractionProfile, &params);
+    assert(!_status && "xrGetCurrentInteractionProfile");
+    return params.result;
+}
+
+XrResult WINAPI xrGetDeviceSampleRateFB(XrSession session, const XrHapticActionInfo *hapticActionInfo, XrDevicePcmSampleRateGetInfoFB *deviceSampleRate)
+{
+    struct xrGetDeviceSampleRateFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.hapticActionInfo = hapticActionInfo;
+    params.deviceSampleRate = deviceSampleRate;
+    _status = UNIX_CALL(xrGetDeviceSampleRateFB, &params);
+    assert(!_status && "xrGetDeviceSampleRateFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetDisplayRefreshRateFB(XrSession session, float *displayRefreshRate)
+{
+    struct xrGetDisplayRefreshRateFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.displayRefreshRate = displayRefreshRate;
+    _status = UNIX_CALL(xrGetDisplayRefreshRateFB, &params);
+    assert(!_status && "xrGetDisplayRefreshRateFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetEnvironmentDepthSwapchainStateMETA(XrEnvironmentDepthSwapchainMETA swapchain, XrEnvironmentDepthSwapchainStateMETA *state)
+{
+    struct xrGetEnvironmentDepthSwapchainStateMETA_params params;
+    NTSTATUS _status;
+    params.swapchain = swapchain;
+    params.state = state;
+    _status = UNIX_CALL(xrGetEnvironmentDepthSwapchainStateMETA, &params);
+    assert(!_status && "xrGetEnvironmentDepthSwapchainStateMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrGetExportedLocalizationMapDataML(XrExportedLocalizationMapML map, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer)
+{
+    struct xrGetExportedLocalizationMapDataML_params params;
+    NTSTATUS _status;
+    params.map = map;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetExportedLocalizationMapDataML, &params);
+    assert(!_status && "xrGetExportedLocalizationMapDataML");
+    return params.result;
+}
+
+XrResult WINAPI xrGetEyeGazesFB(XrEyeTrackerFB eyeTracker, const XrEyeGazesInfoFB *gazeInfo, XrEyeGazesFB *eyeGazes)
+{
+    struct xrGetEyeGazesFB_params params;
+    NTSTATUS _status;
+    params.eyeTracker = eyeTracker;
+    params.gazeInfo = gazeInfo;
+    params.eyeGazes = eyeGazes;
+    _status = UNIX_CALL(xrGetEyeGazesFB, &params);
+    assert(!_status && "xrGetEyeGazesFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetFaceExpressionWeights2FB(XrFaceTracker2FB faceTracker, const XrFaceExpressionInfo2FB *expressionInfo, XrFaceExpressionWeights2FB *expressionWeights)
+{
+    struct xrGetFaceExpressionWeights2FB_params params;
+    NTSTATUS _status;
+    params.faceTracker = faceTracker;
+    params.expressionInfo = expressionInfo;
+    params.expressionWeights = expressionWeights;
+    _status = UNIX_CALL(xrGetFaceExpressionWeights2FB, &params);
+    assert(!_status && "xrGetFaceExpressionWeights2FB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetFaceExpressionWeightsFB(XrFaceTrackerFB faceTracker, const XrFaceExpressionInfoFB *expressionInfo, XrFaceExpressionWeightsFB *expressionWeights)
+{
+    struct xrGetFaceExpressionWeightsFB_params params;
+    NTSTATUS _status;
+    params.faceTracker = faceTracker;
+    params.expressionInfo = expressionInfo;
+    params.expressionWeights = expressionWeights;
+    _status = UNIX_CALL(xrGetFaceExpressionWeightsFB, &params);
+    assert(!_status && "xrGetFaceExpressionWeightsFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetFacialExpressionBlendShapePropertiesML(XrFacialExpressionClientML facialExpressionClient, const XrFacialExpressionBlendShapeGetInfoML *blendShapeGetInfo, uint32_t blendShapeCount, XrFacialExpressionBlendShapePropertiesML *blendShapes)
+{
+    struct xrGetFacialExpressionBlendShapePropertiesML_params params;
+    NTSTATUS _status;
+    params.facialExpressionClient = facialExpressionClient;
+    params.blendShapeGetInfo = blendShapeGetInfo;
+    params.blendShapeCount = blendShapeCount;
+    params.blendShapes = blendShapes;
+    _status = UNIX_CALL(xrGetFacialExpressionBlendShapePropertiesML, &params);
+    assert(!_status && "xrGetFacialExpressionBlendShapePropertiesML");
+    return params.result;
+}
+
+XrResult WINAPI xrGetFacialExpressionsHTC(XrFacialTrackerHTC facialTracker, XrFacialExpressionsHTC *facialExpressions)
+{
+    struct xrGetFacialExpressionsHTC_params params;
+    NTSTATUS _status;
+    params.facialTracker = facialTracker;
+    params.facialExpressions = facialExpressions;
+    _status = UNIX_CALL(xrGetFacialExpressionsHTC, &params);
+    assert(!_status && "xrGetFacialExpressionsHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrGetFoveationEyeTrackedStateMETA(XrSession session, XrFoveationEyeTrackedStateMETA *foveationState)
+{
+    struct xrGetFoveationEyeTrackedStateMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.foveationState = foveationState;
+    _status = UNIX_CALL(xrGetFoveationEyeTrackedStateMETA, &params);
+    assert(!_status && "xrGetFoveationEyeTrackedStateMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrGetHandMeshFB(XrHandTrackerEXT handTracker, XrHandTrackingMeshFB *mesh)
+{
+    struct xrGetHandMeshFB_params params;
+    NTSTATUS _status;
+    params.handTracker = handTracker;
+    params.mesh = mesh;
+    _status = UNIX_CALL(xrGetHandMeshFB, &params);
+    assert(!_status && "xrGetHandMeshFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetInputSourceLocalizedName(XrSession session, const XrInputSourceLocalizedNameGetInfo *getInfo, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer)
+{
+    struct xrGetInputSourceLocalizedName_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.getInfo = getInfo;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetInputSourceLocalizedName, &params);
+    assert(!_status && "xrGetInputSourceLocalizedName");
+    return params.result;
+}
+
+XrResult WINAPI xrGetInstanceProperties(XrInstance instance, XrInstanceProperties *instanceProperties)
+{
+    struct xrGetInstanceProperties_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.instanceProperties = instanceProperties;
+    _status = UNIX_CALL(xrGetInstanceProperties, &params);
+    assert(!_status && "xrGetInstanceProperties");
+    return params.result;
+}
+
+XrResult WINAPI xrGetMarkerDetectorStateML(XrMarkerDetectorML markerDetector, XrMarkerDetectorStateML *state)
+{
+    struct xrGetMarkerDetectorStateML_params params;
+    NTSTATUS _status;
+    params.markerDetector = markerDetector;
+    params.state = state;
+    _status = UNIX_CALL(xrGetMarkerDetectorStateML, &params);
+    assert(!_status && "xrGetMarkerDetectorStateML");
+    return params.result;
+}
+
+XrResult WINAPI xrGetMarkerLengthML(XrMarkerDetectorML markerDetector, XrMarkerML marker, float *meters)
+{
+    struct xrGetMarkerLengthML_params params;
+    NTSTATUS _status;
+    params.markerDetector = markerDetector;
+    params.marker = marker;
+    params.meters = meters;
+    _status = UNIX_CALL(xrGetMarkerLengthML, &params);
+    assert(!_status && "xrGetMarkerLengthML");
+    return params.result;
+}
+
+XrResult WINAPI xrGetMarkerNumberML(XrMarkerDetectorML markerDetector, XrMarkerML marker, uint64_t *number)
+{
+    struct xrGetMarkerNumberML_params params;
+    NTSTATUS _status;
+    params.markerDetector = markerDetector;
+    params.marker = marker;
+    params.number = number;
+    _status = UNIX_CALL(xrGetMarkerNumberML, &params);
+    assert(!_status && "xrGetMarkerNumberML");
+    return params.result;
+}
+
+XrResult WINAPI xrGetMarkerReprojectionErrorML(XrMarkerDetectorML markerDetector, XrMarkerML marker, float *reprojectionErrorMeters)
+{
+    struct xrGetMarkerReprojectionErrorML_params params;
+    NTSTATUS _status;
+    params.markerDetector = markerDetector;
+    params.marker = marker;
+    params.reprojectionErrorMeters = reprojectionErrorMeters;
+    _status = UNIX_CALL(xrGetMarkerReprojectionErrorML, &params);
+    assert(!_status && "xrGetMarkerReprojectionErrorML");
+    return params.result;
+}
+
+XrResult WINAPI xrGetMarkerSizeVARJO(XrSession session, uint64_t markerId, XrExtent2Df *size)
+{
+    struct xrGetMarkerSizeVARJO_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.markerId = markerId;
+    params.size = size;
+    _status = UNIX_CALL(xrGetMarkerSizeVARJO, &params);
+    assert(!_status && "xrGetMarkerSizeVARJO");
+    return params.result;
+}
+
+XrResult WINAPI xrGetMarkerStringML(XrMarkerDetectorML markerDetector, XrMarkerML marker, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer)
+{
+    struct xrGetMarkerStringML_params params;
+    NTSTATUS _status;
+    params.markerDetector = markerDetector;
+    params.marker = marker;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetMarkerStringML, &params);
+    assert(!_status && "xrGetMarkerStringML");
+    return params.result;
+}
+
+XrResult WINAPI xrGetMarkersML(XrMarkerDetectorML markerDetector, uint32_t markerCapacityInput, uint32_t *markerCountOutput, XrMarkerML *markers)
+{
+    struct xrGetMarkersML_params params;
+    NTSTATUS _status;
+    params.markerDetector = markerDetector;
+    params.markerCapacityInput = markerCapacityInput;
+    params.markerCountOutput = markerCountOutput;
+    params.markers = markers;
+    _status = UNIX_CALL(xrGetMarkersML, &params);
+    assert(!_status && "xrGetMarkersML");
+    return params.result;
+}
+
+XrResult WINAPI xrGetOpenGLGraphicsRequirementsKHR(XrInstance instance, XrSystemId systemId, XrGraphicsRequirementsOpenGLKHR *graphicsRequirements)
+{
+    struct xrGetOpenGLGraphicsRequirementsKHR_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.graphicsRequirements = graphicsRequirements;
+    _status = UNIX_CALL(xrGetOpenGLGraphicsRequirementsKHR, &params);
+    assert(!_status && "xrGetOpenGLGraphicsRequirementsKHR");
+    return params.result;
+}
+
+XrResult WINAPI xrGetPassthroughCameraStateANDROID(XrSession session, const XrPassthroughCameraStateGetInfoANDROID *getInfo, XrPassthroughCameraStateANDROID *cameraStateOutput)
+{
+    struct xrGetPassthroughCameraStateANDROID_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.getInfo = getInfo;
+    params.cameraStateOutput = cameraStateOutput;
+    _status = UNIX_CALL(xrGetPassthroughCameraStateANDROID, &params);
+    assert(!_status && "xrGetPassthroughCameraStateANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrGetPassthroughPreferencesMETA(XrSession session, XrPassthroughPreferencesMETA *preferences)
+{
+    struct xrGetPassthroughPreferencesMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.preferences = preferences;
+    _status = UNIX_CALL(xrGetPassthroughPreferencesMETA, &params);
+    assert(!_status && "xrGetPassthroughPreferencesMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrGetPerformanceMetricsStateMETA(XrSession session, XrPerformanceMetricsStateMETA *state)
+{
+    struct xrGetPerformanceMetricsStateMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.state = state;
+    _status = UNIX_CALL(xrGetPerformanceMetricsStateMETA, &params);
+    assert(!_status && "xrGetPerformanceMetricsStateMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrGetPlaneDetectionStateEXT(XrPlaneDetectorEXT planeDetector, XrPlaneDetectionStateEXT *state)
+{
+    struct xrGetPlaneDetectionStateEXT_params params;
+    NTSTATUS _status;
+    params.planeDetector = planeDetector;
+    params.state = state;
+    _status = UNIX_CALL(xrGetPlaneDetectionStateEXT, &params);
+    assert(!_status && "xrGetPlaneDetectionStateEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetPlaneDetectionsEXT(XrPlaneDetectorEXT planeDetector, const XrPlaneDetectorGetInfoEXT *info, XrPlaneDetectorLocationsEXT *locations)
+{
+    struct xrGetPlaneDetectionsEXT_params params;
+    NTSTATUS _status;
+    params.planeDetector = planeDetector;
+    params.info = info;
+    params.locations = locations;
+    _status = UNIX_CALL(xrGetPlaneDetectionsEXT, &params);
+    assert(!_status && "xrGetPlaneDetectionsEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetPlanePolygonBufferEXT(XrPlaneDetectorEXT planeDetector, uint64_t planeId, uint32_t polygonBufferIndex, XrPlaneDetectorPolygonBufferEXT *polygonBuffer)
+{
+    struct xrGetPlanePolygonBufferEXT_params params;
+    NTSTATUS _status;
+    params.planeDetector = planeDetector;
+    params.planeId = planeId;
+    params.polygonBufferIndex = polygonBufferIndex;
+    params.polygonBuffer = polygonBuffer;
+    _status = UNIX_CALL(xrGetPlanePolygonBufferEXT, &params);
+    assert(!_status && "xrGetPlanePolygonBufferEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetQueriedSenseDataBD(XrSenseDataSnapshotBD snapshot, XrQueriedSenseDataGetInfoBD *getInfo, XrQueriedSenseDataBD *queriedSenseData)
+{
+    struct xrGetQueriedSenseDataBD_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.getInfo = getInfo;
+    params.queriedSenseData = queriedSenseData;
+    _status = UNIX_CALL(xrGetQueriedSenseDataBD, &params);
+    assert(!_status && "xrGetQueriedSenseDataBD");
+    return params.result;
+}
+
+XrResult WINAPI xrGetRecommendedLayerResolutionMETA(XrSession session, const XrRecommendedLayerResolutionGetInfoMETA *info, XrRecommendedLayerResolutionMETA *resolution)
+{
+    struct xrGetRecommendedLayerResolutionMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.resolution = resolution;
+    _status = UNIX_CALL(xrGetRecommendedLayerResolutionMETA, &params);
+    assert(!_status && "xrGetRecommendedLayerResolutionMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrGetReferenceSpaceBoundsRect(XrSession session, XrReferenceSpaceType referenceSpaceType, XrExtent2Df *bounds)
+{
+    struct xrGetReferenceSpaceBoundsRect_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.referenceSpaceType = referenceSpaceType;
+    params.bounds = bounds;
+    _status = UNIX_CALL(xrGetReferenceSpaceBoundsRect, &params);
+    assert(!_status && "xrGetReferenceSpaceBoundsRect");
+    return params.result;
+}
+
+XrResult WINAPI xrGetRenderModelAssetDataEXT(XrRenderModelAssetEXT asset, const XrRenderModelAssetDataGetInfoEXT *getInfo, XrRenderModelAssetDataEXT *buffer)
+{
+    struct xrGetRenderModelAssetDataEXT_params params;
+    NTSTATUS _status;
+    params.asset = asset;
+    params.getInfo = getInfo;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetRenderModelAssetDataEXT, &params);
+    assert(!_status && "xrGetRenderModelAssetDataEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetRenderModelAssetPropertiesEXT(XrRenderModelAssetEXT asset, const XrRenderModelAssetPropertiesGetInfoEXT *getInfo, XrRenderModelAssetPropertiesEXT *properties)
+{
+    struct xrGetRenderModelAssetPropertiesEXT_params params;
+    NTSTATUS _status;
+    params.asset = asset;
+    params.getInfo = getInfo;
+    params.properties = properties;
+    _status = UNIX_CALL(xrGetRenderModelAssetPropertiesEXT, &params);
+    assert(!_status && "xrGetRenderModelAssetPropertiesEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetRenderModelPoseTopLevelUserPathEXT(XrRenderModelEXT renderModel, const XrInteractionRenderModelTopLevelUserPathGetInfoEXT *info, XrPath *topLevelUserPath)
+{
+    struct xrGetRenderModelPoseTopLevelUserPathEXT_params params;
+    NTSTATUS _status;
+    params.renderModel = renderModel;
+    params.info = info;
+    params.topLevelUserPath = topLevelUserPath;
+    _status = UNIX_CALL(xrGetRenderModelPoseTopLevelUserPathEXT, &params);
+    assert(!_status && "xrGetRenderModelPoseTopLevelUserPathEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetRenderModelPropertiesEXT(XrRenderModelEXT renderModel, const XrRenderModelPropertiesGetInfoEXT *getInfo, XrRenderModelPropertiesEXT *properties)
+{
+    struct xrGetRenderModelPropertiesEXT_params params;
+    NTSTATUS _status;
+    params.renderModel = renderModel;
+    params.getInfo = getInfo;
+    params.properties = properties;
+    _status = UNIX_CALL(xrGetRenderModelPropertiesEXT, &params);
+    assert(!_status && "xrGetRenderModelPropertiesEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetRenderModelPropertiesFB(XrSession session, XrPath path, XrRenderModelPropertiesFB *properties)
+{
+    struct xrGetRenderModelPropertiesFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.path = path;
+    params.properties = properties;
+    _status = UNIX_CALL(xrGetRenderModelPropertiesFB, &params);
+    assert(!_status && "xrGetRenderModelPropertiesFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetRenderModelStateEXT(XrRenderModelEXT renderModel, const XrRenderModelStateGetInfoEXT *getInfo, XrRenderModelStateEXT *state)
+{
+    struct xrGetRenderModelStateEXT_params params;
+    NTSTATUS _status;
+    params.renderModel = renderModel;
+    params.getInfo = getInfo;
+    params.state = state;
+    _status = UNIX_CALL(xrGetRenderModelStateEXT, &params);
+    assert(!_status && "xrGetRenderModelStateEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSceneComponentsMSFT(XrSceneMSFT scene, const XrSceneComponentsGetInfoMSFT *getInfo, XrSceneComponentsMSFT *components)
+{
+    struct xrGetSceneComponentsMSFT_params params;
+    NTSTATUS _status;
+    params.scene = scene;
+    params.getInfo = getInfo;
+    params.components = components;
+    _status = UNIX_CALL(xrGetSceneComponentsMSFT, &params);
+    assert(!_status && "xrGetSceneComponentsMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSceneComputeStateMSFT(XrSceneObserverMSFT sceneObserver, XrSceneComputeStateMSFT *state)
+{
+    struct xrGetSceneComputeStateMSFT_params params;
+    NTSTATUS _status;
+    params.sceneObserver = sceneObserver;
+    params.state = state;
+    _status = UNIX_CALL(xrGetSceneComputeStateMSFT, &params);
+    assert(!_status && "xrGetSceneComputeStateMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSceneMarkerDecodedStringMSFT(XrSceneMSFT scene, const XrUuidMSFT *markerId, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer)
+{
+    struct xrGetSceneMarkerDecodedStringMSFT_params params;
+    NTSTATUS _status;
+    params.scene = scene;
+    params.markerId = markerId;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetSceneMarkerDecodedStringMSFT, &params);
+    assert(!_status && "xrGetSceneMarkerDecodedStringMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSceneMarkerRawDataMSFT(XrSceneMSFT scene, const XrUuidMSFT *markerId, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, uint8_t *buffer)
+{
+    struct xrGetSceneMarkerRawDataMSFT_params params;
+    NTSTATUS _status;
+    params.scene = scene;
+    params.markerId = markerId;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetSceneMarkerRawDataMSFT, &params);
+    assert(!_status && "xrGetSceneMarkerRawDataMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSceneMeshBuffersMSFT(XrSceneMSFT scene, const XrSceneMeshBuffersGetInfoMSFT *getInfo, XrSceneMeshBuffersMSFT *buffers)
+{
+    struct xrGetSceneMeshBuffersMSFT_params params;
+    NTSTATUS _status;
+    params.scene = scene;
+    params.getInfo = getInfo;
+    params.buffers = buffers;
+    _status = UNIX_CALL(xrGetSceneMeshBuffersMSFT, &params);
+    assert(!_status && "xrGetSceneMeshBuffersMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSenseDataProviderStateBD(XrSenseDataProviderBD provider, XrSenseDataProviderStateBD *state)
+{
+    struct xrGetSenseDataProviderStateBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.state = state;
+    _status = UNIX_CALL(xrGetSenseDataProviderStateBD, &params);
+    assert(!_status && "xrGetSenseDataProviderStateBD");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSerializedSceneFragmentDataMSFT(XrSceneMSFT scene, const XrSerializedSceneFragmentDataGetInfoMSFT *getInfo, uint32_t countInput, uint32_t *readOutput, uint8_t *buffer)
+{
+    struct xrGetSerializedSceneFragmentDataMSFT_params params;
+    NTSTATUS _status;
+    params.scene = scene;
+    params.getInfo = getInfo;
+    params.countInput = countInput;
+    params.readOutput = readOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetSerializedSceneFragmentDataMSFT, &params);
+    assert(!_status && "xrGetSerializedSceneFragmentDataMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpaceBoundary2DFB(XrSession session, XrSpace space, XrBoundary2DFB *boundary2DOutput)
+{
+    struct xrGetSpaceBoundary2DFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.space = space;
+    params.boundary2DOutput = boundary2DOutput;
+    _status = UNIX_CALL(xrGetSpaceBoundary2DFB, &params);
+    assert(!_status && "xrGetSpaceBoundary2DFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpaceBoundingBox2DFB(XrSession session, XrSpace space, XrRect2Df *boundingBox2DOutput)
+{
+    struct xrGetSpaceBoundingBox2DFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.space = space;
+    params.boundingBox2DOutput = boundingBox2DOutput;
+    _status = UNIX_CALL(xrGetSpaceBoundingBox2DFB, &params);
+    assert(!_status && "xrGetSpaceBoundingBox2DFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpaceBoundingBox3DFB(XrSession session, XrSpace space, XrRect3DfFB *boundingBox3DOutput)
+{
+    struct xrGetSpaceBoundingBox3DFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.space = space;
+    params.boundingBox3DOutput = boundingBox3DOutput;
+    _status = UNIX_CALL(xrGetSpaceBoundingBox3DFB, &params);
+    assert(!_status && "xrGetSpaceBoundingBox3DFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpaceComponentStatusFB(XrSpace space, XrSpaceComponentTypeFB componentType, XrSpaceComponentStatusFB *status)
+{
+    struct xrGetSpaceComponentStatusFB_params params;
+    NTSTATUS _status;
+    params.space = space;
+    params.componentType = componentType;
+    params.status = status;
+    _status = UNIX_CALL(xrGetSpaceComponentStatusFB, &params);
+    assert(!_status && "xrGetSpaceComponentStatusFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpaceContainerFB(XrSession session, XrSpace space, XrSpaceContainerFB *spaceContainerOutput)
+{
+    struct xrGetSpaceContainerFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.space = space;
+    params.spaceContainerOutput = spaceContainerOutput;
+    _status = UNIX_CALL(xrGetSpaceContainerFB, &params);
+    assert(!_status && "xrGetSpaceContainerFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpaceRoomLayoutFB(XrSession session, XrSpace space, XrRoomLayoutFB *roomLayoutOutput)
+{
+    struct xrGetSpaceRoomLayoutFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.space = space;
+    params.roomLayoutOutput = roomLayoutOutput;
+    _status = UNIX_CALL(xrGetSpaceRoomLayoutFB, &params);
+    assert(!_status && "xrGetSpaceRoomLayoutFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpaceSemanticLabelsFB(XrSession session, XrSpace space, XrSemanticLabelsFB *semanticLabelsOutput)
+{
+    struct xrGetSpaceSemanticLabelsFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.space = space;
+    params.semanticLabelsOutput = semanticLabelsOutput;
+    _status = UNIX_CALL(xrGetSpaceSemanticLabelsFB, &params);
+    assert(!_status && "xrGetSpaceSemanticLabelsFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpaceTriangleMeshMETA(XrSpace space, const XrSpaceTriangleMeshGetInfoMETA *getInfo, XrSpaceTriangleMeshMETA *triangleMeshOutput)
+{
+    struct xrGetSpaceTriangleMeshMETA_params params;
+    NTSTATUS _status;
+    params.space = space;
+    params.getInfo = getInfo;
+    params.triangleMeshOutput = triangleMeshOutput;
+    _status = UNIX_CALL(xrGetSpaceTriangleMeshMETA, &params);
+    assert(!_status && "xrGetSpaceTriangleMeshMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpaceUserIdFB(XrSpaceUserFB user, XrSpaceUserIdFB *userId)
+{
+    struct xrGetSpaceUserIdFB_params params;
+    NTSTATUS _status;
+    params.user = user;
+    params.userId = userId;
+    _status = UNIX_CALL(xrGetSpaceUserIdFB, &params);
+    assert(!_status && "xrGetSpaceUserIdFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpaceUuidFB(XrSpace space, XrUuidEXT *uuid)
+{
+    struct xrGetSpaceUuidFB_params params;
+    NTSTATUS _status;
+    params.space = space;
+    params.uuid = uuid;
+    _status = UNIX_CALL(xrGetSpaceUuidFB, &params);
+    assert(!_status && "xrGetSpaceUuidFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialAnchorNameHTC(XrSpace anchor, XrSpatialAnchorNameHTC *name)
+{
+    struct xrGetSpatialAnchorNameHTC_params params;
+    NTSTATUS _status;
+    params.anchor = anchor;
+    params.name = name;
+    _status = UNIX_CALL(xrGetSpatialAnchorNameHTC, &params);
+    assert(!_status && "xrGetSpatialAnchorNameHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialAnchorStateML(XrSpace anchor, XrSpatialAnchorStateML *state)
+{
+    struct xrGetSpatialAnchorStateML_params params;
+    NTSTATUS _status;
+    params.anchor = anchor;
+    params.state = state;
+    _status = UNIX_CALL(xrGetSpatialAnchorStateML, &params);
+    assert(!_status && "xrGetSpatialAnchorStateML");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialBufferFloatEXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, float *buffer)
+{
+    struct xrGetSpatialBufferFloatEXT_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.info = info;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetSpatialBufferFloatEXT, &params);
+    assert(!_status && "xrGetSpatialBufferFloatEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialBufferStringEXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer)
+{
+    struct xrGetSpatialBufferStringEXT_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.info = info;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetSpatialBufferStringEXT, &params);
+    assert(!_status && "xrGetSpatialBufferStringEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialBufferUint16EXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, uint16_t *buffer)
+{
+    struct xrGetSpatialBufferUint16EXT_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.info = info;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetSpatialBufferUint16EXT, &params);
+    assert(!_status && "xrGetSpatialBufferUint16EXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialBufferUint32EXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, uint32_t *buffer)
+{
+    struct xrGetSpatialBufferUint32EXT_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.info = info;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetSpatialBufferUint32EXT, &params);
+    assert(!_status && "xrGetSpatialBufferUint32EXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialBufferUint8EXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, uint8_t *buffer)
+{
+    struct xrGetSpatialBufferUint8EXT_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.info = info;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetSpatialBufferUint8EXT, &params);
+    assert(!_status && "xrGetSpatialBufferUint8EXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialBufferVector2fEXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, XrVector2f *buffer)
+{
+    struct xrGetSpatialBufferVector2fEXT_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.info = info;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetSpatialBufferVector2fEXT, &params);
+    assert(!_status && "xrGetSpatialBufferVector2fEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialBufferVector3fEXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, XrVector3f *buffer)
+{
+    struct xrGetSpatialBufferVector3fEXT_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.info = info;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetSpatialBufferVector3fEXT, &params);
+    assert(!_status && "xrGetSpatialBufferVector3fEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialEntityComponentDataBD(XrSenseDataSnapshotBD snapshot, const XrSpatialEntityComponentGetInfoBD *getInfo, XrSpatialEntityComponentDataBaseHeaderBD *componentData)
+{
+    struct xrGetSpatialEntityComponentDataBD_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.getInfo = getInfo;
+    params.componentData = componentData;
+    _status = UNIX_CALL(xrGetSpatialEntityComponentDataBD, &params);
+    assert(!_status && "xrGetSpatialEntityComponentDataBD");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialEntityUuidBD(XrSenseDataSnapshotBD snapshot, XrSpatialEntityIdBD entityId, XrUuidEXT *uuid)
+{
+    struct xrGetSpatialEntityUuidBD_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.entityId = entityId;
+    params.uuid = uuid;
+    _status = UNIX_CALL(xrGetSpatialEntityUuidBD, &params);
+    assert(!_status && "xrGetSpatialEntityUuidBD");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSpatialGraphNodeBindingPropertiesMSFT(XrSpatialGraphNodeBindingMSFT nodeBinding, const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT *getInfo, XrSpatialGraphNodeBindingPropertiesMSFT *properties)
+{
+    struct xrGetSpatialGraphNodeBindingPropertiesMSFT_params params;
+    NTSTATUS _status;
+    params.nodeBinding = nodeBinding;
+    params.getInfo = getInfo;
+    params.properties = properties;
+    _status = UNIX_CALL(xrGetSpatialGraphNodeBindingPropertiesMSFT, &params);
+    assert(!_status && "xrGetSpatialGraphNodeBindingPropertiesMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSwapchainStateFB(XrSwapchain swapchain, XrSwapchainStateBaseHeaderFB *state)
+{
+    struct xrGetSwapchainStateFB_params params;
+    NTSTATUS _status;
+    params.swapchain = swapchain;
+    params.state = state;
+    _status = UNIX_CALL(xrGetSwapchainStateFB, &params);
+    assert(!_status && "xrGetSwapchainStateFB");
+    return params.result;
+}
+
+XrResult WINAPI xrGetSystemProperties(XrInstance instance, XrSystemId systemId, XrSystemProperties *properties)
+{
+    struct xrGetSystemProperties_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.properties = properties;
+    _status = UNIX_CALL(xrGetSystemProperties, &params);
+    assert(!_status && "xrGetSystemProperties");
+    return params.result;
+}
+
+XrResult WINAPI xrGetTrackableMarkerANDROID(XrTrackableTrackerANDROID tracker, const XrTrackableGetInfoANDROID *getInfo, XrTrackableMarkerANDROID *markerOutput)
+{
+    struct xrGetTrackableMarkerANDROID_params params;
+    NTSTATUS _status;
+    params.tracker = tracker;
+    params.getInfo = getInfo;
+    params.markerOutput = markerOutput;
+    _status = UNIX_CALL(xrGetTrackableMarkerANDROID, &params);
+    assert(!_status && "xrGetTrackableMarkerANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrGetTrackableObjectANDROID(XrTrackableTrackerANDROID tracker, const XrTrackableGetInfoANDROID *getInfo, XrTrackableObjectANDROID *objectOutput)
+{
+    struct xrGetTrackableObjectANDROID_params params;
+    NTSTATUS _status;
+    params.tracker = tracker;
+    params.getInfo = getInfo;
+    params.objectOutput = objectOutput;
+    _status = UNIX_CALL(xrGetTrackableObjectANDROID, &params);
+    assert(!_status && "xrGetTrackableObjectANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrGetTrackablePlaneANDROID(XrTrackableTrackerANDROID trackableTracker, const XrTrackableGetInfoANDROID *getInfo, XrTrackablePlaneANDROID *planeOutput)
+{
+    struct xrGetTrackablePlaneANDROID_params params;
+    NTSTATUS _status;
+    params.trackableTracker = trackableTracker;
+    params.getInfo = getInfo;
+    params.planeOutput = planeOutput;
+    _status = UNIX_CALL(xrGetTrackablePlaneANDROID, &params);
+    assert(!_status && "xrGetTrackablePlaneANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrGetViewConfigurationProperties(XrInstance instance, XrSystemId systemId, XrViewConfigurationType viewConfigurationType, XrViewConfigurationProperties *configurationProperties)
+{
+    struct xrGetViewConfigurationProperties_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.viewConfigurationType = viewConfigurationType;
+    params.configurationProperties = configurationProperties;
+    _status = UNIX_CALL(xrGetViewConfigurationProperties, &params);
+    assert(!_status && "xrGetViewConfigurationProperties");
+    return params.result;
+}
+
+XrResult WINAPI xrGetVirtualKeyboardDirtyTexturesMETA(XrVirtualKeyboardMETA keyboard, uint32_t textureIdCapacityInput, uint32_t *textureIdCountOutput, uint64_t *textureIds)
+{
+    struct xrGetVirtualKeyboardDirtyTexturesMETA_params params;
+    NTSTATUS _status;
+    params.keyboard = keyboard;
+    params.textureIdCapacityInput = textureIdCapacityInput;
+    params.textureIdCountOutput = textureIdCountOutput;
+    params.textureIds = textureIds;
+    _status = UNIX_CALL(xrGetVirtualKeyboardDirtyTexturesMETA, &params);
+    assert(!_status && "xrGetVirtualKeyboardDirtyTexturesMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrGetVirtualKeyboardModelAnimationStatesMETA(XrVirtualKeyboardMETA keyboard, XrVirtualKeyboardModelAnimationStatesMETA *animationStates)
+{
+    struct xrGetVirtualKeyboardModelAnimationStatesMETA_params params;
+    NTSTATUS _status;
+    params.keyboard = keyboard;
+    params.animationStates = animationStates;
+    _status = UNIX_CALL(xrGetVirtualKeyboardModelAnimationStatesMETA, &params);
+    assert(!_status && "xrGetVirtualKeyboardModelAnimationStatesMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrGetVirtualKeyboardScaleMETA(XrVirtualKeyboardMETA keyboard, float *scale)
+{
+    struct xrGetVirtualKeyboardScaleMETA_params params;
+    NTSTATUS _status;
+    params.keyboard = keyboard;
+    params.scale = scale;
+    _status = UNIX_CALL(xrGetVirtualKeyboardScaleMETA, &params);
+    assert(!_status && "xrGetVirtualKeyboardScaleMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrGetVirtualKeyboardTextureDataMETA(XrVirtualKeyboardMETA keyboard, uint64_t textureId, XrVirtualKeyboardTextureDataMETA *textureData)
+{
+    struct xrGetVirtualKeyboardTextureDataMETA_params params;
+    NTSTATUS _status;
+    params.keyboard = keyboard;
+    params.textureId = textureId;
+    params.textureData = textureData;
+    _status = UNIX_CALL(xrGetVirtualKeyboardTextureDataMETA, &params);
+    assert(!_status && "xrGetVirtualKeyboardTextureDataMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrGetVisibilityMaskKHR(XrSession session, XrViewConfigurationType viewConfigurationType, uint32_t viewIndex, XrVisibilityMaskTypeKHR visibilityMaskType, XrVisibilityMaskKHR *visibilityMask)
+{
+    struct xrGetVisibilityMaskKHR_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.viewConfigurationType = viewConfigurationType;
+    params.viewIndex = viewIndex;
+    params.visibilityMaskType = visibilityMaskType;
+    params.visibilityMask = visibilityMask;
+    _status = UNIX_CALL(xrGetVisibilityMaskKHR, &params);
+    assert(!_status && "xrGetVisibilityMaskKHR");
+    return params.result;
+}
+
+XrResult WINAPI xrGetVulkanGraphicsDevice2KHR(XrInstance instance, const XrVulkanGraphicsDeviceGetInfoKHR *getInfo, VkPhysicalDevice *vulkanPhysicalDevice)
+{
+    struct xrGetVulkanGraphicsDevice2KHR_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.getInfo = getInfo;
+    params.vulkanPhysicalDevice = vulkanPhysicalDevice;
+    _status = UNIX_CALL(xrGetVulkanGraphicsDevice2KHR, &params);
+    assert(!_status && "xrGetVulkanGraphicsDevice2KHR");
+    return params.result;
+}
+
+XrResult WINAPI xrGetVulkanGraphicsDeviceKHR(XrInstance instance, XrSystemId systemId, VkInstance vkInstance, VkPhysicalDevice *vkPhysicalDevice)
+{
+    struct xrGetVulkanGraphicsDeviceKHR_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.vkInstance = vkInstance;
+    params.vkPhysicalDevice = vkPhysicalDevice;
+    _status = UNIX_CALL(xrGetVulkanGraphicsDeviceKHR, &params);
+    assert(!_status && "xrGetVulkanGraphicsDeviceKHR");
+    return params.result;
+}
+
+XrResult WINAPI xrGetVulkanGraphicsRequirements2KHR(XrInstance instance, XrSystemId systemId, XrGraphicsRequirementsVulkanKHR *graphicsRequirements)
+{
+    struct xrGetVulkanGraphicsRequirements2KHR_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.graphicsRequirements = graphicsRequirements;
+    _status = UNIX_CALL(xrGetVulkanGraphicsRequirements2KHR, &params);
+    assert(!_status && "xrGetVulkanGraphicsRequirements2KHR");
+    return params.result;
+}
+
+XrResult WINAPI xrGetVulkanGraphicsRequirementsKHR(XrInstance instance, XrSystemId systemId, XrGraphicsRequirementsVulkanKHR *graphicsRequirements)
+{
+    struct xrGetVulkanGraphicsRequirementsKHR_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.graphicsRequirements = graphicsRequirements;
+    _status = UNIX_CALL(xrGetVulkanGraphicsRequirementsKHR, &params);
+    assert(!_status && "xrGetVulkanGraphicsRequirementsKHR");
+    return params.result;
+}
+
+XrResult WINAPI xrGetVulkanInstanceExtensionsKHR(XrInstance instance, XrSystemId systemId, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer)
+{
+    struct xrGetVulkanInstanceExtensionsKHR_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.systemId = systemId;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetVulkanInstanceExtensionsKHR, &params);
+    assert(!_status && "xrGetVulkanInstanceExtensionsKHR");
+    return params.result;
+}
+
+XrResult WINAPI xrGetWorldMeshBufferRecommendSizeML(XrWorldMeshDetectorML detector, const XrWorldMeshBufferRecommendedSizeInfoML *sizeInfo, XrWorldMeshBufferSizeML *size)
+{
+    struct xrGetWorldMeshBufferRecommendSizeML_params params;
+    NTSTATUS _status;
+    params.detector = detector;
+    params.sizeInfo = sizeInfo;
+    params.size = size;
+    _status = UNIX_CALL(xrGetWorldMeshBufferRecommendSizeML, &params);
+    assert(!_status && "xrGetWorldMeshBufferRecommendSizeML");
+    return params.result;
+}
+
+XrResult WINAPI xrImportLocalizationMapML(XrSession session, const XrLocalizationMapImportInfoML *importInfo, XrUuidEXT *mapUuid)
+{
+    struct xrImportLocalizationMapML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.importInfo = importInfo;
+    params.mapUuid = mapUuid;
+    _status = UNIX_CALL(xrImportLocalizationMapML, &params);
+    assert(!_status && "xrImportLocalizationMapML");
+    return params.result;
+}
+
+XrResult WINAPI xrLoadControllerModelMSFT(XrSession session, XrControllerModelKeyMSFT modelKey, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, uint8_t *buffer)
+{
+    struct xrLoadControllerModelMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.modelKey = modelKey;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrLoadControllerModelMSFT, &params);
+    assert(!_status && "xrLoadControllerModelMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrLoadRenderModelFB(XrSession session, const XrRenderModelLoadInfoFB *info, XrRenderModelBufferFB *buffer)
+{
+    struct xrLoadRenderModelFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrLoadRenderModelFB, &params);
+    assert(!_status && "xrLoadRenderModelFB");
+    return params.result;
+}
+
+XrResult WINAPI xrLocateBodyJointsBD(XrBodyTrackerBD bodyTracker, const XrBodyJointsLocateInfoBD *locateInfo, XrBodyJointLocationsBD *locations)
+{
+    struct xrLocateBodyJointsBD_params params;
+    NTSTATUS _status;
+    params.bodyTracker = bodyTracker;
+    params.locateInfo = locateInfo;
+    params.locations = locations;
+    _status = UNIX_CALL(xrLocateBodyJointsBD, &params);
+    assert(!_status && "xrLocateBodyJointsBD");
+    return params.result;
+}
+
+XrResult WINAPI xrLocateBodyJointsFB(XrBodyTrackerFB bodyTracker, const XrBodyJointsLocateInfoFB *locateInfo, XrBodyJointLocationsFB *locations)
+{
+    struct xrLocateBodyJointsFB_params params;
+    NTSTATUS _status;
+    params.bodyTracker = bodyTracker;
+    params.locateInfo = locateInfo;
+    params.locations = locations;
+    _status = UNIX_CALL(xrLocateBodyJointsFB, &params);
+    assert(!_status && "xrLocateBodyJointsFB");
+    return params.result;
+}
+
+XrResult WINAPI xrLocateBodyJointsHTC(XrBodyTrackerHTC bodyTracker, const XrBodyJointsLocateInfoHTC *locateInfo, XrBodyJointLocationsHTC *locations)
+{
+    struct xrLocateBodyJointsHTC_params params;
+    NTSTATUS _status;
+    params.bodyTracker = bodyTracker;
+    params.locateInfo = locateInfo;
+    params.locations = locations;
+    _status = UNIX_CALL(xrLocateBodyJointsHTC, &params);
+    assert(!_status && "xrLocateBodyJointsHTC");
+    return params.result;
+}
+
+XrResult WINAPI xrLocateHandJointsEXT(XrHandTrackerEXT handTracker, const XrHandJointsLocateInfoEXT *locateInfo, XrHandJointLocationsEXT *locations)
+{
+    struct xrLocateHandJointsEXT_params params;
+    NTSTATUS _status;
+    params.handTracker = handTracker;
+    params.locateInfo = locateInfo;
+    params.locations = locations;
+    _status = UNIX_CALL(xrLocateHandJointsEXT, &params);
+    assert(!_status && "xrLocateHandJointsEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrLocateSceneComponentsMSFT(XrSceneMSFT scene, const XrSceneComponentsLocateInfoMSFT *locateInfo, XrSceneComponentLocationsMSFT *locations)
+{
+    struct xrLocateSceneComponentsMSFT_params params;
+    NTSTATUS _status;
+    params.scene = scene;
+    params.locateInfo = locateInfo;
+    params.locations = locations;
+    _status = UNIX_CALL(xrLocateSceneComponentsMSFT, &params);
+    assert(!_status && "xrLocateSceneComponentsMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrLocateSpace(XrSpace space, XrSpace baseSpace, XrTime time, XrSpaceLocation *location)
+{
+    struct xrLocateSpace_params params;
+    NTSTATUS _status;
+    params.space = space;
+    params.baseSpace = baseSpace;
+    params.time = time;
+    params.location = location;
+    _status = UNIX_CALL(xrLocateSpace, &params);
+    assert(!_status && "xrLocateSpace");
+    return params.result;
+}
+
+XrResult WINAPI xrLocateSpaces(XrSession session, const XrSpacesLocateInfo *locateInfo, XrSpaceLocations *spaceLocations)
+{
+    struct xrLocateSpaces_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.locateInfo = locateInfo;
+    params.spaceLocations = spaceLocations;
+    _status = UNIX_CALL(xrLocateSpaces, &params);
+    assert(!_status && "xrLocateSpaces");
+    return params.result;
+}
+
+XrResult WINAPI xrLocateSpacesKHR(XrSession session, const XrSpacesLocateInfo *locateInfo, XrSpaceLocations *spaceLocations)
+{
+    struct xrLocateSpacesKHR_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.locateInfo = locateInfo;
+    params.spaceLocations = spaceLocations;
+    _status = UNIX_CALL(xrLocateSpacesKHR, &params);
+    assert(!_status && "xrLocateSpacesKHR");
+    return params.result;
+}
+
+XrResult WINAPI xrLocateViews(XrSession session, const XrViewLocateInfo *viewLocateInfo, XrViewState *viewState, uint32_t viewCapacityInput, uint32_t *viewCountOutput, XrView *views)
+{
+    struct xrLocateViews_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.viewLocateInfo = viewLocateInfo;
+    params.viewState = viewState;
+    params.viewCapacityInput = viewCapacityInput;
+    params.viewCountOutput = viewCountOutput;
+    params.views = views;
+    _status = UNIX_CALL(xrLocateViews, &params);
+    assert(!_status && "xrLocateViews");
+    return params.result;
+}
+
+XrResult WINAPI xrPassthroughLayerPauseFB(XrPassthroughLayerFB layer)
+{
+    struct xrPassthroughLayerPauseFB_params params;
+    NTSTATUS _status;
+    params.layer = layer;
+    _status = UNIX_CALL(xrPassthroughLayerPauseFB, &params);
+    assert(!_status && "xrPassthroughLayerPauseFB");
+    return params.result;
+}
+
+XrResult WINAPI xrPassthroughLayerResumeFB(XrPassthroughLayerFB layer)
+{
+    struct xrPassthroughLayerResumeFB_params params;
+    NTSTATUS _status;
+    params.layer = layer;
+    _status = UNIX_CALL(xrPassthroughLayerResumeFB, &params);
+    assert(!_status && "xrPassthroughLayerResumeFB");
+    return params.result;
+}
+
+XrResult WINAPI xrPassthroughLayerSetKeyboardHandsIntensityFB(XrPassthroughLayerFB layer, const XrPassthroughKeyboardHandsIntensityFB *intensity)
+{
+    struct xrPassthroughLayerSetKeyboardHandsIntensityFB_params params;
+    NTSTATUS _status;
+    params.layer = layer;
+    params.intensity = intensity;
+    _status = UNIX_CALL(xrPassthroughLayerSetKeyboardHandsIntensityFB, &params);
+    assert(!_status && "xrPassthroughLayerSetKeyboardHandsIntensityFB");
+    return params.result;
+}
+
+XrResult WINAPI xrPassthroughLayerSetStyleFB(XrPassthroughLayerFB layer, const XrPassthroughStyleFB *style)
+{
+    struct xrPassthroughLayerSetStyleFB_params params;
+    NTSTATUS _status;
+    params.layer = layer;
+    params.style = style;
+    _status = UNIX_CALL(xrPassthroughLayerSetStyleFB, &params);
+    assert(!_status && "xrPassthroughLayerSetStyleFB");
+    return params.result;
+}
+
+XrResult WINAPI xrPassthroughPauseFB(XrPassthroughFB passthrough)
+{
+    struct xrPassthroughPauseFB_params params;
+    NTSTATUS _status;
+    params.passthrough = passthrough;
+    _status = UNIX_CALL(xrPassthroughPauseFB, &params);
+    assert(!_status && "xrPassthroughPauseFB");
+    return params.result;
+}
+
+XrResult WINAPI xrPassthroughStartFB(XrPassthroughFB passthrough)
+{
+    struct xrPassthroughStartFB_params params;
+    NTSTATUS _status;
+    params.passthrough = passthrough;
+    _status = UNIX_CALL(xrPassthroughStartFB, &params);
+    assert(!_status && "xrPassthroughStartFB");
+    return params.result;
+}
+
+XrResult WINAPI xrPathToString(XrInstance instance, XrPath path, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer)
+{
+    struct xrPathToString_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.path = path;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrPathToString, &params);
+    assert(!_status && "xrPathToString");
+    return params.result;
+}
+
+XrResult WINAPI xrPauseSimultaneousHandsAndControllersTrackingMETA(XrSession session, const XrSimultaneousHandsAndControllersTrackingPauseInfoMETA *pauseInfo)
+{
+    struct xrPauseSimultaneousHandsAndControllersTrackingMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.pauseInfo = pauseInfo;
+    _status = UNIX_CALL(xrPauseSimultaneousHandsAndControllersTrackingMETA, &params);
+    assert(!_status && "xrPauseSimultaneousHandsAndControllersTrackingMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrPerfSettingsSetPerformanceLevelEXT(XrSession session, XrPerfSettingsDomainEXT domain, XrPerfSettingsLevelEXT level)
+{
+    struct xrPerfSettingsSetPerformanceLevelEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.domain = domain;
+    params.level = level;
+    _status = UNIX_CALL(xrPerfSettingsSetPerformanceLevelEXT, &params);
+    assert(!_status && "xrPerfSettingsSetPerformanceLevelEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrPersistAnchorANDROID(XrDeviceAnchorPersistenceANDROID handle, const XrPersistedAnchorSpaceInfoANDROID *persistedInfo, XrUuidEXT *anchorIdOutput)
+{
+    struct xrPersistAnchorANDROID_params params;
+    NTSTATUS _status;
+    params.handle = handle;
+    params.persistedInfo = persistedInfo;
+    params.anchorIdOutput = anchorIdOutput;
+    _status = UNIX_CALL(xrPersistAnchorANDROID, &params);
+    assert(!_status && "xrPersistAnchorANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrPersistSpatialAnchorAsyncBD(XrSenseDataProviderBD provider, const XrSpatialAnchorPersistInfoBD *info, XrFutureEXT *future)
+{
+    struct xrPersistSpatialAnchorAsyncBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.info = info;
+    params.future = future;
+    _status = UNIX_CALL(xrPersistSpatialAnchorAsyncBD, &params);
+    assert(!_status && "xrPersistSpatialAnchorAsyncBD");
+    return params.result;
+}
+
+XrResult WINAPI xrPersistSpatialAnchorCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrFutureCompletionEXT *completion)
+{
+    struct xrPersistSpatialAnchorCompleteBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrPersistSpatialAnchorCompleteBD, &params);
+    assert(!_status && "xrPersistSpatialAnchorCompleteBD");
+    return params.result;
+}
+
+XrResult WINAPI xrPersistSpatialAnchorMSFT(XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore, const XrSpatialAnchorPersistenceInfoMSFT *spatialAnchorPersistenceInfo)
+{
+    struct xrPersistSpatialAnchorMSFT_params params;
+    NTSTATUS _status;
+    params.spatialAnchorStore = spatialAnchorStore;
+    params.spatialAnchorPersistenceInfo = spatialAnchorPersistenceInfo;
+    _status = UNIX_CALL(xrPersistSpatialAnchorMSFT, &params);
+    assert(!_status && "xrPersistSpatialAnchorMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrPersistSpatialEntityAsyncEXT(XrSpatialPersistenceContextEXT persistenceContext, const XrSpatialEntityPersistInfoEXT *persistInfo, XrFutureEXT *future)
+{
+    struct xrPersistSpatialEntityAsyncEXT_params params;
+    NTSTATUS _status;
+    params.persistenceContext = persistenceContext;
+    params.persistInfo = persistInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrPersistSpatialEntityAsyncEXT, &params);
+    assert(!_status && "xrPersistSpatialEntityAsyncEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrPersistSpatialEntityCompleteEXT(XrSpatialPersistenceContextEXT persistenceContext, XrFutureEXT future, XrPersistSpatialEntityCompletionEXT *completion)
+{
+    struct xrPersistSpatialEntityCompleteEXT_params params;
+    NTSTATUS _status;
+    params.persistenceContext = persistenceContext;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrPersistSpatialEntityCompleteEXT, &params);
+    assert(!_status && "xrPersistSpatialEntityCompleteEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrPollFutureEXT(XrInstance instance, const XrFuturePollInfoEXT *pollInfo, XrFuturePollResultEXT *pollResult)
+{
+    struct xrPollFutureEXT_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.pollInfo = pollInfo;
+    params.pollResult = pollResult;
+    _status = UNIX_CALL(xrPollFutureEXT, &params);
+    assert(!_status && "xrPollFutureEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrPublishSpatialAnchorsAsyncML(XrSpatialAnchorsStorageML storage, const XrSpatialAnchorsPublishInfoML *publishInfo, XrFutureEXT *future)
+{
+    struct xrPublishSpatialAnchorsAsyncML_params params;
+    NTSTATUS _status;
+    params.storage = storage;
+    params.publishInfo = publishInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrPublishSpatialAnchorsAsyncML, &params);
+    assert(!_status && "xrPublishSpatialAnchorsAsyncML");
+    return params.result;
+}
+
+XrResult WINAPI xrPublishSpatialAnchorsCompleteML(XrSpatialAnchorsStorageML storage, XrFutureEXT future, XrSpatialAnchorsPublishCompletionML *completion)
+{
+    struct xrPublishSpatialAnchorsCompleteML_params params;
+    NTSTATUS _status;
+    params.storage = storage;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrPublishSpatialAnchorsCompleteML, &params);
+    assert(!_status && "xrPublishSpatialAnchorsCompleteML");
+    return params.result;
+}
+
+XrResult WINAPI xrQueryLocalizationMapsML(XrSession session, const XrLocalizationMapQueryInfoBaseHeaderML *queryInfo, uint32_t mapCapacityInput, uint32_t *mapCountOutput, XrLocalizationMapML *maps)
+{
+    struct xrQueryLocalizationMapsML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.queryInfo = queryInfo;
+    params.mapCapacityInput = mapCapacityInput;
+    params.mapCountOutput = mapCountOutput;
+    params.maps = maps;
+    _status = UNIX_CALL(xrQueryLocalizationMapsML, &params);
+    assert(!_status && "xrQueryLocalizationMapsML");
+    return params.result;
+}
+
+XrResult WINAPI xrQueryPerformanceMetricsCounterMETA(XrSession session, XrPath counterPath, XrPerformanceMetricsCounterMETA *counter)
+{
+    struct xrQueryPerformanceMetricsCounterMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.counterPath = counterPath;
+    params.counter = counter;
+    _status = UNIX_CALL(xrQueryPerformanceMetricsCounterMETA, &params);
+    assert(!_status && "xrQueryPerformanceMetricsCounterMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrQuerySenseDataAsyncBD(XrSenseDataProviderBD provider, const XrSenseDataQueryInfoBD *queryInfo, XrFutureEXT *future)
+{
+    struct xrQuerySenseDataAsyncBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.queryInfo = queryInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrQuerySenseDataAsyncBD, &params);
+    assert(!_status && "xrQuerySenseDataAsyncBD");
+    return params.result;
+}
+
+XrResult WINAPI xrQuerySenseDataCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrSenseDataQueryCompletionBD *completion)
+{
+    struct xrQuerySenseDataCompleteBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrQuerySenseDataCompleteBD, &params);
+    assert(!_status && "xrQuerySenseDataCompleteBD");
+    return params.result;
+}
+
+XrResult WINAPI xrQuerySpacesFB(XrSession session, const XrSpaceQueryInfoBaseHeaderFB *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrQuerySpacesFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrQuerySpacesFB, &params);
+    assert(!_status && "xrQuerySpacesFB");
+    return params.result;
+}
+
+XrResult WINAPI xrQuerySpatialAnchorsAsyncML(XrSpatialAnchorsStorageML storage, const XrSpatialAnchorsQueryInfoBaseHeaderML *queryInfo, XrFutureEXT *future)
+{
+    struct xrQuerySpatialAnchorsAsyncML_params params;
+    NTSTATUS _status;
+    params.storage = storage;
+    params.queryInfo = queryInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrQuerySpatialAnchorsAsyncML, &params);
+    assert(!_status && "xrQuerySpatialAnchorsAsyncML");
+    return params.result;
+}
+
+XrResult WINAPI xrQuerySpatialAnchorsCompleteML(XrSpatialAnchorsStorageML storage, XrFutureEXT future, XrSpatialAnchorsQueryCompletionML *completion)
+{
+    struct xrQuerySpatialAnchorsCompleteML_params params;
+    NTSTATUS _status;
+    params.storage = storage;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrQuerySpatialAnchorsCompleteML, &params);
+    assert(!_status && "xrQuerySpatialAnchorsCompleteML");
+    return params.result;
+}
+
+XrResult WINAPI xrQuerySpatialComponentDataEXT(XrSpatialSnapshotEXT snapshot, const XrSpatialComponentDataQueryConditionEXT *queryCondition, XrSpatialComponentDataQueryResultEXT *queryResult)
+{
+    struct xrQuerySpatialComponentDataEXT_params params;
+    NTSTATUS _status;
+    params.snapshot = snapshot;
+    params.queryCondition = queryCondition;
+    params.queryResult = queryResult;
+    _status = UNIX_CALL(xrQuerySpatialComponentDataEXT, &params);
+    assert(!_status && "xrQuerySpatialComponentDataEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrQuerySystemTrackedKeyboardFB(XrSession session, const XrKeyboardTrackingQueryFB *queryInfo, XrKeyboardTrackingDescriptionFB *keyboard)
+{
+    struct xrQuerySystemTrackedKeyboardFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.queryInfo = queryInfo;
+    params.keyboard = keyboard;
+    _status = UNIX_CALL(xrQuerySystemTrackedKeyboardFB, &params);
+    assert(!_status && "xrQuerySystemTrackedKeyboardFB");
+    return params.result;
+}
+
+XrResult WINAPI xrRaycastANDROID(XrSession session, const XrRaycastInfoANDROID *rayInfo, XrRaycastHitResultsANDROID *results)
+{
+    struct xrRaycastANDROID_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.rayInfo = rayInfo;
+    params.results = results;
+    _status = UNIX_CALL(xrRaycastANDROID, &params);
+    assert(!_status && "xrRaycastANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrRequestDisplayRefreshRateFB(XrSession session, float displayRefreshRate)
+{
+    struct xrRequestDisplayRefreshRateFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.displayRefreshRate = displayRefreshRate;
+    _status = UNIX_CALL(xrRequestDisplayRefreshRateFB, &params);
+    assert(!_status && "xrRequestDisplayRefreshRateFB");
+    return params.result;
+}
+
+XrResult WINAPI xrRequestExitSession(XrSession session)
+{
+    struct xrRequestExitSession_params params;
+    NTSTATUS _status;
+    params.session = session;
+    _status = UNIX_CALL(xrRequestExitSession, &params);
+    assert(!_status && "xrRequestExitSession");
+    return params.result;
+}
+
+XrResult WINAPI xrRequestMapLocalizationML(XrSession session, const XrMapLocalizationRequestInfoML *requestInfo)
+{
+    struct xrRequestMapLocalizationML_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.requestInfo = requestInfo;
+    _status = UNIX_CALL(xrRequestMapLocalizationML, &params);
+    assert(!_status && "xrRequestMapLocalizationML");
+    return params.result;
+}
+
+XrResult WINAPI xrRequestSceneCaptureFB(XrSession session, const XrSceneCaptureRequestInfoFB *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrRequestSceneCaptureFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrRequestSceneCaptureFB, &params);
+    assert(!_status && "xrRequestSceneCaptureFB");
+    return params.result;
+}
+
+XrResult WINAPI xrRequestWorldMeshAsyncML(XrWorldMeshDetectorML detector, const XrWorldMeshGetInfoML *getInfo, XrWorldMeshBufferML *buffer, XrFutureEXT *future)
+{
+    struct xrRequestWorldMeshAsyncML_params params;
+    NTSTATUS _status;
+    params.detector = detector;
+    params.getInfo = getInfo;
+    params.buffer = buffer;
+    params.future = future;
+    _status = UNIX_CALL(xrRequestWorldMeshAsyncML, &params);
+    assert(!_status && "xrRequestWorldMeshAsyncML");
+    return params.result;
+}
+
+XrResult WINAPI xrRequestWorldMeshCompleteML(XrWorldMeshDetectorML detector, const XrWorldMeshRequestCompletionInfoML *completionInfo, XrFutureEXT future, XrWorldMeshRequestCompletionML *completion)
+{
+    struct xrRequestWorldMeshCompleteML_params params;
+    NTSTATUS _status;
+    params.detector = detector;
+    params.completionInfo = completionInfo;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrRequestWorldMeshCompleteML, &params);
+    assert(!_status && "xrRequestWorldMeshCompleteML");
+    return params.result;
+}
+
+XrResult WINAPI xrRequestWorldMeshStateAsyncML(XrWorldMeshDetectorML detector, const XrWorldMeshStateRequestInfoML *stateRequest, XrFutureEXT *future)
+{
+    struct xrRequestWorldMeshStateAsyncML_params params;
+    NTSTATUS _status;
+    params.detector = detector;
+    params.stateRequest = stateRequest;
+    params.future = future;
+    _status = UNIX_CALL(xrRequestWorldMeshStateAsyncML, &params);
+    assert(!_status && "xrRequestWorldMeshStateAsyncML");
+    return params.result;
+}
+
+XrResult WINAPI xrRequestWorldMeshStateCompleteML(XrWorldMeshDetectorML detector, XrFutureEXT future, XrWorldMeshStateRequestCompletionML *completion)
+{
+    struct xrRequestWorldMeshStateCompleteML_params params;
+    NTSTATUS _status;
+    params.detector = detector;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrRequestWorldMeshStateCompleteML, &params);
+    assert(!_status && "xrRequestWorldMeshStateCompleteML");
+    return params.result;
+}
+
+XrResult WINAPI xrResetBodyTrackingCalibrationMETA(XrBodyTrackerFB bodyTracker)
+{
+    struct xrResetBodyTrackingCalibrationMETA_params params;
+    NTSTATUS _status;
+    params.bodyTracker = bodyTracker;
+    _status = UNIX_CALL(xrResetBodyTrackingCalibrationMETA, &params);
+    assert(!_status && "xrResetBodyTrackingCalibrationMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrResultToString(XrInstance instance, XrResult value, char buffer[])
+{
+    struct xrResultToString_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.value = value;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrResultToString, &params);
+    assert(!_status && "xrResultToString");
+    return params.result;
+}
+
+XrResult WINAPI xrResumeSimultaneousHandsAndControllersTrackingMETA(XrSession session, const XrSimultaneousHandsAndControllersTrackingResumeInfoMETA *resumeInfo)
+{
+    struct xrResumeSimultaneousHandsAndControllersTrackingMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.resumeInfo = resumeInfo;
+    _status = UNIX_CALL(xrResumeSimultaneousHandsAndControllersTrackingMETA, &params);
+    assert(!_status && "xrResumeSimultaneousHandsAndControllersTrackingMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrRetrieveSpaceDiscoveryResultsMETA(XrSession session, XrAsyncRequestIdFB requestId, XrSpaceDiscoveryResultsMETA *results)
+{
+    struct xrRetrieveSpaceDiscoveryResultsMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.requestId = requestId;
+    params.results = results;
+    _status = UNIX_CALL(xrRetrieveSpaceDiscoveryResultsMETA, &params);
+    assert(!_status && "xrRetrieveSpaceDiscoveryResultsMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrRetrieveSpaceQueryResultsFB(XrSession session, XrAsyncRequestIdFB requestId, XrSpaceQueryResultsFB *results)
+{
+    struct xrRetrieveSpaceQueryResultsFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.requestId = requestId;
+    params.results = results;
+    _status = UNIX_CALL(xrRetrieveSpaceQueryResultsFB, &params);
+    assert(!_status && "xrRetrieveSpaceQueryResultsFB");
+    return params.result;
+}
+
+XrResult WINAPI xrSaveSpaceFB(XrSession session, const XrSpaceSaveInfoFB *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrSaveSpaceFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrSaveSpaceFB, &params);
+    assert(!_status && "xrSaveSpaceFB");
+    return params.result;
+}
+
+XrResult WINAPI xrSaveSpaceListFB(XrSession session, const XrSpaceListSaveInfoFB *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrSaveSpaceListFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrSaveSpaceListFB, &params);
+    assert(!_status && "xrSaveSpaceListFB");
+    return params.result;
+}
+
+XrResult WINAPI xrSaveSpacesMETA(XrSession session, const XrSpacesSaveInfoMETA *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrSaveSpacesMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrSaveSpacesMETA, &params);
+    assert(!_status && "xrSaveSpacesMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrSendVirtualKeyboardInputMETA(XrVirtualKeyboardMETA keyboard, const XrVirtualKeyboardInputInfoMETA *info, XrPosef *interactorRootPose)
+{
+    struct xrSendVirtualKeyboardInputMETA_params params;
+    NTSTATUS _status;
+    params.keyboard = keyboard;
+    params.info = info;
+    params.interactorRootPose = interactorRootPose;
+    _status = UNIX_CALL(xrSendVirtualKeyboardInputMETA, &params);
+    assert(!_status && "xrSendVirtualKeyboardInputMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrSetColorSpaceFB(XrSession session, const XrColorSpaceFB colorSpace)
+{
+    struct xrSetColorSpaceFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.colorSpace = colorSpace;
+    _status = UNIX_CALL(xrSetColorSpaceFB, &params);
+    assert(!_status && "xrSetColorSpaceFB");
+    return params.result;
+}
+
+XrResult WINAPI xrSetDigitalLensControlALMALENCE(XrSession session, const XrDigitalLensControlALMALENCE *digitalLensControl)
+{
+    struct xrSetDigitalLensControlALMALENCE_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.digitalLensControl = digitalLensControl;
+    _status = UNIX_CALL(xrSetDigitalLensControlALMALENCE, &params);
+    assert(!_status && "xrSetDigitalLensControlALMALENCE");
+    return params.result;
+}
+
+XrResult WINAPI xrSetEnvironmentDepthEstimationVARJO(XrSession session, XrBool32 enabled)
+{
+    struct xrSetEnvironmentDepthEstimationVARJO_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.enabled = enabled;
+    _status = UNIX_CALL(xrSetEnvironmentDepthEstimationVARJO, &params);
+    assert(!_status && "xrSetEnvironmentDepthEstimationVARJO");
+    return params.result;
+}
+
+XrResult WINAPI xrSetEnvironmentDepthHandRemovalMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider, const XrEnvironmentDepthHandRemovalSetInfoMETA *setInfo)
+{
+    struct xrSetEnvironmentDepthHandRemovalMETA_params params;
+    NTSTATUS _status;
+    params.environmentDepthProvider = environmentDepthProvider;
+    params.setInfo = setInfo;
+    _status = UNIX_CALL(xrSetEnvironmentDepthHandRemovalMETA, &params);
+    assert(!_status && "xrSetEnvironmentDepthHandRemovalMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrSetInputDeviceActiveEXT(XrSession session, XrPath interactionProfile, XrPath topLevelPath, XrBool32 isActive)
+{
+    struct xrSetInputDeviceActiveEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.interactionProfile = interactionProfile;
+    params.topLevelPath = topLevelPath;
+    params.isActive = isActive;
+    _status = UNIX_CALL(xrSetInputDeviceActiveEXT, &params);
+    assert(!_status && "xrSetInputDeviceActiveEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrSetInputDeviceLocationEXT(XrSession session, XrPath topLevelPath, XrPath inputSourcePath, XrSpace space, XrPosef pose)
+{
+    struct xrSetInputDeviceLocationEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.topLevelPath = topLevelPath;
+    params.inputSourcePath = inputSourcePath;
+    params.space = space;
+    params.pose = pose;
+    _status = UNIX_CALL(xrSetInputDeviceLocationEXT, &params);
+    assert(!_status && "xrSetInputDeviceLocationEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrSetInputDeviceStateBoolEXT(XrSession session, XrPath topLevelPath, XrPath inputSourcePath, XrBool32 state)
+{
+    struct xrSetInputDeviceStateBoolEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.topLevelPath = topLevelPath;
+    params.inputSourcePath = inputSourcePath;
+    params.state = state;
+    _status = UNIX_CALL(xrSetInputDeviceStateBoolEXT, &params);
+    assert(!_status && "xrSetInputDeviceStateBoolEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrSetInputDeviceStateFloatEXT(XrSession session, XrPath topLevelPath, XrPath inputSourcePath, float state)
+{
+    struct xrSetInputDeviceStateFloatEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.topLevelPath = topLevelPath;
+    params.inputSourcePath = inputSourcePath;
+    params.state = state;
+    _status = UNIX_CALL(xrSetInputDeviceStateFloatEXT, &params);
+    assert(!_status && "xrSetInputDeviceStateFloatEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrSetInputDeviceStateVector2fEXT(XrSession session, XrPath topLevelPath, XrPath inputSourcePath, XrVector2f state)
+{
+    struct xrSetInputDeviceStateVector2fEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.topLevelPath = topLevelPath;
+    params.inputSourcePath = inputSourcePath;
+    params.state = state;
+    _status = UNIX_CALL(xrSetInputDeviceStateVector2fEXT, &params);
+    assert(!_status && "xrSetInputDeviceStateVector2fEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrSetMarkerTrackingPredictionVARJO(XrSession session, uint64_t markerId, XrBool32 enable)
+{
+    struct xrSetMarkerTrackingPredictionVARJO_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.markerId = markerId;
+    params.enable = enable;
+    _status = UNIX_CALL(xrSetMarkerTrackingPredictionVARJO, &params);
+    assert(!_status && "xrSetMarkerTrackingPredictionVARJO");
+    return params.result;
+}
+
+XrResult WINAPI xrSetMarkerTrackingTimeoutVARJO(XrSession session, uint64_t markerId, XrDuration timeout)
+{
+    struct xrSetMarkerTrackingTimeoutVARJO_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.markerId = markerId;
+    params.timeout = timeout;
+    _status = UNIX_CALL(xrSetMarkerTrackingTimeoutVARJO, &params);
+    assert(!_status && "xrSetMarkerTrackingTimeoutVARJO");
+    return params.result;
+}
+
+XrResult WINAPI xrSetMarkerTrackingVARJO(XrSession session, XrBool32 enabled)
+{
+    struct xrSetMarkerTrackingVARJO_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.enabled = enabled;
+    _status = UNIX_CALL(xrSetMarkerTrackingVARJO, &params);
+    assert(!_status && "xrSetMarkerTrackingVARJO");
+    return params.result;
+}
+
+XrResult WINAPI xrSetPerformanceMetricsStateMETA(XrSession session, const XrPerformanceMetricsStateMETA *state)
+{
+    struct xrSetPerformanceMetricsStateMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.state = state;
+    _status = UNIX_CALL(xrSetPerformanceMetricsStateMETA, &params);
+    assert(!_status && "xrSetPerformanceMetricsStateMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrSetSpaceComponentStatusFB(XrSpace space, const XrSpaceComponentStatusSetInfoFB *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrSetSpaceComponentStatusFB_params params;
+    NTSTATUS _status;
+    params.space = space;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrSetSpaceComponentStatusFB, &params);
+    assert(!_status && "xrSetSpaceComponentStatusFB");
+    return params.result;
+}
+
+XrResult WINAPI xrSetSystemNotificationsML(XrInstance instance, const XrSystemNotificationsSetInfoML *info)
+{
+    struct xrSetSystemNotificationsML_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.info = info;
+    _status = UNIX_CALL(xrSetSystemNotificationsML, &params);
+    assert(!_status && "xrSetSystemNotificationsML");
+    return params.result;
+}
+
+XrResult WINAPI xrSetTrackingOptimizationSettingsHintQCOM(XrSession session, XrTrackingOptimizationSettingsDomainQCOM domain, XrTrackingOptimizationSettingsHintQCOM hint)
+{
+    struct xrSetTrackingOptimizationSettingsHintQCOM_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.domain = domain;
+    params.hint = hint;
+    _status = UNIX_CALL(xrSetTrackingOptimizationSettingsHintQCOM, &params);
+    assert(!_status && "xrSetTrackingOptimizationSettingsHintQCOM");
+    return params.result;
+}
+
+XrResult WINAPI xrSetViewOffsetVARJO(XrSession session, float offset)
+{
+    struct xrSetViewOffsetVARJO_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.offset = offset;
+    _status = UNIX_CALL(xrSetViewOffsetVARJO, &params);
+    assert(!_status && "xrSetViewOffsetVARJO");
+    return params.result;
+}
+
+XrResult WINAPI xrSetVirtualKeyboardModelVisibilityMETA(XrVirtualKeyboardMETA keyboard, const XrVirtualKeyboardModelVisibilitySetInfoMETA *modelVisibility)
+{
+    struct xrSetVirtualKeyboardModelVisibilityMETA_params params;
+    NTSTATUS _status;
+    params.keyboard = keyboard;
+    params.modelVisibility = modelVisibility;
+    _status = UNIX_CALL(xrSetVirtualKeyboardModelVisibilityMETA, &params);
+    assert(!_status && "xrSetVirtualKeyboardModelVisibilityMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrShareSpacesFB(XrSession session, const XrSpaceShareInfoFB *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrShareSpacesFB_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrShareSpacesFB, &params);
+    assert(!_status && "xrShareSpacesFB");
+    return params.result;
+}
+
+XrResult WINAPI xrShareSpacesMETA(XrSession session, const XrShareSpacesInfoMETA *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrShareSpacesMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrShareSpacesMETA, &params);
+    assert(!_status && "xrShareSpacesMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrShareSpatialAnchorAsyncBD(XrSenseDataProviderBD provider, const XrSpatialAnchorShareInfoBD *info, XrFutureEXT *future)
+{
+    struct xrShareSpatialAnchorAsyncBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.info = info;
+    params.future = future;
+    _status = UNIX_CALL(xrShareSpatialAnchorAsyncBD, &params);
+    assert(!_status && "xrShareSpatialAnchorAsyncBD");
+    return params.result;
+}
+
+XrResult WINAPI xrShareSpatialAnchorCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrFutureCompletionEXT *completion)
+{
+    struct xrShareSpatialAnchorCompleteBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrShareSpatialAnchorCompleteBD, &params);
+    assert(!_status && "xrShareSpatialAnchorCompleteBD");
+    return params.result;
+}
+
+XrResult WINAPI xrSnapshotMarkerDetectorML(XrMarkerDetectorML markerDetector, XrMarkerDetectorSnapshotInfoML *snapshotInfo)
+{
+    struct xrSnapshotMarkerDetectorML_params params;
+    NTSTATUS _status;
+    params.markerDetector = markerDetector;
+    params.snapshotInfo = snapshotInfo;
+    _status = UNIX_CALL(xrSnapshotMarkerDetectorML, &params);
+    assert(!_status && "xrSnapshotMarkerDetectorML");
+    return params.result;
+}
+
+XrResult WINAPI xrStartColocationAdvertisementMETA(XrSession session, const XrColocationAdvertisementStartInfoMETA *info, XrAsyncRequestIdFB *advertisementRequestId)
+{
+    struct xrStartColocationAdvertisementMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.advertisementRequestId = advertisementRequestId;
+    _status = UNIX_CALL(xrStartColocationAdvertisementMETA, &params);
+    assert(!_status && "xrStartColocationAdvertisementMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrStartColocationDiscoveryMETA(XrSession session, const XrColocationDiscoveryStartInfoMETA *info, XrAsyncRequestIdFB *discoveryRequestId)
+{
+    struct xrStartColocationDiscoveryMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.discoveryRequestId = discoveryRequestId;
+    _status = UNIX_CALL(xrStartColocationDiscoveryMETA, &params);
+    assert(!_status && "xrStartColocationDiscoveryMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrStartEnvironmentDepthProviderMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider)
+{
+    struct xrStartEnvironmentDepthProviderMETA_params params;
+    NTSTATUS _status;
+    params.environmentDepthProvider = environmentDepthProvider;
+    _status = UNIX_CALL(xrStartEnvironmentDepthProviderMETA, &params);
+    assert(!_status && "xrStartEnvironmentDepthProviderMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrStartSenseDataProviderAsyncBD(XrSenseDataProviderBD provider, const XrSenseDataProviderStartInfoBD *startInfo, XrFutureEXT *future)
+{
+    struct xrStartSenseDataProviderAsyncBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.startInfo = startInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrStartSenseDataProviderAsyncBD, &params);
+    assert(!_status && "xrStartSenseDataProviderAsyncBD");
+    return params.result;
+}
+
+XrResult WINAPI xrStartSenseDataProviderCompleteBD(XrSession session, XrFutureEXT future, XrFutureCompletionEXT *completion)
+{
+    struct xrStartSenseDataProviderCompleteBD_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrStartSenseDataProviderCompleteBD, &params);
+    assert(!_status && "xrStartSenseDataProviderCompleteBD");
+    return params.result;
+}
+
+XrResult WINAPI xrStopColocationAdvertisementMETA(XrSession session, const XrColocationAdvertisementStopInfoMETA *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrStopColocationAdvertisementMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrStopColocationAdvertisementMETA, &params);
+    assert(!_status && "xrStopColocationAdvertisementMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrStopColocationDiscoveryMETA(XrSession session, const XrColocationDiscoveryStopInfoMETA *info, XrAsyncRequestIdFB *requestId)
+{
+    struct xrStopColocationDiscoveryMETA_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.info = info;
+    params.requestId = requestId;
+    _status = UNIX_CALL(xrStopColocationDiscoveryMETA, &params);
+    assert(!_status && "xrStopColocationDiscoveryMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrStopEnvironmentDepthProviderMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider)
+{
+    struct xrStopEnvironmentDepthProviderMETA_params params;
+    NTSTATUS _status;
+    params.environmentDepthProvider = environmentDepthProvider;
+    _status = UNIX_CALL(xrStopEnvironmentDepthProviderMETA, &params);
+    assert(!_status && "xrStopEnvironmentDepthProviderMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrStopHapticFeedback(XrSession session, const XrHapticActionInfo *hapticActionInfo)
+{
+    struct xrStopHapticFeedback_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.hapticActionInfo = hapticActionInfo;
+    _status = UNIX_CALL(xrStopHapticFeedback, &params);
+    assert(!_status && "xrStopHapticFeedback");
+    return params.result;
+}
+
+XrResult WINAPI xrStopSenseDataProviderBD(XrSenseDataProviderBD provider)
+{
+    struct xrStopSenseDataProviderBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    _status = UNIX_CALL(xrStopSenseDataProviderBD, &params);
+    assert(!_status && "xrStopSenseDataProviderBD");
+    return params.result;
+}
+
+XrResult WINAPI xrStringToPath(XrInstance instance, const char *pathString, XrPath *path)
+{
+    struct xrStringToPath_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.pathString = pathString;
+    params.path = path;
+    _status = UNIX_CALL(xrStringToPath, &params);
+    assert(!_status && "xrStringToPath");
+    return params.result;
+}
+
+XrResult WINAPI xrStructureTypeToString(XrInstance instance, XrStructureType value, char buffer[])
+{
+    struct xrStructureTypeToString_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.value = value;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrStructureTypeToString, &params);
+    assert(!_status && "xrStructureTypeToString");
+    return params.result;
+}
+
+XrResult WINAPI xrStructureTypeToString2KHR(XrInstance instance, XrStructureType value, char buffer[])
+{
+    struct xrStructureTypeToString2KHR_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.value = value;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrStructureTypeToString2KHR, &params);
+    assert(!_status && "xrStructureTypeToString2KHR");
+    return params.result;
+}
+
+XrResult WINAPI xrSuggestBodyTrackingCalibrationOverrideMETA(XrBodyTrackerFB bodyTracker, const XrBodyTrackingCalibrationInfoMETA *calibrationInfo)
+{
+    struct xrSuggestBodyTrackingCalibrationOverrideMETA_params params;
+    NTSTATUS _status;
+    params.bodyTracker = bodyTracker;
+    params.calibrationInfo = calibrationInfo;
+    _status = UNIX_CALL(xrSuggestBodyTrackingCalibrationOverrideMETA, &params);
+    assert(!_status && "xrSuggestBodyTrackingCalibrationOverrideMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrSuggestInteractionProfileBindings(XrInstance instance, const XrInteractionProfileSuggestedBinding *suggestedBindings)
+{
+    struct xrSuggestInteractionProfileBindings_params params;
+    NTSTATUS _status;
+    params.instance = instance;
+    params.suggestedBindings = suggestedBindings;
+    _status = UNIX_CALL(xrSuggestInteractionProfileBindings, &params);
+    assert(!_status && "xrSuggestInteractionProfileBindings");
+    return params.result;
+}
+
+XrResult WINAPI xrSuggestVirtualKeyboardLocationMETA(XrVirtualKeyboardMETA keyboard, const XrVirtualKeyboardLocationInfoMETA *locationInfo)
+{
+    struct xrSuggestVirtualKeyboardLocationMETA_params params;
+    NTSTATUS _status;
+    params.keyboard = keyboard;
+    params.locationInfo = locationInfo;
+    _status = UNIX_CALL(xrSuggestVirtualKeyboardLocationMETA, &params);
+    assert(!_status && "xrSuggestVirtualKeyboardLocationMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrSyncActions(XrSession session, const XrActionsSyncInfo *syncInfo)
+{
+    struct xrSyncActions_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.syncInfo = syncInfo;
+    _status = UNIX_CALL(xrSyncActions, &params);
+    assert(!_status && "xrSyncActions");
+    return params.result;
+}
+
+XrResult WINAPI xrThermalGetTemperatureTrendEXT(XrSession session, XrPerfSettingsDomainEXT domain, XrPerfSettingsNotificationLevelEXT *notificationLevel, float *tempHeadroom, float *tempSlope)
+{
+    struct xrThermalGetTemperatureTrendEXT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.domain = domain;
+    params.notificationLevel = notificationLevel;
+    params.tempHeadroom = tempHeadroom;
+    params.tempSlope = tempSlope;
+    _status = UNIX_CALL(xrThermalGetTemperatureTrendEXT, &params);
+    assert(!_status && "xrThermalGetTemperatureTrendEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrTriangleMeshBeginUpdateFB(XrTriangleMeshFB mesh)
+{
+    struct xrTriangleMeshBeginUpdateFB_params params;
+    NTSTATUS _status;
+    params.mesh = mesh;
+    _status = UNIX_CALL(xrTriangleMeshBeginUpdateFB, &params);
+    assert(!_status && "xrTriangleMeshBeginUpdateFB");
+    return params.result;
+}
+
+XrResult WINAPI xrTriangleMeshBeginVertexBufferUpdateFB(XrTriangleMeshFB mesh, uint32_t *outVertexCount)
+{
+    struct xrTriangleMeshBeginVertexBufferUpdateFB_params params;
+    NTSTATUS _status;
+    params.mesh = mesh;
+    params.outVertexCount = outVertexCount;
+    _status = UNIX_CALL(xrTriangleMeshBeginVertexBufferUpdateFB, &params);
+    assert(!_status && "xrTriangleMeshBeginVertexBufferUpdateFB");
+    return params.result;
+}
+
+XrResult WINAPI xrTriangleMeshEndUpdateFB(XrTriangleMeshFB mesh, uint32_t vertexCount, uint32_t triangleCount)
+{
+    struct xrTriangleMeshEndUpdateFB_params params;
+    NTSTATUS _status;
+    params.mesh = mesh;
+    params.vertexCount = vertexCount;
+    params.triangleCount = triangleCount;
+    _status = UNIX_CALL(xrTriangleMeshEndUpdateFB, &params);
+    assert(!_status && "xrTriangleMeshEndUpdateFB");
+    return params.result;
+}
+
+XrResult WINAPI xrTriangleMeshEndVertexBufferUpdateFB(XrTriangleMeshFB mesh)
+{
+    struct xrTriangleMeshEndVertexBufferUpdateFB_params params;
+    NTSTATUS _status;
+    params.mesh = mesh;
+    _status = UNIX_CALL(xrTriangleMeshEndVertexBufferUpdateFB, &params);
+    assert(!_status && "xrTriangleMeshEndVertexBufferUpdateFB");
+    return params.result;
+}
+
+XrResult WINAPI xrTriangleMeshGetIndexBufferFB(XrTriangleMeshFB mesh, uint32_t **outIndexBuffer)
+{
+    struct xrTriangleMeshGetIndexBufferFB_params params;
+    NTSTATUS _status;
+    params.mesh = mesh;
+    params.outIndexBuffer = outIndexBuffer;
+    _status = UNIX_CALL(xrTriangleMeshGetIndexBufferFB, &params);
+    assert(!_status && "xrTriangleMeshGetIndexBufferFB");
+    return params.result;
+}
+
+XrResult WINAPI xrTriangleMeshGetVertexBufferFB(XrTriangleMeshFB mesh, XrVector3f **outVertexBuffer)
+{
+    struct xrTriangleMeshGetVertexBufferFB_params params;
+    NTSTATUS _status;
+    params.mesh = mesh;
+    params.outVertexBuffer = outVertexBuffer;
+    _status = UNIX_CALL(xrTriangleMeshGetVertexBufferFB, &params);
+    assert(!_status && "xrTriangleMeshGetVertexBufferFB");
+    return params.result;
+}
+
+XrResult WINAPI xrTryCreateSpatialGraphStaticNodeBindingMSFT(XrSession session, const XrSpatialGraphStaticNodeBindingCreateInfoMSFT *createInfo, XrSpatialGraphNodeBindingMSFT *nodeBinding)
+{
+    struct xrTryCreateSpatialGraphStaticNodeBindingMSFT_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.createInfo = createInfo;
+    params.nodeBinding = nodeBinding;
+    _status = UNIX_CALL(xrTryCreateSpatialGraphStaticNodeBindingMSFT, &params);
+    assert(!_status && "xrTryCreateSpatialGraphStaticNodeBindingMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrUnpersistAnchorANDROID(XrDeviceAnchorPersistenceANDROID handle, const XrUuidEXT *anchorId)
+{
+    struct xrUnpersistAnchorANDROID_params params;
+    NTSTATUS _status;
+    params.handle = handle;
+    params.anchorId = anchorId;
+    _status = UNIX_CALL(xrUnpersistAnchorANDROID, &params);
+    assert(!_status && "xrUnpersistAnchorANDROID");
+    return params.result;
+}
+
+XrResult WINAPI xrUnpersistSpatialAnchorAsyncBD(XrSenseDataProviderBD provider, const XrSpatialAnchorUnpersistInfoBD *info, XrFutureEXT *future)
+{
+    struct xrUnpersistSpatialAnchorAsyncBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.info = info;
+    params.future = future;
+    _status = UNIX_CALL(xrUnpersistSpatialAnchorAsyncBD, &params);
+    assert(!_status && "xrUnpersistSpatialAnchorAsyncBD");
+    return params.result;
+}
+
+XrResult WINAPI xrUnpersistSpatialAnchorCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrFutureCompletionEXT *completion)
+{
+    struct xrUnpersistSpatialAnchorCompleteBD_params params;
+    NTSTATUS _status;
+    params.provider = provider;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrUnpersistSpatialAnchorCompleteBD, &params);
+    assert(!_status && "xrUnpersistSpatialAnchorCompleteBD");
+    return params.result;
+}
+
+XrResult WINAPI xrUnpersistSpatialAnchorMSFT(XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore, const XrSpatialAnchorPersistenceNameMSFT *spatialAnchorPersistenceName)
+{
+    struct xrUnpersistSpatialAnchorMSFT_params params;
+    NTSTATUS _status;
+    params.spatialAnchorStore = spatialAnchorStore;
+    params.spatialAnchorPersistenceName = spatialAnchorPersistenceName;
+    _status = UNIX_CALL(xrUnpersistSpatialAnchorMSFT, &params);
+    assert(!_status && "xrUnpersistSpatialAnchorMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrUnpersistSpatialEntityAsyncEXT(XrSpatialPersistenceContextEXT persistenceContext, const XrSpatialEntityUnpersistInfoEXT *unpersistInfo, XrFutureEXT *future)
+{
+    struct xrUnpersistSpatialEntityAsyncEXT_params params;
+    NTSTATUS _status;
+    params.persistenceContext = persistenceContext;
+    params.unpersistInfo = unpersistInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrUnpersistSpatialEntityAsyncEXT, &params);
+    assert(!_status && "xrUnpersistSpatialEntityAsyncEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrUnpersistSpatialEntityCompleteEXT(XrSpatialPersistenceContextEXT persistenceContext, XrFutureEXT future, XrUnpersistSpatialEntityCompletionEXT *completion)
+{
+    struct xrUnpersistSpatialEntityCompleteEXT_params params;
+    NTSTATUS _status;
+    params.persistenceContext = persistenceContext;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrUnpersistSpatialEntityCompleteEXT, &params);
+    assert(!_status && "xrUnpersistSpatialEntityCompleteEXT");
+    return params.result;
+}
+
+XrResult WINAPI xrUpdateHandMeshMSFT(XrHandTrackerEXT handTracker, const XrHandMeshUpdateInfoMSFT *updateInfo, XrHandMeshMSFT *handMesh)
+{
+    struct xrUpdateHandMeshMSFT_params params;
+    NTSTATUS _status;
+    params.handTracker = handTracker;
+    params.updateInfo = updateInfo;
+    params.handMesh = handMesh;
+    _status = UNIX_CALL(xrUpdateHandMeshMSFT, &params);
+    assert(!_status && "xrUpdateHandMeshMSFT");
+    return params.result;
+}
+
+XrResult WINAPI xrUpdatePassthroughColorLutMETA(XrPassthroughColorLutMETA colorLut, const XrPassthroughColorLutUpdateInfoMETA *updateInfo)
+{
+    struct xrUpdatePassthroughColorLutMETA_params params;
+    NTSTATUS _status;
+    params.colorLut = colorLut;
+    params.updateInfo = updateInfo;
+    _status = UNIX_CALL(xrUpdatePassthroughColorLutMETA, &params);
+    assert(!_status && "xrUpdatePassthroughColorLutMETA");
+    return params.result;
+}
+
+XrResult WINAPI xrUpdateSpatialAnchorsExpirationAsyncML(XrSpatialAnchorsStorageML storage, const XrSpatialAnchorsUpdateExpirationInfoML *updateInfo, XrFutureEXT *future)
+{
+    struct xrUpdateSpatialAnchorsExpirationAsyncML_params params;
+    NTSTATUS _status;
+    params.storage = storage;
+    params.updateInfo = updateInfo;
+    params.future = future;
+    _status = UNIX_CALL(xrUpdateSpatialAnchorsExpirationAsyncML, &params);
+    assert(!_status && "xrUpdateSpatialAnchorsExpirationAsyncML");
+    return params.result;
+}
+
+XrResult WINAPI xrUpdateSpatialAnchorsExpirationCompleteML(XrSpatialAnchorsStorageML storage, XrFutureEXT future, XrSpatialAnchorsUpdateExpirationCompletionML *completion)
+{
+    struct xrUpdateSpatialAnchorsExpirationCompleteML_params params;
+    NTSTATUS _status;
+    params.storage = storage;
+    params.future = future;
+    params.completion = completion;
+    _status = UNIX_CALL(xrUpdateSpatialAnchorsExpirationCompleteML, &params);
+    assert(!_status && "xrUpdateSpatialAnchorsExpirationCompleteML");
+    return params.result;
+}
+
+XrResult WINAPI xrUpdateSwapchainFB(XrSwapchain swapchain, const XrSwapchainStateBaseHeaderFB *state)
+{
+    struct xrUpdateSwapchainFB_params params;
+    NTSTATUS _status;
+    params.swapchain = swapchain;
+    params.state = state;
+    _status = UNIX_CALL(xrUpdateSwapchainFB, &params);
+    assert(!_status && "xrUpdateSwapchainFB");
+    return params.result;
+}
+
+XrResult WINAPI xrWaitFrame(XrSession session, const XrFrameWaitInfo *frameWaitInfo, XrFrameState *frameState)
+{
+    struct xrWaitFrame_params params;
+    NTSTATUS _status;
+    params.session = session;
+    params.frameWaitInfo = frameWaitInfo;
+    params.frameState = frameState;
+    _status = UNIX_CALL(xrWaitFrame, &params);
+    assert(!_status && "xrWaitFrame");
+    return params.result;
+}
+
+XrResult WINAPI xrWaitSwapchainImage(XrSwapchain swapchain, const XrSwapchainImageWaitInfo *waitInfo)
+{
+    struct xrWaitSwapchainImage_params params;
+    NTSTATUS _status;
+    params.swapchain = swapchain;
+    params.waitInfo = waitInfo;
+    _status = UNIX_CALL(xrWaitSwapchainImage, &params);
+    assert(!_status && "xrWaitSwapchainImage");
+    return params.result;
+}
+
+static const struct openxr_func xr_instance_dispatch_table[] =
+{
+    {"xrAcquireEnvironmentDepthImageMETA", xrAcquireEnvironmentDepthImageMETA},
+    {"xrAcquireSwapchainImage", xrAcquireSwapchainImage},
+    {"xrAllocateWorldMeshBufferML", xrAllocateWorldMeshBufferML},
+    {"xrApplyForceFeedbackCurlMNDX", xrApplyForceFeedbackCurlMNDX},
+    {"xrApplyHapticFeedback", xrApplyHapticFeedback},
+    {"xrAttachSessionActionSets", xrAttachSessionActionSets},
+    {"xrBeginFrame", xrBeginFrame},
+    {"xrBeginPlaneDetectionEXT", xrBeginPlaneDetectionEXT},
+    {"xrBeginSession", xrBeginSession},
+    {"xrCancelFutureEXT", xrCancelFutureEXT},
+    {"xrCaptureSceneAsyncBD", xrCaptureSceneAsyncBD},
+    {"xrCaptureSceneCompleteBD", xrCaptureSceneCompleteBD},
+    {"xrChangeVirtualKeyboardTextContextMETA", xrChangeVirtualKeyboardTextContextMETA},
+    {"xrClearSpatialAnchorStoreMSFT", xrClearSpatialAnchorStoreMSFT},
+    {"xrComputeNewSceneMSFT", xrComputeNewSceneMSFT},
+    {"xrConvertTimeToWin32PerformanceCounterKHR", xrConvertTimeToWin32PerformanceCounterKHR},
+    {"xrConvertWin32PerformanceCounterToTimeKHR", xrConvertWin32PerformanceCounterToTimeKHR},
+    {"xrCreateAction", xrCreateAction},
+    {"xrCreateActionSet", xrCreateActionSet},
+    {"xrCreateActionSpace", xrCreateActionSpace},
+    {"xrCreateAnchorSpaceANDROID", xrCreateAnchorSpaceANDROID},
+    {"xrCreateAnchorSpaceBD", xrCreateAnchorSpaceBD},
+    {"xrCreateApiLayerInstance", xrCreateApiLayerInstance},
+    {"xrCreateBodyTrackerBD", xrCreateBodyTrackerBD},
+    {"xrCreateBodyTrackerFB", xrCreateBodyTrackerFB},
+    {"xrCreateBodyTrackerHTC", xrCreateBodyTrackerHTC},
+    {"xrCreateDeviceAnchorPersistenceANDROID", xrCreateDeviceAnchorPersistenceANDROID},
+    {"xrCreateEnvironmentDepthProviderMETA", xrCreateEnvironmentDepthProviderMETA},
+    {"xrCreateEnvironmentDepthSwapchainMETA", xrCreateEnvironmentDepthSwapchainMETA},
+    {"xrCreateExportedLocalizationMapML", xrCreateExportedLocalizationMapML},
+    {"xrCreateEyeTrackerFB", xrCreateEyeTrackerFB},
+    {"xrCreateFaceTracker2FB", xrCreateFaceTracker2FB},
+    {"xrCreateFaceTrackerFB", xrCreateFaceTrackerFB},
+    {"xrCreateFacialExpressionClientML", xrCreateFacialExpressionClientML},
+    {"xrCreateFacialTrackerHTC", xrCreateFacialTrackerHTC},
+    {"xrCreateFoveationProfileFB", xrCreateFoveationProfileFB},
+    {"xrCreateGeometryInstanceFB", xrCreateGeometryInstanceFB},
+    {"xrCreateHandMeshSpaceMSFT", xrCreateHandMeshSpaceMSFT},
+    {"xrCreateHandTrackerEXT", xrCreateHandTrackerEXT},
+    {"xrCreateInstance", xrCreateInstance},
+    {"xrCreateKeyboardSpaceFB", xrCreateKeyboardSpaceFB},
+    {"xrCreateMarkerDetectorML", xrCreateMarkerDetectorML},
+    {"xrCreateMarkerSpaceML", xrCreateMarkerSpaceML},
+    {"xrCreateMarkerSpaceVARJO", xrCreateMarkerSpaceVARJO},
+    {"xrCreatePassthroughColorLutMETA", xrCreatePassthroughColorLutMETA},
+    {"xrCreatePassthroughFB", xrCreatePassthroughFB},
+    {"xrCreatePassthroughHTC", xrCreatePassthroughHTC},
+    {"xrCreatePassthroughLayerFB", xrCreatePassthroughLayerFB},
+    {"xrCreatePersistedAnchorSpaceANDROID", xrCreatePersistedAnchorSpaceANDROID},
+    {"xrCreatePlaneDetectorEXT", xrCreatePlaneDetectorEXT},
+    {"xrCreateReferenceSpace", xrCreateReferenceSpace},
+    {"xrCreateRenderModelAssetEXT", xrCreateRenderModelAssetEXT},
+    {"xrCreateRenderModelEXT", xrCreateRenderModelEXT},
+    {"xrCreateRenderModelSpaceEXT", xrCreateRenderModelSpaceEXT},
+    {"xrCreateSceneMSFT", xrCreateSceneMSFT},
+    {"xrCreateSceneObserverMSFT", xrCreateSceneObserverMSFT},
+    {"xrCreateSenseDataProviderBD", xrCreateSenseDataProviderBD},
+    {"xrCreateSession", xrCreateSession},
+    {"xrCreateSpaceUserFB", xrCreateSpaceUserFB},
+    {"xrCreateSpatialAnchorAsyncBD", xrCreateSpatialAnchorAsyncBD},
+    {"xrCreateSpatialAnchorCompleteBD", xrCreateSpatialAnchorCompleteBD},
+    {"xrCreateSpatialAnchorEXT", xrCreateSpatialAnchorEXT},
+    {"xrCreateSpatialAnchorFB", xrCreateSpatialAnchorFB},
+    {"xrCreateSpatialAnchorFromPersistedNameMSFT", xrCreateSpatialAnchorFromPersistedNameMSFT},
+    {"xrCreateSpatialAnchorHTC", xrCreateSpatialAnchorHTC},
+    {"xrCreateSpatialAnchorMSFT", xrCreateSpatialAnchorMSFT},
+    {"xrCreateSpatialAnchorSpaceMSFT", xrCreateSpatialAnchorSpaceMSFT},
+    {"xrCreateSpatialAnchorStoreConnectionMSFT", xrCreateSpatialAnchorStoreConnectionMSFT},
+    {"xrCreateSpatialAnchorsAsyncML", xrCreateSpatialAnchorsAsyncML},
+    {"xrCreateSpatialAnchorsCompleteML", xrCreateSpatialAnchorsCompleteML},
+    {"xrCreateSpatialAnchorsStorageML", xrCreateSpatialAnchorsStorageML},
+    {"xrCreateSpatialContextAsyncEXT", xrCreateSpatialContextAsyncEXT},
+    {"xrCreateSpatialContextCompleteEXT", xrCreateSpatialContextCompleteEXT},
+    {"xrCreateSpatialDiscoverySnapshotAsyncEXT", xrCreateSpatialDiscoverySnapshotAsyncEXT},
+    {"xrCreateSpatialDiscoverySnapshotCompleteEXT", xrCreateSpatialDiscoverySnapshotCompleteEXT},
+    {"xrCreateSpatialEntityAnchorBD", xrCreateSpatialEntityAnchorBD},
+    {"xrCreateSpatialEntityFromIdEXT", xrCreateSpatialEntityFromIdEXT},
+    {"xrCreateSpatialGraphNodeSpaceMSFT", xrCreateSpatialGraphNodeSpaceMSFT},
+    {"xrCreateSpatialPersistenceContextAsyncEXT", xrCreateSpatialPersistenceContextAsyncEXT},
+    {"xrCreateSpatialPersistenceContextCompleteEXT", xrCreateSpatialPersistenceContextCompleteEXT},
+    {"xrCreateSpatialUpdateSnapshotEXT", xrCreateSpatialUpdateSnapshotEXT},
+    {"xrCreateSwapchain", xrCreateSwapchain},
+    {"xrCreateTrackableTrackerANDROID", xrCreateTrackableTrackerANDROID},
+    {"xrCreateTriangleMeshFB", xrCreateTriangleMeshFB},
+    {"xrCreateVirtualKeyboardMETA", xrCreateVirtualKeyboardMETA},
+    {"xrCreateVirtualKeyboardSpaceMETA", xrCreateVirtualKeyboardSpaceMETA},
+    {"xrCreateVulkanDeviceKHR", xrCreateVulkanDeviceKHR},
+    {"xrCreateVulkanInstanceKHR", xrCreateVulkanInstanceKHR},
+    {"xrCreateWorldMeshDetectorML", xrCreateWorldMeshDetectorML},
+    {"xrDeleteSpatialAnchorsAsyncML", xrDeleteSpatialAnchorsAsyncML},
+    {"xrDeleteSpatialAnchorsCompleteML", xrDeleteSpatialAnchorsCompleteML},
+    {"xrDeserializeSceneMSFT", xrDeserializeSceneMSFT},
+    {"xrDestroyAction", xrDestroyAction},
+    {"xrDestroyActionSet", xrDestroyActionSet},
+    {"xrDestroyAnchorBD", xrDestroyAnchorBD},
+    {"xrDestroyBodyTrackerBD", xrDestroyBodyTrackerBD},
+    {"xrDestroyBodyTrackerFB", xrDestroyBodyTrackerFB},
+    {"xrDestroyBodyTrackerHTC", xrDestroyBodyTrackerHTC},
+    {"xrDestroyDeviceAnchorPersistenceANDROID", xrDestroyDeviceAnchorPersistenceANDROID},
+    {"xrDestroyEnvironmentDepthProviderMETA", xrDestroyEnvironmentDepthProviderMETA},
+    {"xrDestroyEnvironmentDepthSwapchainMETA", xrDestroyEnvironmentDepthSwapchainMETA},
+    {"xrDestroyExportedLocalizationMapML", xrDestroyExportedLocalizationMapML},
+    {"xrDestroyEyeTrackerFB", xrDestroyEyeTrackerFB},
+    {"xrDestroyFaceTracker2FB", xrDestroyFaceTracker2FB},
+    {"xrDestroyFaceTrackerFB", xrDestroyFaceTrackerFB},
+    {"xrDestroyFacialExpressionClientML", xrDestroyFacialExpressionClientML},
+    {"xrDestroyFacialTrackerHTC", xrDestroyFacialTrackerHTC},
+    {"xrDestroyFoveationProfileFB", xrDestroyFoveationProfileFB},
+    {"xrDestroyGeometryInstanceFB", xrDestroyGeometryInstanceFB},
+    {"xrDestroyHandTrackerEXT", xrDestroyHandTrackerEXT},
+    {"xrDestroyInstance", xrDestroyInstance},
+    {"xrDestroyMarkerDetectorML", xrDestroyMarkerDetectorML},
+    {"xrDestroyPassthroughColorLutMETA", xrDestroyPassthroughColorLutMETA},
+    {"xrDestroyPassthroughFB", xrDestroyPassthroughFB},
+    {"xrDestroyPassthroughHTC", xrDestroyPassthroughHTC},
+    {"xrDestroyPassthroughLayerFB", xrDestroyPassthroughLayerFB},
+    {"xrDestroyPlaneDetectorEXT", xrDestroyPlaneDetectorEXT},
+    {"xrDestroyRenderModelAssetEXT", xrDestroyRenderModelAssetEXT},
+    {"xrDestroyRenderModelEXT", xrDestroyRenderModelEXT},
+    {"xrDestroySceneMSFT", xrDestroySceneMSFT},
+    {"xrDestroySceneObserverMSFT", xrDestroySceneObserverMSFT},
+    {"xrDestroySenseDataProviderBD", xrDestroySenseDataProviderBD},
+    {"xrDestroySenseDataSnapshotBD", xrDestroySenseDataSnapshotBD},
+    {"xrDestroySession", xrDestroySession},
+    {"xrDestroySpace", xrDestroySpace},
+    {"xrDestroySpaceUserFB", xrDestroySpaceUserFB},
+    {"xrDestroySpatialAnchorMSFT", xrDestroySpatialAnchorMSFT},
+    {"xrDestroySpatialAnchorStoreConnectionMSFT", xrDestroySpatialAnchorStoreConnectionMSFT},
+    {"xrDestroySpatialAnchorsStorageML", xrDestroySpatialAnchorsStorageML},
+    {"xrDestroySpatialContextEXT", xrDestroySpatialContextEXT},
+    {"xrDestroySpatialEntityEXT", xrDestroySpatialEntityEXT},
+    {"xrDestroySpatialGraphNodeBindingMSFT", xrDestroySpatialGraphNodeBindingMSFT},
+    {"xrDestroySpatialPersistenceContextEXT", xrDestroySpatialPersistenceContextEXT},
+    {"xrDestroySpatialSnapshotEXT", xrDestroySpatialSnapshotEXT},
+    {"xrDestroySwapchain", xrDestroySwapchain},
+    {"xrDestroyTrackableTrackerANDROID", xrDestroyTrackableTrackerANDROID},
+    {"xrDestroyTriangleMeshFB", xrDestroyTriangleMeshFB},
+    {"xrDestroyVirtualKeyboardMETA", xrDestroyVirtualKeyboardMETA},
+    {"xrDestroyWorldMeshDetectorML", xrDestroyWorldMeshDetectorML},
+    {"xrDiscoverSpacesMETA", xrDiscoverSpacesMETA},
+    {"xrDownloadSharedSpatialAnchorAsyncBD", xrDownloadSharedSpatialAnchorAsyncBD},
+    {"xrDownloadSharedSpatialAnchorCompleteBD", xrDownloadSharedSpatialAnchorCompleteBD},
+    {"xrEnableLocalizationEventsML", xrEnableLocalizationEventsML},
+    {"xrEnableUserCalibrationEventsML", xrEnableUserCalibrationEventsML},
+    {"xrEndFrame", xrEndFrame},
+    {"xrEndSession", xrEndSession},
+    {"xrEnumerateApiLayerProperties", xrEnumerateApiLayerProperties},
+    {"xrEnumerateBoundSourcesForAction", xrEnumerateBoundSourcesForAction},
+    {"xrEnumerateColorSpacesFB", xrEnumerateColorSpacesFB},
+    {"xrEnumerateDisplayRefreshRatesFB", xrEnumerateDisplayRefreshRatesFB},
+    {"xrEnumerateEnvironmentBlendModes", xrEnumerateEnvironmentBlendModes},
+    {"xrEnumerateEnvironmentDepthSwapchainImagesMETA", xrEnumerateEnvironmentDepthSwapchainImagesMETA},
+    {"xrEnumerateExternalCamerasOCULUS", xrEnumerateExternalCamerasOCULUS},
+    {"xrEnumerateInstanceExtensionProperties", xrEnumerateInstanceExtensionProperties},
+    {"xrEnumerateInteractionRenderModelIdsEXT", xrEnumerateInteractionRenderModelIdsEXT},
+    {"xrEnumeratePerformanceMetricsCounterPathsMETA", xrEnumeratePerformanceMetricsCounterPathsMETA},
+    {"xrEnumeratePersistedAnchorsANDROID", xrEnumeratePersistedAnchorsANDROID},
+    {"xrEnumeratePersistedSpatialAnchorNamesMSFT", xrEnumeratePersistedSpatialAnchorNamesMSFT},
+    {"xrEnumerateRaycastSupportedTrackableTypesANDROID", xrEnumerateRaycastSupportedTrackableTypesANDROID},
+    {"xrEnumerateReferenceSpaces", xrEnumerateReferenceSpaces},
+    {"xrEnumerateRenderModelPathsFB", xrEnumerateRenderModelPathsFB},
+    {"xrEnumerateRenderModelSubactionPathsEXT", xrEnumerateRenderModelSubactionPathsEXT},
+    {"xrEnumerateReprojectionModesMSFT", xrEnumerateReprojectionModesMSFT},
+    {"xrEnumerateSceneComputeFeaturesMSFT", xrEnumerateSceneComputeFeaturesMSFT},
+    {"xrEnumerateSpaceSupportedComponentsFB", xrEnumerateSpaceSupportedComponentsFB},
+    {"xrEnumerateSpatialCapabilitiesEXT", xrEnumerateSpatialCapabilitiesEXT},
+    {"xrEnumerateSpatialCapabilityComponentTypesEXT", xrEnumerateSpatialCapabilityComponentTypesEXT},
+    {"xrEnumerateSpatialCapabilityFeaturesEXT", xrEnumerateSpatialCapabilityFeaturesEXT},
+    {"xrEnumerateSpatialEntityComponentTypesBD", xrEnumerateSpatialEntityComponentTypesBD},
+    {"xrEnumerateSpatialPersistenceScopesEXT", xrEnumerateSpatialPersistenceScopesEXT},
+    {"xrEnumerateSupportedAnchorTrackableTypesANDROID", xrEnumerateSupportedAnchorTrackableTypesANDROID},
+    {"xrEnumerateSupportedPersistenceAnchorTypesANDROID", xrEnumerateSupportedPersistenceAnchorTypesANDROID},
+    {"xrEnumerateSupportedTrackableTypesANDROID", xrEnumerateSupportedTrackableTypesANDROID},
+    {"xrEnumerateSwapchainFormats", xrEnumerateSwapchainFormats},
+    {"xrEnumerateSwapchainImages", xrEnumerateSwapchainImages},
+    {"xrEnumerateViewConfigurationViews", xrEnumerateViewConfigurationViews},
+    {"xrEnumerateViewConfigurations", xrEnumerateViewConfigurations},
+    {"xrEnumerateViveTrackerPathsHTCX", xrEnumerateViveTrackerPathsHTCX},
+    {"xrEraseSpaceFB", xrEraseSpaceFB},
+    {"xrEraseSpacesMETA", xrEraseSpacesMETA},
+    {"xrFreeWorldMeshBufferML", xrFreeWorldMeshBufferML},
+    {"xrGeometryInstanceSetTransformFB", xrGeometryInstanceSetTransformFB},
+    {"xrGetActionStateBoolean", xrGetActionStateBoolean},
+    {"xrGetActionStateFloat", xrGetActionStateFloat},
+    {"xrGetActionStatePose", xrGetActionStatePose},
+    {"xrGetActionStateVector2f", xrGetActionStateVector2f},
+    {"xrGetAllTrackablesANDROID", xrGetAllTrackablesANDROID},
+    {"xrGetAnchorPersistStateANDROID", xrGetAnchorPersistStateANDROID},
+    {"xrGetAnchorUuidBD", xrGetAnchorUuidBD},
+    {"xrGetAudioInputDeviceGuidOculus", xrGetAudioInputDeviceGuidOculus},
+    {"xrGetAudioOutputDeviceGuidOculus", xrGetAudioOutputDeviceGuidOculus},
+    {"xrGetBodySkeletonFB", xrGetBodySkeletonFB},
+    {"xrGetBodySkeletonHTC", xrGetBodySkeletonHTC},
+    {"xrGetControllerModelKeyMSFT", xrGetControllerModelKeyMSFT},
+    {"xrGetControllerModelPropertiesMSFT", xrGetControllerModelPropertiesMSFT},
+    {"xrGetControllerModelStateMSFT", xrGetControllerModelStateMSFT},
+    {"xrGetCurrentInteractionProfile", xrGetCurrentInteractionProfile},
+    {"xrGetD3D11GraphicsRequirementsKHR", xrGetD3D11GraphicsRequirementsKHR},
+    {"xrGetD3D12GraphicsRequirementsKHR", xrGetD3D12GraphicsRequirementsKHR},
+    {"xrGetDeviceSampleRateFB", xrGetDeviceSampleRateFB},
+    {"xrGetDisplayRefreshRateFB", xrGetDisplayRefreshRateFB},
+    {"xrGetEnvironmentDepthSwapchainStateMETA", xrGetEnvironmentDepthSwapchainStateMETA},
+    {"xrGetExportedLocalizationMapDataML", xrGetExportedLocalizationMapDataML},
+    {"xrGetEyeGazesFB", xrGetEyeGazesFB},
+    {"xrGetFaceExpressionWeights2FB", xrGetFaceExpressionWeights2FB},
+    {"xrGetFaceExpressionWeightsFB", xrGetFaceExpressionWeightsFB},
+    {"xrGetFacialExpressionBlendShapePropertiesML", xrGetFacialExpressionBlendShapePropertiesML},
+    {"xrGetFacialExpressionsHTC", xrGetFacialExpressionsHTC},
+    {"xrGetFoveationEyeTrackedStateMETA", xrGetFoveationEyeTrackedStateMETA},
+    {"xrGetHandMeshFB", xrGetHandMeshFB},
+    {"xrGetInputSourceLocalizedName", xrGetInputSourceLocalizedName},
+    {"xrGetInstanceProcAddr", xrGetInstanceProcAddr},
+    {"xrGetInstanceProperties", xrGetInstanceProperties},
+    {"xrGetMarkerDetectorStateML", xrGetMarkerDetectorStateML},
+    {"xrGetMarkerLengthML", xrGetMarkerLengthML},
+    {"xrGetMarkerNumberML", xrGetMarkerNumberML},
+    {"xrGetMarkerReprojectionErrorML", xrGetMarkerReprojectionErrorML},
+    {"xrGetMarkerSizeVARJO", xrGetMarkerSizeVARJO},
+    {"xrGetMarkerStringML", xrGetMarkerStringML},
+    {"xrGetMarkersML", xrGetMarkersML},
+    {"xrGetOpenGLGraphicsRequirementsKHR", xrGetOpenGLGraphicsRequirementsKHR},
+    {"xrGetPassthroughCameraStateANDROID", xrGetPassthroughCameraStateANDROID},
+    {"xrGetPassthroughPreferencesMETA", xrGetPassthroughPreferencesMETA},
+    {"xrGetPerformanceMetricsStateMETA", xrGetPerformanceMetricsStateMETA},
+    {"xrGetPlaneDetectionStateEXT", xrGetPlaneDetectionStateEXT},
+    {"xrGetPlaneDetectionsEXT", xrGetPlaneDetectionsEXT},
+    {"xrGetPlanePolygonBufferEXT", xrGetPlanePolygonBufferEXT},
+    {"xrGetQueriedSenseDataBD", xrGetQueriedSenseDataBD},
+    {"xrGetRecommendedLayerResolutionMETA", xrGetRecommendedLayerResolutionMETA},
+    {"xrGetReferenceSpaceBoundsRect", xrGetReferenceSpaceBoundsRect},
+    {"xrGetRenderModelAssetDataEXT", xrGetRenderModelAssetDataEXT},
+    {"xrGetRenderModelAssetPropertiesEXT", xrGetRenderModelAssetPropertiesEXT},
+    {"xrGetRenderModelPoseTopLevelUserPathEXT", xrGetRenderModelPoseTopLevelUserPathEXT},
+    {"xrGetRenderModelPropertiesEXT", xrGetRenderModelPropertiesEXT},
+    {"xrGetRenderModelPropertiesFB", xrGetRenderModelPropertiesFB},
+    {"xrGetRenderModelStateEXT", xrGetRenderModelStateEXT},
+    {"xrGetSceneComponentsMSFT", xrGetSceneComponentsMSFT},
+    {"xrGetSceneComputeStateMSFT", xrGetSceneComputeStateMSFT},
+    {"xrGetSceneMarkerDecodedStringMSFT", xrGetSceneMarkerDecodedStringMSFT},
+    {"xrGetSceneMarkerRawDataMSFT", xrGetSceneMarkerRawDataMSFT},
+    {"xrGetSceneMeshBuffersMSFT", xrGetSceneMeshBuffersMSFT},
+    {"xrGetSenseDataProviderStateBD", xrGetSenseDataProviderStateBD},
+    {"xrGetSerializedSceneFragmentDataMSFT", xrGetSerializedSceneFragmentDataMSFT},
+    {"xrGetSpaceBoundary2DFB", xrGetSpaceBoundary2DFB},
+    {"xrGetSpaceBoundingBox2DFB", xrGetSpaceBoundingBox2DFB},
+    {"xrGetSpaceBoundingBox3DFB", xrGetSpaceBoundingBox3DFB},
+    {"xrGetSpaceComponentStatusFB", xrGetSpaceComponentStatusFB},
+    {"xrGetSpaceContainerFB", xrGetSpaceContainerFB},
+    {"xrGetSpaceRoomLayoutFB", xrGetSpaceRoomLayoutFB},
+    {"xrGetSpaceSemanticLabelsFB", xrGetSpaceSemanticLabelsFB},
+    {"xrGetSpaceTriangleMeshMETA", xrGetSpaceTriangleMeshMETA},
+    {"xrGetSpaceUserIdFB", xrGetSpaceUserIdFB},
+    {"xrGetSpaceUuidFB", xrGetSpaceUuidFB},
+    {"xrGetSpatialAnchorNameHTC", xrGetSpatialAnchorNameHTC},
+    {"xrGetSpatialAnchorStateML", xrGetSpatialAnchorStateML},
+    {"xrGetSpatialBufferFloatEXT", xrGetSpatialBufferFloatEXT},
+    {"xrGetSpatialBufferStringEXT", xrGetSpatialBufferStringEXT},
+    {"xrGetSpatialBufferUint16EXT", xrGetSpatialBufferUint16EXT},
+    {"xrGetSpatialBufferUint32EXT", xrGetSpatialBufferUint32EXT},
+    {"xrGetSpatialBufferUint8EXT", xrGetSpatialBufferUint8EXT},
+    {"xrGetSpatialBufferVector2fEXT", xrGetSpatialBufferVector2fEXT},
+    {"xrGetSpatialBufferVector3fEXT", xrGetSpatialBufferVector3fEXT},
+    {"xrGetSpatialEntityComponentDataBD", xrGetSpatialEntityComponentDataBD},
+    {"xrGetSpatialEntityUuidBD", xrGetSpatialEntityUuidBD},
+    {"xrGetSpatialGraphNodeBindingPropertiesMSFT", xrGetSpatialGraphNodeBindingPropertiesMSFT},
+    {"xrGetSwapchainStateFB", xrGetSwapchainStateFB},
+    {"xrGetSystem", xrGetSystem},
+    {"xrGetSystemProperties", xrGetSystemProperties},
+    {"xrGetTrackableMarkerANDROID", xrGetTrackableMarkerANDROID},
+    {"xrGetTrackableObjectANDROID", xrGetTrackableObjectANDROID},
+    {"xrGetTrackablePlaneANDROID", xrGetTrackablePlaneANDROID},
+    {"xrGetViewConfigurationProperties", xrGetViewConfigurationProperties},
+    {"xrGetVirtualKeyboardDirtyTexturesMETA", xrGetVirtualKeyboardDirtyTexturesMETA},
+    {"xrGetVirtualKeyboardModelAnimationStatesMETA", xrGetVirtualKeyboardModelAnimationStatesMETA},
+    {"xrGetVirtualKeyboardScaleMETA", xrGetVirtualKeyboardScaleMETA},
+    {"xrGetVirtualKeyboardTextureDataMETA", xrGetVirtualKeyboardTextureDataMETA},
+    {"xrGetVisibilityMaskKHR", xrGetVisibilityMaskKHR},
+    {"xrGetVulkanDeviceExtensionsKHR", xrGetVulkanDeviceExtensionsKHR},
+    {"xrGetVulkanGraphicsDevice2KHR", xrGetVulkanGraphicsDevice2KHR},
+    {"xrGetVulkanGraphicsDeviceKHR", xrGetVulkanGraphicsDeviceKHR},
+    {"xrGetVulkanGraphicsRequirements2KHR", xrGetVulkanGraphicsRequirements2KHR},
+    {"xrGetVulkanGraphicsRequirementsKHR", xrGetVulkanGraphicsRequirementsKHR},
+    {"xrGetVulkanInstanceExtensionsKHR", xrGetVulkanInstanceExtensionsKHR},
+    {"xrGetWorldMeshBufferRecommendSizeML", xrGetWorldMeshBufferRecommendSizeML},
+    {"xrImportLocalizationMapML", xrImportLocalizationMapML},
+    {"xrLoadControllerModelMSFT", xrLoadControllerModelMSFT},
+    {"xrLoadRenderModelFB", xrLoadRenderModelFB},
+    {"xrLocateBodyJointsBD", xrLocateBodyJointsBD},
+    {"xrLocateBodyJointsFB", xrLocateBodyJointsFB},
+    {"xrLocateBodyJointsHTC", xrLocateBodyJointsHTC},
+    {"xrLocateHandJointsEXT", xrLocateHandJointsEXT},
+    {"xrLocateSceneComponentsMSFT", xrLocateSceneComponentsMSFT},
+    {"xrLocateSpace", xrLocateSpace},
+    {"xrLocateSpaces", xrLocateSpaces},
+    {"xrLocateSpacesKHR", xrLocateSpacesKHR},
+    {"xrLocateViews", xrLocateViews},
+    {"xrNegotiateLoaderRuntimeInterface", xrNegotiateLoaderRuntimeInterface},
+    {"xrPassthroughLayerPauseFB", xrPassthroughLayerPauseFB},
+    {"xrPassthroughLayerResumeFB", xrPassthroughLayerResumeFB},
+    {"xrPassthroughLayerSetKeyboardHandsIntensityFB", xrPassthroughLayerSetKeyboardHandsIntensityFB},
+    {"xrPassthroughLayerSetStyleFB", xrPassthroughLayerSetStyleFB},
+    {"xrPassthroughPauseFB", xrPassthroughPauseFB},
+    {"xrPassthroughStartFB", xrPassthroughStartFB},
+    {"xrPathToString", xrPathToString},
+    {"xrPauseSimultaneousHandsAndControllersTrackingMETA", xrPauseSimultaneousHandsAndControllersTrackingMETA},
+    {"xrPerfSettingsSetPerformanceLevelEXT", xrPerfSettingsSetPerformanceLevelEXT},
+    {"xrPersistAnchorANDROID", xrPersistAnchorANDROID},
+    {"xrPersistSpatialAnchorAsyncBD", xrPersistSpatialAnchorAsyncBD},
+    {"xrPersistSpatialAnchorCompleteBD", xrPersistSpatialAnchorCompleteBD},
+    {"xrPersistSpatialAnchorMSFT", xrPersistSpatialAnchorMSFT},
+    {"xrPersistSpatialEntityAsyncEXT", xrPersistSpatialEntityAsyncEXT},
+    {"xrPersistSpatialEntityCompleteEXT", xrPersistSpatialEntityCompleteEXT},
+    {"xrPollEvent", xrPollEvent},
+    {"xrPollFutureEXT", xrPollFutureEXT},
+    {"xrPublishSpatialAnchorsAsyncML", xrPublishSpatialAnchorsAsyncML},
+    {"xrPublishSpatialAnchorsCompleteML", xrPublishSpatialAnchorsCompleteML},
+    {"xrQueryLocalizationMapsML", xrQueryLocalizationMapsML},
+    {"xrQueryPerformanceMetricsCounterMETA", xrQueryPerformanceMetricsCounterMETA},
+    {"xrQuerySenseDataAsyncBD", xrQuerySenseDataAsyncBD},
+    {"xrQuerySenseDataCompleteBD", xrQuerySenseDataCompleteBD},
+    {"xrQuerySpacesFB", xrQuerySpacesFB},
+    {"xrQuerySpatialAnchorsAsyncML", xrQuerySpatialAnchorsAsyncML},
+    {"xrQuerySpatialAnchorsCompleteML", xrQuerySpatialAnchorsCompleteML},
+    {"xrQuerySpatialComponentDataEXT", xrQuerySpatialComponentDataEXT},
+    {"xrQuerySystemTrackedKeyboardFB", xrQuerySystemTrackedKeyboardFB},
+    {"xrRaycastANDROID", xrRaycastANDROID},
+    {"xrReleaseSwapchainImage", xrReleaseSwapchainImage},
+    {"xrRequestDisplayRefreshRateFB", xrRequestDisplayRefreshRateFB},
+    {"xrRequestExitSession", xrRequestExitSession},
+    {"xrRequestMapLocalizationML", xrRequestMapLocalizationML},
+    {"xrRequestSceneCaptureFB", xrRequestSceneCaptureFB},
+    {"xrRequestWorldMeshAsyncML", xrRequestWorldMeshAsyncML},
+    {"xrRequestWorldMeshCompleteML", xrRequestWorldMeshCompleteML},
+    {"xrRequestWorldMeshStateAsyncML", xrRequestWorldMeshStateAsyncML},
+    {"xrRequestWorldMeshStateCompleteML", xrRequestWorldMeshStateCompleteML},
+    {"xrResetBodyTrackingCalibrationMETA", xrResetBodyTrackingCalibrationMETA},
+    {"xrResultToString", xrResultToString},
+    {"xrResumeSimultaneousHandsAndControllersTrackingMETA", xrResumeSimultaneousHandsAndControllersTrackingMETA},
+    {"xrRetrieveSpaceDiscoveryResultsMETA", xrRetrieveSpaceDiscoveryResultsMETA},
+    {"xrRetrieveSpaceQueryResultsFB", xrRetrieveSpaceQueryResultsFB},
+    {"xrSaveSpaceFB", xrSaveSpaceFB},
+    {"xrSaveSpaceListFB", xrSaveSpaceListFB},
+    {"xrSaveSpacesMETA", xrSaveSpacesMETA},
+    {"xrSendVirtualKeyboardInputMETA", xrSendVirtualKeyboardInputMETA},
+    {"xrSetColorSpaceFB", xrSetColorSpaceFB},
+    {"xrSetDigitalLensControlALMALENCE", xrSetDigitalLensControlALMALENCE},
+    {"xrSetEnvironmentDepthEstimationVARJO", xrSetEnvironmentDepthEstimationVARJO},
+    {"xrSetEnvironmentDepthHandRemovalMETA", xrSetEnvironmentDepthHandRemovalMETA},
+    {"xrSetInputDeviceActiveEXT", xrSetInputDeviceActiveEXT},
+    {"xrSetInputDeviceLocationEXT", xrSetInputDeviceLocationEXT},
+    {"xrSetInputDeviceStateBoolEXT", xrSetInputDeviceStateBoolEXT},
+    {"xrSetInputDeviceStateFloatEXT", xrSetInputDeviceStateFloatEXT},
+    {"xrSetInputDeviceStateVector2fEXT", xrSetInputDeviceStateVector2fEXT},
+    {"xrSetMarkerTrackingPredictionVARJO", xrSetMarkerTrackingPredictionVARJO},
+    {"xrSetMarkerTrackingTimeoutVARJO", xrSetMarkerTrackingTimeoutVARJO},
+    {"xrSetMarkerTrackingVARJO", xrSetMarkerTrackingVARJO},
+    {"xrSetPerformanceMetricsStateMETA", xrSetPerformanceMetricsStateMETA},
+    {"xrSetSpaceComponentStatusFB", xrSetSpaceComponentStatusFB},
+    {"xrSetSystemNotificationsML", xrSetSystemNotificationsML},
+    {"xrSetTrackingOptimizationSettingsHintQCOM", xrSetTrackingOptimizationSettingsHintQCOM},
+    {"xrSetViewOffsetVARJO", xrSetViewOffsetVARJO},
+    {"xrSetVirtualKeyboardModelVisibilityMETA", xrSetVirtualKeyboardModelVisibilityMETA},
+    {"xrShareSpacesFB", xrShareSpacesFB},
+    {"xrShareSpacesMETA", xrShareSpacesMETA},
+    {"xrShareSpatialAnchorAsyncBD", xrShareSpatialAnchorAsyncBD},
+    {"xrShareSpatialAnchorCompleteBD", xrShareSpatialAnchorCompleteBD},
+    {"xrSnapshotMarkerDetectorML", xrSnapshotMarkerDetectorML},
+    {"xrStartColocationAdvertisementMETA", xrStartColocationAdvertisementMETA},
+    {"xrStartColocationDiscoveryMETA", xrStartColocationDiscoveryMETA},
+    {"xrStartEnvironmentDepthProviderMETA", xrStartEnvironmentDepthProviderMETA},
+    {"xrStartSenseDataProviderAsyncBD", xrStartSenseDataProviderAsyncBD},
+    {"xrStartSenseDataProviderCompleteBD", xrStartSenseDataProviderCompleteBD},
+    {"xrStopColocationAdvertisementMETA", xrStopColocationAdvertisementMETA},
+    {"xrStopColocationDiscoveryMETA", xrStopColocationDiscoveryMETA},
+    {"xrStopEnvironmentDepthProviderMETA", xrStopEnvironmentDepthProviderMETA},
+    {"xrStopHapticFeedback", xrStopHapticFeedback},
+    {"xrStopSenseDataProviderBD", xrStopSenseDataProviderBD},
+    {"xrStringToPath", xrStringToPath},
+    {"xrStructureTypeToString", xrStructureTypeToString},
+    {"xrStructureTypeToString2KHR", xrStructureTypeToString2KHR},
+    {"xrSuggestBodyTrackingCalibrationOverrideMETA", xrSuggestBodyTrackingCalibrationOverrideMETA},
+    {"xrSuggestInteractionProfileBindings", xrSuggestInteractionProfileBindings},
+    {"xrSuggestVirtualKeyboardLocationMETA", xrSuggestVirtualKeyboardLocationMETA},
+    {"xrSyncActions", xrSyncActions},
+    {"xrThermalGetTemperatureTrendEXT", xrThermalGetTemperatureTrendEXT},
+    {"xrTriangleMeshBeginUpdateFB", xrTriangleMeshBeginUpdateFB},
+    {"xrTriangleMeshBeginVertexBufferUpdateFB", xrTriangleMeshBeginVertexBufferUpdateFB},
+    {"xrTriangleMeshEndUpdateFB", xrTriangleMeshEndUpdateFB},
+    {"xrTriangleMeshEndVertexBufferUpdateFB", xrTriangleMeshEndVertexBufferUpdateFB},
+    {"xrTriangleMeshGetIndexBufferFB", xrTriangleMeshGetIndexBufferFB},
+    {"xrTriangleMeshGetVertexBufferFB", xrTriangleMeshGetVertexBufferFB},
+    {"xrTryCreateSpatialGraphStaticNodeBindingMSFT", xrTryCreateSpatialGraphStaticNodeBindingMSFT},
+    {"xrUnpersistAnchorANDROID", xrUnpersistAnchorANDROID},
+    {"xrUnpersistSpatialAnchorAsyncBD", xrUnpersistSpatialAnchorAsyncBD},
+    {"xrUnpersistSpatialAnchorCompleteBD", xrUnpersistSpatialAnchorCompleteBD},
+    {"xrUnpersistSpatialAnchorMSFT", xrUnpersistSpatialAnchorMSFT},
+    {"xrUnpersistSpatialEntityAsyncEXT", xrUnpersistSpatialEntityAsyncEXT},
+    {"xrUnpersistSpatialEntityCompleteEXT", xrUnpersistSpatialEntityCompleteEXT},
+    {"xrUpdateHandMeshMSFT", xrUpdateHandMeshMSFT},
+    {"xrUpdatePassthroughColorLutMETA", xrUpdatePassthroughColorLutMETA},
+    {"xrUpdateSpatialAnchorsExpirationAsyncML", xrUpdateSpatialAnchorsExpirationAsyncML},
+    {"xrUpdateSpatialAnchorsExpirationCompleteML", xrUpdateSpatialAnchorsExpirationCompleteML},
+    {"xrUpdateSwapchainFB", xrUpdateSwapchainFB},
+    {"xrWaitFrame", xrWaitFrame},
+    {"xrWaitSwapchainImage", xrWaitSwapchainImage},
+};
+
+void *wine_xr_get_instance_proc_addr(const char *name)
+{
+    unsigned int i;
+    for (i = 0; i < ARRAY_SIZE(xr_instance_dispatch_table); i++)
+    {
+        if (strcmp(xr_instance_dispatch_table[i].name, name) == 0)
+        {
+            TRACE("Found name=%s in instance table\n", debugstr_a(name));
+            return xr_instance_dispatch_table[i].func;
+        }
+    }
+    return NULL;
+}
diff --git a/dlls/wineopenxr/loader_thunks.h b/dlls/wineopenxr/loader_thunks.h
new file mode 100644
index 00000000000..52aec91c897
--- /dev/null
+++ b/dlls/wineopenxr/loader_thunks.h
@@ -0,0 +1,3517 @@
+/* Automatically generated from Vulkan xr.xml; DO NOT EDIT!
+ *
+ * This file is generated from Vulkan xr.xml file covered
+ * by the following copyright and permission notice:
+ *
+ * Copyright (c) 2017-2025 The Khronos Group Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0 OR MIT
+ *
+ * ------------------------------------------------------------------------
+ *
+ * This file, xr.xml, is the OpenXR API Registry. It is a critically important
+ * and normative part of the OpenXR Specification, including a canonical
+ * machine-readable definition of the API, parameter and member validation
+ * language incorporated into the Specification and reference pages, and other
+ * material which is registered by Khronos, such as tags used by extension and
+ * layer authors. The only authoritative version of xr.xml is the one
+ * maintained in the default branch of the Khronos OpenXR GitHub project.
+ *
+ */
+
+#ifndef __WINE_OPENXR_LOADER_THUNKS_H
+#define __WINE_OPENXR_LOADER_THUNKS_H
+
+enum unix_call
+{
+    unix_init,
+    unix_is_available_instance_function,
+    unix_xrAcquireEnvironmentDepthImageMETA,
+    unix_xrAcquireSwapchainImage,
+    unix_xrAllocateWorldMeshBufferML,
+    unix_xrApplyForceFeedbackCurlMNDX,
+    unix_xrApplyHapticFeedback,
+    unix_xrAttachSessionActionSets,
+    unix_xrBeginFrame,
+    unix_xrBeginPlaneDetectionEXT,
+    unix_xrBeginSession,
+    unix_xrCancelFutureEXT,
+    unix_xrCaptureSceneAsyncBD,
+    unix_xrCaptureSceneCompleteBD,
+    unix_xrChangeVirtualKeyboardTextContextMETA,
+    unix_xrClearSpatialAnchorStoreMSFT,
+    unix_xrComputeNewSceneMSFT,
+    unix_xrCreateAction,
+    unix_xrCreateActionSet,
+    unix_xrCreateActionSpace,
+    unix_xrCreateAnchorSpaceANDROID,
+    unix_xrCreateAnchorSpaceBD,
+    unix_xrCreateBodyTrackerBD,
+    unix_xrCreateBodyTrackerFB,
+    unix_xrCreateBodyTrackerHTC,
+    unix_xrCreateDeviceAnchorPersistenceANDROID,
+    unix_xrCreateEnvironmentDepthProviderMETA,
+    unix_xrCreateEnvironmentDepthSwapchainMETA,
+    unix_xrCreateExportedLocalizationMapML,
+    unix_xrCreateEyeTrackerFB,
+    unix_xrCreateFaceTracker2FB,
+    unix_xrCreateFaceTrackerFB,
+    unix_xrCreateFacialExpressionClientML,
+    unix_xrCreateFacialTrackerHTC,
+    unix_xrCreateFoveationProfileFB,
+    unix_xrCreateGeometryInstanceFB,
+    unix_xrCreateHandMeshSpaceMSFT,
+    unix_xrCreateHandTrackerEXT,
+    unix_xrCreateInstance,
+    unix_xrCreateKeyboardSpaceFB,
+    unix_xrCreateMarkerDetectorML,
+    unix_xrCreateMarkerSpaceML,
+    unix_xrCreateMarkerSpaceVARJO,
+    unix_xrCreatePassthroughColorLutMETA,
+    unix_xrCreatePassthroughFB,
+    unix_xrCreatePassthroughHTC,
+    unix_xrCreatePassthroughLayerFB,
+    unix_xrCreatePersistedAnchorSpaceANDROID,
+    unix_xrCreatePlaneDetectorEXT,
+    unix_xrCreateReferenceSpace,
+    unix_xrCreateRenderModelAssetEXT,
+    unix_xrCreateRenderModelEXT,
+    unix_xrCreateRenderModelSpaceEXT,
+    unix_xrCreateSceneMSFT,
+    unix_xrCreateSceneObserverMSFT,
+    unix_xrCreateSenseDataProviderBD,
+    unix_xrCreateSession,
+    unix_xrCreateSpaceUserFB,
+    unix_xrCreateSpatialAnchorAsyncBD,
+    unix_xrCreateSpatialAnchorCompleteBD,
+    unix_xrCreateSpatialAnchorEXT,
+    unix_xrCreateSpatialAnchorFB,
+    unix_xrCreateSpatialAnchorFromPersistedNameMSFT,
+    unix_xrCreateSpatialAnchorHTC,
+    unix_xrCreateSpatialAnchorMSFT,
+    unix_xrCreateSpatialAnchorSpaceMSFT,
+    unix_xrCreateSpatialAnchorStoreConnectionMSFT,
+    unix_xrCreateSpatialAnchorsAsyncML,
+    unix_xrCreateSpatialAnchorsCompleteML,
+    unix_xrCreateSpatialAnchorsStorageML,
+    unix_xrCreateSpatialContextAsyncEXT,
+    unix_xrCreateSpatialContextCompleteEXT,
+    unix_xrCreateSpatialDiscoverySnapshotAsyncEXT,
+    unix_xrCreateSpatialDiscoverySnapshotCompleteEXT,
+    unix_xrCreateSpatialEntityAnchorBD,
+    unix_xrCreateSpatialEntityFromIdEXT,
+    unix_xrCreateSpatialGraphNodeSpaceMSFT,
+    unix_xrCreateSpatialPersistenceContextAsyncEXT,
+    unix_xrCreateSpatialPersistenceContextCompleteEXT,
+    unix_xrCreateSpatialUpdateSnapshotEXT,
+    unix_xrCreateSwapchain,
+    unix_xrCreateTrackableTrackerANDROID,
+    unix_xrCreateTriangleMeshFB,
+    unix_xrCreateVirtualKeyboardMETA,
+    unix_xrCreateVirtualKeyboardSpaceMETA,
+    unix_xrCreateWorldMeshDetectorML,
+    unix_xrDeleteSpatialAnchorsAsyncML,
+    unix_xrDeleteSpatialAnchorsCompleteML,
+    unix_xrDeserializeSceneMSFT,
+    unix_xrDestroyAction,
+    unix_xrDestroyActionSet,
+    unix_xrDestroyAnchorBD,
+    unix_xrDestroyBodyTrackerBD,
+    unix_xrDestroyBodyTrackerFB,
+    unix_xrDestroyBodyTrackerHTC,
+    unix_xrDestroyDeviceAnchorPersistenceANDROID,
+    unix_xrDestroyEnvironmentDepthProviderMETA,
+    unix_xrDestroyEnvironmentDepthSwapchainMETA,
+    unix_xrDestroyExportedLocalizationMapML,
+    unix_xrDestroyEyeTrackerFB,
+    unix_xrDestroyFaceTracker2FB,
+    unix_xrDestroyFaceTrackerFB,
+    unix_xrDestroyFacialExpressionClientML,
+    unix_xrDestroyFacialTrackerHTC,
+    unix_xrDestroyFoveationProfileFB,
+    unix_xrDestroyGeometryInstanceFB,
+    unix_xrDestroyHandTrackerEXT,
+    unix_xrDestroyInstance,
+    unix_xrDestroyMarkerDetectorML,
+    unix_xrDestroyPassthroughColorLutMETA,
+    unix_xrDestroyPassthroughFB,
+    unix_xrDestroyPassthroughHTC,
+    unix_xrDestroyPassthroughLayerFB,
+    unix_xrDestroyPlaneDetectorEXT,
+    unix_xrDestroyRenderModelAssetEXT,
+    unix_xrDestroyRenderModelEXT,
+    unix_xrDestroySceneMSFT,
+    unix_xrDestroySceneObserverMSFT,
+    unix_xrDestroySenseDataProviderBD,
+    unix_xrDestroySenseDataSnapshotBD,
+    unix_xrDestroySession,
+    unix_xrDestroySpace,
+    unix_xrDestroySpaceUserFB,
+    unix_xrDestroySpatialAnchorMSFT,
+    unix_xrDestroySpatialAnchorStoreConnectionMSFT,
+    unix_xrDestroySpatialAnchorsStorageML,
+    unix_xrDestroySpatialContextEXT,
+    unix_xrDestroySpatialEntityEXT,
+    unix_xrDestroySpatialGraphNodeBindingMSFT,
+    unix_xrDestroySpatialPersistenceContextEXT,
+    unix_xrDestroySpatialSnapshotEXT,
+    unix_xrDestroySwapchain,
+    unix_xrDestroyTrackableTrackerANDROID,
+    unix_xrDestroyTriangleMeshFB,
+    unix_xrDestroyVirtualKeyboardMETA,
+    unix_xrDestroyWorldMeshDetectorML,
+    unix_xrDiscoverSpacesMETA,
+    unix_xrDownloadSharedSpatialAnchorAsyncBD,
+    unix_xrDownloadSharedSpatialAnchorCompleteBD,
+    unix_xrEnableLocalizationEventsML,
+    unix_xrEnableUserCalibrationEventsML,
+    unix_xrEndFrame,
+    unix_xrEndSession,
+    unix_xrEnumerateApiLayerProperties,
+    unix_xrEnumerateBoundSourcesForAction,
+    unix_xrEnumerateColorSpacesFB,
+    unix_xrEnumerateDisplayRefreshRatesFB,
+    unix_xrEnumerateEnvironmentBlendModes,
+    unix_xrEnumerateEnvironmentDepthSwapchainImagesMETA,
+    unix_xrEnumerateExternalCamerasOCULUS,
+    unix_xrEnumerateInstanceExtensionProperties,
+    unix_xrEnumerateInteractionRenderModelIdsEXT,
+    unix_xrEnumeratePerformanceMetricsCounterPathsMETA,
+    unix_xrEnumeratePersistedAnchorsANDROID,
+    unix_xrEnumeratePersistedSpatialAnchorNamesMSFT,
+    unix_xrEnumerateRaycastSupportedTrackableTypesANDROID,
+    unix_xrEnumerateReferenceSpaces,
+    unix_xrEnumerateRenderModelPathsFB,
+    unix_xrEnumerateRenderModelSubactionPathsEXT,
+    unix_xrEnumerateReprojectionModesMSFT,
+    unix_xrEnumerateSceneComputeFeaturesMSFT,
+    unix_xrEnumerateSpaceSupportedComponentsFB,
+    unix_xrEnumerateSpatialCapabilitiesEXT,
+    unix_xrEnumerateSpatialCapabilityComponentTypesEXT,
+    unix_xrEnumerateSpatialCapabilityFeaturesEXT,
+    unix_xrEnumerateSpatialEntityComponentTypesBD,
+    unix_xrEnumerateSpatialPersistenceScopesEXT,
+    unix_xrEnumerateSupportedAnchorTrackableTypesANDROID,
+    unix_xrEnumerateSupportedPersistenceAnchorTypesANDROID,
+    unix_xrEnumerateSupportedTrackableTypesANDROID,
+    unix_xrEnumerateSwapchainFormats,
+    unix_xrEnumerateSwapchainImages,
+    unix_xrEnumerateViewConfigurationViews,
+    unix_xrEnumerateViewConfigurations,
+    unix_xrEnumerateViveTrackerPathsHTCX,
+    unix_xrEraseSpaceFB,
+    unix_xrEraseSpacesMETA,
+    unix_xrFreeWorldMeshBufferML,
+    unix_xrGeometryInstanceSetTransformFB,
+    unix_xrGetActionStateBoolean,
+    unix_xrGetActionStateFloat,
+    unix_xrGetActionStatePose,
+    unix_xrGetActionStateVector2f,
+    unix_xrGetAllTrackablesANDROID,
+    unix_xrGetAnchorPersistStateANDROID,
+    unix_xrGetAnchorUuidBD,
+    unix_xrGetAudioInputDeviceGuidOculus,
+    unix_xrGetAudioOutputDeviceGuidOculus,
+    unix_xrGetBodySkeletonFB,
+    unix_xrGetBodySkeletonHTC,
+    unix_xrGetControllerModelKeyMSFT,
+    unix_xrGetControllerModelPropertiesMSFT,
+    unix_xrGetControllerModelStateMSFT,
+    unix_xrGetCurrentInteractionProfile,
+    unix_xrGetDeviceSampleRateFB,
+    unix_xrGetDisplayRefreshRateFB,
+    unix_xrGetEnvironmentDepthSwapchainStateMETA,
+    unix_xrGetExportedLocalizationMapDataML,
+    unix_xrGetEyeGazesFB,
+    unix_xrGetFaceExpressionWeights2FB,
+    unix_xrGetFaceExpressionWeightsFB,
+    unix_xrGetFacialExpressionBlendShapePropertiesML,
+    unix_xrGetFacialExpressionsHTC,
+    unix_xrGetFoveationEyeTrackedStateMETA,
+    unix_xrGetHandMeshFB,
+    unix_xrGetInputSourceLocalizedName,
+    unix_xrGetInstanceProperties,
+    unix_xrGetMarkerDetectorStateML,
+    unix_xrGetMarkerLengthML,
+    unix_xrGetMarkerNumberML,
+    unix_xrGetMarkerReprojectionErrorML,
+    unix_xrGetMarkerSizeVARJO,
+    unix_xrGetMarkerStringML,
+    unix_xrGetMarkersML,
+    unix_xrGetOpenGLGraphicsRequirementsKHR,
+    unix_xrGetPassthroughCameraStateANDROID,
+    unix_xrGetPassthroughPreferencesMETA,
+    unix_xrGetPerformanceMetricsStateMETA,
+    unix_xrGetPlaneDetectionStateEXT,
+    unix_xrGetPlaneDetectionsEXT,
+    unix_xrGetPlanePolygonBufferEXT,
+    unix_xrGetQueriedSenseDataBD,
+    unix_xrGetRecommendedLayerResolutionMETA,
+    unix_xrGetReferenceSpaceBoundsRect,
+    unix_xrGetRenderModelAssetDataEXT,
+    unix_xrGetRenderModelAssetPropertiesEXT,
+    unix_xrGetRenderModelPoseTopLevelUserPathEXT,
+    unix_xrGetRenderModelPropertiesEXT,
+    unix_xrGetRenderModelPropertiesFB,
+    unix_xrGetRenderModelStateEXT,
+    unix_xrGetSceneComponentsMSFT,
+    unix_xrGetSceneComputeStateMSFT,
+    unix_xrGetSceneMarkerDecodedStringMSFT,
+    unix_xrGetSceneMarkerRawDataMSFT,
+    unix_xrGetSceneMeshBuffersMSFT,
+    unix_xrGetSenseDataProviderStateBD,
+    unix_xrGetSerializedSceneFragmentDataMSFT,
+    unix_xrGetSpaceBoundary2DFB,
+    unix_xrGetSpaceBoundingBox2DFB,
+    unix_xrGetSpaceBoundingBox3DFB,
+    unix_xrGetSpaceComponentStatusFB,
+    unix_xrGetSpaceContainerFB,
+    unix_xrGetSpaceRoomLayoutFB,
+    unix_xrGetSpaceSemanticLabelsFB,
+    unix_xrGetSpaceTriangleMeshMETA,
+    unix_xrGetSpaceUserIdFB,
+    unix_xrGetSpaceUuidFB,
+    unix_xrGetSpatialAnchorNameHTC,
+    unix_xrGetSpatialAnchorStateML,
+    unix_xrGetSpatialBufferFloatEXT,
+    unix_xrGetSpatialBufferStringEXT,
+    unix_xrGetSpatialBufferUint16EXT,
+    unix_xrGetSpatialBufferUint32EXT,
+    unix_xrGetSpatialBufferUint8EXT,
+    unix_xrGetSpatialBufferVector2fEXT,
+    unix_xrGetSpatialBufferVector3fEXT,
+    unix_xrGetSpatialEntityComponentDataBD,
+    unix_xrGetSpatialEntityUuidBD,
+    unix_xrGetSpatialGraphNodeBindingPropertiesMSFT,
+    unix_xrGetSwapchainStateFB,
+    unix_xrGetSystem,
+    unix_xrGetSystemProperties,
+    unix_xrGetTrackableMarkerANDROID,
+    unix_xrGetTrackableObjectANDROID,
+    unix_xrGetTrackablePlaneANDROID,
+    unix_xrGetViewConfigurationProperties,
+    unix_xrGetVirtualKeyboardDirtyTexturesMETA,
+    unix_xrGetVirtualKeyboardModelAnimationStatesMETA,
+    unix_xrGetVirtualKeyboardScaleMETA,
+    unix_xrGetVirtualKeyboardTextureDataMETA,
+    unix_xrGetVisibilityMaskKHR,
+    unix_xrGetVulkanDeviceExtensionsKHR,
+    unix_xrGetVulkanGraphicsDevice2KHR,
+    unix_xrGetVulkanGraphicsDeviceKHR,
+    unix_xrGetVulkanGraphicsRequirements2KHR,
+    unix_xrGetVulkanGraphicsRequirementsKHR,
+    unix_xrGetVulkanInstanceExtensionsKHR,
+    unix_xrGetWorldMeshBufferRecommendSizeML,
+    unix_xrImportLocalizationMapML,
+    unix_xrLoadControllerModelMSFT,
+    unix_xrLoadRenderModelFB,
+    unix_xrLocateBodyJointsBD,
+    unix_xrLocateBodyJointsFB,
+    unix_xrLocateBodyJointsHTC,
+    unix_xrLocateHandJointsEXT,
+    unix_xrLocateSceneComponentsMSFT,
+    unix_xrLocateSpace,
+    unix_xrLocateSpaces,
+    unix_xrLocateSpacesKHR,
+    unix_xrLocateViews,
+    unix_xrPassthroughLayerPauseFB,
+    unix_xrPassthroughLayerResumeFB,
+    unix_xrPassthroughLayerSetKeyboardHandsIntensityFB,
+    unix_xrPassthroughLayerSetStyleFB,
+    unix_xrPassthroughPauseFB,
+    unix_xrPassthroughStartFB,
+    unix_xrPathToString,
+    unix_xrPauseSimultaneousHandsAndControllersTrackingMETA,
+    unix_xrPerfSettingsSetPerformanceLevelEXT,
+    unix_xrPersistAnchorANDROID,
+    unix_xrPersistSpatialAnchorAsyncBD,
+    unix_xrPersistSpatialAnchorCompleteBD,
+    unix_xrPersistSpatialAnchorMSFT,
+    unix_xrPersistSpatialEntityAsyncEXT,
+    unix_xrPersistSpatialEntityCompleteEXT,
+    unix_xrPollEvent,
+    unix_xrPollFutureEXT,
+    unix_xrPublishSpatialAnchorsAsyncML,
+    unix_xrPublishSpatialAnchorsCompleteML,
+    unix_xrQueryLocalizationMapsML,
+    unix_xrQueryPerformanceMetricsCounterMETA,
+    unix_xrQuerySenseDataAsyncBD,
+    unix_xrQuerySenseDataCompleteBD,
+    unix_xrQuerySpacesFB,
+    unix_xrQuerySpatialAnchorsAsyncML,
+    unix_xrQuerySpatialAnchorsCompleteML,
+    unix_xrQuerySpatialComponentDataEXT,
+    unix_xrQuerySystemTrackedKeyboardFB,
+    unix_xrRaycastANDROID,
+    unix_xrReleaseSwapchainImage,
+    unix_xrRequestDisplayRefreshRateFB,
+    unix_xrRequestExitSession,
+    unix_xrRequestMapLocalizationML,
+    unix_xrRequestSceneCaptureFB,
+    unix_xrRequestWorldMeshAsyncML,
+    unix_xrRequestWorldMeshCompleteML,
+    unix_xrRequestWorldMeshStateAsyncML,
+    unix_xrRequestWorldMeshStateCompleteML,
+    unix_xrResetBodyTrackingCalibrationMETA,
+    unix_xrResultToString,
+    unix_xrResumeSimultaneousHandsAndControllersTrackingMETA,
+    unix_xrRetrieveSpaceDiscoveryResultsMETA,
+    unix_xrRetrieveSpaceQueryResultsFB,
+    unix_xrSaveSpaceFB,
+    unix_xrSaveSpaceListFB,
+    unix_xrSaveSpacesMETA,
+    unix_xrSendVirtualKeyboardInputMETA,
+    unix_xrSetColorSpaceFB,
+    unix_xrSetDigitalLensControlALMALENCE,
+    unix_xrSetEnvironmentDepthEstimationVARJO,
+    unix_xrSetEnvironmentDepthHandRemovalMETA,
+    unix_xrSetInputDeviceActiveEXT,
+    unix_xrSetInputDeviceLocationEXT,
+    unix_xrSetInputDeviceStateBoolEXT,
+    unix_xrSetInputDeviceStateFloatEXT,
+    unix_xrSetInputDeviceStateVector2fEXT,
+    unix_xrSetMarkerTrackingPredictionVARJO,
+    unix_xrSetMarkerTrackingTimeoutVARJO,
+    unix_xrSetMarkerTrackingVARJO,
+    unix_xrSetPerformanceMetricsStateMETA,
+    unix_xrSetSpaceComponentStatusFB,
+    unix_xrSetSystemNotificationsML,
+    unix_xrSetTrackingOptimizationSettingsHintQCOM,
+    unix_xrSetViewOffsetVARJO,
+    unix_xrSetVirtualKeyboardModelVisibilityMETA,
+    unix_xrShareSpacesFB,
+    unix_xrShareSpacesMETA,
+    unix_xrShareSpatialAnchorAsyncBD,
+    unix_xrShareSpatialAnchorCompleteBD,
+    unix_xrSnapshotMarkerDetectorML,
+    unix_xrStartColocationAdvertisementMETA,
+    unix_xrStartColocationDiscoveryMETA,
+    unix_xrStartEnvironmentDepthProviderMETA,
+    unix_xrStartSenseDataProviderAsyncBD,
+    unix_xrStartSenseDataProviderCompleteBD,
+    unix_xrStopColocationAdvertisementMETA,
+    unix_xrStopColocationDiscoveryMETA,
+    unix_xrStopEnvironmentDepthProviderMETA,
+    unix_xrStopHapticFeedback,
+    unix_xrStopSenseDataProviderBD,
+    unix_xrStringToPath,
+    unix_xrStructureTypeToString,
+    unix_xrStructureTypeToString2KHR,
+    unix_xrSuggestBodyTrackingCalibrationOverrideMETA,
+    unix_xrSuggestInteractionProfileBindings,
+    unix_xrSuggestVirtualKeyboardLocationMETA,
+    unix_xrSyncActions,
+    unix_xrThermalGetTemperatureTrendEXT,
+    unix_xrTriangleMeshBeginUpdateFB,
+    unix_xrTriangleMeshBeginVertexBufferUpdateFB,
+    unix_xrTriangleMeshEndUpdateFB,
+    unix_xrTriangleMeshEndVertexBufferUpdateFB,
+    unix_xrTriangleMeshGetIndexBufferFB,
+    unix_xrTriangleMeshGetVertexBufferFB,
+    unix_xrTryCreateSpatialGraphStaticNodeBindingMSFT,
+    unix_xrUnpersistAnchorANDROID,
+    unix_xrUnpersistSpatialAnchorAsyncBD,
+    unix_xrUnpersistSpatialAnchorCompleteBD,
+    unix_xrUnpersistSpatialAnchorMSFT,
+    unix_xrUnpersistSpatialEntityAsyncEXT,
+    unix_xrUnpersistSpatialEntityCompleteEXT,
+    unix_xrUpdateHandMeshMSFT,
+    unix_xrUpdatePassthroughColorLutMETA,
+    unix_xrUpdateSpatialAnchorsExpirationAsyncML,
+    unix_xrUpdateSpatialAnchorsExpirationCompleteML,
+    unix_xrUpdateSwapchainFB,
+    unix_xrWaitFrame,
+    unix_xrWaitSwapchainImage,
+    unix_count,
+};
+
+struct xrAcquireEnvironmentDepthImageMETA_params
+{
+    XrEnvironmentDepthProviderMETA environmentDepthProvider;
+    const XrEnvironmentDepthImageAcquireInfoMETA *acquireInfo;
+    XrEnvironmentDepthImageMETA *environmentDepthImage;
+    XrResult result;
+};
+
+struct xrAcquireSwapchainImage_params
+{
+    XrSwapchain swapchain;
+    const XrSwapchainImageAcquireInfo *acquireInfo;
+    uint32_t *index;
+    XrResult result;
+};
+
+struct xrAllocateWorldMeshBufferML_params
+{
+    XrWorldMeshDetectorML detector;
+    const XrWorldMeshBufferSizeML *size;
+    XrWorldMeshBufferML *buffer;
+    XrResult result;
+};
+
+struct xrApplyForceFeedbackCurlMNDX_params
+{
+    XrHandTrackerEXT handTracker;
+    const XrForceFeedbackCurlApplyLocationsMNDX *locations;
+    XrResult result;
+};
+
+struct xrApplyHapticFeedback_params
+{
+    XrSession session;
+    const XrHapticActionInfo *hapticActionInfo;
+    const XrHapticBaseHeader *hapticFeedback;
+    XrResult result;
+};
+
+struct xrAttachSessionActionSets_params
+{
+    XrSession session;
+    const XrSessionActionSetsAttachInfo *attachInfo;
+    XrResult result;
+};
+
+struct xrBeginFrame_params
+{
+    XrSession session;
+    const XrFrameBeginInfo *frameBeginInfo;
+    XrResult result;
+};
+
+struct xrBeginPlaneDetectionEXT_params
+{
+    XrPlaneDetectorEXT planeDetector;
+    const XrPlaneDetectorBeginInfoEXT *beginInfo;
+    XrResult result;
+};
+
+struct xrBeginSession_params
+{
+    XrSession session;
+    const XrSessionBeginInfo *beginInfo;
+    XrResult result;
+};
+
+struct xrCancelFutureEXT_params
+{
+    XrInstance instance;
+    const XrFutureCancelInfoEXT *cancelInfo;
+    XrResult result;
+};
+
+struct xrCaptureSceneAsyncBD_params
+{
+    XrSenseDataProviderBD provider;
+    const XrSceneCaptureInfoBD *info;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrCaptureSceneCompleteBD_params
+{
+    XrSenseDataProviderBD provider;
+    XrFutureEXT future;
+    XrFutureCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrChangeVirtualKeyboardTextContextMETA_params
+{
+    XrVirtualKeyboardMETA keyboard;
+    const XrVirtualKeyboardTextContextChangeInfoMETA *changeInfo;
+    XrResult result;
+};
+
+struct xrClearSpatialAnchorStoreMSFT_params
+{
+    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
+    XrResult result;
+};
+
+struct xrComputeNewSceneMSFT_params
+{
+    XrSceneObserverMSFT sceneObserver;
+    const XrNewSceneComputeInfoMSFT *computeInfo;
+    XrResult result;
+};
+
+struct xrCreateAction_params
+{
+    XrActionSet actionSet;
+    const XrActionCreateInfo *createInfo;
+    XrAction *action;
+    XrResult result;
+};
+
+struct xrCreateActionSet_params
+{
+    XrInstance instance;
+    const XrActionSetCreateInfo *createInfo;
+    XrActionSet *actionSet;
+    XrResult result;
+};
+
+struct xrCreateActionSpace_params
+{
+    XrSession session;
+    const XrActionSpaceCreateInfo *createInfo;
+    XrSpace *space;
+    XrResult result;
+};
+
+struct xrCreateAnchorSpaceANDROID_params
+{
+    XrSession session;
+    const XrAnchorSpaceCreateInfoANDROID *createInfo;
+    XrSpace *anchorOutput;
+    XrResult result;
+};
+
+struct xrCreateAnchorSpaceBD_params
+{
+    XrSession session;
+    const XrAnchorSpaceCreateInfoBD *createInfo;
+    XrSpace *space;
+    XrResult result;
+};
+
+struct xrCreateBodyTrackerBD_params
+{
+    XrSession session;
+    const XrBodyTrackerCreateInfoBD *createInfo;
+    XrBodyTrackerBD *bodyTracker;
+    XrResult result;
+};
+
+struct xrCreateBodyTrackerFB_params
+{
+    XrSession session;
+    const XrBodyTrackerCreateInfoFB *createInfo;
+    XrBodyTrackerFB *bodyTracker;
+    XrResult result;
+};
+
+struct xrCreateBodyTrackerHTC_params
+{
+    XrSession session;
+    const XrBodyTrackerCreateInfoHTC *createInfo;
+    XrBodyTrackerHTC *bodyTracker;
+    XrResult result;
+};
+
+struct xrCreateDeviceAnchorPersistenceANDROID_params
+{
+    XrSession session;
+    const XrDeviceAnchorPersistenceCreateInfoANDROID *createInfo;
+    XrDeviceAnchorPersistenceANDROID *outHandle;
+    XrResult result;
+};
+
+struct xrCreateEnvironmentDepthProviderMETA_params
+{
+    XrSession session;
+    const XrEnvironmentDepthProviderCreateInfoMETA *createInfo;
+    XrEnvironmentDepthProviderMETA *environmentDepthProvider;
+    XrResult result;
+};
+
+struct xrCreateEnvironmentDepthSwapchainMETA_params
+{
+    XrEnvironmentDepthProviderMETA environmentDepthProvider;
+    const XrEnvironmentDepthSwapchainCreateInfoMETA *createInfo;
+    XrEnvironmentDepthSwapchainMETA *swapchain;
+    XrResult result;
+};
+
+struct xrCreateExportedLocalizationMapML_params
+{
+    XrSession session;
+    const XrUuidEXT *mapUuid;
+    XrExportedLocalizationMapML *map;
+    XrResult result;
+};
+
+struct xrCreateEyeTrackerFB_params
+{
+    XrSession session;
+    const XrEyeTrackerCreateInfoFB *createInfo;
+    XrEyeTrackerFB *eyeTracker;
+    XrResult result;
+};
+
+struct xrCreateFaceTracker2FB_params
+{
+    XrSession session;
+    const XrFaceTrackerCreateInfo2FB *createInfo;
+    XrFaceTracker2FB *faceTracker;
+    XrResult result;
+};
+
+struct xrCreateFaceTrackerFB_params
+{
+    XrSession session;
+    const XrFaceTrackerCreateInfoFB *createInfo;
+    XrFaceTrackerFB *faceTracker;
+    XrResult result;
+};
+
+struct xrCreateFacialExpressionClientML_params
+{
+    XrSession session;
+    const XrFacialExpressionClientCreateInfoML *createInfo;
+    XrFacialExpressionClientML *facialExpressionClient;
+    XrResult result;
+};
+
+struct xrCreateFacialTrackerHTC_params
+{
+    XrSession session;
+    const XrFacialTrackerCreateInfoHTC *createInfo;
+    XrFacialTrackerHTC *facialTracker;
+    XrResult result;
+};
+
+struct xrCreateFoveationProfileFB_params
+{
+    XrSession session;
+    const XrFoveationProfileCreateInfoFB *createInfo;
+    XrFoveationProfileFB *profile;
+    XrResult result;
+};
+
+struct xrCreateGeometryInstanceFB_params
+{
+    XrSession session;
+    const XrGeometryInstanceCreateInfoFB *createInfo;
+    XrGeometryInstanceFB *outGeometryInstance;
+    XrResult result;
+};
+
+struct xrCreateHandMeshSpaceMSFT_params
+{
+    XrHandTrackerEXT handTracker;
+    const XrHandMeshSpaceCreateInfoMSFT *createInfo;
+    XrSpace *space;
+    XrResult result;
+};
+
+struct xrCreateHandTrackerEXT_params
+{
+    XrSession session;
+    const XrHandTrackerCreateInfoEXT *createInfo;
+    XrHandTrackerEXT *handTracker;
+    XrResult result;
+};
+
+struct xrCreateInstance_params
+{
+    const XrInstanceCreateInfo *createInfo;
+    XrInstance *instance;
+    XrResult result;
+};
+
+struct xrCreateKeyboardSpaceFB_params
+{
+    XrSession session;
+    const XrKeyboardSpaceCreateInfoFB *createInfo;
+    XrSpace *keyboardSpace;
+    XrResult result;
+};
+
+struct xrCreateMarkerDetectorML_params
+{
+    XrSession session;
+    const XrMarkerDetectorCreateInfoML *createInfo;
+    XrMarkerDetectorML *markerDetector;
+    XrResult result;
+};
+
+struct xrCreateMarkerSpaceML_params
+{
+    XrSession session;
+    const XrMarkerSpaceCreateInfoML *createInfo;
+    XrSpace *space;
+    XrResult result;
+};
+
+struct xrCreateMarkerSpaceVARJO_params
+{
+    XrSession session;
+    const XrMarkerSpaceCreateInfoVARJO *createInfo;
+    XrSpace *space;
+    XrResult result;
+};
+
+struct xrCreatePassthroughColorLutMETA_params
+{
+    XrPassthroughFB passthrough;
+    const XrPassthroughColorLutCreateInfoMETA *createInfo;
+    XrPassthroughColorLutMETA *colorLut;
+    XrResult result;
+};
+
+struct xrCreatePassthroughFB_params
+{
+    XrSession session;
+    const XrPassthroughCreateInfoFB *createInfo;
+    XrPassthroughFB *outPassthrough;
+    XrResult result;
+};
+
+struct xrCreatePassthroughHTC_params
+{
+    XrSession session;
+    const XrPassthroughCreateInfoHTC *createInfo;
+    XrPassthroughHTC *passthrough;
+    XrResult result;
+};
+
+struct xrCreatePassthroughLayerFB_params
+{
+    XrSession session;
+    const XrPassthroughLayerCreateInfoFB *createInfo;
+    XrPassthroughLayerFB *outLayer;
+    XrResult result;
+};
+
+struct xrCreatePersistedAnchorSpaceANDROID_params
+{
+    XrDeviceAnchorPersistenceANDROID handle;
+    const XrPersistedAnchorSpaceCreateInfoANDROID *createInfo;
+    XrSpace *anchorOutput;
+    XrResult result;
+};
+
+struct xrCreatePlaneDetectorEXT_params
+{
+    XrSession session;
+    const XrPlaneDetectorCreateInfoEXT *createInfo;
+    XrPlaneDetectorEXT *planeDetector;
+    XrResult result;
+};
+
+struct xrCreateReferenceSpace_params
+{
+    XrSession session;
+    const XrReferenceSpaceCreateInfo *createInfo;
+    XrSpace *space;
+    XrResult result;
+};
+
+struct xrCreateRenderModelAssetEXT_params
+{
+    XrSession session;
+    const XrRenderModelAssetCreateInfoEXT *createInfo;
+    XrRenderModelAssetEXT *asset;
+    XrResult result;
+};
+
+struct xrCreateRenderModelEXT_params
+{
+    XrSession session;
+    const XrRenderModelCreateInfoEXT *createInfo;
+    XrRenderModelEXT *renderModel;
+    XrResult result;
+};
+
+struct xrCreateRenderModelSpaceEXT_params
+{
+    XrSession session;
+    const XrRenderModelSpaceCreateInfoEXT *createInfo;
+    XrSpace *space;
+    XrResult result;
+};
+
+struct xrCreateSceneMSFT_params
+{
+    XrSceneObserverMSFT sceneObserver;
+    const XrSceneCreateInfoMSFT *createInfo;
+    XrSceneMSFT *scene;
+    XrResult result;
+};
+
+struct xrCreateSceneObserverMSFT_params
+{
+    XrSession session;
+    const XrSceneObserverCreateInfoMSFT *createInfo;
+    XrSceneObserverMSFT *sceneObserver;
+    XrResult result;
+};
+
+struct xrCreateSenseDataProviderBD_params
+{
+    XrSession session;
+    const XrSenseDataProviderCreateInfoBD *createInfo;
+    XrSenseDataProviderBD *provider;
+    XrResult result;
+};
+
+struct xrCreateSession_params
+{
+    XrInstance instance;
+    const XrSessionCreateInfo *createInfo;
+    XrSession *session;
+    XrResult result;
+};
+
+struct xrCreateSpaceUserFB_params
+{
+    XrSession session;
+    const XrSpaceUserCreateInfoFB *info;
+    XrSpaceUserFB *user;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorAsyncBD_params
+{
+    XrSenseDataProviderBD provider;
+    const XrSpatialAnchorCreateInfoBD *info;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorCompleteBD_params
+{
+    XrSenseDataProviderBD provider;
+    XrFutureEXT future;
+    XrSpatialAnchorCreateCompletionBD *completion;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorEXT_params
+{
+    XrSpatialContextEXT spatialContext;
+    const XrSpatialAnchorCreateInfoEXT *createInfo;
+    XrSpatialEntityIdEXT *anchorEntityId;
+    XrSpatialEntityEXT *anchorEntity;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorFB_params
+{
+    XrSession session;
+    const XrSpatialAnchorCreateInfoFB *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorFromPersistedNameMSFT_params
+{
+    XrSession session;
+    const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT *spatialAnchorCreateInfo;
+    XrSpatialAnchorMSFT *spatialAnchor;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorHTC_params
+{
+    XrSession session;
+    const XrSpatialAnchorCreateInfoHTC *createInfo;
+    XrSpace *anchor;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorMSFT_params
+{
+    XrSession session;
+    const XrSpatialAnchorCreateInfoMSFT *createInfo;
+    XrSpatialAnchorMSFT *anchor;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorSpaceMSFT_params
+{
+    XrSession session;
+    const XrSpatialAnchorSpaceCreateInfoMSFT *createInfo;
+    XrSpace *space;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorStoreConnectionMSFT_params
+{
+    XrSession session;
+    XrSpatialAnchorStoreConnectionMSFT *spatialAnchorStore;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorsAsyncML_params
+{
+    XrSession session;
+    const XrSpatialAnchorsCreateInfoBaseHeaderML *createInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorsCompleteML_params
+{
+    XrSession session;
+    XrFutureEXT future;
+    XrCreateSpatialAnchorsCompletionML *completion;
+    XrResult result;
+};
+
+struct xrCreateSpatialAnchorsStorageML_params
+{
+    XrSession session;
+    const XrSpatialAnchorsCreateStorageInfoML *createInfo;
+    XrSpatialAnchorsStorageML *storage;
+    XrResult result;
+};
+
+struct xrCreateSpatialContextAsyncEXT_params
+{
+    XrSession session;
+    const XrSpatialContextCreateInfoEXT *createInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrCreateSpatialContextCompleteEXT_params
+{
+    XrSession session;
+    XrFutureEXT future;
+    XrCreateSpatialContextCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrCreateSpatialDiscoverySnapshotAsyncEXT_params
+{
+    XrSpatialContextEXT spatialContext;
+    const XrSpatialDiscoverySnapshotCreateInfoEXT *createInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrCreateSpatialDiscoverySnapshotCompleteEXT_params
+{
+    XrSpatialContextEXT spatialContext;
+    const XrCreateSpatialDiscoverySnapshotCompletionInfoEXT *createSnapshotCompletionInfo;
+    XrCreateSpatialDiscoverySnapshotCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrCreateSpatialEntityAnchorBD_params
+{
+    XrSenseDataProviderBD provider;
+    const XrSpatialEntityAnchorCreateInfoBD *createInfo;
+    XrAnchorBD *anchor;
+    XrResult result;
+};
+
+struct xrCreateSpatialEntityFromIdEXT_params
+{
+    XrSpatialContextEXT spatialContext;
+    const XrSpatialEntityFromIdCreateInfoEXT *createInfo;
+    XrSpatialEntityEXT *spatialEntity;
+    XrResult result;
+};
+
+struct xrCreateSpatialGraphNodeSpaceMSFT_params
+{
+    XrSession session;
+    const XrSpatialGraphNodeSpaceCreateInfoMSFT *createInfo;
+    XrSpace *space;
+    XrResult result;
+};
+
+struct xrCreateSpatialPersistenceContextAsyncEXT_params
+{
+    XrSession session;
+    const XrSpatialPersistenceContextCreateInfoEXT *createInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrCreateSpatialPersistenceContextCompleteEXT_params
+{
+    XrSession session;
+    XrFutureEXT future;
+    XrCreateSpatialPersistenceContextCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrCreateSpatialUpdateSnapshotEXT_params
+{
+    XrSpatialContextEXT spatialContext;
+    const XrSpatialUpdateSnapshotCreateInfoEXT *createInfo;
+    XrSpatialSnapshotEXT *snapshot;
+    XrResult result;
+};
+
+struct xrCreateSwapchain_params
+{
+    XrSession session;
+    const XrSwapchainCreateInfo *createInfo;
+    XrSwapchain *swapchain;
+    XrResult result;
+};
+
+struct xrCreateTrackableTrackerANDROID_params
+{
+    XrSession session;
+    const XrTrackableTrackerCreateInfoANDROID *createInfo;
+    XrTrackableTrackerANDROID *trackableTracker;
+    XrResult result;
+};
+
+struct xrCreateTriangleMeshFB_params
+{
+    XrSession session;
+    const XrTriangleMeshCreateInfoFB *createInfo;
+    XrTriangleMeshFB *outTriangleMesh;
+    XrResult result;
+};
+
+struct xrCreateVirtualKeyboardMETA_params
+{
+    XrSession session;
+    const XrVirtualKeyboardCreateInfoMETA *createInfo;
+    XrVirtualKeyboardMETA *keyboard;
+    XrResult result;
+};
+
+struct xrCreateVirtualKeyboardSpaceMETA_params
+{
+    XrSession session;
+    XrVirtualKeyboardMETA keyboard;
+    const XrVirtualKeyboardSpaceCreateInfoMETA *createInfo;
+    XrSpace *keyboardSpace;
+    XrResult result;
+};
+
+struct xrCreateWorldMeshDetectorML_params
+{
+    XrSession session;
+    const XrWorldMeshDetectorCreateInfoML *createInfo;
+    XrWorldMeshDetectorML *detector;
+    XrResult result;
+};
+
+struct xrDeleteSpatialAnchorsAsyncML_params
+{
+    XrSpatialAnchorsStorageML storage;
+    const XrSpatialAnchorsDeleteInfoML *deleteInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrDeleteSpatialAnchorsCompleteML_params
+{
+    XrSpatialAnchorsStorageML storage;
+    XrFutureEXT future;
+    XrSpatialAnchorsDeleteCompletionML *completion;
+    XrResult result;
+};
+
+struct xrDeserializeSceneMSFT_params
+{
+    XrSceneObserverMSFT sceneObserver;
+    const XrSceneDeserializeInfoMSFT *deserializeInfo;
+    XrResult result;
+};
+
+struct xrDestroyAction_params
+{
+    XrAction action;
+    XrResult result;
+};
+
+struct xrDestroyActionSet_params
+{
+    XrActionSet actionSet;
+    XrResult result;
+};
+
+struct xrDestroyAnchorBD_params
+{
+    XrAnchorBD anchor;
+    XrResult result;
+};
+
+struct xrDestroyBodyTrackerBD_params
+{
+    XrBodyTrackerBD bodyTracker;
+    XrResult result;
+};
+
+struct xrDestroyBodyTrackerFB_params
+{
+    XrBodyTrackerFB bodyTracker;
+    XrResult result;
+};
+
+struct xrDestroyBodyTrackerHTC_params
+{
+    XrBodyTrackerHTC bodyTracker;
+    XrResult result;
+};
+
+struct xrDestroyDeviceAnchorPersistenceANDROID_params
+{
+    XrDeviceAnchorPersistenceANDROID handle;
+    XrResult result;
+};
+
+struct xrDestroyEnvironmentDepthProviderMETA_params
+{
+    XrEnvironmentDepthProviderMETA environmentDepthProvider;
+    XrResult result;
+};
+
+struct xrDestroyEnvironmentDepthSwapchainMETA_params
+{
+    XrEnvironmentDepthSwapchainMETA swapchain;
+    XrResult result;
+};
+
+struct xrDestroyExportedLocalizationMapML_params
+{
+    XrExportedLocalizationMapML map;
+    XrResult result;
+};
+
+struct xrDestroyEyeTrackerFB_params
+{
+    XrEyeTrackerFB eyeTracker;
+    XrResult result;
+};
+
+struct xrDestroyFaceTracker2FB_params
+{
+    XrFaceTracker2FB faceTracker;
+    XrResult result;
+};
+
+struct xrDestroyFaceTrackerFB_params
+{
+    XrFaceTrackerFB faceTracker;
+    XrResult result;
+};
+
+struct xrDestroyFacialExpressionClientML_params
+{
+    XrFacialExpressionClientML facialExpressionClient;
+    XrResult result;
+};
+
+struct xrDestroyFacialTrackerHTC_params
+{
+    XrFacialTrackerHTC facialTracker;
+    XrResult result;
+};
+
+struct xrDestroyFoveationProfileFB_params
+{
+    XrFoveationProfileFB profile;
+    XrResult result;
+};
+
+struct xrDestroyGeometryInstanceFB_params
+{
+    XrGeometryInstanceFB instance;
+    XrResult result;
+};
+
+struct xrDestroyHandTrackerEXT_params
+{
+    XrHandTrackerEXT handTracker;
+    XrResult result;
+};
+
+struct xrDestroyInstance_params
+{
+    XrInstance instance;
+    XrResult result;
+};
+
+struct xrDestroyMarkerDetectorML_params
+{
+    XrMarkerDetectorML markerDetector;
+    XrResult result;
+};
+
+struct xrDestroyPassthroughColorLutMETA_params
+{
+    XrPassthroughColorLutMETA colorLut;
+    XrResult result;
+};
+
+struct xrDestroyPassthroughFB_params
+{
+    XrPassthroughFB passthrough;
+    XrResult result;
+};
+
+struct xrDestroyPassthroughHTC_params
+{
+    XrPassthroughHTC passthrough;
+    XrResult result;
+};
+
+struct xrDestroyPassthroughLayerFB_params
+{
+    XrPassthroughLayerFB layer;
+    XrResult result;
+};
+
+struct xrDestroyPlaneDetectorEXT_params
+{
+    XrPlaneDetectorEXT planeDetector;
+    XrResult result;
+};
+
+struct xrDestroyRenderModelAssetEXT_params
+{
+    XrRenderModelAssetEXT asset;
+    XrResult result;
+};
+
+struct xrDestroyRenderModelEXT_params
+{
+    XrRenderModelEXT renderModel;
+    XrResult result;
+};
+
+struct xrDestroySceneMSFT_params
+{
+    XrSceneMSFT scene;
+    XrResult result;
+};
+
+struct xrDestroySceneObserverMSFT_params
+{
+    XrSceneObserverMSFT sceneObserver;
+    XrResult result;
+};
+
+struct xrDestroySenseDataProviderBD_params
+{
+    XrSenseDataProviderBD provider;
+    XrResult result;
+};
+
+struct xrDestroySenseDataSnapshotBD_params
+{
+    XrSenseDataSnapshotBD snapshot;
+    XrResult result;
+};
+
+struct xrDestroySession_params
+{
+    XrSession session;
+    XrResult result;
+};
+
+struct xrDestroySpace_params
+{
+    XrSpace space;
+    XrResult result;
+};
+
+struct xrDestroySpaceUserFB_params
+{
+    XrSpaceUserFB user;
+    XrResult result;
+};
+
+struct xrDestroySpatialAnchorMSFT_params
+{
+    XrSpatialAnchorMSFT anchor;
+    XrResult result;
+};
+
+struct xrDestroySpatialAnchorStoreConnectionMSFT_params
+{
+    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
+    XrResult result;
+};
+
+struct xrDestroySpatialAnchorsStorageML_params
+{
+    XrSpatialAnchorsStorageML storage;
+    XrResult result;
+};
+
+struct xrDestroySpatialContextEXT_params
+{
+    XrSpatialContextEXT spatialContext;
+    XrResult result;
+};
+
+struct xrDestroySpatialEntityEXT_params
+{
+    XrSpatialEntityEXT spatialEntity;
+    XrResult result;
+};
+
+struct xrDestroySpatialGraphNodeBindingMSFT_params
+{
+    XrSpatialGraphNodeBindingMSFT nodeBinding;
+    XrResult result;
+};
+
+struct xrDestroySpatialPersistenceContextEXT_params
+{
+    XrSpatialPersistenceContextEXT persistenceContext;
+    XrResult result;
+};
+
+struct xrDestroySpatialSnapshotEXT_params
+{
+    XrSpatialSnapshotEXT snapshot;
+    XrResult result;
+};
+
+struct xrDestroySwapchain_params
+{
+    XrSwapchain swapchain;
+    XrResult result;
+};
+
+struct xrDestroyTrackableTrackerANDROID_params
+{
+    XrTrackableTrackerANDROID trackableTracker;
+    XrResult result;
+};
+
+struct xrDestroyTriangleMeshFB_params
+{
+    XrTriangleMeshFB mesh;
+    XrResult result;
+};
+
+struct xrDestroyVirtualKeyboardMETA_params
+{
+    XrVirtualKeyboardMETA keyboard;
+    XrResult result;
+};
+
+struct xrDestroyWorldMeshDetectorML_params
+{
+    XrWorldMeshDetectorML detector;
+    XrResult result;
+};
+
+struct xrDiscoverSpacesMETA_params
+{
+    XrSession session;
+    const XrSpaceDiscoveryInfoMETA *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrDownloadSharedSpatialAnchorAsyncBD_params
+{
+    XrSenseDataProviderBD provider;
+    const XrSharedSpatialAnchorDownloadInfoBD *info;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrDownloadSharedSpatialAnchorCompleteBD_params
+{
+    XrSenseDataProviderBD provider;
+    XrFutureEXT future;
+    XrFutureCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrEnableLocalizationEventsML_params
+{
+    XrSession session;
+    const XrLocalizationEnableEventsInfoML *info;
+    XrResult result;
+};
+
+struct xrEnableUserCalibrationEventsML_params
+{
+    XrInstance instance;
+    const XrUserCalibrationEnableEventsInfoML *enableInfo;
+    XrResult result;
+};
+
+struct xrEndFrame_params
+{
+    XrSession session;
+    const XrFrameEndInfo *frameEndInfo;
+    XrResult result;
+};
+
+struct xrEndSession_params
+{
+    XrSession session;
+    XrResult result;
+};
+
+struct xrEnumerateApiLayerProperties_params
+{
+    uint32_t propertyCapacityInput;
+    uint32_t *propertyCountOutput;
+    XrApiLayerProperties *properties;
+    XrResult result;
+};
+
+struct xrEnumerateBoundSourcesForAction_params
+{
+    XrSession session;
+    const XrBoundSourcesForActionEnumerateInfo *enumerateInfo;
+    uint32_t sourceCapacityInput;
+    uint32_t *sourceCountOutput;
+    XrPath *sources;
+    XrResult result;
+};
+
+struct xrEnumerateColorSpacesFB_params
+{
+    XrSession session;
+    uint32_t colorSpaceCapacityInput;
+    uint32_t *colorSpaceCountOutput;
+    XrColorSpaceFB *colorSpaces;
+    XrResult result;
+};
+
+struct xrEnumerateDisplayRefreshRatesFB_params
+{
+    XrSession session;
+    uint32_t displayRefreshRateCapacityInput;
+    uint32_t *displayRefreshRateCountOutput;
+    float *displayRefreshRates;
+    XrResult result;
+};
+
+struct xrEnumerateEnvironmentBlendModes_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    XrViewConfigurationType viewConfigurationType;
+    uint32_t environmentBlendModeCapacityInput;
+    uint32_t *environmentBlendModeCountOutput;
+    XrEnvironmentBlendMode *environmentBlendModes;
+    XrResult result;
+};
+
+struct xrEnumerateEnvironmentDepthSwapchainImagesMETA_params
+{
+    XrEnvironmentDepthSwapchainMETA swapchain;
+    uint32_t imageCapacityInput;
+    uint32_t *imageCountOutput;
+    XrSwapchainImageBaseHeader *images;
+    XrResult result;
+};
+
+struct xrEnumerateExternalCamerasOCULUS_params
+{
+    XrSession session;
+    uint32_t cameraCapacityInput;
+    uint32_t *cameraCountOutput;
+    XrExternalCameraOCULUS *cameras;
+    XrResult result;
+};
+
+struct xrEnumerateInstanceExtensionProperties_params
+{
+    const char *layerName;
+    uint32_t propertyCapacityInput;
+    uint32_t *propertyCountOutput;
+    XrExtensionProperties *properties;
+    XrResult result;
+};
+
+struct xrEnumerateInteractionRenderModelIdsEXT_params
+{
+    XrSession session;
+    const XrInteractionRenderModelIdsEnumerateInfoEXT *getInfo;
+    uint32_t renderModelIdCapacityInput;
+    uint32_t *renderModelIdCountOutput;
+    XrRenderModelIdEXT *renderModelIds;
+    XrResult result;
+};
+
+struct xrEnumeratePerformanceMetricsCounterPathsMETA_params
+{
+    XrInstance instance;
+    uint32_t counterPathCapacityInput;
+    uint32_t *counterPathCountOutput;
+    XrPath *counterPaths;
+    XrResult result;
+};
+
+struct xrEnumeratePersistedAnchorsANDROID_params
+{
+    XrDeviceAnchorPersistenceANDROID handle;
+    uint32_t anchorIdCapacityInput;
+    uint32_t *anchorIdCountOutput;
+    XrUuidEXT *anchorIds;
+    XrResult result;
+};
+
+struct xrEnumeratePersistedSpatialAnchorNamesMSFT_params
+{
+    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
+    uint32_t spatialAnchorNameCapacityInput;
+    uint32_t *spatialAnchorNameCountOutput;
+    XrSpatialAnchorPersistenceNameMSFT *spatialAnchorNames;
+    XrResult result;
+};
+
+struct xrEnumerateRaycastSupportedTrackableTypesANDROID_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    uint32_t trackableTypeCapacityInput;
+    uint32_t *trackableTypeCountOutput;
+    XrTrackableTypeANDROID *trackableTypes;
+    XrResult result;
+};
+
+struct xrEnumerateReferenceSpaces_params
+{
+    XrSession session;
+    uint32_t spaceCapacityInput;
+    uint32_t *spaceCountOutput;
+    XrReferenceSpaceType *spaces;
+    XrResult result;
+};
+
+struct xrEnumerateRenderModelPathsFB_params
+{
+    XrSession session;
+    uint32_t pathCapacityInput;
+    uint32_t *pathCountOutput;
+    XrRenderModelPathInfoFB *paths;
+    XrResult result;
+};
+
+struct xrEnumerateRenderModelSubactionPathsEXT_params
+{
+    XrRenderModelEXT renderModel;
+    const XrInteractionRenderModelSubactionPathInfoEXT *info;
+    uint32_t pathCapacityInput;
+    uint32_t *pathCountOutput;
+    XrPath *paths;
+    XrResult result;
+};
+
+struct xrEnumerateReprojectionModesMSFT_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    XrViewConfigurationType viewConfigurationType;
+    uint32_t modeCapacityInput;
+    uint32_t *modeCountOutput;
+    XrReprojectionModeMSFT *modes;
+    XrResult result;
+};
+
+struct xrEnumerateSceneComputeFeaturesMSFT_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    uint32_t featureCapacityInput;
+    uint32_t *featureCountOutput;
+    XrSceneComputeFeatureMSFT *features;
+    XrResult result;
+};
+
+struct xrEnumerateSpaceSupportedComponentsFB_params
+{
+    XrSpace space;
+    uint32_t componentTypeCapacityInput;
+    uint32_t *componentTypeCountOutput;
+    XrSpaceComponentTypeFB *componentTypes;
+    XrResult result;
+};
+
+struct xrEnumerateSpatialCapabilitiesEXT_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    uint32_t capabilityCapacityInput;
+    uint32_t *capabilityCountOutput;
+    XrSpatialCapabilityEXT *capabilities;
+    XrResult result;
+};
+
+struct xrEnumerateSpatialCapabilityComponentTypesEXT_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    XrSpatialCapabilityEXT capability;
+    XrSpatialCapabilityComponentTypesEXT *capabilityComponents;
+    XrResult result;
+};
+
+struct xrEnumerateSpatialCapabilityFeaturesEXT_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    XrSpatialCapabilityEXT capability;
+    uint32_t capabilityFeatureCapacityInput;
+    uint32_t *capabilityFeatureCountOutput;
+    XrSpatialCapabilityFeatureEXT *capabilityFeatures;
+    XrResult result;
+};
+
+struct xrEnumerateSpatialEntityComponentTypesBD_params
+{
+    XrSenseDataSnapshotBD snapshot;
+    XrSpatialEntityIdBD entityId;
+    uint32_t componentTypeCapacityInput;
+    uint32_t *componentTypeCountOutput;
+    XrSpatialEntityComponentTypeBD *componentTypes;
+    XrResult result;
+};
+
+struct xrEnumerateSpatialPersistenceScopesEXT_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    uint32_t persistenceScopeCapacityInput;
+    uint32_t *persistenceScopeCountOutput;
+    XrSpatialPersistenceScopeEXT *persistenceScopes;
+    XrResult result;
+};
+
+struct xrEnumerateSupportedAnchorTrackableTypesANDROID_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    uint32_t trackableTypeCapacityInput;
+    uint32_t *trackableTypeCountOutput;
+    XrTrackableTypeANDROID *trackableTypes;
+    XrResult result;
+};
+
+struct xrEnumerateSupportedPersistenceAnchorTypesANDROID_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    uint32_t trackableTypeCapacityInput;
+    uint32_t *trackableTypeCountOutput;
+    XrTrackableTypeANDROID *trackableTypes;
+    XrResult result;
+};
+
+struct xrEnumerateSupportedTrackableTypesANDROID_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    uint32_t trackableTypeCapacityInput;
+    uint32_t *trackableTypeCountOutput;
+    XrTrackableTypeANDROID *trackableTypes;
+    XrResult result;
+};
+
+struct xrEnumerateSwapchainFormats_params
+{
+    XrSession session;
+    uint32_t formatCapacityInput;
+    uint32_t *formatCountOutput;
+    int64_t *formats;
+    XrResult result;
+};
+
+struct xrEnumerateSwapchainImages_params
+{
+    XrSwapchain swapchain;
+    uint32_t imageCapacityInput;
+    uint32_t *imageCountOutput;
+    XrSwapchainImageBaseHeader *images;
+    XrResult result;
+};
+
+struct xrEnumerateViewConfigurationViews_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    XrViewConfigurationType viewConfigurationType;
+    uint32_t viewCapacityInput;
+    uint32_t *viewCountOutput;
+    XrViewConfigurationView *views;
+    XrResult result;
+};
+
+struct xrEnumerateViewConfigurations_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    uint32_t viewConfigurationTypeCapacityInput;
+    uint32_t *viewConfigurationTypeCountOutput;
+    XrViewConfigurationType *viewConfigurationTypes;
+    XrResult result;
+};
+
+struct xrEnumerateViveTrackerPathsHTCX_params
+{
+    XrInstance instance;
+    uint32_t pathCapacityInput;
+    uint32_t *pathCountOutput;
+    XrViveTrackerPathsHTCX *paths;
+    XrResult result;
+};
+
+struct xrEraseSpaceFB_params
+{
+    XrSession session;
+    const XrSpaceEraseInfoFB *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrEraseSpacesMETA_params
+{
+    XrSession session;
+    const XrSpacesEraseInfoMETA *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrFreeWorldMeshBufferML_params
+{
+    XrWorldMeshDetectorML detector;
+    const XrWorldMeshBufferML *buffer;
+    XrResult result;
+};
+
+struct xrGeometryInstanceSetTransformFB_params
+{
+    XrGeometryInstanceFB instance;
+    const XrGeometryInstanceTransformFB *transformation;
+    XrResult result;
+};
+
+struct xrGetActionStateBoolean_params
+{
+    XrSession session;
+    const XrActionStateGetInfo *getInfo;
+    XrActionStateBoolean *state;
+    XrResult result;
+};
+
+struct xrGetActionStateFloat_params
+{
+    XrSession session;
+    const XrActionStateGetInfo *getInfo;
+    XrActionStateFloat *state;
+    XrResult result;
+};
+
+struct xrGetActionStatePose_params
+{
+    XrSession session;
+    const XrActionStateGetInfo *getInfo;
+    XrActionStatePose *state;
+    XrResult result;
+};
+
+struct xrGetActionStateVector2f_params
+{
+    XrSession session;
+    const XrActionStateGetInfo *getInfo;
+    XrActionStateVector2f *state;
+    XrResult result;
+};
+
+struct xrGetAllTrackablesANDROID_params
+{
+    XrTrackableTrackerANDROID trackableTracker;
+    uint32_t trackableCapacityInput;
+    uint32_t *trackableCountOutput;
+    XrTrackableANDROID *trackables;
+    XrResult result;
+};
+
+struct xrGetAnchorPersistStateANDROID_params
+{
+    XrDeviceAnchorPersistenceANDROID handle;
+    const XrUuidEXT *anchorId;
+    XrAnchorPersistStateANDROID *persistState;
+    XrResult result;
+};
+
+struct xrGetAnchorUuidBD_params
+{
+    XrAnchorBD anchor;
+    XrUuidEXT *uuid;
+    XrResult result;
+};
+
+struct xrGetAudioInputDeviceGuidOculus_params
+{
+    XrInstance instance;
+    wchar_t *buffer;
+    XrResult result;
+};
+
+struct xrGetAudioOutputDeviceGuidOculus_params
+{
+    XrInstance instance;
+    wchar_t *buffer;
+    XrResult result;
+};
+
+struct xrGetBodySkeletonFB_params
+{
+    XrBodyTrackerFB bodyTracker;
+    XrBodySkeletonFB *skeleton;
+    XrResult result;
+};
+
+struct xrGetBodySkeletonHTC_params
+{
+    XrBodyTrackerHTC bodyTracker;
+    XrSpace baseSpace;
+    uint32_t skeletonGenerationId;
+    XrBodySkeletonHTC *skeleton;
+    XrResult result;
+};
+
+struct xrGetControllerModelKeyMSFT_params
+{
+    XrSession session;
+    XrPath topLevelUserPath;
+    XrControllerModelKeyStateMSFT *controllerModelKeyState;
+    XrResult result;
+};
+
+struct xrGetControllerModelPropertiesMSFT_params
+{
+    XrSession session;
+    XrControllerModelKeyMSFT modelKey;
+    XrControllerModelPropertiesMSFT *properties;
+    XrResult result;
+};
+
+struct xrGetControllerModelStateMSFT_params
+{
+    XrSession session;
+    XrControllerModelKeyMSFT modelKey;
+    XrControllerModelStateMSFT *state;
+    XrResult result;
+};
+
+struct xrGetCurrentInteractionProfile_params
+{
+    XrSession session;
+    XrPath topLevelUserPath;
+    XrInteractionProfileState *interactionProfile;
+    XrResult result;
+};
+
+struct xrGetDeviceSampleRateFB_params
+{
+    XrSession session;
+    const XrHapticActionInfo *hapticActionInfo;
+    XrDevicePcmSampleRateGetInfoFB *deviceSampleRate;
+    XrResult result;
+};
+
+struct xrGetDisplayRefreshRateFB_params
+{
+    XrSession session;
+    float *displayRefreshRate;
+    XrResult result;
+};
+
+struct xrGetEnvironmentDepthSwapchainStateMETA_params
+{
+    XrEnvironmentDepthSwapchainMETA swapchain;
+    XrEnvironmentDepthSwapchainStateMETA *state;
+    XrResult result;
+};
+
+struct xrGetExportedLocalizationMapDataML_params
+{
+    XrExportedLocalizationMapML map;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrGetEyeGazesFB_params
+{
+    XrEyeTrackerFB eyeTracker;
+    const XrEyeGazesInfoFB *gazeInfo;
+    XrEyeGazesFB *eyeGazes;
+    XrResult result;
+};
+
+struct xrGetFaceExpressionWeights2FB_params
+{
+    XrFaceTracker2FB faceTracker;
+    const XrFaceExpressionInfo2FB *expressionInfo;
+    XrFaceExpressionWeights2FB *expressionWeights;
+    XrResult result;
+};
+
+struct xrGetFaceExpressionWeightsFB_params
+{
+    XrFaceTrackerFB faceTracker;
+    const XrFaceExpressionInfoFB *expressionInfo;
+    XrFaceExpressionWeightsFB *expressionWeights;
+    XrResult result;
+};
+
+struct xrGetFacialExpressionBlendShapePropertiesML_params
+{
+    XrFacialExpressionClientML facialExpressionClient;
+    const XrFacialExpressionBlendShapeGetInfoML *blendShapeGetInfo;
+    uint32_t blendShapeCount;
+    XrFacialExpressionBlendShapePropertiesML *blendShapes;
+    XrResult result;
+};
+
+struct xrGetFacialExpressionsHTC_params
+{
+    XrFacialTrackerHTC facialTracker;
+    XrFacialExpressionsHTC *facialExpressions;
+    XrResult result;
+};
+
+struct xrGetFoveationEyeTrackedStateMETA_params
+{
+    XrSession session;
+    XrFoveationEyeTrackedStateMETA *foveationState;
+    XrResult result;
+};
+
+struct xrGetHandMeshFB_params
+{
+    XrHandTrackerEXT handTracker;
+    XrHandTrackingMeshFB *mesh;
+    XrResult result;
+};
+
+struct xrGetInputSourceLocalizedName_params
+{
+    XrSession session;
+    const XrInputSourceLocalizedNameGetInfo *getInfo;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrGetInstanceProperties_params
+{
+    XrInstance instance;
+    XrInstanceProperties *instanceProperties;
+    XrResult result;
+};
+
+struct xrGetMarkerDetectorStateML_params
+{
+    XrMarkerDetectorML markerDetector;
+    XrMarkerDetectorStateML *state;
+    XrResult result;
+};
+
+struct xrGetMarkerLengthML_params
+{
+    XrMarkerDetectorML markerDetector;
+    XrMarkerML marker;
+    float *meters;
+    XrResult result;
+};
+
+struct xrGetMarkerNumberML_params
+{
+    XrMarkerDetectorML markerDetector;
+    XrMarkerML marker;
+    uint64_t *number;
+    XrResult result;
+};
+
+struct xrGetMarkerReprojectionErrorML_params
+{
+    XrMarkerDetectorML markerDetector;
+    XrMarkerML marker;
+    float *reprojectionErrorMeters;
+    XrResult result;
+};
+
+struct xrGetMarkerSizeVARJO_params
+{
+    XrSession session;
+    uint64_t DECLSPEC_ALIGN(8) markerId;
+    XrExtent2Df *size;
+    XrResult result;
+};
+
+struct xrGetMarkerStringML_params
+{
+    XrMarkerDetectorML markerDetector;
+    XrMarkerML marker;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrGetMarkersML_params
+{
+    XrMarkerDetectorML markerDetector;
+    uint32_t markerCapacityInput;
+    uint32_t *markerCountOutput;
+    XrMarkerML *markers;
+    XrResult result;
+};
+
+struct xrGetOpenGLGraphicsRequirementsKHR_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    XrGraphicsRequirementsOpenGLKHR *graphicsRequirements;
+    XrResult result;
+};
+
+struct xrGetPassthroughCameraStateANDROID_params
+{
+    XrSession session;
+    const XrPassthroughCameraStateGetInfoANDROID *getInfo;
+    XrPassthroughCameraStateANDROID *cameraStateOutput;
+    XrResult result;
+};
+
+struct xrGetPassthroughPreferencesMETA_params
+{
+    XrSession session;
+    XrPassthroughPreferencesMETA *preferences;
+    XrResult result;
+};
+
+struct xrGetPerformanceMetricsStateMETA_params
+{
+    XrSession session;
+    XrPerformanceMetricsStateMETA *state;
+    XrResult result;
+};
+
+struct xrGetPlaneDetectionStateEXT_params
+{
+    XrPlaneDetectorEXT planeDetector;
+    XrPlaneDetectionStateEXT *state;
+    XrResult result;
+};
+
+struct xrGetPlaneDetectionsEXT_params
+{
+    XrPlaneDetectorEXT planeDetector;
+    const XrPlaneDetectorGetInfoEXT *info;
+    XrPlaneDetectorLocationsEXT *locations;
+    XrResult result;
+};
+
+struct xrGetPlanePolygonBufferEXT_params
+{
+    XrPlaneDetectorEXT planeDetector;
+    uint64_t DECLSPEC_ALIGN(8) planeId;
+    uint32_t polygonBufferIndex;
+    XrPlaneDetectorPolygonBufferEXT *polygonBuffer;
+    XrResult result;
+};
+
+struct xrGetQueriedSenseDataBD_params
+{
+    XrSenseDataSnapshotBD snapshot;
+    XrQueriedSenseDataGetInfoBD *getInfo;
+    XrQueriedSenseDataBD *queriedSenseData;
+    XrResult result;
+};
+
+struct xrGetRecommendedLayerResolutionMETA_params
+{
+    XrSession session;
+    const XrRecommendedLayerResolutionGetInfoMETA *info;
+    XrRecommendedLayerResolutionMETA *resolution;
+    XrResult result;
+};
+
+struct xrGetReferenceSpaceBoundsRect_params
+{
+    XrSession session;
+    XrReferenceSpaceType referenceSpaceType;
+    XrExtent2Df *bounds;
+    XrResult result;
+};
+
+struct xrGetRenderModelAssetDataEXT_params
+{
+    XrRenderModelAssetEXT asset;
+    const XrRenderModelAssetDataGetInfoEXT *getInfo;
+    XrRenderModelAssetDataEXT *buffer;
+    XrResult result;
+};
+
+struct xrGetRenderModelAssetPropertiesEXT_params
+{
+    XrRenderModelAssetEXT asset;
+    const XrRenderModelAssetPropertiesGetInfoEXT *getInfo;
+    XrRenderModelAssetPropertiesEXT *properties;
+    XrResult result;
+};
+
+struct xrGetRenderModelPoseTopLevelUserPathEXT_params
+{
+    XrRenderModelEXT renderModel;
+    const XrInteractionRenderModelTopLevelUserPathGetInfoEXT *info;
+    XrPath *topLevelUserPath;
+    XrResult result;
+};
+
+struct xrGetRenderModelPropertiesEXT_params
+{
+    XrRenderModelEXT renderModel;
+    const XrRenderModelPropertiesGetInfoEXT *getInfo;
+    XrRenderModelPropertiesEXT *properties;
+    XrResult result;
+};
+
+struct xrGetRenderModelPropertiesFB_params
+{
+    XrSession session;
+    XrPath path;
+    XrRenderModelPropertiesFB *properties;
+    XrResult result;
+};
+
+struct xrGetRenderModelStateEXT_params
+{
+    XrRenderModelEXT renderModel;
+    const XrRenderModelStateGetInfoEXT *getInfo;
+    XrRenderModelStateEXT *state;
+    XrResult result;
+};
+
+struct xrGetSceneComponentsMSFT_params
+{
+    XrSceneMSFT scene;
+    const XrSceneComponentsGetInfoMSFT *getInfo;
+    XrSceneComponentsMSFT *components;
+    XrResult result;
+};
+
+struct xrGetSceneComputeStateMSFT_params
+{
+    XrSceneObserverMSFT sceneObserver;
+    XrSceneComputeStateMSFT *state;
+    XrResult result;
+};
+
+struct xrGetSceneMarkerDecodedStringMSFT_params
+{
+    XrSceneMSFT scene;
+    const XrUuidMSFT *markerId;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrGetSceneMarkerRawDataMSFT_params
+{
+    XrSceneMSFT scene;
+    const XrUuidMSFT *markerId;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    uint8_t *buffer;
+    XrResult result;
+};
+
+struct xrGetSceneMeshBuffersMSFT_params
+{
+    XrSceneMSFT scene;
+    const XrSceneMeshBuffersGetInfoMSFT *getInfo;
+    XrSceneMeshBuffersMSFT *buffers;
+    XrResult result;
+};
+
+struct xrGetSenseDataProviderStateBD_params
+{
+    XrSenseDataProviderBD provider;
+    XrSenseDataProviderStateBD *state;
+    XrResult result;
+};
+
+struct xrGetSerializedSceneFragmentDataMSFT_params
+{
+    XrSceneMSFT scene;
+    const XrSerializedSceneFragmentDataGetInfoMSFT *getInfo;
+    uint32_t countInput;
+    uint32_t *readOutput;
+    uint8_t *buffer;
+    XrResult result;
+};
+
+struct xrGetSpaceBoundary2DFB_params
+{
+    XrSession session;
+    XrSpace space;
+    XrBoundary2DFB *boundary2DOutput;
+    XrResult result;
+};
+
+struct xrGetSpaceBoundingBox2DFB_params
+{
+    XrSession session;
+    XrSpace space;
+    XrRect2Df *boundingBox2DOutput;
+    XrResult result;
+};
+
+struct xrGetSpaceBoundingBox3DFB_params
+{
+    XrSession session;
+    XrSpace space;
+    XrRect3DfFB *boundingBox3DOutput;
+    XrResult result;
+};
+
+struct xrGetSpaceComponentStatusFB_params
+{
+    XrSpace space;
+    XrSpaceComponentTypeFB componentType;
+    XrSpaceComponentStatusFB *status;
+    XrResult result;
+};
+
+struct xrGetSpaceContainerFB_params
+{
+    XrSession session;
+    XrSpace space;
+    XrSpaceContainerFB *spaceContainerOutput;
+    XrResult result;
+};
+
+struct xrGetSpaceRoomLayoutFB_params
+{
+    XrSession session;
+    XrSpace space;
+    XrRoomLayoutFB *roomLayoutOutput;
+    XrResult result;
+};
+
+struct xrGetSpaceSemanticLabelsFB_params
+{
+    XrSession session;
+    XrSpace space;
+    XrSemanticLabelsFB *semanticLabelsOutput;
+    XrResult result;
+};
+
+struct xrGetSpaceTriangleMeshMETA_params
+{
+    XrSpace space;
+    const XrSpaceTriangleMeshGetInfoMETA *getInfo;
+    XrSpaceTriangleMeshMETA *triangleMeshOutput;
+    XrResult result;
+};
+
+struct xrGetSpaceUserIdFB_params
+{
+    XrSpaceUserFB user;
+    XrSpaceUserIdFB *userId;
+    XrResult result;
+};
+
+struct xrGetSpaceUuidFB_params
+{
+    XrSpace space;
+    XrUuidEXT *uuid;
+    XrResult result;
+};
+
+struct xrGetSpatialAnchorNameHTC_params
+{
+    XrSpace anchor;
+    XrSpatialAnchorNameHTC *name;
+    XrResult result;
+};
+
+struct xrGetSpatialAnchorStateML_params
+{
+    XrSpace anchor;
+    XrSpatialAnchorStateML *state;
+    XrResult result;
+};
+
+struct xrGetSpatialBufferFloatEXT_params
+{
+    XrSpatialSnapshotEXT snapshot;
+    const XrSpatialBufferGetInfoEXT *info;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    float *buffer;
+    XrResult result;
+};
+
+struct xrGetSpatialBufferStringEXT_params
+{
+    XrSpatialSnapshotEXT snapshot;
+    const XrSpatialBufferGetInfoEXT *info;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrGetSpatialBufferUint16EXT_params
+{
+    XrSpatialSnapshotEXT snapshot;
+    const XrSpatialBufferGetInfoEXT *info;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    uint16_t *buffer;
+    XrResult result;
+};
+
+struct xrGetSpatialBufferUint32EXT_params
+{
+    XrSpatialSnapshotEXT snapshot;
+    const XrSpatialBufferGetInfoEXT *info;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    uint32_t *buffer;
+    XrResult result;
+};
+
+struct xrGetSpatialBufferUint8EXT_params
+{
+    XrSpatialSnapshotEXT snapshot;
+    const XrSpatialBufferGetInfoEXT *info;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    uint8_t *buffer;
+    XrResult result;
+};
+
+struct xrGetSpatialBufferVector2fEXT_params
+{
+    XrSpatialSnapshotEXT snapshot;
+    const XrSpatialBufferGetInfoEXT *info;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    XrVector2f *buffer;
+    XrResult result;
+};
+
+struct xrGetSpatialBufferVector3fEXT_params
+{
+    XrSpatialSnapshotEXT snapshot;
+    const XrSpatialBufferGetInfoEXT *info;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    XrVector3f *buffer;
+    XrResult result;
+};
+
+struct xrGetSpatialEntityComponentDataBD_params
+{
+    XrSenseDataSnapshotBD snapshot;
+    const XrSpatialEntityComponentGetInfoBD *getInfo;
+    XrSpatialEntityComponentDataBaseHeaderBD *componentData;
+    XrResult result;
+};
+
+struct xrGetSpatialEntityUuidBD_params
+{
+    XrSenseDataSnapshotBD snapshot;
+    XrSpatialEntityIdBD entityId;
+    XrUuidEXT *uuid;
+    XrResult result;
+};
+
+struct xrGetSpatialGraphNodeBindingPropertiesMSFT_params
+{
+    XrSpatialGraphNodeBindingMSFT nodeBinding;
+    const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT *getInfo;
+    XrSpatialGraphNodeBindingPropertiesMSFT *properties;
+    XrResult result;
+};
+
+struct xrGetSwapchainStateFB_params
+{
+    XrSwapchain swapchain;
+    XrSwapchainStateBaseHeaderFB *state;
+    XrResult result;
+};
+
+struct xrGetSystem_params
+{
+    XrInstance instance;
+    const XrSystemGetInfo *getInfo;
+    XrSystemId *systemId;
+    XrResult result;
+};
+
+struct xrGetSystemProperties_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    XrSystemProperties *properties;
+    XrResult result;
+};
+
+struct xrGetTrackableMarkerANDROID_params
+{
+    XrTrackableTrackerANDROID tracker;
+    const XrTrackableGetInfoANDROID *getInfo;
+    XrTrackableMarkerANDROID *markerOutput;
+    XrResult result;
+};
+
+struct xrGetTrackableObjectANDROID_params
+{
+    XrTrackableTrackerANDROID tracker;
+    const XrTrackableGetInfoANDROID *getInfo;
+    XrTrackableObjectANDROID *objectOutput;
+    XrResult result;
+};
+
+struct xrGetTrackablePlaneANDROID_params
+{
+    XrTrackableTrackerANDROID trackableTracker;
+    const XrTrackableGetInfoANDROID *getInfo;
+    XrTrackablePlaneANDROID *planeOutput;
+    XrResult result;
+};
+
+struct xrGetViewConfigurationProperties_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    XrViewConfigurationType viewConfigurationType;
+    XrViewConfigurationProperties *configurationProperties;
+    XrResult result;
+};
+
+struct xrGetVirtualKeyboardDirtyTexturesMETA_params
+{
+    XrVirtualKeyboardMETA keyboard;
+    uint32_t textureIdCapacityInput;
+    uint32_t *textureIdCountOutput;
+    uint64_t *textureIds;
+    XrResult result;
+};
+
+struct xrGetVirtualKeyboardModelAnimationStatesMETA_params
+{
+    XrVirtualKeyboardMETA keyboard;
+    XrVirtualKeyboardModelAnimationStatesMETA *animationStates;
+    XrResult result;
+};
+
+struct xrGetVirtualKeyboardScaleMETA_params
+{
+    XrVirtualKeyboardMETA keyboard;
+    float *scale;
+    XrResult result;
+};
+
+struct xrGetVirtualKeyboardTextureDataMETA_params
+{
+    XrVirtualKeyboardMETA keyboard;
+    uint64_t DECLSPEC_ALIGN(8) textureId;
+    XrVirtualKeyboardTextureDataMETA *textureData;
+    XrResult result;
+};
+
+struct xrGetVisibilityMaskKHR_params
+{
+    XrSession session;
+    XrViewConfigurationType viewConfigurationType;
+    uint32_t viewIndex;
+    XrVisibilityMaskTypeKHR visibilityMaskType;
+    XrVisibilityMaskKHR *visibilityMask;
+    XrResult result;
+};
+
+struct xrGetVulkanDeviceExtensionsKHR_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrGetVulkanGraphicsDevice2KHR_params
+{
+    XrInstance instance;
+    const XrVulkanGraphicsDeviceGetInfoKHR *getInfo;
+    VkPhysicalDevice *vulkanPhysicalDevice;
+    XrResult result;
+};
+
+struct xrGetVulkanGraphicsDeviceKHR_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    VkInstance vkInstance;
+    VkPhysicalDevice *vkPhysicalDevice;
+    XrResult result;
+};
+
+struct xrGetVulkanGraphicsRequirements2KHR_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    XrGraphicsRequirementsVulkanKHR *graphicsRequirements;
+    XrResult result;
+};
+
+struct xrGetVulkanGraphicsRequirementsKHR_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    XrGraphicsRequirementsVulkanKHR *graphicsRequirements;
+    XrResult result;
+};
+
+struct xrGetVulkanInstanceExtensionsKHR_params
+{
+    XrInstance instance;
+    XrSystemId systemId;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrGetWorldMeshBufferRecommendSizeML_params
+{
+    XrWorldMeshDetectorML detector;
+    const XrWorldMeshBufferRecommendedSizeInfoML *sizeInfo;
+    XrWorldMeshBufferSizeML *size;
+    XrResult result;
+};
+
+struct xrImportLocalizationMapML_params
+{
+    XrSession session;
+    const XrLocalizationMapImportInfoML *importInfo;
+    XrUuidEXT *mapUuid;
+    XrResult result;
+};
+
+struct xrLoadControllerModelMSFT_params
+{
+    XrSession session;
+    XrControllerModelKeyMSFT modelKey;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    uint8_t *buffer;
+    XrResult result;
+};
+
+struct xrLoadRenderModelFB_params
+{
+    XrSession session;
+    const XrRenderModelLoadInfoFB *info;
+    XrRenderModelBufferFB *buffer;
+    XrResult result;
+};
+
+struct xrLocateBodyJointsBD_params
+{
+    XrBodyTrackerBD bodyTracker;
+    const XrBodyJointsLocateInfoBD *locateInfo;
+    XrBodyJointLocationsBD *locations;
+    XrResult result;
+};
+
+struct xrLocateBodyJointsFB_params
+{
+    XrBodyTrackerFB bodyTracker;
+    const XrBodyJointsLocateInfoFB *locateInfo;
+    XrBodyJointLocationsFB *locations;
+    XrResult result;
+};
+
+struct xrLocateBodyJointsHTC_params
+{
+    XrBodyTrackerHTC bodyTracker;
+    const XrBodyJointsLocateInfoHTC *locateInfo;
+    XrBodyJointLocationsHTC *locations;
+    XrResult result;
+};
+
+struct xrLocateHandJointsEXT_params
+{
+    XrHandTrackerEXT handTracker;
+    const XrHandJointsLocateInfoEXT *locateInfo;
+    XrHandJointLocationsEXT *locations;
+    XrResult result;
+};
+
+struct xrLocateSceneComponentsMSFT_params
+{
+    XrSceneMSFT scene;
+    const XrSceneComponentsLocateInfoMSFT *locateInfo;
+    XrSceneComponentLocationsMSFT *locations;
+    XrResult result;
+};
+
+struct xrLocateSpace_params
+{
+    XrSpace space;
+    XrSpace baseSpace;
+    XrTime time;
+    XrSpaceLocation *location;
+    XrResult result;
+};
+
+struct xrLocateSpaces_params
+{
+    XrSession session;
+    const XrSpacesLocateInfo *locateInfo;
+    XrSpaceLocations *spaceLocations;
+    XrResult result;
+};
+
+struct xrLocateSpacesKHR_params
+{
+    XrSession session;
+    const XrSpacesLocateInfo *locateInfo;
+    XrSpaceLocations *spaceLocations;
+    XrResult result;
+};
+
+struct xrLocateViews_params
+{
+    XrSession session;
+    const XrViewLocateInfo *viewLocateInfo;
+    XrViewState *viewState;
+    uint32_t viewCapacityInput;
+    uint32_t *viewCountOutput;
+    XrView *views;
+    XrResult result;
+};
+
+struct xrPassthroughLayerPauseFB_params
+{
+    XrPassthroughLayerFB layer;
+    XrResult result;
+};
+
+struct xrPassthroughLayerResumeFB_params
+{
+    XrPassthroughLayerFB layer;
+    XrResult result;
+};
+
+struct xrPassthroughLayerSetKeyboardHandsIntensityFB_params
+{
+    XrPassthroughLayerFB layer;
+    const XrPassthroughKeyboardHandsIntensityFB *intensity;
+    XrResult result;
+};
+
+struct xrPassthroughLayerSetStyleFB_params
+{
+    XrPassthroughLayerFB layer;
+    const XrPassthroughStyleFB *style;
+    XrResult result;
+};
+
+struct xrPassthroughPauseFB_params
+{
+    XrPassthroughFB passthrough;
+    XrResult result;
+};
+
+struct xrPassthroughStartFB_params
+{
+    XrPassthroughFB passthrough;
+    XrResult result;
+};
+
+struct xrPathToString_params
+{
+    XrInstance instance;
+    XrPath path;
+    uint32_t bufferCapacityInput;
+    uint32_t *bufferCountOutput;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrPauseSimultaneousHandsAndControllersTrackingMETA_params
+{
+    XrSession session;
+    const XrSimultaneousHandsAndControllersTrackingPauseInfoMETA *pauseInfo;
+    XrResult result;
+};
+
+struct xrPerfSettingsSetPerformanceLevelEXT_params
+{
+    XrSession session;
+    XrPerfSettingsDomainEXT domain;
+    XrPerfSettingsLevelEXT level;
+    XrResult result;
+};
+
+struct xrPersistAnchorANDROID_params
+{
+    XrDeviceAnchorPersistenceANDROID handle;
+    const XrPersistedAnchorSpaceInfoANDROID *persistedInfo;
+    XrUuidEXT *anchorIdOutput;
+    XrResult result;
+};
+
+struct xrPersistSpatialAnchorAsyncBD_params
+{
+    XrSenseDataProviderBD provider;
+    const XrSpatialAnchorPersistInfoBD *info;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrPersistSpatialAnchorCompleteBD_params
+{
+    XrSenseDataProviderBD provider;
+    XrFutureEXT future;
+    XrFutureCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrPersistSpatialAnchorMSFT_params
+{
+    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
+    const XrSpatialAnchorPersistenceInfoMSFT *spatialAnchorPersistenceInfo;
+    XrResult result;
+};
+
+struct xrPersistSpatialEntityAsyncEXT_params
+{
+    XrSpatialPersistenceContextEXT persistenceContext;
+    const XrSpatialEntityPersistInfoEXT *persistInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrPersistSpatialEntityCompleteEXT_params
+{
+    XrSpatialPersistenceContextEXT persistenceContext;
+    XrFutureEXT future;
+    XrPersistSpatialEntityCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrPollEvent_params
+{
+    XrInstance instance;
+    XrEventDataBuffer *eventData;
+    XrResult result;
+};
+
+struct xrPollFutureEXT_params
+{
+    XrInstance instance;
+    const XrFuturePollInfoEXT *pollInfo;
+    XrFuturePollResultEXT *pollResult;
+    XrResult result;
+};
+
+struct xrPublishSpatialAnchorsAsyncML_params
+{
+    XrSpatialAnchorsStorageML storage;
+    const XrSpatialAnchorsPublishInfoML *publishInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrPublishSpatialAnchorsCompleteML_params
+{
+    XrSpatialAnchorsStorageML storage;
+    XrFutureEXT future;
+    XrSpatialAnchorsPublishCompletionML *completion;
+    XrResult result;
+};
+
+struct xrQueryLocalizationMapsML_params
+{
+    XrSession session;
+    const XrLocalizationMapQueryInfoBaseHeaderML *queryInfo;
+    uint32_t mapCapacityInput;
+    uint32_t *mapCountOutput;
+    XrLocalizationMapML *maps;
+    XrResult result;
+};
+
+struct xrQueryPerformanceMetricsCounterMETA_params
+{
+    XrSession session;
+    XrPath counterPath;
+    XrPerformanceMetricsCounterMETA *counter;
+    XrResult result;
+};
+
+struct xrQuerySenseDataAsyncBD_params
+{
+    XrSenseDataProviderBD provider;
+    const XrSenseDataQueryInfoBD *queryInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrQuerySenseDataCompleteBD_params
+{
+    XrSenseDataProviderBD provider;
+    XrFutureEXT future;
+    XrSenseDataQueryCompletionBD *completion;
+    XrResult result;
+};
+
+struct xrQuerySpacesFB_params
+{
+    XrSession session;
+    const XrSpaceQueryInfoBaseHeaderFB *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrQuerySpatialAnchorsAsyncML_params
+{
+    XrSpatialAnchorsStorageML storage;
+    const XrSpatialAnchorsQueryInfoBaseHeaderML *queryInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrQuerySpatialAnchorsCompleteML_params
+{
+    XrSpatialAnchorsStorageML storage;
+    XrFutureEXT future;
+    XrSpatialAnchorsQueryCompletionML *completion;
+    XrResult result;
+};
+
+struct xrQuerySpatialComponentDataEXT_params
+{
+    XrSpatialSnapshotEXT snapshot;
+    const XrSpatialComponentDataQueryConditionEXT *queryCondition;
+    XrSpatialComponentDataQueryResultEXT *queryResult;
+    XrResult result;
+};
+
+struct xrQuerySystemTrackedKeyboardFB_params
+{
+    XrSession session;
+    const XrKeyboardTrackingQueryFB *queryInfo;
+    XrKeyboardTrackingDescriptionFB *keyboard;
+    XrResult result;
+};
+
+struct xrRaycastANDROID_params
+{
+    XrSession session;
+    const XrRaycastInfoANDROID *rayInfo;
+    XrRaycastHitResultsANDROID *results;
+    XrResult result;
+};
+
+struct xrReleaseSwapchainImage_params
+{
+    XrSwapchain swapchain;
+    const XrSwapchainImageReleaseInfo *releaseInfo;
+    XrResult result;
+};
+
+struct xrRequestDisplayRefreshRateFB_params
+{
+    XrSession session;
+    float displayRefreshRate;
+    XrResult result;
+};
+
+struct xrRequestExitSession_params
+{
+    XrSession session;
+    XrResult result;
+};
+
+struct xrRequestMapLocalizationML_params
+{
+    XrSession session;
+    const XrMapLocalizationRequestInfoML *requestInfo;
+    XrResult result;
+};
+
+struct xrRequestSceneCaptureFB_params
+{
+    XrSession session;
+    const XrSceneCaptureRequestInfoFB *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrRequestWorldMeshAsyncML_params
+{
+    XrWorldMeshDetectorML detector;
+    const XrWorldMeshGetInfoML *getInfo;
+    XrWorldMeshBufferML *buffer;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrRequestWorldMeshCompleteML_params
+{
+    XrWorldMeshDetectorML detector;
+    const XrWorldMeshRequestCompletionInfoML *completionInfo;
+    XrFutureEXT future;
+    XrWorldMeshRequestCompletionML *completion;
+    XrResult result;
+};
+
+struct xrRequestWorldMeshStateAsyncML_params
+{
+    XrWorldMeshDetectorML detector;
+    const XrWorldMeshStateRequestInfoML *stateRequest;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrRequestWorldMeshStateCompleteML_params
+{
+    XrWorldMeshDetectorML detector;
+    XrFutureEXT future;
+    XrWorldMeshStateRequestCompletionML *completion;
+    XrResult result;
+};
+
+struct xrResetBodyTrackingCalibrationMETA_params
+{
+    XrBodyTrackerFB bodyTracker;
+    XrResult result;
+};
+
+struct xrResultToString_params
+{
+    XrInstance instance;
+    XrResult value;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrResumeSimultaneousHandsAndControllersTrackingMETA_params
+{
+    XrSession session;
+    const XrSimultaneousHandsAndControllersTrackingResumeInfoMETA *resumeInfo;
+    XrResult result;
+};
+
+struct xrRetrieveSpaceDiscoveryResultsMETA_params
+{
+    XrSession session;
+    XrAsyncRequestIdFB requestId;
+    XrSpaceDiscoveryResultsMETA *results;
+    XrResult result;
+};
+
+struct xrRetrieveSpaceQueryResultsFB_params
+{
+    XrSession session;
+    XrAsyncRequestIdFB requestId;
+    XrSpaceQueryResultsFB *results;
+    XrResult result;
+};
+
+struct xrSaveSpaceFB_params
+{
+    XrSession session;
+    const XrSpaceSaveInfoFB *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrSaveSpaceListFB_params
+{
+    XrSession session;
+    const XrSpaceListSaveInfoFB *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrSaveSpacesMETA_params
+{
+    XrSession session;
+    const XrSpacesSaveInfoMETA *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrSendVirtualKeyboardInputMETA_params
+{
+    XrVirtualKeyboardMETA keyboard;
+    const XrVirtualKeyboardInputInfoMETA *info;
+    XrPosef *interactorRootPose;
+    XrResult result;
+};
+
+struct xrSetColorSpaceFB_params
+{
+    XrSession session;
+    XrColorSpaceFB colorSpace;
+    XrResult result;
+};
+
+struct xrSetDigitalLensControlALMALENCE_params
+{
+    XrSession session;
+    const XrDigitalLensControlALMALENCE *digitalLensControl;
+    XrResult result;
+};
+
+struct xrSetEnvironmentDepthEstimationVARJO_params
+{
+    XrSession session;
+    XrBool32 enabled;
+    XrResult result;
+};
+
+struct xrSetEnvironmentDepthHandRemovalMETA_params
+{
+    XrEnvironmentDepthProviderMETA environmentDepthProvider;
+    const XrEnvironmentDepthHandRemovalSetInfoMETA *setInfo;
+    XrResult result;
+};
+
+struct xrSetInputDeviceActiveEXT_params
+{
+    XrSession session;
+    XrPath interactionProfile;
+    XrPath topLevelPath;
+    XrBool32 isActive;
+    XrResult result;
+};
+
+struct xrSetInputDeviceLocationEXT_params
+{
+    XrSession session;
+    XrPath topLevelPath;
+    XrPath inputSourcePath;
+    XrSpace space;
+    XrPosef pose;
+    XrResult result;
+};
+
+struct xrSetInputDeviceStateBoolEXT_params
+{
+    XrSession session;
+    XrPath topLevelPath;
+    XrPath inputSourcePath;
+    XrBool32 state;
+    XrResult result;
+};
+
+struct xrSetInputDeviceStateFloatEXT_params
+{
+    XrSession session;
+    XrPath topLevelPath;
+    XrPath inputSourcePath;
+    float state;
+    XrResult result;
+};
+
+struct xrSetInputDeviceStateVector2fEXT_params
+{
+    XrSession session;
+    XrPath topLevelPath;
+    XrPath inputSourcePath;
+    XrVector2f state;
+    XrResult result;
+};
+
+struct xrSetMarkerTrackingPredictionVARJO_params
+{
+    XrSession session;
+    uint64_t DECLSPEC_ALIGN(8) markerId;
+    XrBool32 enable;
+    XrResult result;
+};
+
+struct xrSetMarkerTrackingTimeoutVARJO_params
+{
+    XrSession session;
+    uint64_t DECLSPEC_ALIGN(8) markerId;
+    XrDuration timeout;
+    XrResult result;
+};
+
+struct xrSetMarkerTrackingVARJO_params
+{
+    XrSession session;
+    XrBool32 enabled;
+    XrResult result;
+};
+
+struct xrSetPerformanceMetricsStateMETA_params
+{
+    XrSession session;
+    const XrPerformanceMetricsStateMETA *state;
+    XrResult result;
+};
+
+struct xrSetSpaceComponentStatusFB_params
+{
+    XrSpace space;
+    const XrSpaceComponentStatusSetInfoFB *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrSetSystemNotificationsML_params
+{
+    XrInstance instance;
+    const XrSystemNotificationsSetInfoML *info;
+    XrResult result;
+};
+
+struct xrSetTrackingOptimizationSettingsHintQCOM_params
+{
+    XrSession session;
+    XrTrackingOptimizationSettingsDomainQCOM domain;
+    XrTrackingOptimizationSettingsHintQCOM hint;
+    XrResult result;
+};
+
+struct xrSetViewOffsetVARJO_params
+{
+    XrSession session;
+    float offset;
+    XrResult result;
+};
+
+struct xrSetVirtualKeyboardModelVisibilityMETA_params
+{
+    XrVirtualKeyboardMETA keyboard;
+    const XrVirtualKeyboardModelVisibilitySetInfoMETA *modelVisibility;
+    XrResult result;
+};
+
+struct xrShareSpacesFB_params
+{
+    XrSession session;
+    const XrSpaceShareInfoFB *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrShareSpacesMETA_params
+{
+    XrSession session;
+    const XrShareSpacesInfoMETA *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrShareSpatialAnchorAsyncBD_params
+{
+    XrSenseDataProviderBD provider;
+    const XrSpatialAnchorShareInfoBD *info;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrShareSpatialAnchorCompleteBD_params
+{
+    XrSenseDataProviderBD provider;
+    XrFutureEXT future;
+    XrFutureCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrSnapshotMarkerDetectorML_params
+{
+    XrMarkerDetectorML markerDetector;
+    XrMarkerDetectorSnapshotInfoML *snapshotInfo;
+    XrResult result;
+};
+
+struct xrStartColocationAdvertisementMETA_params
+{
+    XrSession session;
+    const XrColocationAdvertisementStartInfoMETA *info;
+    XrAsyncRequestIdFB *advertisementRequestId;
+    XrResult result;
+};
+
+struct xrStartColocationDiscoveryMETA_params
+{
+    XrSession session;
+    const XrColocationDiscoveryStartInfoMETA *info;
+    XrAsyncRequestIdFB *discoveryRequestId;
+    XrResult result;
+};
+
+struct xrStartEnvironmentDepthProviderMETA_params
+{
+    XrEnvironmentDepthProviderMETA environmentDepthProvider;
+    XrResult result;
+};
+
+struct xrStartSenseDataProviderAsyncBD_params
+{
+    XrSenseDataProviderBD provider;
+    const XrSenseDataProviderStartInfoBD *startInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrStartSenseDataProviderCompleteBD_params
+{
+    XrSession session;
+    XrFutureEXT future;
+    XrFutureCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrStopColocationAdvertisementMETA_params
+{
+    XrSession session;
+    const XrColocationAdvertisementStopInfoMETA *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrStopColocationDiscoveryMETA_params
+{
+    XrSession session;
+    const XrColocationDiscoveryStopInfoMETA *info;
+    XrAsyncRequestIdFB *requestId;
+    XrResult result;
+};
+
+struct xrStopEnvironmentDepthProviderMETA_params
+{
+    XrEnvironmentDepthProviderMETA environmentDepthProvider;
+    XrResult result;
+};
+
+struct xrStopHapticFeedback_params
+{
+    XrSession session;
+    const XrHapticActionInfo *hapticActionInfo;
+    XrResult result;
+};
+
+struct xrStopSenseDataProviderBD_params
+{
+    XrSenseDataProviderBD provider;
+    XrResult result;
+};
+
+struct xrStringToPath_params
+{
+    XrInstance instance;
+    const char *pathString;
+    XrPath *path;
+    XrResult result;
+};
+
+struct xrStructureTypeToString_params
+{
+    XrInstance instance;
+    XrStructureType value;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrStructureTypeToString2KHR_params
+{
+    XrInstance instance;
+    XrStructureType value;
+    char *buffer;
+    XrResult result;
+};
+
+struct xrSuggestBodyTrackingCalibrationOverrideMETA_params
+{
+    XrBodyTrackerFB bodyTracker;
+    const XrBodyTrackingCalibrationInfoMETA *calibrationInfo;
+    XrResult result;
+};
+
+struct xrSuggestInteractionProfileBindings_params
+{
+    XrInstance instance;
+    const XrInteractionProfileSuggestedBinding *suggestedBindings;
+    XrResult result;
+};
+
+struct xrSuggestVirtualKeyboardLocationMETA_params
+{
+    XrVirtualKeyboardMETA keyboard;
+    const XrVirtualKeyboardLocationInfoMETA *locationInfo;
+    XrResult result;
+};
+
+struct xrSyncActions_params
+{
+    XrSession session;
+    const XrActionsSyncInfo *syncInfo;
+    XrResult result;
+};
+
+struct xrThermalGetTemperatureTrendEXT_params
+{
+    XrSession session;
+    XrPerfSettingsDomainEXT domain;
+    XrPerfSettingsNotificationLevelEXT *notificationLevel;
+    float *tempHeadroom;
+    float *tempSlope;
+    XrResult result;
+};
+
+struct xrTriangleMeshBeginUpdateFB_params
+{
+    XrTriangleMeshFB mesh;
+    XrResult result;
+};
+
+struct xrTriangleMeshBeginVertexBufferUpdateFB_params
+{
+    XrTriangleMeshFB mesh;
+    uint32_t *outVertexCount;
+    XrResult result;
+};
+
+struct xrTriangleMeshEndUpdateFB_params
+{
+    XrTriangleMeshFB mesh;
+    uint32_t vertexCount;
+    uint32_t triangleCount;
+    XrResult result;
+};
+
+struct xrTriangleMeshEndVertexBufferUpdateFB_params
+{
+    XrTriangleMeshFB mesh;
+    XrResult result;
+};
+
+struct xrTriangleMeshGetIndexBufferFB_params
+{
+    XrTriangleMeshFB mesh;
+    uint32_t **outIndexBuffer;
+    XrResult result;
+};
+
+struct xrTriangleMeshGetVertexBufferFB_params
+{
+    XrTriangleMeshFB mesh;
+    XrVector3f **outVertexBuffer;
+    XrResult result;
+};
+
+struct xrTryCreateSpatialGraphStaticNodeBindingMSFT_params
+{
+    XrSession session;
+    const XrSpatialGraphStaticNodeBindingCreateInfoMSFT *createInfo;
+    XrSpatialGraphNodeBindingMSFT *nodeBinding;
+    XrResult result;
+};
+
+struct xrUnpersistAnchorANDROID_params
+{
+    XrDeviceAnchorPersistenceANDROID handle;
+    const XrUuidEXT *anchorId;
+    XrResult result;
+};
+
+struct xrUnpersistSpatialAnchorAsyncBD_params
+{
+    XrSenseDataProviderBD provider;
+    const XrSpatialAnchorUnpersistInfoBD *info;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrUnpersistSpatialAnchorCompleteBD_params
+{
+    XrSenseDataProviderBD provider;
+    XrFutureEXT future;
+    XrFutureCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrUnpersistSpatialAnchorMSFT_params
+{
+    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
+    const XrSpatialAnchorPersistenceNameMSFT *spatialAnchorPersistenceName;
+    XrResult result;
+};
+
+struct xrUnpersistSpatialEntityAsyncEXT_params
+{
+    XrSpatialPersistenceContextEXT persistenceContext;
+    const XrSpatialEntityUnpersistInfoEXT *unpersistInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrUnpersistSpatialEntityCompleteEXT_params
+{
+    XrSpatialPersistenceContextEXT persistenceContext;
+    XrFutureEXT future;
+    XrUnpersistSpatialEntityCompletionEXT *completion;
+    XrResult result;
+};
+
+struct xrUpdateHandMeshMSFT_params
+{
+    XrHandTrackerEXT handTracker;
+    const XrHandMeshUpdateInfoMSFT *updateInfo;
+    XrHandMeshMSFT *handMesh;
+    XrResult result;
+};
+
+struct xrUpdatePassthroughColorLutMETA_params
+{
+    XrPassthroughColorLutMETA colorLut;
+    const XrPassthroughColorLutUpdateInfoMETA *updateInfo;
+    XrResult result;
+};
+
+struct xrUpdateSpatialAnchorsExpirationAsyncML_params
+{
+    XrSpatialAnchorsStorageML storage;
+    const XrSpatialAnchorsUpdateExpirationInfoML *updateInfo;
+    XrFutureEXT *future;
+    XrResult result;
+};
+
+struct xrUpdateSpatialAnchorsExpirationCompleteML_params
+{
+    XrSpatialAnchorsStorageML storage;
+    XrFutureEXT future;
+    XrSpatialAnchorsUpdateExpirationCompletionML *completion;
+    XrResult result;
+};
+
+struct xrUpdateSwapchainFB_params
+{
+    XrSwapchain swapchain;
+    const XrSwapchainStateBaseHeaderFB *state;
+    XrResult result;
+};
+
+struct xrWaitFrame_params
+{
+    XrSession session;
+    const XrFrameWaitInfo *frameWaitInfo;
+    XrFrameState *frameState;
+    XrResult result;
+};
+
+struct xrWaitSwapchainImage_params
+{
+    XrSwapchain swapchain;
+    const XrSwapchainImageWaitInfo *waitInfo;
+    XrResult result;
+};
+
+#endif /* __WINE_OPENXR_LOADER_THUNKS_H */
diff --git a/dlls/wineopenxr/make_openxr b/dlls/wineopenxr/make_openxr
new file mode 100755
index 00000000000..ff0d387dbb1
--- /dev/null
+++ b/dlls/wineopenxr/make_openxr
@@ -0,0 +1,3583 @@
+#!/usr/bin/env python3
+# Wine Vulkan generator
+#
+# Copyright 2017-2018 Roderick Colenbrander
+# Copyright 2022 Jacek Caban for CodeWeavers
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+#  License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+#
+
+import argparse
+import logging
+import os
+import re
+import urllib.request
+import xml.etree.ElementTree as ET
+from collections import OrderedDict
+from collections.abc import Sequence
+from enum import Enum
+
+# This script generates code for a Wine Vulkan ICD driver from Vulkan's xr.xml.
+# Generating the code is like 10x worse than OpenGL, which is mostly a calling
+# convention passthrough.
+#
+# The script parses xr.xml and maps functions and types to helper objects. These
+# helper objects simplify the xml parsing and map closely to the Vulkan types.
+# The code generation utilizes the helper objects during code generation and
+# most of the ugly work is carried out by these objects.
+#
+# Vulkan ICD challenges:
+# - Vulkan ICD loader (openxr-1.dll) relies on a section at the start of
+#   'dispatchable handles' (e.g. XrDevice, XrInstance) for it to insert
+#   its private data. It uses this area to stare its own dispatch tables
+#   for loader internal use. This means any dispatchable objects need wrapping.
+#
+# - Vulkan structures have different alignment between win32 and 32-bit Linux.
+#   This means structures with alignment differences need conversion logic.
+#   Often structures are nested, so the parent structure may not need any
+#   conversion, but some child may need some.
+#
+# xr.xml parsing challenges:
+# - Contains type data for all platforms (generic Vulkan, Windows, Linux,..).
+#   Parsing of extension information required to pull in types and functions
+#   we really want to generate. Just tying all the data together is tricky.
+#
+# - Extensions can affect core types e.g. add new enum values, bitflags or
+#   additional structure chaining through 'next' / 'type'.
+#
+# - Arrays are used all over the place for parameters or for structure members.
+#   Array length is often stored in a previous parameter or another structure
+#   member and thus needs careful parsing.
+
+LOGGER = logging.Logger("openxr")
+LOGGER.addHandler(logging.StreamHandler())
+
+XR_XML_VERSION = "1.1.52"
+WINE_XR_VERSION = (1, 1)
+
+# Filenames to create.
+WINE_OPENXR_H = "./wineopenxr.h"
+WINE_OPENXR_JSON = "./wineopenxr.json"
+WINE_OPENXR_THUNKS_C = "./openxr_thunks.c"
+WINE_OPENXR_THUNKS_H = "./openxr_thunks.h"
+WINE_OPENXR_LOADER_THUNKS_C = "./loader_thunks.c"
+WINE_OPENXR_LOADER_THUNKS_H = "./loader_thunks.h"
+
+# Extension enum values start at a certain offset (EXT_BASE).
+# Relative to the offset each extension has a block (EXT_BLOCK_SIZE)
+# of values.
+# Start for a given extension is:
+# EXT_BASE + (extension_number-1) * EXT_BLOCK_SIZE
+EXT_BASE = 1000000000
+EXT_BLOCK_SIZE = 1000
+
+UNSUPPORTED_EXTENSIONS = [
+    # Handling of XR_EXT_debug_report requires some consideration. The win32
+    # loader already provides it for us and it is somewhat usable. If we add
+    # plumbing down to the native layer, we will get each message twice as we
+    # use 2 loaders (win32+native), but we may get output from the driver.
+    # In any case callback conversion is required.
+    "XR_EXT_debug_utils",
+    "XR_KHR_loader_init",
+    "XR_MSFT_perception_anchor_interop",
+    "XR_HTC_foveation",
+]
+
+# Functions part of our wineopenxr graphics driver interface.
+# DRIVER_VERSION should be bumped on any change to driver interface
+# in FUNCTION_OVERRIDES
+DRIVER_VERSION = 1
+
+# Table of functions for which we have a special implementation.
+# These are regular device / instance functions for which we need
+# to do more work compared to a regular thunk or because they are
+# part of the driver interface.
+# - dispatch (default: True):  set whether we need a function pointer in the device / instance dispatch table.
+FUNCTION_OVERRIDES = {
+    # Global functions
+    "xrCreateInstance" : {"dispatch" : False},
+
+    "xrCreateSession" : {"dispatch" : True},
+
+    "xrGetInstanceProcAddr" : {"dispatch" : False},
+    "xrEnumerateInstanceExtensionProperties" : {"dispatch" : False},
+
+    "xrConvertTimeToWin32PerformanceCounterKHR" : {"dispatch" : False},
+    "xrConvertWin32PerformanceCounterToTimeKHR" : {"dispatch" : False},
+    "xrGetD3D11GraphicsRequirementsKHR" : {"dispatch" : False},
+    "xrGetD3D12GraphicsRequirementsKHR" : {"dispatch" : False},
+
+    "xrGetVulkanGraphicsDeviceKHR" : {"dispatch" : True},
+    "xrGetVulkanGraphicsDevice2KHR" : {"dispatch" : True},
+    "xrGetVulkanDeviceExtensionsKHR" : {"dispatch" : True},
+    "xrGetVulkanInstanceExtensionsKHR" : {"dispatch" : True},
+
+    "xrCreateSwapchain" : {"dispatch" : True},
+}
+
+# functions for which a user driver entry must be generated
+USER_DRIVER_FUNCS = {}
+
+# functions for which the unix thunk is manually implemented
+MANUAL_UNIX_THUNKS = {
+    "xrCreateInstance",
+    "xrCreateSession",
+    "xrCreateSwapchain",
+    "xrGetInstanceProcAddr",
+    "xrEnumerateInstanceExtensionProperties",
+    "xrConvertTimeToWin32PerformanceCounterKHR",
+    "xrConvertWin32PerformanceCounterToTimeKHR",
+    "xrGetD3D11GraphicsRequirementsKHR",
+    "xrGetD3D12GraphicsRequirementsKHR",
+    "xrGetVulkanGraphicsDeviceKHR",
+    "xrGetVulkanGraphicsDevice2KHR",
+    "xrGetVulkanInstanceExtensionsKHR",
+}
+
+# loader functions which are entirely manually implemented
+MANUAL_LOADER_FUNCTIONS = {
+    "xrConvertTimeToWin32PerformanceCounterKHR",
+    "xrConvertWin32PerformanceCounterToTimeKHR",
+    "xrGetD3D11GraphicsRequirementsKHR",
+    "xrGetD3D12GraphicsRequirementsKHR",
+    "xrCreateApiLayerInstance",
+    "xrGetInstanceProcAddr",
+    "xrNegotiateLoaderRuntimeInterface",
+    "xrNegotiateLoaderApiLayerInterface",
+    "xrCreateVulkanInstanceKHR",
+    "xrCreateVulkanDeviceKHR"
+}
+
+# functions which loader thunks are manually implemented
+MANUAL_LOADER_THUNKS = {
+    "xrCreateInstance",
+    "xrDestroyInstance",
+    "xrCreateSession",
+    "xrDestroySession",
+    "xrPollEvent",
+    "xrGetSystem",
+    "xrEnumerateSwapchainFormats",
+    "xrCreateSwapchain",
+    "xrDestroySwapchain",
+    "xrEnumerateSwapchainImages",
+    "xrAcquireSwapchainImage",
+    "xrReleaseSwapchainImage",
+    "xrBeginFrame",
+    "xrEndFrame",
+    "xrGetVulkanDeviceExtensionsKHR",
+}
+
+STRUCT_CHAIN_CONVERSIONS = {
+    "XrInstanceCreateInfo": [],
+}
+
+UNEXPOSED_EXTENSIONS = {}
+STRUCT_COPY = {};
+
+# Some struct members are conditionally ignored and callers are free to leave them uninitialized.
+# We can't deduce that from XML, so we allow expressing it here.
+MEMBER_LENGTH_EXPRESSIONS = {}
+
+PERF_CRITICAL_FUNCTIONS = []
+
+ALLOWED_PROTECTS = [
+        "XR_USE_PLATFORM_WIN32",
+        "XR_USE_GRAPHICS_API_VULKAN",
+        "XR_USE_GRAPHICS_API_OPENGL",
+        "XR_USE_GRAPHICS_API_D3D11",
+        "XR_USE_GRAPHICS_API_D3D12",
+]
+NOT_OUR_FUNCTIONS = [
+    # xr.xml defines that as a part of XR_LOADER_VERSION_1_0 commands but it looks like only layers should provide it
+    # (through dll export).
+    "xrNegotiateLoaderApiLayerInterface",
+]
+
+class Direction(Enum):
+    """ Parameter direction: input, output, input_output. """
+    INPUT = 1
+    OUTPUT = 2
+
+
+class Unwrap(Enum):
+    NONE = 0
+    HOST = 1
+    DRIVER = 2
+
+
+def api_is_openxr(obj):
+    return "openxr" in obj.get("api", "openxr").split(",")
+
+
+def convert_suffix(direction, win_type, unwrap, is_wrapped):
+    if direction == Direction.OUTPUT:
+        if not is_wrapped:
+            return "host_to_{0}".format(win_type)
+        if unwrap == Unwrap.NONE:
+            return "unwrapped_host_to_{0}".format(win_type)
+        if unwrap == Unwrap.DRIVER:
+            return "driver_to_{0}".format(win_type)
+        return "host_to_{0}".format(win_type)
+    else:
+        if not is_wrapped:
+            return "{0}_to_host".format(win_type)
+        if unwrap == Unwrap.NONE:
+            return "{0}_to_unwrapped_host".format(win_type)
+        if unwrap == Unwrap.DRIVER:
+            return "{0}_to_driver".format(win_type)
+        return "{0}_to_host".format(win_type)
+
+
+class XrBaseType(object):
+    def __init__(self, name, _type, alias=None, requires=None):
+        """ Vulkan base type class.
+
+        XrBaseType is mostly used by Vulkan to define its own
+        base types like XrFlags through typedef out of e.g. uint32_t.
+
+        Args:
+            name (:obj:'str'): Name of the base type.
+            _type (:obj:'str'): Underlying type
+            alias (bool): type is an alias or not.
+            requires (:obj:'str', optional): Other types required.
+                Often bitmask values pull in a *FlagBits type.
+        """
+        self.name = name
+        self.type = _type
+        self.alias = alias
+        self.requires = requires
+        self.required = False
+
+    def definition(self):
+        # Definition is similar for alias or non-alias as type
+        # is already set to alias.
+        if not self.type is None:
+            return "typedef {0} {1};\n".format(self.type, self.name)
+        else:
+            return "struct {0};\n".format(self.name)
+
+    def is_alias(self):
+        return bool(self.alias)
+
+
+class XrConstant(object):
+    def __init__(self, name, value):
+        self.name = name
+        self.value = value
+
+    def definition(self):
+        text = "#define {0} {1}\n".format(self.name, self.value)
+        return text
+
+
+class XrDefine(object):
+    def __init__(self, name, value):
+        self.name = name
+        self.value = value
+
+    @staticmethod
+    def from_xml(define):
+        if not api_is_openxr(define):
+            return None
+
+        name_elem = define.find("name")
+
+        if name_elem is None:
+            # <type category="define" name="some_name">some_value</type>
+            name = define.attrib.get("name")
+
+            # We override behavior of XR_USE_64_BIT_PTR_DEFINES as the default non-dispatchable handle
+            # definition various between 64-bit (uses pointers) and 32-bit (uses uint64_t).
+            # This complicates TRACEs in the thunks, so just use uint64_t.
+            if name == "XR_USE_64_BIT_PTR_DEFINES":
+                value = "#define XR_USE_64_BIT_PTR_DEFINES 0"
+            else:
+                value = define.text
+            return XrDefine(name, value)
+
+        # With a name element the structure is like:
+        # <type category="define"><name>some_name</name>some_value</type>
+        name = name_elem.text
+
+        # Perform minimal parsing for Vulkan constants, which we don't need, but are referenced
+        # elsewhere in xr.xml.
+        # - XR_API_VERSION is a messy, deprecated constant and we don't want generate code for it.
+        # - AHardwareBuffer/ANativeWindow are forward declarations for Android types, which leaked
+        #   into the define region.
+        if name in ["XR_API_VERSION", "AHardwareBuffer", "ANativeWindow", "CAMetalLayer"]:
+            return XrDefine(name, None)
+
+        # The body of the define is basically unstructured C code. It is not meant for easy parsing.
+        # Some lines contain deprecated values or comments, which we try to filter out.
+        value = ""
+        for line in define.text.splitlines():
+            value += "\n"
+            # Skip comments or deprecated values.
+            if "//" in line:
+                continue
+            value += line
+
+        for child in define:
+            value += child.text
+            if child.tail is not None:
+                # Split comments for XR_API_VERSION_1_0 / XR_API_VERSION_1_1
+                if "//" in child.tail:
+                    value += child.tail.split("//")[0]
+                else:
+                    value += child.tail
+
+        return XrDefine(name, value.rstrip(' '))
+
+    def definition(self):
+        if self.value is None:
+            return ""
+
+        # Nothing to do as the value was already put in the right form during parsing.
+        return "{0}\n".format(self.value)
+
+    def is_alias(self):
+        return False
+
+class XrEnum(object):
+    def __init__(self, name, bitwidth, alias=None):
+        if not bitwidth in [32, 64]:
+            LOGGER.error("unknown bitwidth {0} for {1}".format(bitwidth, name))
+        self.name = name
+        self.bitwidth = bitwidth
+        self.values = [] if alias == None else alias.values
+        self.required = False
+        self.alias = alias
+        self.aliased_by = []
+
+    @staticmethod
+    def from_alias(enum, alias):
+        name = enum.attrib.get("name")
+        aliasee = XrEnum(name, alias.bitwidth, alias=alias)
+
+        alias.add_aliased_by(aliasee)
+        return aliasee
+
+    @staticmethod
+    def from_xml(enum):
+        if not api_is_openxr(enum):
+            return None
+
+        name = enum.attrib.get("name")
+        bitwidth = int(enum.attrib.get("bitwidth", "32"))
+        result = XrEnum(name, bitwidth)
+
+        for v in enum.findall("enum"):
+            value_name = v.attrib.get("name")
+            # Value is either a value or a bitpos, only one can exist.
+            value = v.attrib.get("value")
+            alias_name = v.attrib.get("alias")
+            if alias_name:
+                result.create_alias(value_name, alias_name)
+            elif value:
+                result.create_value(value_name, value)
+            else:
+                # bitmask
+                result.create_bitpos(value_name, int(v.attrib.get("bitpos")))
+
+        if bitwidth == 32:
+            # openxr.h contains a *_MAX_ENUM value set to 32-bit at the time of writing,
+            # which is to prepare for extensions as they can add values and hence affect
+            # the size definition.
+            max_name = re.sub(r'([0-9a-z_])([A-Z0-9])',r'\1_\2', name).upper() + "_MAX_ENUM"
+            result.create_value(max_name, "0x7fffffff")
+
+        return result
+
+    def create_alias(self, name, alias_name):
+        """ Create an aliased value for this enum """
+        self.add(XrEnumValue(name, self.bitwidth, alias=alias_name))
+
+    def create_value(self, name, value):
+        """ Create a new value for this enum """
+        # Some values are in hex form. We want to preserve the hex representation
+        # at least when we convert back to a string. Internally we want to use int.
+        hex = "0x" in value
+        self.add(XrEnumValue(name, self.bitwidth, value=int(value, 0), hex=hex))
+
+    def create_bitpos(self, name, pos):
+        """ Create a new bitmask value for this enum """
+        self.add(XrEnumValue(name, self.bitwidth, value=(1 << pos), hex=True))
+
+    def add(self, value):
+        """ Add a value to enum. """
+
+        # Extensions can add new enum values. When an extension is promoted to Core
+        # the registry defines the value twice once for old extension and once for
+        # new Core features. Add the duplicate if it's explicitly marked as an
+        # alias, otherwise ignore it.
+        for v in self.values:
+            if not value.is_alias() and v.value == value.value:
+                LOGGER.debug("Adding duplicate enum value {0} to {1}".format(v, self.name))
+                return
+        # Avoid adding duplicate aliases multiple times
+        if not any(x.name == value.name for x in self.values):
+            self.values.append(value)
+
+    def fixup_64bit_aliases(self):
+        """ Replace 64bit aliases with literal values """
+        # Older GCC versions need a literal to initialize a static const uint64_t
+        # which is what we use for 64bit bitmasks.
+        if self.bitwidth != 64:
+            return
+        for value in self.values:
+            if not value.is_alias():
+                continue
+            alias = next(x for x in self.values if x.name == value.alias)
+            value.hex = alias.hex
+            value.value = alias.value
+
+    def definition(self):
+        if self.is_alias():
+            return ""
+
+        default_value = 0x7ffffffe if self.bitwidth == 32 else 0xfffffffffffffffe
+
+        # Print values sorted, values can have been added in a random order.
+        values = sorted(self.values, key=lambda value: value.value if value.value is not None else default_value)
+
+        if self.bitwidth == 32:
+            text = "typedef enum {0}\n{{\n".format(self.name)
+            for value in values:
+                text += "    {0},\n".format(value.definition())
+            text += "}} {0};\n".format(self.name)
+        elif self.bitwidth == 64:
+            text = "typedef XrFlags64 {0};\n\n".format(self.name)
+            for value in values:
+                text += "static const {0} {1};\n".format(self.name, value.definition())
+
+        for aliasee in self.aliased_by:
+            text += "typedef {0} {1};\n".format(self.name, aliasee.name)
+
+        text += "\n"
+        return text
+
+    def is_alias(self):
+        return bool(self.alias)
+
+    def add_aliased_by(self, aliasee):
+        self.aliased_by.append(aliasee)
+
+
+class XrEnumValue(object):
+    def __init__(self, name, bitwidth, value=None, hex=False, alias=None):
+        self.name = name
+        self.bitwidth = bitwidth
+        self.value = value
+        self.hex = hex
+        self.alias = alias
+
+    def __repr__(self):
+        postfix = "ull" if self.bitwidth == 64 else ""
+        if self.is_alias() and self.value == None:
+            return "{0}={1}".format(self.name, self.alias)
+        return "{0}={1}{2}".format(self.name, self.value, postfix)
+
+    def definition(self):
+        """ Convert to text definition e.g. XR_FOO = 1 """
+        postfix = "ull" if self.bitwidth == 64 else ""
+        if self.is_alias() and self.value == None:
+            return "{0} = {1}".format(self.name, self.alias)
+
+        # Hex is commonly used for FlagBits and sometimes within
+        # a non-FlagBits enum for a bitmask value as well.
+        if self.hex:
+            return "{0} = 0x{1:08x}{2}".format(self.name, self.value, postfix)
+        else:
+            return "{0} = {1}{2}".format(self.name, self.value, postfix)
+
+    def is_alias(self):
+        return self.alias is not None
+
+
+class XrFunction(object):
+    def __init__(self, _type=None, name=None, params=[], alias=None):
+        self.extensions = set()
+        self.name = name
+        self.type = _type
+        self.params = params
+        self.alias = alias
+
+        # For some functions we need some extra metadata from FUNCTION_OVERRIDES.
+        func_info = FUNCTION_OVERRIDES.get(self.name, {})
+        self.dispatch = func_info.get("dispatch", True)
+        self.extra_param = func_info.get("extra_param", None)
+
+        # Required is set while parsing which APIs and types are required
+        # and is used by the code generation.
+        self.required = True if func_info else False
+
+        if self.name in MANUAL_UNIX_THUNKS:
+            self.unwrap = Unwrap.NONE
+        elif self.name in USER_DRIVER_FUNCS:
+            self.unwrap = Unwrap.DRIVER
+        else:
+            self.unwrap = Unwrap.HOST
+
+    @staticmethod
+    def from_alias(command, alias):
+        """ Create XrFunction from an alias command.
+
+        Args:
+            command: xml data for command
+            alias (XrFunction): function to use as a base for types / parameters.
+
+        Returns:
+            XrFunction
+        """
+        if not api_is_openxr(command):
+            return None
+
+        func_name = command.attrib.get("name")
+        func_type = alias.type
+        params = alias.params
+
+        return XrFunction(_type=func_type, name=func_name, params=params, alias=alias)
+
+    @staticmethod
+    def from_xml(command, types):
+        if not api_is_openxr(command):
+            return None
+
+        proto = command.find("proto")
+        func_name = proto.find("name").text
+        func_type = proto.find("type").text
+
+        params = []
+        for param in command.findall("param"):
+            xr_param = XrParam.from_xml(param, types, params)
+            if xr_param:
+                params.append(xr_param)
+
+        return XrFunction(_type=func_type, name=func_name, params=params)
+
+    def get_conversions(self):
+        """ Get a list of conversion functions required for this function if any.
+        Parameters which are structures may require conversion between win32
+        and the host platform. This function returns a list of conversions
+        required.
+        """
+
+        conversions = []
+        for param in self.params:
+            conversions.extend(param.get_conversions(self.unwrap))
+        return conversions
+
+    def is_alias(self):
+        return bool(self.alias)
+
+    def is_core_func(self):
+        """ Returns whether the function is a Vulkan core function.
+        Core functions are APIs defined by the Vulkan spec to be part of the
+        Core API as well as several KHR WSI extensions.
+        """
+
+        if not self.extensions:
+            return True
+
+        return any(ext in self.extensions for ext in CORE_EXTENSIONS)
+
+    def is_device_func(self):
+        # If none of the other, it must be a device function
+        return not self.is_global_func() and not self.is_instance_func() and not self.is_phys_dev_func()
+
+    def is_driver_func(self):
+        """ Returns if function is part of Wine driver interface. """
+        return self.name in USER_DRIVER_FUNCS
+
+    def is_global_func(self):
+        # Treat xrGetInstanceProcAddr as a global function as it
+        # can operate with NULL for xrInstance.
+        if self.name == "xrGetInstanceProcAddr":
+            return True
+        # Global functions are not passed a dispatchable object.
+        elif self.params[0].is_dispatchable():
+            return False
+        return True
+
+    def is_instance_func(self):
+        # Instance functions are passed XrInstance.
+        if self.params[0].type == "XrInstance":
+            return True
+        return False
+
+    def is_phys_dev_func(self):
+        # Physical device functions are passed XrPhysicalDevice.
+        if self.params[0].type == "XrPhysicalDevice":
+            return True
+        return False
+
+    def is_required(self):
+        return self.required
+
+    def returns_longlong(self):
+        return self.type in ["uint64_t", "XrDeviceAddress"]
+
+    def needs_dispatch(self):
+        return self.dispatch
+
+    def needs_private_thunk(self):
+        return self.needs_exposing() and self.name not in MANUAL_LOADER_FUNCTIONS and \
+            self.name in MANUAL_UNIX_THUNKS
+
+    def needs_exposing(self):
+        # The function needs exposed if at-least one extension isn't both UNSUPPORTED and UNEXPOSED
+        return self.is_required() and (not self.extensions or not self.extensions.issubset(UNEXPOSED_EXTENSIONS))
+
+    def is_perf_critical(self):
+        # xrCmd* functions are frequently called, do not trace for performance
+        if self.name.startswith("xrCmd") and self.type == "void":
+            return True
+        return self.name in PERF_CRITICAL_FUNCTIONS
+
+    def pfn(self, prefix="p", call_conv=None):
+        """ Create function pointer. """
+
+        if call_conv:
+            pfn = "{0} ({1} *{2}_{3})(".format(self.type, call_conv, prefix, self.name)
+        else:
+            pfn = "{0} (*{1}_{2})(".format(self.type, prefix, self.name)
+
+        for i, param in enumerate(self.params):
+            if param.const:
+                pfn += param.const + " "
+
+            pfn += param.type
+
+            if param.is_pointer():
+                pfn += " " + param.pointer
+
+            if param.array_len is not None:
+                pfn += "[{0}]".format(param.array_len)
+
+            if i < len(self.params) - 1:
+                pfn += ", "
+        pfn += ")"
+        return pfn
+
+    def prototype(self, call_conv=None, prefix=None, is_thunk=False):
+        """ Generate prototype for given function.
+
+        Args:
+            call_conv (str, optional): calling convention e.g. WINAPI
+            prefix (str, optional): prefix to append prior to function name e.g. xrFoo -> wine_xrFoo
+        """
+
+        proto = "{0}".format(self.type)
+
+        if call_conv is not None:
+            proto += " {0}".format(call_conv)
+
+        if prefix is not None:
+            proto += " {0}{1}(".format(prefix, self.name)
+        else:
+            proto += " {0}(".format(self.name)
+
+        # Add all the parameters.
+        proto += ", ".join([p.definition() for p in self.params])
+
+        if is_thunk and self.extra_param:
+            extra_param_is_new = True
+            for p in self.params:
+                if p.name == self.extra_param:
+                    extra_param_is_new = False
+            if extra_param_is_new:
+                proto += ", void *" + self.extra_param
+            else:
+                proto += ", void *win_" + self.extra_param
+
+        proto += ")"
+        return proto
+
+    def loader_body(self):
+        body = "    struct {0}_params params;\n".format(self.name)
+        if not self.is_perf_critical():
+            body += "    NTSTATUS _status;\n"
+        for p in self.params:
+            body += "    params.{0} = {0};\n".format(p.name)
+
+        # Call the Unix function.
+        if self.is_perf_critical():
+            body += "    UNIX_CALL({0}, &params);\n".format(self.name)
+        else:
+            body += "    _status = UNIX_CALL({0}, &params);\n".format(self.name)
+            body += "    assert(!_status && \"{0}\");\n".format(self.name)
+
+        if self.type != "void":
+            body += "    return params.result;\n"
+        return body
+
+    def body(self, conv, params_prefix=""):
+        body = ""
+        needs_alloc = False
+        deferred_op = None
+
+        # Declare any tmp parameters for conversion.
+        for p in self.params:
+            if p.needs_variable(conv, self.unwrap):
+                if p.is_dynamic_array():
+                    body += "    {2}{0} *{1}_host;\n".format(
+                        p.type, p.name, "const " if p.is_const() else "")
+                elif p.optional:
+                    body += "    {0} *{1}_host = NULL;\n".format(p.type, p.name)
+                    needs_alloc = True
+                else:
+                    body += "    {0} {1}_host;\n".format(p.type, p.name)
+            if p.needs_alloc(conv, self.unwrap):
+                needs_alloc = True
+            if p.type == "XrDeferredOperationKHR" and not p.is_pointer():
+                deferred_op = p.name
+
+        if needs_alloc:
+            body += "    struct conversion_context local_ctx;\n"
+            body += "    struct conversion_context *ctx = &local_ctx;\n"
+        body += "\n"
+
+        if not self.is_perf_critical():
+            body += "    {0}\n".format(self.trace(params_prefix=params_prefix, conv=conv))
+
+        if self.params[0].optional and self.params[0].is_handle():
+            if self.type != "void":
+                LOGGER.warning("return type {0} with optional handle not supported".format(self.type))
+            body += "    if (!{0}{1})\n".format(params_prefix, self.params[0].name)
+            body += "        return STATUS_SUCCESS;\n\n"
+
+        if needs_alloc:
+            if deferred_op is not None:
+                body += "    if (params->{} == XR_NULL_HANDLE)\n".format(deferred_op)
+                body += "    "
+            body += "    init_conversion_context(ctx);\n"
+            if deferred_op is not None:
+                body += "    else\n"
+                body += "        ctx = &wine_deferred_operation_from_handle(params->{})->ctx;\n".format(deferred_op)
+
+        # Call any win_to_host conversion calls.
+        unwrap = self.name not in MANUAL_UNIX_THUNKS
+        for p in self.params:
+            if p.needs_conversion(conv, self.unwrap, Direction.INPUT):
+                body += p.copy(Direction.INPUT, conv, self.unwrap, prefix=params_prefix)
+            elif p.is_dynamic_array() and p.needs_conversion(conv, self.unwrap, Direction.OUTPUT):
+                body += "    {0}_host = ({2}{0} && {1}) ? conversion_context_alloc(ctx, sizeof(*{0}_host) * {1}) : NULL;\n".format(
+                    p.name, p.get_dyn_array_len(params_prefix, conv), params_prefix)
+
+        # Build list of parameters containing converted and non-converted parameters.
+        # The param itself knows if conversion is needed and applies it when we set conv=True.
+        unwrap = Unwrap.NONE if self.name in MANUAL_UNIX_THUNKS else self.unwrap
+        params = ", ".join([p.variable(conv, unwrap, params_prefix) for p in self.params])
+        if self.extra_param:
+            if conv:
+                params += ", UlongToPtr({0}{1})".format(params_prefix, self.extra_param)
+            else:
+                params += ", (void *){0}{1}".format(params_prefix, self.extra_param)
+
+        if self.name not in MANUAL_UNIX_THUNKS:
+            func_prefix = "g_xr_host_instance_dispatch_table.p_"
+        else:
+            func_prefix = "wine_"
+
+        # Call the host Vulkan function.
+        if self.type == "void":
+            body += "    {0}{1}({2});\n".format(func_prefix, self.name, params)
+        else:
+            body += "    {0}result = {1}{2}({3});\n".format(params_prefix, func_prefix, self.name, params)
+
+        # Call any host_to_win conversion calls.
+        for p in self.params:
+            if p.needs_conversion(conv, self.unwrap, Direction.OUTPUT):
+                body += p.copy(Direction.OUTPUT, conv, self.unwrap, prefix=params_prefix)
+
+        if needs_alloc:
+            if deferred_op is not None:
+                body += "    if (params->{} == XR_NULL_HANDLE)\n".format(deferred_op)
+                body += "    "
+            body += "    free_conversion_context(ctx);\n"
+
+        # Finally return the result. Performance critical functions return void to allow tail calls.
+        if not self.is_perf_critical():
+            body += "    return STATUS_SUCCESS;\n"
+
+        return body
+
+    def spec(self, prefix=None, symbol=None):
+        """ Generate spec file entry for this function.
+
+        Args
+            prefix (str, optional): prefix to prepend to entry point name.
+            symbol (str, optional): allows overriding the name of the function implementing the entry point.
+        """
+
+        spec = ""
+        params = " ".join([p.spec() for p in self.params])
+        if prefix is not None:
+            spec += "@ stdcall -private {0}{1}({2})".format(prefix, self.name, params)
+        else:
+            spec += "@ stdcall {0}({1})".format(self.name, params)
+
+        if symbol is not None:
+            spec += " " + symbol
+
+        spec += "\n"
+        return spec
+
+    def stub(self, call_conv=None, prefix=None):
+        stub = self.prototype(call_conv=call_conv, prefix=prefix)
+        stub += "\n{\n"
+        stub += "    {0}".format(self.trace(message="stub: ", trace_func="FIXME"))
+
+        if self.type == "XrResult":
+            stub += "    return XR_ERROR_OUT_OF_HOST_MEMORY;\n"
+        elif self.type == "XrBool32":
+            stub += "    return XR_FALSE;\n"
+        elif self.type == "PFN_xrVoidFunction":
+            stub += "    return NULL;\n"
+
+        stub += "}\n\n"
+        return stub
+
+    def thunk(self, prefix=None, conv=False):
+        thunk = ""
+        if not conv:
+            thunk += "#ifdef _WIN64\n"
+        if self.is_perf_critical():
+            thunk += "static void {0}{1}(void *args)\n".format(prefix, self.name)
+        else:
+            thunk += "static NTSTATUS {0}{1}(void *args)\n".format(prefix, self.name)
+        thunk += "{\n"
+        if conv:
+            thunk += "    struct\n"
+            thunk += "    {\n"
+            extra_param_is_new = True
+            for p in self.params:
+                thunk += "        {0};\n".format(p.definition(conv=True, is_member=True))
+                if p.name == self.extra_param:
+                    extra_param_is_new = False
+            if self.extra_param and extra_param_is_new:
+                thunk += "        PTR32 {0};\n".format(self.extra_param)
+            if self.type != "void":
+                thunk += "        {0} result;\n".format(self.type)
+            thunk += "    } *params = args;\n"
+        else:
+            thunk += "    struct {0}_params *params = args;\n".format(self.name)
+        thunk += self.body(conv, params_prefix="params->")
+        thunk += "}\n"
+        if not conv:
+            thunk += "#endif /* _WIN64 */\n"
+        thunk += "\n"
+        return thunk
+
+    def loader_thunk(self, prefix=None):
+        thunk = self.prototype(call_conv="WINAPI", prefix=prefix)
+        thunk += "\n{\n"
+        thunk += self.loader_body()
+        thunk += "}\n\n"
+        return thunk
+
+    def trace(self, message=None, trace_func=None, params_prefix="", conv=False):
+        """ Create a trace string including all parameters.
+
+        Args:
+            message (str, optional): text to print at start of trace message e.g. 'stub: '
+            trace_func (str, optional): used to override trace function e.g. FIXME, printf, etcetera.
+        """
+        if trace_func is not None:
+            trace = "{0}(\"".format(trace_func)
+        else:
+            trace = "TRACE(\""
+
+        if message is not None:
+            trace += message
+
+        # First loop is for all the format strings.
+        trace += ", ".join([p.format_string(conv) for p in self.params])
+        trace += "\\n\""
+
+        # Second loop for parameter names and optional conversions.
+        for param in self.params:
+            if param.format_conv is not None:
+                trace += ", " + param.format_conv.format("{0}{1}".format(params_prefix, param.name))
+            else:
+                trace += ", {0}{1}".format(params_prefix, param.name)
+        trace += ");\n"
+
+        return trace
+
+
+class XrFunctionPointer(object):
+    def __init__(self, _type, name, members, forward_decls, params_text):
+        self.name = name
+        self.members = members
+        self.type = _type
+        self.required = False
+        self.forward_decls = forward_decls
+        self.params_text = params_text
+
+    @staticmethod
+    def from_xml(funcpointer):
+        members = []
+        begin = None
+
+        for t in funcpointer.findall("type"):
+            # General form:
+            # <type>void</type>*       pUserData,
+            # Parsing of the tail (anything past </type>) is tricky since there
+            # can be other data on the next line like: const <type>int</type>..
+
+            const = True if begin and "const" in begin else False
+            _type = t.text
+            lines = t.tail.split(",\n")
+            if lines[0][0] == "*":
+                pointer = "*"
+                name = lines[0][1:].strip()
+            else:
+                pointer = None
+                name = lines[0].strip()
+
+            # Filter out ); if it is contained.
+            name = name.partition(");")[0]
+
+            # If tail encompasses multiple lines, assign the second line to begin
+            # for the next line.
+            try:
+                begin = lines[1].strip()
+            except IndexError:
+                begin = None
+
+            members.append(XrMember(const=const, _type=_type, pointer=pointer, name=name))
+
+        _type = funcpointer.text
+        name = funcpointer.find("name").text
+        if "requires" in funcpointer.attrib:
+            forward_decls = funcpointer.attrib.get("requires").split(",")
+        else:
+            forward_decls = []
+        params_text = None
+        if members == []:
+            index = 0
+            for elem_part in funcpointer.itertext():
+                index = index + 1
+                if index == 3:
+                    p = re.findall(r'\([^)]*\)', elem_part)
+                    params_text = next(iter(p), None)
+                    if params_text:
+                        params_text = params_text[1:-1]
+                    break
+            
+        if name == "PFN_xrCreateApiLayerInstance":
+            forward_decls += ["XrInstanceCreateInfo"]
+
+
+        return XrFunctionPointer(_type, name, members, forward_decls, params_text)
+
+    def definition(self):
+        text = ""
+        # forward declare required structs
+        for decl in self.forward_decls:
+            text += "typedef struct {0} {0};\n".format(decl)
+
+        text += "{0} {1})(\n".format(self.type, self.name)
+
+        first = True
+        if len(self.members) > 0:
+            for m in self.members:
+                if first:
+                    text += "    " + m.definition()
+                    first = False
+                else:
+                    text += ",\n    " + m.definition()
+        elif self.params_text is not None:
+            text += self.params_text
+        else:
+            # Just make the compiler happy by adding a void parameter.
+            text += "void"
+        text += ");\n"
+        return text
+
+    def is_alias(self):
+        return False
+
+class XrHandle(object):
+    def __init__(self, name, _type, parent, alias=None):
+        self.name = name
+        self.type = _type
+        self.parent = parent
+        self.alias = alias
+        self.required = False
+        self.object_type = None
+
+    @staticmethod
+    def from_alias(handle, alias):
+        name = handle.attrib.get("name")
+        return XrHandle(name, alias.type, alias.parent, alias=alias)
+
+    @staticmethod
+    def from_xml(handle):
+        if not api_is_openxr(handle):
+            return None
+
+        name = handle.find("name").text
+        _type = handle.find("type").text
+        parent = handle.attrib.get("parent") # Most objects have a parent e.g. XrQueue has XrDevice.
+        return XrHandle(name, _type, parent)
+
+    def definition(self):
+        """ Generates handle definition e.g. XR_DEFINE_HANDLE(xrInstance) """
+
+        # Legacy types are typedef'ed to the new type if they are aliases.
+        if self.is_alias():
+            return "typedef {0} {1};\n".format(self.alias.name, self.name)
+
+        return "{0}({1})\n".format(self.type, self.name)
+
+    def is_alias(self):
+        return self.alias is not None
+
+    def is_dispatchable(self):
+        """ Some handles like XrInstance, XrDevice are dispatchable objects,
+        which means they contain a dispatch table of function pointers.
+        """
+        return self.type == "XR_DEFINE_HANDLE"
+
+    def is_required(self):
+        return self.required
+
+    def host_handle(self, name):
+        """ Provide access to the host handle of a wrapped object. """
+        if self.name == "XrInstance":
+            return "wine_instance_from_handle({0})->host_instance".format(name)
+        if self.name == "XrSession":
+            return "wine_session_from_handle({0})->host_session".format(name)
+        if self.name == "XrSwapchain":
+            return "wine_swapchain_from_handle({0})->host_swapchain".format(name)
+
+        return None
+
+    def driver_handle(self, name):
+        """ Provide access to the handle that should be passed to the wine driver """
+        return self.host_handle(name)
+
+    def unwrap_handle(self, name, unwrap):
+        if unwrap == Unwrap.DRIVER:
+            return self.driver_handle(name)
+        if unwrap == Unwrap.HOST:
+            return self.host_handle(name)
+        if unwrap == Unwrap.NONE:
+            return name
+        return None
+
+    def is_wrapped(self):
+        return self.host_handle("test") is not None
+
+
+class XrVariable(object):
+    def __init__(self, const=False, type_info=None, type=None, name=None, pointer=None, array_len=None,
+                 dyn_array_len=None, object_type=None, optional=False, returnedonly=False, parent=None,
+                 selection=None, selector=None):
+        self.const = const
+        self.type_info = type_info
+        self.type = type
+        self.name = name
+        self.parent = parent
+        self.object_type = object_type
+        self.optional = optional
+        self.returnedonly = returnedonly
+        self.selection = selection
+        self.selector = selector
+
+        self.pointer = pointer
+        self.array_len = array_len
+        self.dyn_array_len = dyn_array_len
+        self.pointer_array = False
+        if isinstance(dyn_array_len, str):
+            i = dyn_array_len.find(",")
+            if i != -1:
+                self.dyn_array_len = dyn_array_len[0:i]
+                self.pointer_array = True
+
+        if type_info:
+            self.set_type_info(type_info)
+
+    def __eq__(self, other):
+        """ Compare member based on name against a string. """
+        return self.name == other
+
+    def set_type_info(self, type_info):
+        """ Helper function to set type information from the type registry.
+        This is needed, because not all type data is available at time of
+        parsing.
+        """
+        self.type_info = type_info
+        self.handle = type_info["data"] if type_info["category"] == "handle" else None
+        self.struct = type_info["data"] if type_info["category"] == "struct" or type_info["category"] == "union" else None
+
+    def get_dyn_array_len(self, prefix, conv):
+        if isinstance(self.dyn_array_len, int):
+            return self.dyn_array_len
+
+        len_str = self.dyn_array_len
+        parent = self.parent
+        len = prefix
+
+        # check if length is a member of another struct (for example pAllocateInfo->commandBufferCount)
+        i = len_str.find("->")
+        if i != -1:
+            var = parent[parent.index(len_str[0:i])]
+            len_str = len_str[i+2:]
+            len = "({0})->".format(var.value(len, conv))
+            parent = var.struct
+
+        if len_str in parent:
+            var = parent[parent.index(len_str)]
+            len = var.value(len, conv);
+            if var.is_pointer():
+                len = "*" + len
+        else:
+            len += len_str
+
+        if isinstance(self.parent, XrStruct) and self.parent.name in MEMBER_LENGTH_EXPRESSIONS:
+            exprs = MEMBER_LENGTH_EXPRESSIONS[self.parent.name]
+            if self.name in exprs:
+                len = exprs[self.name].format(struct=prefix, len=len)
+
+        return len
+
+    def is_const(self):
+        return self.const
+
+    def is_pointer(self):
+        return self.pointer is not None
+
+    def is_pointer_size(self):
+        if self.type in ["size_t", "HWND", "HINSTANCE"]:
+            return True
+        if self.is_handle() and self.handle.is_dispatchable():
+            return True
+        return False
+
+    def is_handle(self):
+        return self.handle is not None
+
+    def is_struct(self):
+        return self.type_info["category"] == "struct"
+
+    def is_union(self):
+        return self.type_info["category"] == "union"
+
+    def is_bitmask(self):
+        return self.type_info["category"] == "bitmask"
+
+    def is_enum(self):
+        return self.type_info["category"] == "enum"
+
+    def is_dynamic_array(self):
+        """ Returns if the member is an array element.
+        Vulkan uses this for dynamically sized arrays for which
+        there is a 'count' parameter.
+        """
+        return self.dyn_array_len is not None and self.array_len is None
+
+    def is_static_array(self):
+        """ Returns if the member is an array.
+        Vulkan uses this often for fixed size arrays in which the
+        length is part of the member.
+        """
+        return self.array_len is not None
+
+    def is_generic_handle(self):
+        """ Returns True if the member is a unit64_t containing
+        a handle with a separate object type
+        """
+        return self.object_type != None and self.type == "uint64_t"
+
+    def needs_alignment(self):
+        """ Check if this member needs alignment for 64-bit data.
+        Various structures need alignment on 64-bit variables due
+        to compiler differences on 32-bit between Win32 and Linux.
+        """
+
+        if self.is_pointer():
+            return False
+        elif self.type == "size_t":
+            return False
+        elif self.type in ["uint64_t", "XrDeviceAddress", "XrDeviceSize"]:
+            return True
+        elif self.is_bitmask():
+            return self.type_info["data"].type == "XrFlags64"
+        elif self.is_enum():
+            return self.type_info["data"].bitwidth == 64
+        elif self.is_struct() or self.is_union():
+            return self.type_info["data"].needs_alignment()
+        elif self.is_handle():
+            # Dispatchable handles are pointers to objects, while
+            # non-dispatchable are uint64_t and hence need alignment.
+            return not self.handle.is_dispatchable()
+        return False
+
+    def is_wrapped(self):
+        """ Returns if variable needs unwrapping of handle. """
+
+        if self.is_struct():
+            return self.struct.is_wrapped()
+
+        if self.is_handle():
+            return self.handle.is_wrapped()
+
+        if self.is_generic_handle():
+            return True
+
+        return False
+
+    def needs_alloc(self, conv, unwrap):
+        """ Returns True if conversion needs allocation """
+        if self.is_dynamic_array():
+            return self.needs_conversion(conv, unwrap, Direction.INPUT, False) \
+                or self.needs_conversion(conv, unwrap, Direction.OUTPUT, False)
+
+        return (self.is_struct() or (self.is_union() and self.selector)) and self.struct.needs_alloc(conv, unwrap)
+
+    def needs_win32_type(self):
+        return (self.is_struct() or (self.is_union() and self.selector)) and self.struct.needs_win32_type()
+
+    def get_conversions(self, unwrap, parent_const=False):
+        """ Get a list of conversions required for this parameter if any.
+        Parameters which are structures may require conversion between win32
+        and the host platform. This function returns a list of conversions
+        required.
+        """
+
+        conversions = []
+
+        # Collect any member conversions first, so we can guarantee
+        # those functions will be defined prior to usage by the
+        # 'parent' param requiring conversion.
+        if self.is_struct() or (self.is_union() and self.selector):
+            struct = self.struct
+            is_const = self.is_const() if self.is_pointer() else parent_const
+
+            conversions.extend(struct.get_conversions(unwrap, is_const))
+
+            for conv in [False]:
+                if struct.needs_conversion(conv, unwrap, Direction.INPUT, is_const):
+                    conversions.append(StructConversionFunction(struct, Direction.INPUT, conv, unwrap, is_const))
+                if struct.needs_conversion(conv, unwrap, Direction.OUTPUT, is_const):
+                    conversions.append(StructConversionFunction(struct, Direction.OUTPUT, conv, unwrap, is_const))
+
+            if struct.name in STRUCT_COPY:
+                conversions.append(StructConversionFunction(struct, Direction.INPUT, False, unwrap, is_const, True))
+
+        if self.is_static_array() or self.is_dynamic_array():
+            for conv in [False]:
+                if self.needs_conversion(conv, unwrap, Direction.INPUT, parent_const):
+                    conversions.append(ArrayConversionFunction(self, Direction.INPUT, conv, unwrap))
+                if self.needs_conversion(conv, unwrap, Direction.OUTPUT, parent_const):
+                    conversions.append(ArrayConversionFunction(self, Direction.OUTPUT, conv, unwrap))
+
+        return conversions
+
+    def needs_ptr32_type(self):
+        """ Check if variable needs to use PTR32 type. """
+
+        return self.is_pointer() or self.is_pointer_size() or self.is_static_array()
+
+    def value(self, prefix, conv):
+        """ Returns code accessing member value, casting 32-bit pointers when needed. """
+
+        if not conv or not self.needs_ptr32_type() or (not self.is_pointer() and self.type == "size_t"):
+            return prefix + self.name
+
+        cast_type = ""
+        if self.const:
+            cast_type += "const "
+
+        if self.pointer_array or ((self.is_pointer() or self.is_static_array()) and self.is_pointer_size()):
+            cast_type += "PTR32 *"
+        else:
+            cast_type += self.type
+            if self.needs_win32_type():
+                cast_type += "32"
+
+            if self.is_pointer():
+                cast_type += " {0}".format(self.pointer)
+            elif self.is_static_array():
+                cast_type += " *"
+
+        return "({0})UlongToPtr({1}{2})".format(cast_type, prefix, self.name)
+
+
+class XrMember(XrVariable):
+    def __init__(self, const=False, struct_fwd_decl=False,_type=None, pointer=None, name=None, array_len=None,
+                 dyn_array_len=None, optional=False, values=None, object_type=None, bit_width=None,
+                 returnedonly=False, parent=None, selection=None, selector=None):
+        XrVariable.__init__(self, const=const, type=_type, name=name, pointer=pointer, array_len=array_len,
+                            dyn_array_len=dyn_array_len, object_type=object_type, optional=optional,
+                            returnedonly=returnedonly, parent=parent, selection=selection, selector=selector)
+        self.struct_fwd_decl = struct_fwd_decl
+        self.values = values
+        self.bit_width = bit_width
+
+    def __repr__(self):
+        return "{0} {1} {2} {3} {4} {5} {6}".format(self.const, self.struct_fwd_decl, self.type, self.pointer,
+                self.name, self.array_len, self.dyn_array_len)
+
+    @staticmethod
+    def from_xml(member, returnedonly, parent):
+        """ Helper function for parsing a member tag within a struct or union. """
+
+        if not api_is_openxr(member):
+            return None
+
+        name_elem = member.find("name")
+        type_elem = member.find("type")
+
+        const = False
+        struct_fwd_decl = False
+        member_type = None
+        pointer = None
+        array_len = None
+        bit_width = None
+
+        values = member.get("values")
+
+        if member.text:
+            if "const" in member.text:
+                const = True
+
+            # Some members contain forward declarations:
+            # - XrBaseInstructure has a member "const struct XrBaseInStructure *next"
+            # - XrWaylandSurfaceCreateInfoKHR has a member "struct wl_display *display"
+            if "struct" in member.text:
+                struct_fwd_decl = True
+
+        if type_elem is not None:
+            member_type = type_elem.text
+            if type_elem.tail is not None:
+                pointer = type_elem.tail.strip() if type_elem.tail.strip() != "" else None
+
+        # Name of other member within, which stores the number of
+        # elements pointed to be by this member.
+        dyn_array_len = member.get("len")
+
+        # Some members are optional, which is important for conversion code e.g. not dereference NULL pointer.
+        optional = True if member.get("optional") else False
+
+        # Usually we need to allocate memory for dynamic arrays. We need to do the same in a few other cases
+        # like for XrCommandBufferBeginInfo.pInheritanceInfo. Just threat such cases as dynamic arrays of
+        # size 1 to simplify code generation.
+        if dyn_array_len is None and pointer is not None:
+            dyn_array_len = 1
+
+        # Some members are arrays, attempt to parse these. Formats include:
+        # <member><type>char</type><name>extensionName</name>[<enum>XR_MAX_EXTENSION_NAME_SIZE</enum>]</member>
+        # <member><type>uint32_t</type><name>foo</name>[4]</member>
+        if name_elem.tail and name_elem.tail[0] == '[':
+            LOGGER.debug("Found array type")
+            enum_elem = member.find("enum")
+            if enum_elem is not None:
+                array_len = enum_elem.text
+            else:
+                # Remove brackets around length
+                array_len = name_elem.tail.strip("[]")
+
+        object_type = member.get("objecttype", None)
+
+        # Some members are bit field values:
+        # <member><type>uint32_t</type> <name>mask</name>:8</member>
+        if name_elem.tail and name_elem.tail[0] == ':':
+            LOGGER.debug("Found bit field")
+            bit_width = int(name_elem.tail[1:])
+
+        selection = member.get("selection").split(',') if member.get("selection") else None
+        selector = member.get("selector", None)
+
+        return XrMember(const=const, struct_fwd_decl=struct_fwd_decl, _type=member_type, pointer=pointer,
+                        name=name_elem.text, array_len=array_len, dyn_array_len=dyn_array_len, optional=optional,
+                        values=values, object_type=object_type, bit_width=bit_width, returnedonly=returnedonly,
+                        parent=parent, selection=selection, selector=selector)
+
+    def copy(self, input, output, direction, conv, unwrap, copy):
+        """ Helper method for use by conversion logic to generate a C-code statement to copy this member.
+            - `conv` indicates whether the statement is in a struct alignment conversion path. """
+
+        win_type = "win32" if conv else "win64"
+        suffix = convert_suffix(direction, win_type, unwrap, self.is_wrapped())
+
+        if self.needs_conversion(conv, unwrap, direction, False):
+            if self.is_dynamic_array():
+                # Array length is either a variable name (string) or an int.
+                count = self.get_dyn_array_len(input, conv)
+                pointer_part = "pointer_" if self.pointer_array else ""
+                if direction == Direction.OUTPUT:
+                    return "convert_{2}_{6}array_{5}({3}{1}, {0}, {4});\n".format(self.value(output, conv),
+                        self.name, self.type, input, count, suffix, pointer_part)
+                else:
+                    return "{0}{1} = convert_{2}_{6}array_{5}(ctx, {3}, {4});\n".format(output,
+                        self.name, self.type, self.value(input, conv), count, suffix, pointer_part)
+            elif self.is_static_array():
+                count = self.array_len
+                if direction == Direction.OUTPUT:
+                    # Needed by XrMemoryHeap.memoryHeaps
+                    return "convert_{0}_array_{5}({2}{1}, {3}{1}, {4});\n".format(self.type,
+                        self.name, input, output, count, suffix)
+                else:
+                    # Nothing needed this yet.
+                    LOGGER.warn("TODO: implement copying of static array for {0}.{1}".format(self.type, self.name))
+            elif self.is_handle() and self.is_wrapped():
+                handle = self.type_info["data"]
+                if direction == Direction.OUTPUT:
+                    LOGGER.error("OUTPUT parameter {0}.{1} cannot be unwrapped".format(self.type, self.name))
+                elif self.optional:
+                    return "{0}{1} = {2} ? {3} : 0;\n".format(output, self.name, self.value(input, conv),
+                        handle.unwrap_handle(self.value(input, conv), unwrap))
+                else:
+                    input_name = "{0}{1}".format(input, self.name)
+                    return "{0}{1} = {2} ? {3} : XR_NULL_HANDLE;\n".format(output, self.name,
+                        input_name, handle.unwrap_handle(self.value(input, conv), unwrap))
+            elif self.is_generic_handle():
+                if direction == Direction.OUTPUT:
+                    LOGGER.error("OUTPUT parameter {0}.{1} cannot be unwrapped".format(self.type, self.name))
+                if unwrap == Unwrap.DRIVER and self.is_wrapped(Unwrap.DRIVER):
+                    LOGGER.error("DRIVER unwrapping of {0}.{1} not implemented".format(self.type, self.name))
+                return "{0}{1} = wine_xr_unwrap_handle({2}{3}, {2}{1});\n".format(output, self.name, input, self.object_type)
+            else:
+                selector_part = ", {0}{1}".format(input, self.selector) if self.selector else ""
+                if direction == Direction.OUTPUT:
+                    return "convert_{0}_{4}(&{2}{1}, &{3}{1}{5});\n".format(self.type,
+                        self.name, input, output, suffix, selector_part)
+                else:
+                    ctx_param = "ctx, " if self.needs_alloc(conv, unwrap) else ""
+                    return "convert_{0}_{4}({5}&{2}{1}, &{3}{1}{6});\n".format(self.type,
+                        self.name, input, output, suffix, ctx_param, selector_part)
+        elif self.is_static_array():
+            bytes_count = "{0} * sizeof({1})".format(self.array_len, self.type)
+            return "memcpy({0}{1}, {2}{1}, {3});\n".format(output, self.name, input, bytes_count)
+        elif self.is_dynamic_array() and copy:
+            if self.type == "void":
+                return "MEMDUP_VOID(ctx, {0}{1}, {2}{1}, {3});\n".format(output, self.name, input, self.get_dyn_array_len(input, conv))
+            else:
+                return "MEMDUP(ctx, {0}{1}, {2}{1}, {3});\n".format(output, self.name, input, self.get_dyn_array_len(input, conv))
+        elif direction == Direction.INPUT:
+            return "{0}{1} = {2};\n".format(output, self.name, self.value(input, conv))
+        elif conv and direction == Direction.OUTPUT and self.is_pointer():
+            return "{0}{1} = PtrToUlong({2}{1});\n".format(output, self.name, input)
+        else:
+            return "{0}{1} = {2}{1};\n".format(output, self.name, input)
+
+    def definition(self, align=False, conv=False):
+        """ Generate prototype for given function.
+
+        Args:
+            align (bool, optional): Enable alignment if a type needs it. This adds WINE_XR_ALIGN(8) to a member.
+            conv (bool, optional): Enable conversion if a type needs it. This appends '_host' to the name.
+        """
+
+        if conv and (self.is_pointer() or self.is_pointer_size()):
+            text = "PTR32 " + self.name
+            if self.is_static_array():
+                text += "[{0}]".format(self.array_len)
+            return text
+
+        text = ""
+        if self.is_const():
+            text += "const "
+
+        if self.is_struct_forward_declaration():
+            text += "struct "
+
+        text += self.type
+        if conv and self.needs_win32_type():
+            text += "32"
+
+        if self.is_pointer():
+            text += " {0}{1}".format(self.pointer, self.name)
+        else:
+            if align and self.needs_alignment():
+                if conv:
+                    text += " DECLSPEC_ALIGN(8) " + self.name
+                else:
+                    text += " WINE_XR_ALIGN(8) " + self.name
+            else:
+                text += " " + self.name
+
+        if self.is_static_array():
+            text += "[{0}]".format(self.array_len)
+
+        if self.is_bit_field():
+            text += ":{}".format(self.bit_width)
+
+        return text
+
+    def is_struct_forward_declaration(self):
+        return self.struct_fwd_decl
+
+    def is_bit_field(self):
+        return self.bit_width is not None
+
+    def needs_conversion(self, conv, unwrap, direction, struct_const):
+        """ Check if member needs conversion. """
+
+        # we can't convert unions if we don't have a selector
+        if self.is_union() and not self.selector:
+            return False
+
+        is_const = self.is_const() if self.is_pointer() else struct_const
+
+        # const members don't needs output conversion unless they are structs with non-const pointers
+        if direction == Direction.OUTPUT and is_const and not self.is_struct():
+            return False
+
+        if direction == Direction.INPUT:
+            # returnedonly members don't needs input conversions
+            if not self.is_pointer() and self.returnedonly:
+                return False
+            # pointer arrays always need input conversion
+            if conv and self.is_dynamic_array() and self.pointer_array:
+                return True
+
+        if self.is_handle():
+            if unwrap != Unwrap.NONE and self.handle.is_wrapped():
+                return True
+            if conv and self.handle.is_dispatchable():
+                return True
+        elif self.is_generic_handle():
+            if unwrap != Unwrap.NONE:
+                return True
+        elif self.is_struct() or self.is_union():
+            if self.struct.needs_conversion(conv, unwrap, direction, is_const):
+                return True
+
+        # if pointer member needs output conversion, it also needs input conversion
+        # to allocate the pointer
+        if direction == Direction.INPUT and self.is_pointer() and \
+           self.needs_conversion(conv, unwrap, Direction.OUTPUT, struct_const):
+            return True
+
+        return False
+
+class XrParam(XrVariable):
+    """ Helper class which describes a parameter to a function call. """
+
+    def __init__(self, type_info, const=None, pointer=None, name=None, parent=None, array_len=None,
+                 dyn_array_len=None, object_type=None, optional=False):
+        XrVariable.__init__(self, const=const, type_info=type_info, type=type_info["name"], name=name,
+                            pointer=pointer, array_len=array_len, dyn_array_len=dyn_array_len,
+                            object_type=object_type, optional=optional, parent=parent)
+
+        self._set_format_string()
+
+    def __repr__(self):
+        return "{0} {1} {2} {3} {4} {5}".format(self.const, self.type, self.pointer, self.name, self.array_len, self.dyn_array_len)
+
+    @staticmethod
+    def from_xml(param, types, parent):
+        """ Helper function to create XrParam from xml. """
+
+        if not api_is_openxr(param):
+            return None
+
+        # Parameter parsing is slightly tricky. All the data is contained within
+        # a param tag, but some data is within subtags while others are text
+        # before or after the type tag.
+        # Common structure:
+        # <param>const <type>char</type>* <name>pLayerName</name></param>
+
+        name_elem = param.find("name")
+        array_len = None
+        name = name_elem.text
+        # Tail contains array length e.g. for blendConstants param of xrSetBlendConstants
+        if name_elem.tail is not None:
+            array_len = name_elem.tail.strip("[]")
+
+        # Name of other parameter in function prototype, which stores the number of
+        # elements pointed to be by this parameter.
+        dyn_array_len = param.get("len", None)
+
+        const = param.text.strip() if param.text else None
+        type_elem = param.find("type")
+        pointer = type_elem.tail.strip() if type_elem.tail.strip() != "" else None
+
+        attr = param.get("optional")
+        optional = attr and attr.startswith("true")
+
+        # Some uint64_t are actually handles with a separate type param
+        object_type = param.get("objecttype", None)
+
+        # Since we have parsed all types before hand, this should not happen.
+        type_info = types.get(type_elem.text, None)
+        if type_info is None:
+            LOGGER.error("type info not found for: {0}".format(type_elem.text))
+
+        return XrParam(type_info, const=const, pointer=pointer, name=name, array_len=array_len,
+                       dyn_array_len=dyn_array_len, object_type=object_type, optional=optional,
+                       parent=parent)
+
+    def _set_format_string(self):
+        """ Internal helper function to be used by constructor to set format string. """
+
+        # Determine a format string used by code generation for traces.
+        # 64-bit types need a conversion function.
+        self.format_conv = None
+        if self.is_static_array() or self.is_pointer() or self.type in [ "XrFutureEXT" ]:
+            self.format_str = "%p"
+        else:
+            if self.type_info["category"] in ["bitmask"]:
+                # Since 1.2.170 bitmasks can be 32 or 64-bit, check the basetype.
+                if self.type_info["data"].type == "XrFlags64":
+                    self.format_str = "0x%s"
+                    self.format_conv = "wine_dbgstr_longlong({0})"
+                else:
+                    self.format_str = "%#x"
+            elif self.type_info["category"] in ["enum"]:
+                self.format_str = "%#x"
+            elif self.is_handle():
+                # We use uint64_t for non-dispatchable handles as opposed to pointers
+                # for dispatchable handles.
+                if self.handle.is_dispatchable():
+                    self.format_str = "%p"
+                else:
+                    self.format_str = "0x%s"
+                    self.format_conv = "wine_dbgstr_longlong({0})"
+            elif self.type == "float":
+                self.format_str = "%f"
+            elif self.type == "int":
+                self.format_str = "%d"
+            elif self.type == "int32_t":
+                self.format_str = "%d"
+            elif self.type == "size_t":
+                self.format_str = "0x%s"
+                self.format_conv = "wine_dbgstr_longlong({0})"
+            elif self.type in ["uint16_t", "uint32_t", "XrBool32"]:
+                self.format_str = "%u"
+            elif self.type in ["uint64_t","XrAsyncRequestIdFB"]:
+                self.format_str = "0x%s"
+                self.format_conv = "wine_dbgstr_longlong({0})"
+            elif self.type in ["HANDLE", "VkInstance"]:
+                self.format_str = "%p"
+            elif self.type in ["XrSystemId", "XrPath", "XrTime", "XrDuration", "XrControllerModelKeyMSFT", "XrMarkerML", "XrSpatialEntityIdBD"]:
+                self.format_str = "0x%s"
+                self.format_conv = "wine_dbgstr_longlong({0})"
+            elif self.type in ["XrVector2f"]:
+                self.format_str = "%f, %f"
+                self.format_conv = "{0}.x, {0}.y"
+            elif self.type in ["XrPosef"]:
+                self.format_str = "{{%f, %f, %f, %f}, {%f %f %f}}"
+                self.format_conv = "{0}.orientation.x, {0}.orientation.y, {0}.orientation.z, {0}.orientation.w, {0}.position.x, {0}.position.y, {0}.position.z"
+            elif self.type in ["VisualID", "xcb_visualid_t"]:
+                # Don't care about specific types for non-Windows platforms.
+                self.format_str = ""
+            else:
+                LOGGER.warn("Unhandled type: {0}".format(self.type_info))
+
+    def copy(self, direction, conv, unwrap, prefix=""):
+        win_type = "win32" if conv else "win64"
+        suffix = convert_suffix(direction, win_type, unwrap, self.is_wrapped())
+
+        if direction == Direction.INPUT:
+            ctx_param = "ctx, " if self.needs_alloc(conv, unwrap) else ""
+            if self.is_dynamic_array():
+                return "    {0}_host = convert_{2}_array_{4}({5}{1}, {3});\n".format(self.name, self.value(prefix, conv),
+                    self.type, self.get_dyn_array_len(prefix, conv), suffix, ctx_param)
+            elif self.optional:
+                ret  = "    if ({0}{1})\n".format(prefix, self.name)
+                ret += "    {\n"
+                ret += "        {0}_host = conversion_context_alloc(ctx, sizeof(*{0}_host));\n".format(self.name)
+                ret += "        convert_{0}_{3}({4}{1}, {2}_host);\n".format(self.type, self.value(prefix, conv),
+                    self.name, suffix, ctx_param)
+                ret += "    }\n"
+                return ret
+            elif self.is_struct():
+                return "    convert_{0}_{3}({4}{1}, &{2}_host);\n".format(self.type, self.value(prefix, conv),
+                    self.name, suffix, ctx_param)
+            elif self.is_pointer_size() and self.type != "size_t":
+                return "    {0}_host = UlongToPtr(*{1});\n".format(self.name, self.value(prefix, conv))
+            else:
+                return "    {0}_host = *{1};\n".format(self.name, self.value(prefix, conv))
+        else:
+            if self.is_dynamic_array():
+                return "    convert_{0}_array_{1}({2}_host, {3}, {4});\n".format(
+                    self.type, suffix, self.name, self.value(prefix, conv),
+                    self.get_dyn_array_len(prefix, conv))
+            elif self.is_struct():
+                ref_part = "" if self.optional else "&"
+                return "    convert_{0}_host_to_{3}({4}{2}_host, {1});\n".format(
+                    self.type, self.value(prefix, conv), self.name, win_type, ref_part)
+            elif self.is_pointer_size() and self.type != "size_t":
+                return "    *{0} = PtrToUlong({1}_host);\n".format(self.value(prefix, conv), self.name)
+            else:
+                return "    *{0} = {1}_host;\n".format(self.value(prefix, conv), self.name)
+
+    def definition(self, postfix=None, is_member=False, conv=False):
+        """ Return prototype for the parameter. E.g. 'const char *foo' """
+
+        if is_member and conv and self.needs_ptr32_type():
+            return "PTR32 {0}".format(self.name)
+
+        proto = ""
+        if self.const and (not is_member or self.pointer):
+            proto += self.const + " "
+
+        proto += self.type
+        name = self.name
+        if conv and self.needs_win32_type():
+            proto += "32"
+
+        if is_member and self.needs_alignment():
+            proto += " DECLSPEC_ALIGN(8)"
+
+        if self.is_pointer():
+            proto += " {0}{1}".format(self.pointer, name)
+        elif is_member and self.is_static_array():
+            proto += " *" + name
+        else:
+            proto += " " + name
+
+        # Allows appending something to the variable name useful for
+        # win32 to host conversion.
+        if postfix is not None:
+            proto += postfix
+
+        if not is_member and self.is_static_array():
+            proto += "[{0}]".format(self.array_len)
+
+        return proto
+
+    def format_string(self, conv):
+        if conv and self.needs_ptr32_type() and (self.type != "size_t" or self.is_pointer()):
+            return "%#x"
+        return self.format_str
+
+    def is_dispatchable(self):
+        if not self.is_handle():
+            return False
+
+        return self.handle.is_dispatchable()
+
+    def needs_conversion(self, conv, unwrap, direction, parent_const=False):
+        """ Check if param needs conversion. """
+
+        if self.is_struct():
+            return self.struct.needs_conversion(conv, unwrap, direction, self.is_const())
+
+        if self.is_handle():
+            # non-pointer handles are handled inline in thunks
+            if not self.is_dynamic_array() and not self.is_static_array():
+                return conv and self.is_pointer() and self.handle.is_dispatchable()
+
+            # xrAllocateCommandBuffers is a special case, we use it in our private thunk as an input param
+            param_direction = (Direction.INPUT if self.is_const() else Direction.OUTPUT)
+            if self.name == "pCommandBuffers":
+                param_direction = Direction.INPUT
+            if direction != param_direction:
+                return False
+
+            if unwrap != Unwrap.NONE and self.handle.is_wrapped():
+                return True
+            if conv and self.handle.is_dispatchable():
+                return True
+        elif self.is_pointer() and self.is_pointer_size():
+            return conv
+
+        return False
+
+    def needs_variable(self, conv, unwrap):
+        if self.needs_conversion(conv, unwrap, Direction.INPUT):
+            return True
+        if self.needs_conversion(conv, unwrap, Direction.OUTPUT):
+            return True
+        return False
+
+    def spec(self):
+        """ Generate spec file entry for this parameter. """
+
+        if self.is_pointer() and self.type == "char":
+            return "str"
+        if self.is_dispatchable() or self.is_pointer() or self.is_static_array():
+            return "ptr"
+        if self.type_info["category"] in ["bitmask"]:
+            # Since 1.2.170 bitmasks can be 32 or 64-bit, check the basetype.
+            if self.type_info["data"].type == "XrFlags64":
+                return "int64"
+            else:
+                return "long"
+        if self.type_info["category"] in ["enum"]:
+            return "long"
+        if self.is_handle() and not self.is_dispatchable():
+            return "int64"
+        if self.type == "float":
+            return "float"
+        if self.type in ["int", "int32_t", "size_t", "uint16_t", "uint32_t", "XrBool32"]:
+            return "long"
+        if self.type in ["uint64_t", "XrDeviceSize"]:
+            return "int64"
+
+        LOGGER.error("Unhandled spec conversion for type: {0}".format(self.type))
+
+    def variable(self, conv, unwrap, params_prefix=""):
+        """ Returns 'glue' code during generation of a function call on how to access the variable.
+        This function handles various scenarios such as 'unwrapping' if dispatchable objects and
+        renaming of parameters in case of win32 -> host conversion.
+
+        Args:
+            conv (bool, optional): Enable conversion if the param needs it. This appends '_host' to the name.
+        """
+
+        # Hack until we enable allocation callbacks from ICD to application. These are a joy
+        # to enable one day, because of calling convention conversion.
+        if unwrap != Unwrap.NONE and "XrAllocationCallbacks" in self.type:
+            LOGGER.debug("TODO: setting NULL XrAllocationCallbacks for {0}".format(self.name))
+            return "NULL"
+
+        if self.needs_variable(conv, unwrap):
+            if self.is_dynamic_array() or self.optional:
+                return "{0}_host".format(self.name)
+            else:
+                return "&{0}_host".format(self.name)
+
+        p = self.value(params_prefix, conv)
+
+        if unwrap != Unwrap.NONE:
+            unwrap_handle = None
+            if self.object_type != None and self.type == "uint64_t":
+                if unwrap == Unwrap.DRIVER and self.is_wrapped(Unwrap.DRIVER):
+                    LOGGER.error("DRIVER unwrapping of {0}.{1} not implemented".format(self.type, self.name))
+                unwrap_handle = "wine_xr_unwrap_handle({0}{1}, {0}{2})".format(
+                    params_prefix, self.object_type, self.name)
+
+            elif self.is_handle():
+                # We need to pass the host handle to the host Vulkan calls and
+                # the wine driver's handle to calls which are wrapped by the driver.
+                unwrap_handle = self.handle.unwrap_handle(p, unwrap)
+            if unwrap_handle:
+                if self.optional:
+                    unwrap_handle = "{0}{1} ? {2} : 0".format(params_prefix, self.name, unwrap_handle)
+                return unwrap_handle
+
+        return p
+
+
+class XrStruct(Sequence):
+    """ Class which represents the type union and struct. """
+
+    def __init__(self, name, members, returnedonly, structextends, alias=None, union=False):
+        self.name = name
+        self.members = members
+        self.returnedonly = returnedonly
+        self.structextends = structextends
+        self.required = False
+        self.alias = alias
+        self.union = union
+        self.type_info = None # To be set later.
+        self.struct_extensions = []
+        self.aliased_by = []
+
+    def __getitem__(self, i):
+        return self.members[i]
+
+    def __len__(self):
+        return len(self.members)
+
+    @staticmethod
+    def from_alias(struct, alias):
+        name = struct.attrib.get("name")
+        aliasee = XrStruct(name, alias.members, alias.returnedonly, alias.structextends, alias=alias)
+
+        alias.add_aliased_by(aliasee)
+        return aliasee
+
+    @staticmethod
+    def from_xml(struct):
+        if not api_is_openxr(struct):
+            return None
+
+        # Unions and structs are the same parsing wise, but we need to
+        # know which one we are dealing with later on for code generation.
+        union = True if struct.attrib["category"] == "union" else False
+
+        name = struct.attrib.get("name")
+
+        # 'Output' structures for which data is filled in by the API are
+        # marked as 'returnedonly'.
+        returnedonly = True if struct.attrib.get("returnedonly") else False
+
+        # Those structs seem to be broken in spec, they are specified as
+        # returned only, but documented as input structs.
+        if name in ["XrPipelineShaderStageRequiredSubgroupSizeCreateInfo"]:
+            returnedonly = False
+
+        # Those structs don't have returnedonly in spec, but they could (should?).
+        if name in ["XrSurfaceCapabilitiesPresentBarrierNV"]:
+            returnedonly = True
+
+        structextends = struct.attrib.get("structextends")
+        structextends = structextends.split(",") if structextends else []
+
+        s = XrStruct(name, [], returnedonly, structextends, union=union)
+        for member in struct.findall("member"):
+            xr_member = XrMember.from_xml(member, returnedonly, s)
+            if xr_member:
+                s.members.append(xr_member)
+
+        return s
+
+    @staticmethod
+    def decouple_structs(structs):
+        """ Helper function which decouples a list of structs.
+        Structures often depend on other structures. To make the C compiler
+        happy we need to define 'substructures' first. This function analyzes
+        the list of structures and reorders them in such a way that they are
+        decoupled.
+        """
+
+        tmp_structs = list(structs) # Don't modify the original structures.
+        decoupled_structs = []
+
+        while (len(tmp_structs) > 0):
+            # Iterate over a copy because we want to modify the list inside the loop.
+            for struct in list(tmp_structs):
+                dependends = False
+
+                if not struct.required:
+                    tmp_structs.remove(struct)
+                    continue
+
+                for m in struct:
+                    if not (m.is_struct() or m.is_union()):
+                        continue
+
+                    # XrBaseInstructure and XrBaseOutStructure reference themselves.
+                    if m.type == struct.name:
+                        break
+
+                    found = False
+                    # Check if a struct we depend on has already been defined.
+                    for s in decoupled_structs:
+                        if s.name == m.type:
+                            found = True
+                            break
+
+                    if not found:
+                        # Check if the struct we depend on is even in the list of structs.
+                        # If found now, it means we haven't met all dependencies before we
+                        # can operate on the current struct.
+                        # When generating 'host' structs we may not be able to find a struct
+                        # as the list would only contain the structs requiring conversion.
+                        for s in tmp_structs:
+                            if s.name == m.type:
+                                dependends = True
+                                break
+
+                if dependends == False:
+                    decoupled_structs.append(struct)
+                    tmp_structs.remove(struct)
+
+        return decoupled_structs
+
+    def definition(self, align=False, conv=False):
+        """ Convert structure to textual definition.
+
+        Args:
+            align (bool, optional): enable alignment to 64-bit for win32 struct compatibility.
+            conv (bool, optional): enable struct conversion if the struct needs it.
+            postfix (str, optional): text to append to end of struct name, useful for struct renaming.
+        """
+
+        if self.is_alias():
+            return ""
+
+        suffix = "32" if conv else ""
+        if self.union:
+            text = "typedef union {0}".format(self.name)
+        else:
+            text = "typedef struct {0}".format(self.name)
+        text += suffix
+
+        text += "\n{\n"
+
+        for m in self:
+            if align and m.needs_alignment():
+                text += "    {0};\n".format(m.definition(align=align, conv=conv))
+            else:
+                text += "    {0};\n".format(m.definition(conv=conv))
+
+        text += "}} {0}{1};\n".format(self.name, suffix)
+
+        for aliasee in self.aliased_by:
+            text += "typedef {0}{2} {1}{2};\n".format(self.name, aliasee.name, suffix)
+
+        return text
+
+    def is_alias(self):
+        return bool(self.alias)
+
+    def add_aliased_by(self, aliasee):
+        self.aliased_by.append(aliasee)
+
+    def needs_alignment(self):
+        """ Check if structure needs alignment for 64-bit data.
+        Various structures need alignment on 64-bit variables due
+        to compiler differences on 32-bit between Win32 and Linux.
+        """
+
+        for m in self.members:
+            if self.name == m.type:
+                continue
+            if m.needs_alignment():
+                return True
+        return False
+
+    def is_wrapped(self):
+        """ Returns if struct members need unwrapping of handle. """
+
+        for m in self.members:
+            if self.name == m.type:
+                continue
+            if m.is_wrapped():
+                return True
+        return False
+
+    def needs_extensions_conversion(self, conv, direction):
+        """ Check if struct contains extensions chain that needs to be converted """
+
+        if direction == Direction.INPUT and self.name in STRUCT_CHAIN_CONVERSIONS:
+            return True
+
+        if not "next" in self:
+            return False
+        is_const = self.members[self.members.index("next")].is_const()
+        # XrOpticalFlowSessionCreateInfoNV is missing const in its next pointer
+        if self.name in ["XrOpticalFlowSessionCreateInfoNV",
+                         "XrDescriptorBufferBindingInfoEXT"]:
+            is_const = True
+
+        for e in self.struct_extensions:
+            if not e.required:
+                continue
+            if e.needs_conversion(conv, Unwrap.HOST, direction, is_const, check_extensions=False):
+                return True
+            if direction == Direction.INPUT:
+                # we need input conversion of structs containing struct chain even if it's returnedonly,
+                # so that we have a chance to allocate buffers
+                if e.needs_conversion(conv, Unwrap.HOST, Direction.OUTPUT, is_const, check_extensions=False):
+                    return True
+
+        return False
+
+    def needs_conversion(self, conv, unwrap, direction, is_const, check_extensions=True):
+        """ Check if struct needs conversion. """
+
+        # XrAllocationCallbacks never needs conversion
+        if self.name == "XrAllocationCallbacks":
+            return False
+
+        # pFixedRateFlags field is missing const, but it doesn't need output conversion
+        if direction == Direction.OUTPUT and self.name == "XrImageCompressionControlEXT":
+            return False
+
+        needs_output_copy = False
+
+        for m in self.members:
+            if self.name == m.type:
+                continue
+
+            if m.name == "next":
+                # next is a pointer, so it always needs conversion
+                if conv and direction == Direction.INPUT:
+                    return True
+                # we need input conversion of structs containing struct chain even if it's returnedonly
+                if direction == Direction.INPUT and \
+                   self.needs_conversion(conv, unwrap, Direction.OUTPUT, is_const):
+                    return True
+                continue
+
+            # for non-pointer members, check for returnedonly and const attributes
+            if not m.is_pointer() or m.type == "void":
+                if direction == Direction.INPUT:
+                    if self.returnedonly:
+                        continue
+                else:
+                    if is_const or m.is_const():
+                        continue
+
+            # check alignment and pointer-sized members for 32-bit conversions
+            if conv and (direction == Direction.INPUT or not is_const):
+                if m.is_pointer() or m.is_pointer_size():
+                    return True
+                # we don't check structs here, they will will be traversed by needs_conversion chain anyway
+                if not m.is_struct() and m.needs_alignment():
+                    return True
+
+            if m.needs_conversion(conv, unwrap, direction, is_const):
+                return True
+
+            # pointers will be handled by needs_conversion, but if we have any other non-const
+            # member, we may need to copy output
+            if direction == Direction.OUTPUT and not m.is_pointer() and not is_const and not m.is_const():
+                needs_output_copy = True
+
+        # if output needs any copy and we need input conversion, then we also need output conversion
+        if needs_output_copy and self.needs_conversion(conv, unwrap, Direction.INPUT, check_extensions):
+            return True
+
+        return check_extensions and self.needs_extensions_conversion(conv, direction)
+
+    def needs_alloc(self, conv, unwrap):
+        """ Check if any struct member needs some memory allocation."""
+
+        if self.needs_extensions_conversion(conv, Direction.INPUT):
+            return True
+
+        for m in self.members:
+            if self.name == m.type:
+                continue
+            if m.needs_alloc(conv, unwrap):
+                return True
+
+        return False
+
+    def needs_win32_type(self):
+        # XrAllocationCallbacks never needs conversion
+        if self.name == "XrAllocationCallbacks":
+            return False
+
+        for m in self.members:
+            if self.name == m.type:
+                continue
+            if m.is_pointer() or m.is_pointer_size():
+                return True
+            if m.needs_alignment():
+                return True
+            if (m.is_struct() or m.is_union()) and m.struct.needs_win32_type():
+                return True
+
+    def set_type_info(self, types):
+        """ Helper function to set type information from the type registry.
+        This is needed, because not all type data is available at time of
+        parsing.
+        """
+        for m in self.members:
+            type_info = types[m.type]
+            m.set_type_info(type_info)
+
+    def get_conversions(self, unwrap, parent_const):
+        conversions = []
+
+        # Collect any conversion for any extension structs.
+        for e in self.struct_extensions:
+            if not e.required:
+                continue
+            conversions.extend(e.get_conversions(Unwrap.HOST, parent_const))
+
+        # Collect any conversion for any member structs.
+        for m in self:
+            if m.type == self.name:
+                continue
+            conversions.extend(m.get_conversions(unwrap, parent_const))
+
+        return conversions
+
+
+class StructConversionFunction(object):
+    def __init__(self, struct, direction, conv, unwrap, const, copy=False):
+        self.direction = direction
+        self.operand = struct
+        self.type = struct.name
+        self.conv = conv
+        self.unwrap = unwrap
+        self.const = const
+        self.copy = copy
+
+        if copy:
+            name = "copy_{0}".format(self.type)
+        else:
+            name = "convert_{0}_".format(self.type)
+            win_type = "win32" if self.conv else "win64"
+            name += convert_suffix(direction, win_type, unwrap, struct.is_wrapped())
+        self.name = name
+
+    def __eq__(self, other):
+        return self.name == other.name
+
+    def member_needs_copy(self, struct, m):
+        if self.direction == Direction.OUTPUT:
+            if m.name in ["type", "next"]:
+                return False
+            if self.const and not m.is_pointer():
+                return False
+            if m.is_const() and not m.needs_conversion(self.conv, self.unwrap, Direction.OUTPUT, self.const):
+                return False
+        else:
+            if m.name == "next":
+                return True
+            if m.name != "type" and struct.returnedonly and not m.needs_conversion(
+                    self.conv, self.unwrap, Direction.INPUT, self.const):
+                return False
+        return True
+
+    def definition(self):
+        """ Helper function for generating a struct conversion function. """
+
+        # It doesn't make sense to generate conversion functions for non-struct variables
+        # which aren't in arrays, as this should be handled by the copy() function
+        if not isinstance(self.operand, XrStruct):
+            return ""
+
+        body = ""
+
+        if not self.conv and not self.copy:
+            body += "#ifdef _WIN64\n"
+
+        needs_alloc = self.direction != Direction.OUTPUT and self.operand.needs_alloc(self.conv, self.unwrap)
+        win_type = self.type
+        if self.conv and self.operand.needs_win32_type():
+            win_type += "32"
+        if self.direction == Direction.OUTPUT and self.const:
+            win_type = "const " + win_type
+
+        if self.copy:
+            body += "void {0}(".format(self.name)
+        else:
+            body += "static inline void {0}(".format(self.name)
+        if self.conv:
+
+            if self.direction == Direction.OUTPUT:
+                params = ["const {0} *in".format(self.type), "{0} *out".format(win_type)]
+            else:
+                params = ["const {0} *in".format(win_type), "{0} *out".format(self.type)]
+
+            if self.operand.union:
+                params.append("XrFlags selector")
+
+            # Generate parameter list
+            if needs_alloc:
+                body += "struct conversion_context *ctx, "
+            body += ", ".join(p for p in params)
+            body += ")\n"
+
+        else:
+            params = ["const {0} *in".format(self.type), "{0} *out".format(self.type)]
+
+            # Generate parameter list
+            if needs_alloc:
+                body += "struct conversion_context *ctx, "
+            body += ", ".join(p for p in params)
+            body += ")\n"
+
+        needs_extensions = self.operand.needs_extensions_conversion(self.conv, self.direction)
+
+        body += "{\n"
+        if needs_extensions:
+            if self.direction == Direction.INPUT:
+                if self.conv:
+                    body += "    const XrBaseInStructure32 *in_header;\n"
+                else:
+                    body += "    const XrBaseInStructure *in_header;\n"
+                body += "    XrBaseOutStructure *out_header = (void *)out;\n\n"
+            else:
+                body += "    const XrBaseInStructure *in_header;\n"
+                if self.conv:
+                    body += "    XrBaseOutStructure32 *out_header = (void *)out;\n\n"
+                else:
+                    body += "    XrBaseOutStructure *out_header = (void *)out;\n\n"
+
+        body += "    if (!in) return;\n\n"
+
+        for m in self.operand:
+            if not self.member_needs_copy(self.operand, m):
+                continue
+            if m.name == "next" and (needs_extensions or self.conv):
+                body += "    out->next = NULL;\n"
+                continue
+
+            if m.selection:
+                body += "    if ("
+                body += " || ".join("selector == {}".format(s) for s in m.selection)
+                body += ")\n    "
+
+            body += "    " + m.copy("in->", "out->", self.direction, self.conv, self.unwrap, self.copy)
+
+        if needs_extensions:
+            if self.conv and self.direction == Direction.INPUT:
+                body += "\n    for (in_header = UlongToPtr(in->next); in_header; in_header = UlongToPtr(in_header->next))\n"
+            else:
+                body += "\n    for (in_header = (void *)in->next; in_header; in_header = (void *)in_header->next)\n"
+            body += "    {\n"
+            body += "        switch (in_header->type)\n"
+            body += "        {\n"
+
+            ident = "            "
+
+            if self.direction == Direction.INPUT and self.type in STRUCT_CHAIN_CONVERSIONS:
+                has_any_chain_conversions = False
+                for i in STRUCT_CHAIN_CONVERSIONS[self.type]:
+                    body += "        case {0}:\n".format(i)
+                    has_any_chain_conversions = True
+                if has_any_chain_conversions:
+                    body += ident + "break;\n"
+
+            for ext in self.operand.struct_extensions:
+                if not ext.required:
+                    continue
+
+                if self.direction == Direction.OUTPUT and not any([self.member_needs_copy(ext, m) for m in ext]):
+                    continue
+
+
+                stype = next(x for x in ext.members if x.name == "type").values
+                if self.type in STRUCT_CHAIN_CONVERSIONS and stype in STRUCT_CHAIN_CONVERSIONS[self.type]:
+                    continue
+                win_type = ext.name + "32" if self.conv and ext.needs_win32_type() else ext.name
+                if self.direction == Direction.INPUT:
+                    in_type = "const " + win_type
+                    out_type = ext.name
+                else:
+                    in_type = "const " + ext.name
+                    out_type = win_type
+
+                body += "        case {0}:\n".format(stype)
+                body += "        {\n"
+                if self.direction == Direction.INPUT:
+                    body += ident + "{0} *out_ext = conversion_context_alloc(ctx, sizeof(*out_ext));\n".format(out_type)
+                elif self.conv:
+                    body += ident + "{0} *out_ext = find_next_struct32(out_header, {1});\n".format(out_type, stype)
+                else:
+                    body += ident + "{0} *out_ext = find_next_struct(out_header, {1});\n".format(out_type, stype)
+
+                copy_body = ""
+
+                for m in ext:
+                    if m.name == "type":
+                        copy_body += ident + "out_ext->type = {0};\n".format(stype)
+                        continue
+                    if not self.member_needs_copy(ext, m):
+                        continue
+                    if m.name == "next":
+                        copy_body += ident + "out_ext->next = NULL;\n"
+                        continue
+                    copy_body += ident + m.copy("in_ext->", "out_ext->", self.direction, self.conv, Unwrap.HOST, self.copy)
+
+                # Generate the definition of "in_ext" if we need it
+                if "in_ext->" in copy_body:
+                    body += ident + "{0} *in_ext = ({0} *)in_header;\n".format(in_type)
+                body += copy_body
+
+                if self.direction == Direction.INPUT:
+                    body += ident + "out_header->next = (void *)out_ext;\n"
+                body += ident + "out_header = (void *)out_ext;\n"
+                body += ident + "break;\n"
+                body += "        }\n"
+
+            body += "        default:\n"
+            if self.direction == Direction.INPUT:
+                body += ident + "if ((in_header->type >> 16) == 0x7ead)\n"
+                body += ident + "{\n"
+                body += ident + "    XrBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);\n";
+                body += ident + "    memcpy(out_ext, in_header, 32);\n";
+                body += ident + "    out_ext->next = NULL;\n";
+                body += ident + "    out_header->next = (void *)out_ext;\n";
+                body += ident + "    out_header = (void *)out_ext;\n";
+                body += ident + "}\n"
+                body += ident + "else\n"
+                body += ident + "{\n"
+                body += ident + "    FIXME(\"Unhandled type %u.\\n\", in_header->type);\n"
+                body += ident + "}\n"
+            body += "            break;\n"
+            body += "        }\n"
+            body += "    }\n"
+        elif self.conv and self.direction == Direction.INPUT and "next" in self.operand:
+            body += "    if (in->next)\n"
+            body += "        FIXME(\"Unexpected next\\n\");\n"
+
+        body += "}\n"
+        if not self.conv and not self.copy:
+            body += "#endif /* _WIN64 */\n"
+        body += "\n"
+
+        return body
+
+
+class ArrayConversionFunction(object):
+    def __init__(self, array, direction, conv, unwrap):
+        self.array = array
+        self.direction = direction
+        self.type = array.type
+        self.conv = conv
+        self.unwrap = unwrap
+
+        if array.is_static_array() and direction == Direction.INPUT:
+            LOGGER.error("Static array input conversion is not supported")
+
+        name = "convert_{0}_".format(array.type)
+        if array.pointer_array:
+            name += "pointer_"
+        name += "array_"
+        win_type = "win32" if self.conv else "win64"
+        name += convert_suffix(direction, win_type, unwrap, array.is_wrapped())
+        self.name = name
+
+    def __eq__(self, other):
+        return self.name == other.name
+
+    def definition(self):
+        """ Helper function for generating a conversion function for array operands. """
+
+        body = ""
+
+        if not self.conv:
+            body += "#ifdef _WIN64\n"
+
+        needs_alloc = self.direction != Direction.OUTPUT and self.array.needs_alloc(self.conv, self.unwrap)
+
+        win_type = self.type
+        if self.conv:
+            if self.array.needs_win32_type():
+                win_type += "32"
+            elif self.array.is_handle() and self.array.handle.is_dispatchable():
+                win_type = "PTR32"
+        if self.direction == Direction.OUTPUT and self.array.is_const():
+            win_type = "const " + win_type
+        pointer_part = self.array.pointer if self.array.pointer else "*"
+
+        if self.direction == Direction.OUTPUT:
+            params = ["const {0} {1}in".format(self.type, pointer_part),
+                      "{0} {1}out".format(win_type, pointer_part), "uint32_t count"]
+            return_type = None
+        elif self.conv and self.array.pointer_array:
+            params = ["const PTR32 *in", "uint32_t count"]
+            return_type = self.type
+        else:
+            params = ["const {0} {1}in".format(win_type, pointer_part), "uint32_t count"]
+            return_type = self.type
+
+        needs_copy = not self.array.is_struct() or self.direction != Direction.INPUT or \
+            not self.array.struct.returnedonly or "next" in self.array.struct
+
+        # Generate function prototype.
+        if return_type:
+            body += "static inline {0}{1} {2}{3}(".format(
+                "const " if self.array.is_const() else "", return_type, pointer_part, self.name)
+        else:
+            body += "static inline void {0}(".format(self.name)
+        if needs_alloc:
+            body += "struct conversion_context *ctx, "
+        body += ", ".join(p for p in params)
+        body += ")\n{\n"
+
+        if return_type:
+            body += "    {0} {1}out;\n".format(return_type, "**" if self.array.pointer_array else "*")
+        if needs_copy:
+            body += "    unsigned int i;\n\n"
+
+        if return_type:
+            body += "    if (!in || !count) return NULL;\n\n"
+        else:
+            body += "    if (!in) return;\n\n"
+
+        if self.direction == Direction.INPUT:
+            body += "    out = conversion_context_alloc(ctx, count * sizeof(*out));\n"
+
+        if needs_copy:
+            body += "    for (i = 0; i < count; i++)\n"
+            body += "    {\n"
+
+            if self.array.is_struct():
+                struct = self.array.struct
+                win_part = "win32" if self.conv else "win64"
+                suffix = convert_suffix(self.direction, win_part, self.unwrap, struct.is_wrapped())
+                ctx_part = ""
+                if self.direction == Direction.INPUT and struct.needs_alloc(self.conv, self.unwrap):
+                    ctx_part = "ctx, "
+
+                if not self.array.pointer_array:
+                    body += "        convert_{0}_{1}({2}&in[i], &out[i]);\n".format(
+                        struct.name, suffix, ctx_part)
+                else:
+                    if struct.needs_conversion(self.conv, self.unwrap, self.direction, False):
+                        body += "        if (in[i])\n"
+                        body += "        {\n"
+                        body += "            out[i] = conversion_context_alloc(ctx, sizeof(*out[i]));\n"
+                        if self.conv:
+                            in_param = "({0} *)UlongToPtr(in[i])".format(win_type)
+                        else:
+                            in_param = "in[i]"
+                        body += "            convert_{0}_{1}({2}{3}, out[i]);\n".format(
+                            struct.name, suffix, ctx_part, in_param)
+                        body += "        }\n"
+                        body += "        else\n"
+                        body += "            out[i] = NULL;\n"
+                    else:
+                        body += "        out[i] = UlongToPtr(in[i]);\n"
+            elif self.array.is_handle():
+                if self.array.pointer_array:
+                    LOGGER.error("Unhandled handle pointer arrays")
+                handle = self.array.handle
+                if not self.conv or not handle.is_dispatchable():
+                    input = "in[i]"
+                elif self.direction == Direction.INPUT:
+                    input = "UlongToPtr(in[i])"
+                else:
+                    input = "PtrToUlong(in[i])"
+
+                if self.unwrap == Unwrap.NONE or not handle.is_wrapped():
+                    body += "        out[i] = {0};\n".format(input)
+                elif self.direction == Direction.INPUT:
+                    body += "        out[i] = {0};\n".format(handle.unwrap_handle(input, self.unwrap))
+                else:
+                    LOGGER.warning("Unhandled handle output conversion")
+            elif self.array.pointer_array:
+                body += "        out[i] = UlongToPtr(in[i]);\n"
+            else:
+                body += "        out[i] = in[i];\n"
+
+            body += "    }\n"
+
+        if return_type:
+            body += "\n    return {0}out;\n".format("(void *)" if self.array.pointer_array else "")
+        body += "}\n"
+
+        if not self.conv:
+            body += "#endif /* _WIN64 */\n"
+
+        body += "\n"
+
+        return body
+
+
+class XrGenerator(object):
+    def __init__(self, registry):
+        self.registry = registry
+
+        # Build a list conversion functions for struct conversion.
+        self.conversions = []
+        self.win32_structs = []
+        for func in self.registry.funcs.values():
+            if not func.needs_exposing():
+                continue
+
+            conversions = func.get_conversions()
+            for conv in conversions:
+                # Append if we don't already have this conversion.
+                if not any(c == conv for c in self.conversions):
+                    self.conversions.append(conv)
+
+                if not isinstance(conv, StructConversionFunction):
+                    continue
+
+                for e in conv.operand.struct_extensions:
+                    if not e.required or not e.needs_win32_type():
+                        continue
+                    if not any(s.name == e.name for s in self.win32_structs):
+                        self.win32_structs.append(e)
+
+                if not conv.operand.needs_win32_type():
+                    continue
+
+                # Structs can be used in different ways by different conversions
+                # e.g. array vs non-array. Just make sure we pull in each struct once.
+                if not any(s.name == conv.operand.name for s in self.win32_structs):
+                    self.win32_structs.append(conv.operand)
+
+    def _generate_copyright(self, f, spec_file=False):
+        f.write("# " if spec_file else "/* ")
+        f.write("Automatically generated from Vulkan xr.xml; DO NOT EDIT!\n")
+        lines = ["", "This file is generated from Vulkan xr.xml file covered",
+            "by the following copyright and permission notice:"]
+        lines.extend([l.rstrip(" ") for l in self.registry.copyright.splitlines()])
+        for line in lines:
+            f.write("{0}{1}".format("# " if spec_file else " * ", line).rstrip(" ") + "\n")
+        f.write("\n" if spec_file else " */\n\n")
+
+    def generate_thunks_c(self, f):
+        self._generate_copyright(f)
+
+        f.write("#if 0\n")
+        f.write("#pragma makedep unix\n")
+        f.write("#endif\n\n")
+
+        f.write("#include \"config.h\"\n\n")
+
+        f.write("#include <stdlib.h>\n\n")
+
+        f.write("#include \"openxr_private.h\"\n\n")
+
+        f.write("WINE_DEFAULT_DEBUG_CHANNEL(openxr);\n\n")
+        # Generate any conversion helper functions.
+        for conv in self.conversions:
+            f.write(conv.definition())
+
+        # Create thunks for instance and device functions.
+        # Global functions don't go through the thunks.
+        for xr_func in self.registry.funcs.values():
+            if not xr_func.needs_exposing():
+                continue
+            if xr_func.name in MANUAL_LOADER_FUNCTIONS:
+                continue
+
+            f.write(xr_func.thunk(prefix="thunk64_"))
+
+        # Create array of extensions.
+        f.write("static const char * const xr_extensions[] =\n{\n")
+        for ext in self.registry.extensions:
+            if ext["type"] != "instance":
+                continue
+            if ext["name"] in UNEXPOSED_EXTENSIONS:
+                continue
+
+            f.write("    \"{0}\",\n".format(ext["name"]))
+        f.write("};\n\n")
+
+        f.write("BOOL wine_xr_extension_supported(const char *name)\n")
+        f.write("{\n")
+        f.write("    unsigned int i;\n")
+        f.write("    for (i = 0; i < ARRAY_SIZE(xr_extensions); i++)\n")
+        f.write("    {\n")
+        f.write("        if (strcmp(xr_extensions[i], name) == 0)\n")
+        f.write("            return TRUE;\n")
+        f.write("    }\n")
+        f.write("    return FALSE;\n")
+        f.write("}\n\n")
+
+        f.write("BOOL wine_xr_is_type_wrapped(XrObjectType type)\n")
+        f.write("{\n")
+        f.write("    return FALSE")
+        for handle in self.registry.handles:
+            if not handle.is_required() or not handle.is_wrapped() or handle.is_alias():
+                continue
+            f.write(" ||\n        type == {}".format(handle.object_type))
+        f.write(";\n")
+        f.write("}\n\n")
+
+
+        f.write("#ifdef _WIN64\n\n")
+
+        f.write("const unixlib_entry_t __wine_unix_call_funcs[] =\n")
+        f.write("{\n")
+        f.write("    init_openxr,\n")
+        f.write("    is_available_instance_function_openxr,\n")
+        for xr_func in self.registry.funcs.values():
+            if not xr_func.needs_exposing():
+                continue
+            if xr_func.name in MANUAL_LOADER_FUNCTIONS:
+                continue
+
+            if xr_func.is_perf_critical():
+                f.write("    (void *){1}{0},\n".format(xr_func.name, "thunk64_"))
+            else:
+                f.write("    {1}{0},\n".format(xr_func.name, "thunk64_"))
+        f.write("};\n")
+        f.write("C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);\n\n")
+
+        f.write("#endif /* _WIN64 */\n\n")
+        f.write("C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);\n")
+
+    def generate_thunks_h(self, f, prefix):
+        self._generate_copyright(f)
+
+        f.write("#ifndef __WINE_OPENXR_THUNKS_H\n")
+        f.write("#define __WINE_OPENXR_THUNKS_H\n\n")
+
+        f.write("#define WINE_XR_VERSION XR_API_VERSION_{0}_{1}\n\n".format(WINE_XR_VERSION[0], WINE_XR_VERSION[1]))
+
+        # Generate prototypes for device and instance functions requiring a custom implementation.
+        f.write("/* Functions for which we have custom implementations outside of the thunks. */\n")
+        for xr_func in self.registry.funcs.values():
+            if not xr_func.needs_private_thunk():
+                continue
+
+            f.write("{0};\n".format(xr_func.prototype(prefix=prefix, is_thunk=True)))
+        f.write("\n")
+
+        f.write("/* For use by xrInstance and children */\n")
+        f.write("struct openxr_instance_funcs\n{\n")
+        for xr_func in self.registry.instance_funcs:
+            if not xr_func.needs_exposing():
+                continue
+
+            if not xr_func.needs_dispatch():
+                LOGGER.debug("skipping {0} in openxr_instance_funcs".format(xr_func.name))
+                continue
+
+            f.write("    {0};\n".format(xr_func.pfn()))
+        f.write("};\n\n")
+
+        f.write("#define ALL_XR_INSTANCE_FUNCS() \\\n")
+        first = True
+        for xr_func in self.registry.instance_funcs:
+            if not xr_func.needs_exposing():
+                continue
+
+            if not xr_func.needs_dispatch():
+                LOGGER.debug("skipping {0} in ALL_XR_INSTANCE_FUNCS".format(xr_func.name))
+                continue
+
+            if first:
+                f.write("    USE_XR_FUNC({0})".format(xr_func.name))
+                first = False
+            else:
+                f.write(" \\\n    USE_XR_FUNC({0})".format(xr_func.name))
+        f.write("\n\n")
+
+        f.write("#endif /* __WINE_OPENXR_THUNKS_H */\n")
+
+    def generate_loader_thunks_c(self, f):
+        self._generate_copyright(f)
+
+        f.write("#include \"openxr_loader.h\"\n\n")
+
+        f.write("WINE_DEFAULT_DEBUG_CHANNEL(openxr);\n\n")
+
+        for xr_func in self.registry.funcs.values():
+            if not xr_func.needs_exposing():
+                continue
+            if xr_func.name in MANUAL_LOADER_THUNKS | MANUAL_LOADER_FUNCTIONS:
+                continue
+
+            f.write(xr_func.loader_thunk())
+
+        f.write("static const struct openxr_func xr_instance_dispatch_table[] =\n{\n")
+        for xr_func in self.registry.instance_funcs:
+            if not xr_func.needs_exposing():
+                continue
+
+            f.write("    {{\"{0}\", {0}}},\n".format(xr_func.name))
+        f.write("};\n\n")
+
+        f.write("void *wine_xr_get_instance_proc_addr(const char *name)\n")
+        f.write("{\n")
+        f.write("    unsigned int i;\n")
+        f.write("    for (i = 0; i < ARRAY_SIZE(xr_instance_dispatch_table); i++)\n")
+        f.write("    {\n")
+        f.write("        if (strcmp(xr_instance_dispatch_table[i].name, name) == 0)\n")
+        f.write("        {\n")
+        f.write("            TRACE(\"Found name=%s in instance table\\n\", debugstr_a(name));\n")
+        f.write("            return xr_instance_dispatch_table[i].func;\n")
+        f.write("        }\n")
+        f.write("    }\n")
+        f.write("    return NULL;\n")
+        f.write("}\n")
+
+    def generate_loader_thunks_h(self, f):
+        self._generate_copyright(f)
+
+        f.write("#ifndef __WINE_OPENXR_LOADER_THUNKS_H\n")
+        f.write("#define __WINE_OPENXR_LOADER_THUNKS_H\n\n")
+
+        f.write("enum unix_call\n")
+        f.write("{\n")
+        f.write("    unix_init,\n")
+        f.write("    unix_is_available_instance_function,\n")
+        for xr_func in self.registry.funcs.values():
+            if not xr_func.needs_exposing():
+                continue
+            if xr_func.name in MANUAL_LOADER_FUNCTIONS:
+                continue
+
+            f.write("    unix_{0},\n".format(xr_func.name))
+        f.write("    unix_count,\n")
+        f.write("};\n\n")
+
+        for xr_func in self.registry.funcs.values():
+            if not xr_func.needs_exposing():
+                continue
+            if xr_func.name in MANUAL_LOADER_FUNCTIONS:
+                continue
+
+            f.write("struct {0}_params\n".format(xr_func.name))
+            f.write("{\n");
+            extra_param_is_new = True
+            for p in xr_func.params:
+                f.write("    {0};\n".format(p.definition(is_member=True)))
+                if p.name == xr_func.extra_param:
+                    extra_param_is_new = False
+
+            if xr_func.extra_param and extra_param_is_new:
+                f.write("    void *{0};\n".format(xr_func.extra_param))
+            if xr_func.type != "void":
+                f.write("    {0} result;\n".format(xr_func.type))
+            f.write("};\n\n");
+
+        f.write("#endif /* __WINE_OPENXR_LOADER_THUNKS_H */\n")
+
+    def generate_openxr_h(self, f):
+        self._generate_copyright(f)
+        f.write("#ifndef __WINE_OPENXR_H\n")
+        f.write("#define __WINE_OPENXR_H\n\n")
+
+        f.write("#include <windef.h>\n")
+        f.write("#include <stdint.h>\n\n")
+
+        f.write("/* Define WINE_XR_HOST to get 'host' headers. */\n")
+        f.write("#ifdef WINE_XR_HOST\n")
+        f.write("#define XRAPI_CALL\n")
+        f.write('#define WINE_XR_ALIGN(x)\n')
+        f.write("#endif\n\n")
+
+        f.write("#ifndef XRAPI_CALL\n")
+        f.write("#define XRAPI_CALL __stdcall\n")
+        f.write("#endif\n\n")
+
+        f.write("#ifndef XRAPI_PTR\n")
+        f.write("#define XRAPI_PTR XRAPI_CALL\n")
+        f.write("#endif\n\n")
+
+        f.write("#ifndef WINE_XR_ALIGN\n")
+        f.write("#define WINE_XR_ALIGN DECLSPEC_ALIGN\n")
+        f.write("#endif\n\n")
+
+        f.write("#if defined(__x86_64__) || defined(__aarch64__)\n")
+        f.write("#define XR_PTR_SIZE 8\n")
+        f.write("#endif\n\n")
+
+        # The overall strategy is to define independent constants and datatypes,
+        # prior to complex structures and function calls to avoid forward declarations.
+        for const in self.registry.consts:
+            # For now just generate things we may not need. The amount of parsing needed
+            # to get some of the info is tricky as you need to figure out which structure
+            # references a certain constant.
+            f.write(const.definition())
+        f.write("\n")
+
+        for define in self.registry.defines:
+            f.write(define.definition())
+
+        for handle in self.registry.handles:
+            # For backward compatibility also create definitions for aliases.
+            # These types normally don't get pulled in as we use the new types
+            # even in legacy functions if they are aliases.
+            if handle.is_required() or handle.is_alias():
+                 f.write(handle.definition())
+        f.write("\n")
+
+        for base_type in self.registry.base_types:
+            f.write(base_type.definition())
+        f.write("\n")
+
+        for bitmask in self.registry.bitmasks:
+            f.write(bitmask.definition())
+        f.write("\n")
+
+        # Define enums, this includes values for some of the bitmask types as well.
+        for enum in self.registry.enums.values():
+            if enum.required:
+                f.write(enum.definition())
+
+        for fp in self.registry.funcpointers:
+            if fp.required:
+                f.write(fp.definition())
+        f.write("\n")
+
+        # This generates both structures and unions. Since structures
+        # may depend on other structures/unions, we need a list of
+        # decoupled structs.
+        # Note: unions are stored in structs for dependency reasons,
+        # see comment in parsing section.
+        structs = XrStruct.decouple_structs(self.registry.structs)
+        for struct in structs:
+            LOGGER.debug("Generating struct: {0}".format(struct.name))
+            f.write(struct.definition(align=True))
+            f.write("\n")
+
+        for func in self.registry.funcs.values():
+            if not func.is_required():
+                LOGGER.debug("Skipping PFN definition for: {0}".format(func.name))
+                continue
+
+            f.write("typedef {0};\n".format(func.pfn(prefix="PFN", call_conv="XRAPI_PTR")))
+        f.write("\n")
+
+        f.write("#ifndef XR_NO_PROTOTYPES\n")
+        for func in self.registry.funcs.values():
+            if not func.is_required():
+                LOGGER.debug("Skipping API definition for: {0}".format(func.name))
+                continue
+
+            LOGGER.debug("Generating API definition for: {0}".format(func.name))
+            f.write("{0};\n".format(func.prototype(call_conv="XRAPI_CALL")))
+        f.write("#endif /* XR_NO_PROTOTYPES */\n\n")
+
+        f.write("#endif /* __WINE_OPENXR_H */\n")
+
+class XrRegistry(object):
+    def __init__(self, reg_filename):
+        # Used for storage of type information.
+        self.base_types = None
+        self.bitmasks = None
+        self.consts = None
+        self.defines = None
+        self.enums = None
+        self.funcpointers = None
+        self.handles = None
+        self.structs = None
+
+        # We aggregate all types in here for cross-referencing.
+        self.funcs = {}
+        self.types = {}
+
+        self.version_regex = re.compile(
+            r'^'
+            r'XR_VERSION_'
+            r'(?P<major>[0-9])'
+            r'_'
+            r'(?P<minor>[0-9])'
+            r'$'
+        )
+
+        # Overall strategy for parsing the registry is to first
+        # parse all type / function definitions. Then parse
+        # features and extensions to decide which types / functions
+        # to actually 'pull in' for code generation. For each type or
+        # function call we want we set a member 'required' to True.
+        tree = ET.parse(reg_filename)
+        root = tree.getroot()
+
+        self._parse_enums(root)
+        self._parse_types(root)
+        self._parse_commands(root)
+
+        # Pull in any required types and functions.
+        self._parse_features(root)
+        self._parse_extensions(root)
+
+        for enum in self.enums.values():
+            enum.fixup_64bit_aliases()
+
+        self._match_object_types()
+
+        self.copyright = root.find('./comment').text
+
+    def _is_feature_supported(self, feature):
+        version = self.version_regex.match(feature)
+        if not version:
+            return True
+
+        version = tuple(map(int, version.group('major', 'minor')))
+        return version <= WINE_XR_VERSION
+
+    def _is_extension_supported(self, extension):
+        # We disable some extensions as either we haven't implemented
+        # support yet or because they are for platforms other than win32.
+        return extension not in UNSUPPORTED_EXTENSIONS
+
+    def _mark_type_required(self, type_info):
+        """ Helper function to mark a certain types and the datatypes they needs as required."""
+        def mark_bitmask_dependencies(bitmask, types):
+            if bitmask.requires is not None:
+                self._mark_type_required(types[bitmask.requires])
+
+        def mark_funcpointer_dependencies(fp, types):
+            for m in fp.members:
+                self._mark_type_required(types[m.type])
+
+        def mark_struct_dependencies(struct, types):
+             for m in struct:
+                type_info = types[m.type]
+
+                if struct.name != m.type:
+                    self._mark_type_required(types[m.type])
+
+        # Check if we are dealing with a complex type e.g. XrEnum, XrStruct and others.
+        if "data" not in type_info:
+            return
+
+        # Mark the complex type as required.
+        type_info["data"].required = True
+        if type_info["category"] == "struct":
+            mark_struct_dependencies(type_info["data"], self.types)
+        elif type_info["category"] == "funcpointer":
+            mark_funcpointer_dependencies(type_info["data"], self.types)
+        elif type_info["category"] == "bitmask":
+            mark_bitmask_dependencies(type_info["data"], self.types)
+
+    def _mark_command_required(self, command):
+        """ Helper function to mark a certain command and the datatypes it needs as required."""
+        func = self.funcs[command]
+        func.required = True
+
+        # Pull in return type
+        if func.type != "void":
+            self.types[func.type]["data"].required = True
+
+        # Analyze parameter dependencies and pull in any type needed.
+        for p in func.params:
+            self._mark_type_required(self.types[p.type])
+
+    def _match_object_types(self):
+        """ Matches each handle with the correct object type. """
+        # Use upper case comparison for simplicity.
+        object_types = {}
+        for value in self.enums["XrObjectType"].values:
+            object_name = "XR" + value.name[len("XR_OBJECT_TYPE"):].replace("_", "")
+            object_types[object_name] = value.name
+
+        for handle in self.handles:
+            if not handle.is_required():
+                continue
+            handle.object_type = object_types.get(handle.name.upper())
+            if not handle.object_type:
+                LOGGER.warning("No object type found for {}".format(handle.name))
+
+    def _parse_commands(self, root):
+        """ Parse command section containing the Vulkan function calls. """
+        funcs = {}
+        commands = root.findall("./commands/")
+
+        # As of Vulkan 1.1, various extensions got promoted to Core.
+        # The old commands (e.g. KHR) are available for backwards compatibility
+        # and are marked in xr.xml as 'alias' to the non-extension type.
+        # The registry likes to avoid data duplication, so parameters and other
+        # metadata need to be looked up from the Core command.
+        # We parse the alias commands in a second pass.
+        alias_commands = []
+        for command in commands:
+            alias_name = command.attrib.get("alias")
+            if alias_name:
+                alias_commands.append(command)
+                continue
+
+            func = XrFunction.from_xml(command, self.types)
+
+            if func:
+                funcs[func.name] = func
+
+        for command in alias_commands:
+            alias_name = command.attrib.get("alias")
+            alias = funcs[alias_name]
+            func = XrFunction.from_alias(command, alias)
+            if func:
+                funcs[func.name] = func
+
+        # To make life easy for the code generation, separate all function
+        # calls out in the 4 types of Vulkan functions:
+        # device, global, physical device and instance.
+        instance_funcs = []
+        for func in funcs.values():
+            if not func.name in NOT_OUR_FUNCTIONS:
+                instance_funcs.append(func)
+
+        # Sort function lists by name and store them.
+        self.instance_funcs = sorted(instance_funcs, key=lambda func: func.name)
+
+        # The funcs dictionary is used as a convenient way to lookup function
+        # calls when needed e.g. to adjust member variables.
+        self.funcs = OrderedDict(sorted(funcs.items()))
+
+    def _parse_enums(self, root):
+        """ Parse enums section or better described as constants section. """
+        enums = {}
+        self.consts = []
+        for enum in root.findall("./enums"):
+            name = enum.attrib.get("name")
+            _type = enum.attrib.get("type")
+
+            if _type in ("enum", "bitmask"):
+                enum_obj = XrEnum.from_xml(enum)
+                if enum_obj:
+                    enums[name] = enum_obj
+            else:
+                # If no type is set, we are dealing with API constants.
+                for value in enum.findall("enum"):
+                    # If enum is an alias, set the value to the alias name.
+                    # E.g. XR_LUID_SIZE_KHR is an alias to XR_LUID_SIZE.
+                    alias = value.attrib.get("alias")
+                    if alias:
+                        self.consts.append(XrConstant(value.attrib.get("name"), alias))
+                    else:
+                        self.consts.append(XrConstant(value.attrib.get("name"), value.attrib.get("value")))
+
+        self.enums = OrderedDict(sorted(enums.items()))
+
+    def _process_require_enum(self, enum_elem, ext=None, only_aliased=False):
+        if "extends" in enum_elem.keys():
+            enum = self.types[enum_elem.attrib["extends"]]["data"]
+
+            # Need to define XrEnumValues which were aliased to by another value. This is necessary
+            # from XR spec version 1.2.135 where the provisional XR_KHR_ray_tracing extension was
+            # added which altered XR_NV_ray_tracing's XrEnumValues to alias to the provisional
+            # extension.
+            aliased = False
+            for _, t in self.types.items():
+                if t["category"] != "enum":
+                    continue
+                if not t["data"]:
+                    continue
+                for value in t["data"].values:
+                    if value.alias == enum_elem.attrib["name"]:
+                        aliased = True
+
+            if only_aliased and not aliased:
+                return
+
+            if "bitpos" in enum_elem.keys():
+                # We need to add an extra value to an existing enum type.
+                # E.g. XR_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG to XrFormatFeatureFlagBits.
+                enum.create_bitpos(enum_elem.attrib["name"], int(enum_elem.attrib["bitpos"]))
+
+            elif "offset" in enum_elem.keys():
+                # Extensions promoted to Core, have the extension number as part
+                # of the enum value. Else retrieve from the extension tag.
+                if enum_elem.attrib.get("extnumber"):
+                    ext_number = int(enum_elem.attrib.get("extnumber"))
+                else:
+                    ext_number = int(ext.attrib["number"])
+                offset = int(enum_elem.attrib["offset"])
+                value = EXT_BASE + (ext_number - 1) * EXT_BLOCK_SIZE + offset
+
+                # Deal with negative values.
+                direction = enum_elem.attrib.get("dir")
+                if direction is not None:
+                    value = -value
+
+                enum.create_value(enum_elem.attrib["name"], str(value))
+
+            elif "value" in enum_elem.keys():
+                enum.create_value(enum_elem.attrib["name"], enum_elem.attrib["value"])
+            elif "alias" in enum_elem.keys():
+                enum.create_alias(enum_elem.attrib["name"], enum_elem.attrib["alias"])
+
+        elif "value" in enum_elem.keys():
+            # Constant with an explicit value
+            if only_aliased:
+                return
+
+            self.consts.append(XrConstant(enum_elem.attrib["name"], enum_elem.attrib["value"]))
+        elif "alias" in enum_elem.keys():
+            # Aliased constant
+            if not only_aliased:
+                return
+
+            self.consts.append(XrConstant(enum_elem.attrib["name"], enum_elem.attrib["alias"]))
+
+    @staticmethod
+    def _require_type(type_info):
+        if type_info.is_alias():
+            type_info = type_info.alias
+
+        type_info.required = True
+        if type(type_info) == XrStruct:
+            for member in type_info.members:
+                if "data" in member.type_info:
+                  XrRegistry._require_type(member.type_info["data"])
+
+    def _parse_extensions(self, root):
+        """ Parse extensions section and pull in any types and commands for this extension. """
+        extensions = []
+        exts = root.findall("./extensions/extension")
+        deferred_exts = []
+        skipped_exts = UNSUPPORTED_EXTENSIONS.copy()
+
+        def process_ext(ext, deferred=False):
+            ext_name = ext.attrib["name"]
+
+            # Set extension name on any functions calls part of this extension as we
+            # were not aware of the name during initial parsing.
+            commands = ext.findall("require/command")
+            for command in commands:
+                cmd_name = command.attrib["name"]
+                # Need to verify that the command is defined, and otherwise skip it.
+                # xrCreateScreenSurfaceQNX is declared in <extensions> but not defined in
+                # <commands>. A command without a definition cannot be enabled, so it's valid for
+                # the XML file to handle this, but because of the manner in which we parse the XML
+                # file we pre-populate from <commands> before we check if a command is enabled.
+                if cmd_name in self.funcs:
+                    self.funcs[cmd_name].extensions.add(ext_name)
+
+            # Some extensions are not ready or have numbers reserved as a place holder
+            # or are only supported for VulkanSC.
+            if not "openxr" in ext.attrib["supported"].split(","):
+                LOGGER.debug("Skipping disabled extension: {0}".format(ext_name))
+                skipped_exts.append(ext_name)
+                return
+
+            protect = ext.attrib.get("protect", None)
+            if not protect is None and \
+                    not protect in ALLOWED_PROTECTS:
+                return
+
+            # Defer extensions with 'sortorder' as they are order-dependent for spec-parsing.
+            if not deferred and "sortorder" in ext.attrib:
+                deferred_exts.append(ext)
+                return
+
+            # Disable highly experimental extensions as the APIs are unstable and can
+            # change between minor Vulkan revisions until API is final and becomes KHR
+            # or NV.
+            if ("KHX" in ext_name or "NVX" in ext_name) and ext_name not in ALLOWED_X_EXTENSIONS:
+                LOGGER.debug("Skipping experimental extension: {0}".format(ext_name))
+                skipped_exts.append(ext_name)
+                return
+
+            # Extensions can define XrEnumValues which alias to provisional extensions. Pre-process
+            # extensions to define any required XrEnumValues before the platform check below.
+            for require in ext.findall("require"):
+                # Extensions can add enum values to Core / extension enums, so add these.
+                for enum_elem in require.findall("enum"):
+                    self._process_require_enum(enum_elem, ext, only_aliased=True)
+
+            platform = ext.attrib.get("platform")
+            if platform and platform != "win32":
+                LOGGER.debug("Skipping extensions {0} for platform {1}".format(ext_name, platform))
+                skipped_exts.append(ext_name)
+                return
+
+            if not self._is_extension_supported(ext_name):
+                LOGGER.debug("Skipping unsupported extension: {0}".format(ext_name))
+                skipped_exts.append(ext_name)
+                return
+            elif "requires" in ext.attrib:
+                # Check if this extension builds on top of another unsupported extension.
+                requires = ext.attrib["requires"].split(",")
+                if len(set(requires).intersection(skipped_exts)) > 0:
+                    skipped_exts.append(ext_name)
+                    return
+            elif "depends" in ext.attrib:
+                # The syntax for this is more complex, but this is good enough for now.
+                if any([sext in ext.attrib["depends"] for sext in skipped_exts]):
+                    skipped_exts.append(ext_name)
+                    return
+
+            LOGGER.debug("Loading extension: {0}".format(ext_name))
+
+            # Extensions can define one or more require sections each requiring
+            # different features (e.g. Vulkan 1.1). Parse each require section
+            # separately, so we can skip sections we don't want.
+            for require in ext.findall("require"):
+                # Extensions can add enum values to Core / extension enums, so add these.
+                for enum_elem in require.findall("enum"):
+                    self._process_require_enum(enum_elem, ext)
+
+                for t in require.findall("type"):
+                    if not t.attrib["name"] in self.types:
+                        continue
+
+                    type_info = self.types[t.attrib["name"]]["data"]
+                    self._require_type(type_info)
+                feature = require.attrib.get("feature")
+                if feature and not self._is_feature_supported(feature):
+                    continue
+
+                required_extension = require.attrib.get("extension")
+                if required_extension and not self._is_extension_supported(required_extension):
+                    continue
+
+                # Pull in any commands we need. We infer types to pull in from the command
+                # as well.
+                for command in require.findall("command"):
+                    cmd_name = command.attrib["name"]
+                    self._mark_command_required(cmd_name)
+
+
+            # Store a list with extensions.
+            ext_info = {"name" : ext_name, "type" : ext.attrib["type"]}
+            extensions.append(ext_info)
+
+
+        # Process extensions, allowing for sortorder to defer extension processing
+        for ext in exts:
+            process_ext(ext)
+
+        deferred_exts.sort(key=lambda ext: ext.attrib["sortorder"])
+
+        # Respect sortorder
+        for ext in deferred_exts:
+            process_ext(ext, deferred=True)
+
+        # Sort in alphabetical order.
+        self.extensions = sorted(extensions, key=lambda ext: ext["name"])
+
+    def _parse_features(self, root):
+        """ Parse the feature section, which describes Core commands and types needed. """
+
+        for feature in root.findall("./feature"):
+            if not api_is_openxr(feature):
+                continue
+            feature_name = feature.attrib["name"]
+            for require in feature.findall("require"):
+                LOGGER.info("Including features for {0}".format(require.attrib.get("comment")))
+                for tag in require:
+                    if tag.tag == "comment":
+                        continue
+                    elif tag.tag == "command":
+                        if not self._is_feature_supported(feature_name):
+                            continue
+                        name = tag.attrib["name"]
+                        self._mark_command_required(name)
+                    elif tag.tag == "enum":
+                        self._process_require_enum(tag)
+                    elif tag.tag == "type":
+                        name = tag.attrib["name"]
+
+                        # Skip pull in for openxr_platform_defines.h for now.
+                        if name == "openxr_platform_defines":
+                            continue
+
+                        self._mark_type_required(self.types[name])
+
+    def _parse_types(self, root):
+        """ Parse types section, which contains all data types e.g. structs, typedefs etcetera. """
+        types = root.findall("./types/type")
+
+        base_types = []
+        bitmasks = []
+        defines = []
+        funcpointers = []
+        handles = []
+        structs = []
+
+        alias_types = []
+        for t in types:
+            type_info = {}
+            type_info["category"] = t.attrib.get("category", None)
+            type_info["requires"] = t.attrib.get("requires", None)
+
+            # We parse aliases in a second pass when we know more.
+            alias = t.attrib.get("alias")
+            if alias:
+                LOGGER.debug("Alias found: {0}".format(alias))
+                alias_types.append(t)
+                continue
+
+            protect = t.attrib.get("protect", None)
+            if not protect is None and \
+                    not protect in ALLOWED_PROTECTS:
+                continue
+
+            if type_info["category"] in ["include"]:
+                continue
+
+            if type_info["category"] == "basetype":
+                name = t.find("name").text
+                _type = None
+                if not t.find("type") is None:
+                    _type = t.find("type").text
+#                    tail = t.find("type").tail
+#                    if tail is not None:
+#                        _type += tail.strip()
+
+                if (_type == "XR_DEFINE_ATOM"):
+                    _type = "uint64_t"
+                elif (_type == "XR_DEFINE_OPAQUE_64"):
+                    _type = "struct " + name + "_T*"
+
+                basetype = XrBaseType(name, _type)
+                if basetype:
+                    base_types.append(basetype)
+                    type_info["data"] = basetype
+                else:
+                    continue
+
+            # Basic C types don't need us to define them, but we do need data for them
+            if type_info["requires"] == "xr_platform":
+                requires = type_info["requires"]
+                basic_c = XrBaseType(name, _type, requires=requires)
+                type_info["data"] = basic_c
+
+            if type_info["category"] == "bitmask":
+                name = t.find("name").text
+                _type = t.find("type").text
+
+                # Most bitmasks have a bitvalues attribute used to pull in
+                # required '*FlagBits" enum.
+                type_info["requires"] = t.attrib.get("bitvalues", None)
+
+                requires = type_info["requires"]
+                bitmask = XrBaseType(name, _type, requires=requires)
+                bitmasks.append(bitmask)
+                type_info["data"] = bitmask
+
+            if type_info["category"] == "define":
+                define = XrDefine.from_xml(t)
+                if define:
+                    defines.append(define)
+                    type_info["data"] = define
+                else:
+                    continue
+
+            if type_info["category"] == "enum":
+                name = t.attrib.get("name")
+                # The type section only contains enum names, not the actual definition.
+                # Since we already parsed the enum before, just link it in.
+                try:
+                    type_info["data"] = self.enums[name]
+                except KeyError:
+                    # Not all enums seem to be defined yet, typically that's for
+                    # ones ending in 'FlagBits' where future extensions may add
+                    # definitions.
+                    type_info["data"] = None
+
+            if type_info["category"] == "funcpointer":
+                funcpointer = XrFunctionPointer.from_xml(t)
+                if funcpointer:
+                    funcpointers.append(funcpointer)
+                    type_info["data"] = funcpointer
+                else:
+                    continue
+
+            if type_info["category"] == "handle":
+                handle = XrHandle.from_xml(t)
+                if handle:
+                    handles.append(handle)
+                    type_info["data"] = handle
+                else:
+                    continue
+
+            if type_info["category"] in ["struct", "union"]:
+                # We store unions among structs as some structs depend
+                # on unions. The types are very similar in parsing and
+                # generation anyway. The official Vulkan scripts use
+                # a similar kind of hack.
+                struct = XrStruct.from_xml(t)
+                if struct:
+                    structs.append(struct)
+                    type_info["data"] = struct
+                else:
+                    continue
+
+            # Name is in general within a name tag else it is an optional
+            # attribute on the type tag.
+            name_elem = t.find("name")
+            if name_elem is not None:
+                type_info["name"] = name_elem.text
+            else:
+                type_info["name"] = t.attrib.get("name", None)
+
+            # Store all type data in a shared dictionary, so we can easily
+            # look up information for a given type. There are no duplicate
+            # names.
+            self.types[type_info["name"]] = type_info
+
+        # Second pass for alias types, so we can retrieve all data from
+        # the aliased object.
+        for t in alias_types:
+            type_info = {}
+            type_info["category"] = t.attrib.get("category")
+            type_info["name"] = t.attrib.get("name")
+
+            alias = t.attrib.get("alias")
+
+            if type_info["category"] == "bitmask":
+                bitmask = XrBaseType(type_info["name"], alias, alias=self.types[alias]["data"])
+                bitmasks.append(bitmask)
+                type_info["data"] = bitmask
+
+            if type_info["category"] == "enum":
+                enum = XrEnum.from_alias(t, self.types[alias]["data"])
+                type_info["data"] = enum
+                self.enums[enum.name] = enum
+
+            if type_info["category"] == "handle":
+                handle = XrHandle.from_alias(t, self.types[alias]["data"])
+                handles.append(handle)
+                type_info["data"] = handle
+
+            if type_info["category"] == "struct":
+                struct = XrStruct.from_alias(t, self.types[alias]["data"])
+                structs.append(struct)
+                type_info["data"] = struct
+
+            self.types[type_info["name"]] = type_info
+
+        # We need detailed type information during code generation
+        # on structs for alignment reasons. Unfortunately structs
+        # are parsed among other types, so there is no guarantee
+        # that any types needed have been parsed already, so set
+        # the data now.
+        for struct in structs:
+            struct.set_type_info(self.types)
+
+            # Alias structures have enum values equivalent to those of the
+            # structure which they are aliased against. we need to ignore alias
+            # structs when populating the struct extensions list, otherwise we
+            # will create duplicate case entries.
+            if struct.alias:
+                continue
+
+            for structextend in struct.structextends:
+                s = self.types[structextend]["data"]
+                s.struct_extensions.append(struct)
+
+        # Guarantee everything is sorted, so code generation doesn't have
+        # to deal with this.
+        self.base_types = sorted(base_types, key=lambda base_type: base_type.name)
+        self.bitmasks = sorted(bitmasks, key=lambda bitmask: bitmask.name)
+        self.defines = defines
+        self.enums = OrderedDict(sorted(self.enums.items()))
+        self.funcpointers = funcpointers
+        self.handles = sorted(handles, key=lambda handle: handle.name)
+        self.structs = sorted(structs, key=lambda struct: struct.name)
+
+def generate_openxr_json(f):
+    f.write("{\n")
+    f.write("    \"file_format_version\": \"1.0.0\",\n")
+    f.write("    \"ICD\": {\n")
+    f.write("        \"library_path\": \".\\\\wineopenxr.dll\",\n")
+    f.write("        \"api_version\": \"{0}\"\n".format(XR_XML_VERSION))
+    f.write("    }\n")
+    f.write("}\n")
+
+def set_working_directory():
+    path = os.path.abspath(__file__)
+    path = os.path.dirname(path)
+    os.chdir(path)
+
+def download_xr_xml(filename):
+    url = "https://raw.githubusercontent.com/KhronosGroup/OpenXR-SDK/release-{0}/specification/registry/xr.xml".format(XR_XML_VERSION)
+    if not os.path.isfile(filename):
+        urllib.request.urlretrieve(url, filename)
+
+def main():
+    parser = argparse.ArgumentParser()
+    parser.add_argument("-v", "--verbose", action="count", default=0, help="increase output verbosity")
+    parser.add_argument("-x", "--xml", default=None, type=str, help="path to specification XML file")
+
+    args = parser.parse_args()
+    if args.verbose == 0:
+        LOGGER.setLevel(logging.WARNING)
+    elif args.verbose == 1:
+        LOGGER.setLevel(logging.INFO)
+    else: # > 1
+        LOGGER.setLevel(logging.DEBUG)
+
+    set_working_directory()
+
+    if args.xml:
+        xr_xml = args.xml
+    else:
+        xr_xml = "xr-{0}.xml".format(XR_XML_VERSION)
+        download_xr_xml(xr_xml)
+
+    registry = XrRegistry(xr_xml)
+    generator = XrGenerator(registry)
+
+    with open(WINE_OPENXR_H, "w") as f:
+        generator.generate_openxr_h(f)
+
+    with open(WINE_OPENXR_THUNKS_H, "w") as f:
+        generator.generate_thunks_h(f, "wine_")
+
+    with open(WINE_OPENXR_THUNKS_C, "w") as f:
+        generator.generate_thunks_c(f)
+
+    with open(WINE_OPENXR_LOADER_THUNKS_H, "w") as f:
+        generator.generate_loader_thunks_h(f)
+
+    with open(WINE_OPENXR_LOADER_THUNKS_C, "w") as f:
+        generator.generate_loader_thunks_c(f)
+
+    with open(WINE_OPENXR_JSON, "w") as f:
+        generate_openxr_json(f)
+
+if __name__ == "__main__":
+    main()
diff --git a/dlls/wineopenxr/openxr.c b/dlls/wineopenxr/openxr.c
new file mode 100644
index 00000000000..a37eceb0516
--- /dev/null
+++ b/dlls/wineopenxr/openxr.c
@@ -0,0 +1,409 @@
+#if 0
+#pragma makedep unix
+#endif
+
+#define _GNU_SOURCE
+#include <dlfcn.h>
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "windef.h"
+#include "winnt.h"
+#include "wine/server_protocol.h"
+
+#include "openxr_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(openxr);
+
+static struct {
+  const char *win32_ext, *linux_ext;
+  BOOL remove_original;
+  BOOL force_enable;
+} substitute_extensions[] = {
+    {"XR_KHR_D3D11_enable", "XR_KHR_vulkan_enable"},
+    {"XR_KHR_D3D12_enable", "XR_KHR_vulkan_enable"},
+    {"XR_KHR_win32_convert_performance_counter_time", "XR_KHR_convert_timespec_time", TRUE, TRUE},
+};
+
+struct openxr_instance_funcs g_xr_host_instance_dispatch_table;
+
+VkDevice (*get_native_VkDevice)(VkDevice);
+VkInstance (*get_native_VkInstance)(VkInstance);
+VkPhysicalDevice (*get_native_VkPhysicalDevice)(VkPhysicalDevice);
+VkPhysicalDevice (*get_wrapped_VkPhysicalDevice)(VkInstance, VkPhysicalDevice);
+VkQueue (*get_native_VkQueue)(VkQueue);
+
+XrResult WINAPI wine_xrCreateInstance(const XrInstanceCreateInfo *createInfo, XrInstance *instance) {
+  XrResult res;
+  uint32_t i, j, count = 0;
+  XrInstanceCreateInfo our_createInfo;
+  const char *ext_name;
+  const char **new_list;
+
+  TRACE("%p, %p\n", createInfo, instance);
+
+  TRACE("Incoming extensions:\n");
+  for (i = 0; i < createInfo->enabledExtensionCount; ++i) {
+    TRACE("  -%s\n", createInfo->enabledExtensionNames[i]);
+  }
+
+  new_list = malloc(createInfo->enabledExtensionCount * sizeof(*new_list));
+
+  /* remove win32 extensions */
+  for (i = 0; i < createInfo->enabledExtensionCount; ++i) {
+    ext_name = createInfo->enabledExtensionNames[i];
+    for (j = 0; j < ARRAY_SIZE(substitute_extensions); ++j) {
+      if (!strcmp(ext_name, substitute_extensions[j].win32_ext)) {
+        if (substitute_extensions[j].force_enable) {
+          ext_name = NULL;
+        } else {
+          ext_name = substitute_extensions[j].linux_ext;
+        }
+        break;
+      }
+    }
+    if (ext_name) {
+      new_list[count++] = ext_name;
+    }
+  }
+
+  our_createInfo = *createInfo;
+  our_createInfo.enabledExtensionNames = (const char *const *)new_list;
+  our_createInfo.enabledExtensionCount = count;
+  createInfo = &our_createInfo;
+
+  TRACE("Enabled extensions:\n");
+  for (i = 0; i < createInfo->enabledExtensionCount; ++i) {
+    TRACE("  -%s\n", createInfo->enabledExtensionNames[i]);
+  }
+
+  res = xrCreateInstance(createInfo, instance);
+  if (res != XR_SUCCESS) {
+    WARN("xrCreateInstance failed: %d\n", res);
+    goto cleanup;
+  }
+
+#define USE_XR_FUNC(x) \
+  xrGetInstanceProcAddr(*instance, #x, (PFN_xrVoidFunction *)&g_xr_host_instance_dispatch_table.p_##x);
+  ALL_XR_INSTANCE_FUNCS()
+#undef USE_XR_FUNC
+
+cleanup:
+  free((void *)our_createInfo.enabledExtensionNames);
+  return res;
+}
+
+XrResult WINAPI wine_xrCreateSession(XrInstance instance, const XrSessionCreateInfo *createInfo, XrSession *session) {
+  wine_XrInstance *wine_instance = wine_instance_from_handle(instance);
+  XrResult res;
+  XrSessionCreateInfo our_create_info;
+  XrGraphicsBindingVulkanKHR our_vk_binding;
+
+  if (createInfo->next) {
+    switch (((XrBaseInStructure *)createInfo->next)->type) {
+      case XR_TYPE_GRAPHICS_BINDING_VULKAN2_KHR /* == XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR */: {
+        const XrGraphicsBindingVulkanKHR *their_vk_binding = (const XrGraphicsBindingVulkanKHR *)createInfo->next;
+
+        our_vk_binding = *their_vk_binding;
+        our_vk_binding.instance = get_native_VkInstance(their_vk_binding->instance);
+        our_vk_binding.physicalDevice = get_native_VkPhysicalDevice(their_vk_binding->physicalDevice);
+        our_vk_binding.device = get_native_VkDevice(their_vk_binding->device);
+
+        our_create_info = *createInfo;
+        our_create_info.next = &our_vk_binding;
+        createInfo = &our_create_info;
+        break;
+      }
+      default:
+        WARN("Unhandled graphics binding type: %d\n", ((XrBaseInStructure *)createInfo->next)->type);
+        break;
+    }
+  }
+
+  res = g_xr_host_instance_dispatch_table.p_xrCreateSession(wine_instance->host_instance, createInfo, session);
+  if (res != XR_SUCCESS) {
+    WARN("xrCreateSession failed: %d\n", res);
+    return res;
+  }
+
+  return XR_SUCCESS;
+}
+
+XrResult WINAPI wine_xrCreateSwapchain(XrSession session,
+                                       const XrSwapchainCreateInfo *createInfo,
+                                       XrSwapchain *swapchain) {
+  return g_xr_host_instance_dispatch_table.p_xrCreateSwapchain(wine_session_from_handle(session)->host_session,
+                                                               createInfo, swapchain);
+}
+
+XrResult WINAPI wine_xrEnumerateInstanceExtensionProperties(const char *layerName,
+                                                            uint32_t propertyCapacityInput,
+                                                            uint32_t *propertyCountOutput,
+                                                            XrExtensionProperties *properties) {
+  uint32_t i, j, dst, count, extra_extensions_count;
+  XrResult res;
+
+  TRACE("\n");
+
+  res = xrEnumerateInstanceExtensionProperties(layerName, propertyCapacityInput, propertyCountOutput, properties);
+  if (res != XR_SUCCESS) {
+    return res;
+  }
+
+  if (!properties) {
+    extra_extensions_count = 0;
+    for (i = 0; i < ARRAY_SIZE(substitute_extensions); ++i) {
+      if (!substitute_extensions[i].remove_original || substitute_extensions[i].force_enable) {
+        ++extra_extensions_count;
+      }
+    }
+
+    *propertyCountOutput += extra_extensions_count;
+    TRACE("%u extensions.\n", *propertyCountOutput);
+    return XR_SUCCESS;
+  }
+
+  count = *propertyCountOutput;
+  for (i = 0; i < count; ++i) {
+    for (j = 0; j < ARRAY_SIZE(substitute_extensions); ++j) {
+      if (!strcmp(properties[i].extensionName, substitute_extensions[j].linux_ext)) {
+        if (substitute_extensions[j].force_enable) {
+          FIXME("Force enabled extension %s already supported by the runtime.\n", substitute_extensions[j].linux_ext);
+          substitute_extensions[j].force_enable = FALSE;
+        }
+
+        if (substitute_extensions[j].remove_original) {
+          dst = i;
+        } else {
+          dst = (*propertyCountOutput)++;
+        }
+        strcpy(properties[dst].extensionName, substitute_extensions[j].win32_ext);
+      }
+    }
+  }
+
+  for (j = 0; j < ARRAY_SIZE(substitute_extensions); ++j) {
+    if (substitute_extensions[j].force_enable) {
+      strcpy(properties[*propertyCountOutput].extensionName, substitute_extensions[j].win32_ext);
+      ++*propertyCountOutput;
+    }
+  }
+
+  TRACE("Enumerated extensions:\n");
+  for (i = 0; i < *propertyCountOutput; ++i) {
+    TRACE("  -%s\n", properties[i].extensionName);
+  }
+
+  return XR_SUCCESS;
+}
+
+XrResult WINAPI wine_xrGetVulkanGraphicsDeviceKHR(XrInstance instance,
+                                                  XrSystemId systemId,
+                                                  VkInstance vkInstance,
+                                                  VkPhysicalDevice *vkPhysicalDevice) {
+  XrResult res;
+  TRACE("%p, 0x%s, %p, %p\n", instance, wine_dbgstr_longlong(systemId), vkInstance, vkPhysicalDevice);
+  res = g_xr_host_instance_dispatch_table.p_xrGetVulkanGraphicsDeviceKHR(
+      wine_instance_from_handle(instance)->host_instance, systemId, get_native_VkInstance(vkInstance),
+      vkPhysicalDevice);
+  *vkPhysicalDevice = get_wrapped_VkPhysicalDevice(vkInstance, *vkPhysicalDevice);
+  return res;
+}
+
+XrResult WINAPI wine_xrGetVulkanGraphicsDevice2KHR(XrInstance instance,
+                                                   const XrVulkanGraphicsDeviceGetInfoKHR *getInfo,
+                                                   VkPhysicalDevice *vulkanPhysicalDevice) {
+  XrVulkanGraphicsDeviceGetInfoKHR our_getinfo;
+  XrResult res;
+
+  TRACE("instance %p, getInfo %p, vulkanPhysicalDevice %p.\n", instance, getInfo, vulkanPhysicalDevice);
+
+  if (getInfo->next) {
+    WARN("Unsupported chained structure %p.\n", getInfo->next);
+  }
+
+  our_getinfo = *getInfo;
+  our_getinfo.vulkanInstance = get_native_VkInstance(our_getinfo.vulkanInstance);
+
+  res = g_xr_host_instance_dispatch_table.p_xrGetVulkanGraphicsDevice2KHR(
+      wine_instance_from_handle(instance)->host_instance, &our_getinfo, vulkanPhysicalDevice);
+  if (res == XR_SUCCESS) {
+    *vulkanPhysicalDevice = get_wrapped_VkPhysicalDevice(getInfo->vulkanInstance, *vulkanPhysicalDevice);
+  }
+  return res;
+}
+
+XrResult WINAPI wine_xrGetVulkanInstanceExtensionsKHR(XrInstance instance,
+                                                      XrSystemId systemId,
+                                                      uint32_t bufferCapacityInput,
+                                                      uint32_t *bufferCountOutput,
+                                                      char *buffer) {
+  static const char win32_surface[] = "VK_KHR_surface VK_KHR_win32_surface";
+
+  XrResult res;
+  uint32_t lin_len;
+
+  TRACE("%p, 0x%s, %u, %p, %p\n", instance, wine_dbgstr_longlong(systemId), bufferCapacityInput, bufferCountOutput,
+        buffer);
+
+  /* Linux SteamVR does not return xlib_surface, but Windows SteamVR _does_
+   * return win32_surface. Some games (including hello_xr) depend on that, so
+   * add it here. */
+
+  res = g_xr_host_instance_dispatch_table.p_xrGetVulkanInstanceExtensionsKHR(
+      wine_instance_from_handle(instance)->host_instance, systemId, bufferCapacityInput, bufferCountOutput, buffer);
+  if (res == XR_SUCCESS) {
+    if (bufferCapacityInput > 0) {
+      /* *bufferCountOutput is not required to (and sometimes does not) contain the offset to the NUL byte */
+      lin_len = strlen(buffer) + 1;
+
+      if (bufferCapacityInput < lin_len + sizeof(win32_surface)) {
+        return XR_ERROR_SIZE_INSUFFICIENT;
+      }
+
+      buffer[lin_len - 1] = ' ';
+      memcpy(&buffer[lin_len], win32_surface, sizeof(win32_surface));
+
+      TRACE("returning: %s\n", buffer);
+      *bufferCountOutput = lin_len + sizeof(win32_surface);
+    } else {
+      *bufferCountOutput += sizeof(win32_surface) /* NUL byte included for required ' ' */;
+    }
+  }
+
+  return res;
+}
+
+static VkResult WINAPI vk_create_instance_callback(const VkInstanceCreateInfo *create_info,
+                                                   const VkAllocationCallbacks *allocator,
+                                                   VkInstance *vk_instance,
+                                                   void *(*pfnGetInstanceProcAddr)(VkInstance, const char *),
+                                                   void *context) {
+  struct vk_create_callback_context *c = context;
+  XrVulkanInstanceCreateInfoKHR our_create_info;
+  VkInstanceCreateInfo our_vulkan_create_info;
+  const char **enabled_extensions = NULL;
+  unsigned int i;
+  VkResult ret;
+
+  our_create_info = *(const XrVulkanInstanceCreateInfoKHR *)c->create_info;
+  our_create_info.pfnGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)pfnGetInstanceProcAddr;
+  our_create_info.vulkanCreateInfo = create_info;
+  our_create_info.vulkanAllocator = allocator;
+
+  for (i = 0; i < create_info->enabledExtensionCount; ++i) {
+    if (!strcmp(create_info->ppEnabledExtensionNames[i], "VK_KHR_surface")) {
+      break;
+    }
+  }
+
+  if (i == create_info->enabledExtensionCount) {
+    our_vulkan_create_info = *create_info;
+    our_create_info.vulkanCreateInfo = &our_vulkan_create_info;
+
+    enabled_extensions = malloc((create_info->enabledExtensionCount + 2) * sizeof(*enabled_extensions));
+    memcpy(enabled_extensions, create_info->ppEnabledExtensionNames,
+           create_info->enabledExtensionCount * sizeof(*enabled_extensions));
+    enabled_extensions[our_vulkan_create_info.enabledExtensionCount++] = "VK_KHR_surface";
+    enabled_extensions[our_vulkan_create_info.enabledExtensionCount++] = "VK_KHR_xlib_surface";
+    our_vulkan_create_info.ppEnabledExtensionNames = enabled_extensions;
+  }
+
+  c->ret = g_xr_host_instance_dispatch_table.p_xrCreateVulkanInstanceKHR(
+      wine_instance_from_handle(c->wine_instance)->host_instance, &our_create_info, vk_instance, &ret);
+  free(enabled_extensions);
+  return ret;
+}
+
+static VkResult WINAPI vk_create_device_callback(VkPhysicalDevice phys_dev,
+                                                 const VkDeviceCreateInfo *create_info,
+                                                 const VkAllocationCallbacks *allocator,
+                                                 VkDevice *vk_device,
+                                                 void *(*pfnGetInstanceProcAddr)(VkInstance, const char *),
+                                                 void *context) {
+  /* Only Unix calls here, called from the Unix side. */
+  struct vk_create_callback_context *c = context;
+  XrVulkanDeviceCreateInfoKHR our_create_info;
+  VkResult ret;
+
+  our_create_info = *(const XrVulkanDeviceCreateInfoKHR *)c->create_info;
+  our_create_info.pfnGetInstanceProcAddr = (PFN_vkGetInstanceProcAddr)pfnGetInstanceProcAddr;
+  our_create_info.vulkanPhysicalDevice = phys_dev;
+  our_create_info.vulkanCreateInfo = create_info;
+  our_create_info.vulkanAllocator = allocator;
+  c->ret = g_xr_host_instance_dispatch_table.p_xrCreateVulkanDeviceKHR(
+      wine_instance_from_handle(c->wine_instance)->host_instance, &our_create_info, vk_device, &ret);
+  return ret;
+}
+
+NTSTATUS init_openxr(void *args) {
+  struct init_openxr_params *params = args;
+  NTSTATUS status;
+  unixlib_handle_t unix_funcs;
+  Dl_info info;
+  void *unix_handle;
+
+  status = NtQueryVirtualMemory(GetCurrentProcess(), params->winevulkan,
+                                (MEMORY_INFORMATION_CLASS)1000 /*MemoryWineUnixFuncs*/, &unix_funcs, sizeof(unix_funcs),
+                                NULL);
+  if (status) {
+    ERR("NtQueryVirtualMemory status %#x.\n", (int)status);
+    return status;
+  }
+
+  if (!dladdr((void *)(ULONG_PTR)unix_funcs, &info)) {
+    ERR("dladdr failed.\n");
+    return STATUS_INVALID_PARAMETER;
+  }
+
+  TRACE("path %s.\n", info.dli_fname);
+  if (!(unix_handle = dlopen(info.dli_fname, RTLD_NOW))) {
+    ERR("dlopen failed.\n");
+    return STATUS_INVALID_PARAMETER;
+  }
+
+#define L(name)                                      \
+  if (!(name = dlsym(unix_handle, "__wine_" #name))) \
+    ERR("%s not found.\n", #name);
+
+  L(get_native_VkDevice);
+  L(get_native_VkInstance);
+  L(get_native_VkPhysicalDevice);
+  L(get_wrapped_VkPhysicalDevice);
+  L(get_native_VkQueue);
+#undef L
+
+  dlclose(unix_handle);
+
+  params->create_instance_callback = (UINT64)&vk_create_instance_callback;
+  params->create_device_callback = (UINT64)&vk_create_device_callback;
+
+  return STATUS_SUCCESS;
+}
+
+NTSTATUS is_available_instance_function_openxr(void *args)
+{
+  struct is_available_instance_function_openxr_params *params = args;
+  static const char *always_supported[] =
+  {
+    "xrGetD3D11GraphicsRequirementsKHR",
+    "xrGetD3D12GraphicsRequirementsKHR",
+    "xrConvertTimeToWin32PerformanceCounterKHR",
+    "xrConvertWin32PerformanceCounterToTimeKHR",
+  };
+  wine_XrInstance *wine_instance = wine_instance_from_handle(params->instance);
+  PFN_xrVoidFunction fn;
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE(always_supported); ++i)
+  {
+    if (!strcmp(params->name, always_supported[i]))
+    {
+      params->ret = XR_SUCCESS;
+      return STATUS_SUCCESS;
+    }
+  }
+
+  params->ret = xrGetInstanceProcAddr(wine_instance ? wine_instance->host_instance : NULL, params->name, &fn);
+  return STATUS_SUCCESS;
+}
diff --git a/dlls/wineopenxr/openxr_loader.c b/dlls/wineopenxr/openxr_loader.c
new file mode 100644
index 00000000000..14dffd725f1
--- /dev/null
+++ b/dlls/wineopenxr/openxr_loader.c
@@ -0,0 +1,2015 @@
+#include <stdlib.h>
+
+#include "initguid.h"
+#include "openxr_loader.h"
+#include "wine/unixlib.h"
+#include "wine/vulkan_driver.h"
+#include "dxvk-interop.h"
+#include "vkd3d-proton-interop.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(openxr);
+
+static uint32_t g_physdev_vid, g_physdev_pid;
+static char *g_instance_extensions, *g_device_extensions;
+static XrVersion api_version = XR_CURRENT_API_VERSION;
+
+#define SESSION_TYPE_VULKAN 1
+#define SESSION_TYPE_OPENGL 2
+#define SESSION_TYPE_D3D11 3
+#define SESSION_TYPE_D3D12 4
+
+UINT64 g_vk_create_instance_callback;
+UINT64 g_vk_create_device_callback;
+
+union CompositionLayer {
+  XrCompositionLayerProjection projection;
+  XrCompositionLayerQuad quad;
+  XrCompositionLayerCubeKHR cube;
+  XrCompositionLayerDepthInfoKHR depth_info;
+  XrCompositionLayerCylinderKHR cylinder;
+  XrCompositionLayerEquirectKHR equirect;
+  XrCompositionLayerEquirect2KHR equirect2;
+};
+
+static CRITICAL_SECTION session_list_lock = {NULL, -1, 0, 0, 0, 0};
+static struct list session_list = LIST_INIT(session_list);
+
+static wine_XrSession *get_wrapped_XrSession(XrSession native) {
+  wine_XrSession *cursor;
+
+  EnterCriticalSection(&session_list_lock);
+
+  LIST_FOR_EACH_ENTRY(cursor, &session_list, wine_XrSession, entry) {
+    if (cursor->host_session == native) {
+      break;
+    }
+  }
+
+  LeaveCriticalSection(&session_list_lock);
+
+  if (&cursor->entry == &session_list) {
+    return NULL;
+  }
+
+  return cursor;
+}
+
+static void parse_extensions(const char *in, uint32_t *out_count, char ***out_strs) {
+  char *iter, *start;
+  char **list, *str = strdup(in);
+  uint32_t extension_count = 0, o = 0;
+
+  iter = str;
+  while (*iter) {
+    if (*iter++ == ' ') {
+      extension_count++;
+    }
+  }
+  /* count the one ending in NUL */
+  if (iter != str) {
+    extension_count++;
+  }
+  if (!extension_count) {
+    *out_count = 0;
+    *out_strs = NULL;
+    return;
+  }
+
+  list = malloc(extension_count * sizeof(char *));
+
+  start = iter = str;
+  do {
+    if (*iter == ' ') {
+      *iter = 0;
+      list[o++] = strdup(start);
+      TRACE("added %s to list\n", list[o - 1]);
+      iter++;
+      start = iter;
+    } else if (*iter == 0) {
+      list[o++] = strdup(start);
+      TRACE("added %s to list\n", list[o - 1]);
+      break;
+    } else {
+      iter++;
+    }
+  } while (1);
+
+  *out_count = extension_count;
+  *out_strs = list;
+}
+
+static BOOL get_vulkan_extensions(void) {
+  /* Linux SteamVR's xrCreateInstance will hang forever if SteamVR hasn't
+   * already been launched by the user.  Since that's the only way to tell if
+   * OpenXR is functioning, let's use OpenVR to tell whether SteamVR is
+   * functioning before calling xrCreateInstance.
+   *
+   * This should be removed when SteamVR's bug is fixed. */
+  DWORD type, value, wait_status = 0, size;
+  LSTATUS status;
+  HANDLE event;
+  HKEY vr_key;
+
+  if ((status = RegOpenKeyExA(HKEY_CURRENT_USER, "Software\\Wine\\VR", 0, KEY_READ, &vr_key))) {
+    ERR("Could not create key, status %#x.\n", status);
+    return FALSE;
+  }
+
+  size = sizeof(value);
+  if ((status = RegQueryValueExA(vr_key, "state", NULL, &type, (BYTE *)&value, &size))) {
+    ERR("Could not query value, status %#x.\n", status);
+    RegCloseKey(vr_key);
+    return FALSE;
+  }
+  if (type != REG_DWORD) {
+    ERR("Unexpected value type %#x.\n", type);
+    RegCloseKey(vr_key);
+    return FALSE;
+  }
+
+  if (value) {
+    goto done;
+  }
+
+  event = CreateEventA(NULL, FALSE, FALSE, NULL);
+  while (1) {
+    if (RegNotifyChangeKeyValue(vr_key, FALSE, REG_NOTIFY_CHANGE_LAST_SET, event, TRUE)) {
+      ERR("Error registering registry change notification.\n");
+      CloseHandle(event);
+      goto done;
+    }
+    size = sizeof(value);
+    if ((status = RegQueryValueExA(vr_key, "state", NULL, &type, (BYTE *)&value, &size))) {
+      ERR("Could not query value, status %#x.\n", status);
+      CloseHandle(event);
+      goto done;
+    }
+    if (value) {
+      break;
+    }
+    while ((wait_status = WaitForSingleObject(event, 1000)) == WAIT_TIMEOUT) {
+      ERR("VR state wait timeout.\n");
+    }
+
+    if (wait_status != WAIT_OBJECT_0) {
+      ERR("Got unexpected wait status %#x.\n", wait_status);
+      break;
+    }
+  }
+  CloseHandle(event);
+
+done:
+  if (value == 1) {
+    if ((status = RegQueryValueExA(vr_key, "openxr_vulkan_instance_extensions", NULL, &type, NULL, &size))) {
+      ERR("Error getting openxr_vulkan_instance_extensions, status %#x.\n", status);
+      RegCloseKey(vr_key);
+      return FALSE;
+    }
+    g_instance_extensions = malloc(size);
+    if ((status = RegQueryValueExA(vr_key, "openxr_vulkan_instance_extensions", NULL, &type,
+                                   (BYTE *)g_instance_extensions, &size))) {
+      ERR("Error getting openxr_vulkan_instance_extensions, status %#x.\n", status);
+      RegCloseKey(vr_key);
+      return FALSE;
+    }
+    if ((status = RegQueryValueExA(vr_key, "openxr_vulkan_device_extensions", NULL, &type, NULL, &size))) {
+      ERR("Error getting openxr_vulkan_device_extensions, status %#x.\n", status);
+      RegCloseKey(vr_key);
+      return FALSE;
+    }
+    g_device_extensions = malloc(size);
+    if ((status = RegQueryValueExA(vr_key, "openxr_vulkan_device_extensions", NULL, &type, (BYTE *)g_device_extensions,
+                                   &size))) {
+      ERR("Error getting openxr_vulkan_device_extensions, status %#x.\n", status);
+      RegCloseKey(vr_key);
+      return FALSE;
+    }
+    if ((status = RegQueryValueExA(vr_key, "openxr_vulkan_device_vid", NULL, &type, (BYTE *)&g_physdev_vid, &size))) {
+      ERR("Error getting openxr_vulkan_device_vid, status: %#x.\n", status);
+      RegCloseKey(vr_key);
+      return FALSE;
+    }
+    if ((status = RegQueryValueExA(vr_key, "openxr_vulkan_device_pid", NULL, &type, (BYTE *)&g_physdev_pid, &size))) {
+      ERR("Error getting openxr_vulkan_device_pid, status: %#x.\n", status);
+      RegCloseKey(vr_key);
+      return FALSE;
+    }
+  }
+
+  RegCloseKey(vr_key);
+  return value == 1;
+}
+
+static BOOL WINAPI wine_openxr_unix_init(INIT_ONCE *once, void *param, void **context) {
+  struct init_openxr_params params = {.winevulkan = LoadLibraryA("winevulkan.dll")};
+  if (__wine_init_unix_call() || UNIX_CALL(init, &params)) {
+    return FALSE;
+  }
+  g_vk_create_instance_callback = params.create_instance_callback;
+  g_vk_create_device_callback = params.create_device_callback;
+  return TRUE;
+}
+
+static BOOL wine_openxr_unix_init_once(void) {
+  static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+
+  return InitOnceExecuteOnce(&init_once, wine_openxr_unix_init, NULL, NULL);
+}
+
+static XrResult wine_openxr_init_once(void) {
+  if (g_instance_extensions || g_device_extensions) {
+    /* already done */
+    return XR_SUCCESS;
+  }
+
+  if (!wine_openxr_unix_init_once()) {
+    return XR_ERROR_INITIALIZATION_FAILED;
+  }
+
+  if (!get_vulkan_extensions()) {
+    return XR_ERROR_INITIALIZATION_FAILED;
+  }
+
+  TRACE("g_device_extensions %s.\n", g_device_extensions);
+  __wine_set_unix_env(WINE_VULKAN_DEVICE_VARIABLE, g_device_extensions);
+  return XR_SUCCESS;
+}
+
+static int get_extensions(char **ret_instance_extensions, char **ret_device_extensions,
+                          uint32_t *ret_physdev_vid, uint32_t *ret_physdev_pid) {
+  PFN_xrGetVulkanInstanceExtensionsKHR pxrGetVulkanInstanceExtensionsKHR;
+  PFN_xrGetSystem pxrGetSystem;
+  PFN_xrGetVulkanGraphicsDeviceKHR pxrGetVulkanGraphicsDeviceKHR;
+  PFN_xrGetVulkanGraphicsRequirementsKHR pxrGetVulkanGraphicsRequirementsKHR;
+  PFN_xrGetInstanceProperties pxrGetInstanceProperties;
+  PFN_xrEnumerateViewConfigurations pxrEnumerateViewConfigurations;
+  char *instance_extensions, *device_extensions;
+  uint32_t len, i;
+  XrInstance instance;
+  XrSystemId system;
+  XrResult res;
+  VkInstance vk_instance;
+  VkResult vk_res;
+  VkPhysicalDevice vk_physdev;
+  VkPhysicalDeviceProperties vk_dev_props;
+  struct xrGetVulkanDeviceExtensionsKHR_params params;
+  NTSTATUS status;
+
+  static const char *xr_extensions[] = {
+      "XR_KHR_vulkan_enable",
+  };
+
+  XrInstanceCreateInfo xrCreateInfo = {
+      .type = XR_TYPE_INSTANCE_CREATE_INFO,
+      .next = NULL,
+      .createFlags = 0,
+      .applicationInfo =
+          {
+              .applicationVersion = 0,
+              .engineVersion = 0,
+              .apiVersion = api_version,
+          },
+      .enabledApiLayerCount = 0,
+      .enabledApiLayerNames = NULL,
+      .enabledExtensionCount = ARRAY_SIZE(xr_extensions),
+      .enabledExtensionNames = xr_extensions,
+  };
+  XrInstanceProperties inst_props = {
+      .type = XR_TYPE_INSTANCE_PROPERTIES,
+  };
+  XrSystemGetInfo system_info = {
+      .type = XR_TYPE_SYSTEM_GET_INFO,
+      .formFactor = XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY,
+  };
+  XrGraphicsRequirementsVulkanKHR reqs = {
+      .type = XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR,
+  };
+  VkApplicationInfo vk_appinfo = {
+      .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
+      .pNext = NULL,
+      .pApplicationName = "wineopenxr test instance",
+      .applicationVersion = 0,
+      .pEngineName = "wineopenxr test instance",
+      .engineVersion = VK_MAKE_VERSION(1, 0, 0),
+      .apiVersion = VK_MAKE_VERSION(1, 1, 0),
+  };
+  VkInstanceCreateInfo vk_createinfo = {
+      .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
+      .pNext = NULL,
+      .flags = 0,
+      .pApplicationInfo = &vk_appinfo,
+      .enabledLayerCount = 0,
+      .ppEnabledLayerNames = NULL,
+      .enabledExtensionCount = 0,
+      .ppEnabledExtensionNames = NULL,
+  };
+  XrViewConfigurationType *configs;
+
+  if (!wine_openxr_unix_init_once()) {
+    WARN("unixlib initialization failed.\n");
+    return XR_ERROR_INITIALIZATION_FAILED;
+  }
+
+  strcpy(xrCreateInfo.applicationInfo.applicationName, "wineopenxr test instance");
+  strcpy(xrCreateInfo.applicationInfo.engineName, "wineopenxr test instance");
+
+  res = xrCreateInstance(&xrCreateInfo, &instance);
+  if (res == XR_ERROR_API_VERSION_UNSUPPORTED) {
+    WARN("version %#lx unsupported.\n", (long)api_version);
+    api_version = XR_MAKE_VERSION(1, 0, 0);
+    xrCreateInfo.applicationInfo.apiVersion = api_version;
+    res = xrCreateInstance(&xrCreateInfo, &instance);
+  }
+  if (res != XR_SUCCESS) {
+    WARN("xrCreateInstance failed: %d\n", res);
+    return res;
+  }
+
+  xrGetInstanceProcAddr(instance, "xrGetVulkanInstanceExtensionsKHR",
+                        (PFN_xrVoidFunction *)&pxrGetVulkanInstanceExtensionsKHR);
+  xrGetInstanceProcAddr(instance, "xrGetSystem", (PFN_xrVoidFunction *)&pxrGetSystem);
+  xrGetInstanceProcAddr(instance, "xrGetVulkanGraphicsDeviceKHR", (PFN_xrVoidFunction *)&pxrGetVulkanGraphicsDeviceKHR);
+  xrGetInstanceProcAddr(instance, "xrGetVulkanGraphicsRequirementsKHR",
+                        (PFN_xrVoidFunction *)&pxrGetVulkanGraphicsRequirementsKHR);
+  xrGetInstanceProcAddr(instance, "xrGetInstanceProperties", (PFN_xrVoidFunction *)&pxrGetInstanceProperties);
+  xrGetInstanceProcAddr(instance, "xrEnumerateViewConfigurations",
+                        (PFN_xrVoidFunction *)&pxrEnumerateViewConfigurations);
+
+  res = pxrGetInstanceProperties(instance, &inst_props);
+  if (res != XR_SUCCESS) {
+    WARN("xrGetInstanceProperties failed: %d\n", res);
+  }
+
+  res = pxrGetSystem(instance, &system_info, &system);
+  if (res != XR_SUCCESS) {
+    WARN("xrGetSystem failed: %d\n", res);
+    xrDestroyInstance(instance);
+    return res;
+  }
+
+  res = pxrEnumerateViewConfigurations(instance, system, 0, &len, NULL);
+  if (res != XR_SUCCESS) {
+    WARN("xrEnumerateViewConfigurations failed: %d\n", res);
+  }
+  configs = malloc(len * sizeof(*configs));
+  res = pxrEnumerateViewConfigurations(instance, system, len, &len, configs);
+  if (res != XR_SUCCESS) {
+    WARN("xrEnumerateViewConfigurations failed: %d\n", res);
+  }
+  free(configs);
+
+  res = pxrGetVulkanGraphicsRequirementsKHR(instance, system, &reqs);
+  if (res != XR_SUCCESS) {
+    WARN("xrGetVulkanGraphicsRequirementsKHR failed: %d\n", res);
+  }
+
+  res = pxrGetVulkanInstanceExtensionsKHR(instance, system, 0, &len, NULL);
+  if (res != XR_SUCCESS) {
+    WARN("xrGetVulkanInstanceExtensionsKHR failed: %d\n", res);
+    xrDestroyInstance(instance);
+    return res;
+  }
+  instance_extensions = malloc(len);
+  res = pxrGetVulkanInstanceExtensionsKHR(instance, system, len, &len, instance_extensions);
+  if (res != XR_SUCCESS) {
+    WARN("xrGetVulkanInstanceExtensionsKHR failed: %d\n", res);
+    xrDestroyInstance(instance);
+    free(instance_extensions);
+    return res;
+  }
+
+  parse_extensions(instance_extensions, &vk_createinfo.enabledExtensionCount,
+                   (char ***)&vk_createinfo.ppEnabledExtensionNames);
+
+  vk_res = vkCreateInstance(&vk_createinfo, NULL, &vk_instance);
+  if (vk_res != VK_SUCCESS) {
+    WARN("vkCreateInstance failed: %d\n", vk_res);
+    for (i = 0; i < vk_createinfo.enabledExtensionCount; ++i) {
+      free((void *)vk_createinfo.ppEnabledExtensionNames[i]);
+    }
+    free((void *)vk_createinfo.ppEnabledExtensionNames);
+    xrDestroyInstance(instance);
+    free(instance_extensions);
+    return XR_ERROR_INITIALIZATION_FAILED;
+  }
+
+  for (i = 0; i < vk_createinfo.enabledExtensionCount; ++i) {
+    free((void *)vk_createinfo.ppEnabledExtensionNames[i]);
+  }
+  free((void *)vk_createinfo.ppEnabledExtensionNames);
+
+  res = pxrGetVulkanGraphicsDeviceKHR(instance, system, vk_instance, &vk_physdev);
+  if (res != XR_SUCCESS) {
+    WARN("xrGetVulkanGraphicsDeviceKHR failed: %d\n", res);
+    vkDestroyInstance(vk_instance, NULL);
+    xrDestroyInstance(instance);
+    free(instance_extensions);
+    return res;
+  }
+
+  vkGetPhysicalDeviceProperties(vk_physdev, &vk_dev_props);
+  *ret_physdev_vid = vk_dev_props.vendorID;
+  *ret_physdev_pid = vk_dev_props.deviceID;
+
+  /* Call Unix thunk directly to get the real host extensions list */
+  params.instance = instance;
+  params.systemId = system;
+  params.bufferCapacityInput = 0;
+  params.bufferCountOutput = &len;
+  params.buffer = NULL;
+  status = UNIX_CALL(xrGetVulkanDeviceExtensionsKHR, &params);
+  assert(!status && "xrGetVulkanDeviceExtensionsKHR");
+  res = params.result;
+
+  if (res != XR_SUCCESS) {
+    WARN("pxrGetVulkanDeviceExtensionsKHR fail: %d\n", res);
+    vkDestroyInstance(vk_instance, NULL);
+    xrDestroyInstance(instance);
+    free(instance_extensions);
+    return res;
+  }
+  device_extensions = malloc(len);
+
+  params.bufferCapacityInput = len;
+  params.buffer = device_extensions;
+  status = UNIX_CALL(xrGetVulkanDeviceExtensionsKHR, &params);
+  assert(!status && "xrGetVulkanDeviceExtensionsKHR");
+  res = params.result;
+
+  if (res != XR_SUCCESS) {
+    WARN("pxrGetVulkanDeviceExtensionsKHR fail: %d\n", res);
+    vkDestroyInstance(vk_instance, NULL);
+    xrDestroyInstance(instance);
+    free(instance_extensions);
+    free(device_extensions);
+    return res;
+  }
+
+  vkDestroyInstance(vk_instance, NULL);
+  xrDestroyInstance(instance);
+
+  TRACE("Got required instance extensions: %s\n", instance_extensions);
+  TRACE("Got required device extensions: %s\n", device_extensions);
+
+  *ret_instance_extensions = instance_extensions;
+  *ret_device_extensions = device_extensions;
+
+  return XR_SUCCESS;
+}
+
+XrResult WINAPI xrCreateInstance(const XrInstanceCreateInfo *createInfo, XrInstance *instance) {
+  wine_XrInstance *wine_instance = calloc(1, sizeof(wine_XrInstance));
+  struct xrCreateInstance_params params = {
+      .createInfo = createInfo,
+      .instance = &wine_instance->host_instance,
+  };
+  NTSTATUS _status;
+  _status = UNIX_CALL(xrCreateInstance, &params);
+  assert(!_status && "xrCreateInstance");
+
+  if (params.result != XR_SUCCESS) {
+    WARN("xrCreateInstance failed: %d\n", params.result);
+    free(wine_instance);
+  } else {
+    *instance = (XrInstance)wine_instance;
+  }
+
+  return params.result;
+}
+
+XrResult WINAPI xrDestroyInstance(XrInstance instance) {
+  wine_XrInstance *wine_instance = wine_instance_from_handle(instance);
+  struct xrDestroyInstance_params params = {
+      .instance = instance,
+  };
+  NTSTATUS _status;
+
+  TRACE("\n");
+  _status = UNIX_CALL(xrDestroyInstance, &params);
+  assert(!_status && "xrDestroyInstance");
+
+  if (params.result != XR_SUCCESS) {
+    WARN("xrDestroyInstance failed: %d\n", params.result);
+    return params.result;
+  }
+
+  if (wine_instance->dxvk_device) {
+    wine_instance->dxvk_device->lpVtbl->Release(wine_instance->dxvk_device);
+  }
+
+  if (wine_instance->d3d12_device) {
+    vkDestroyCommandPool(wine_instance->vk_device, wine_instance->vk_command_pool, NULL);
+    assert(!wine_instance->d3d12_device2 || (void *)wine_instance->d3d12_device2 == (void *)wine_instance->d3d12_device);
+    wine_instance->d3d12_device->lpVtbl->Release(wine_instance->d3d12_device);
+    wine_instance->d3d12_queue->lpVtbl->Release(wine_instance->d3d12_queue);
+  }
+
+  free(wine_instance);
+
+  return XR_SUCCESS;
+}
+
+/* SteamVR does some internal init during these functions. */
+static XrResult do_vulkan_init(wine_XrInstance *wine_instance, VkInstance vk_instance) {
+  XrInstance instance = (XrInstance)wine_instance;
+  char *instance_extensions, *device_extensions;
+  XrGraphicsRequirementsVulkanKHR vk_reqs;
+  XrResult res;
+  uint32_t len;
+
+  vk_reqs.type = XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR;
+  vk_reqs.next = NULL;
+  res = xrGetVulkanGraphicsRequirementsKHR(instance, wine_instance->systemId, &vk_reqs);
+  if (res != XR_SUCCESS) {
+    WINE_WARN("xrGetVulkanGraphicsRequirementsKHR failed: %d\n", res);
+    return res;
+  }
+
+  res = xrGetVulkanInstanceExtensionsKHR(instance, wine_instance->systemId, 0, &len, NULL);
+  if (res != XR_SUCCESS) {
+    WINE_WARN("xrGetVulkanInstanceExtensionsKHR failed: %d\n", res);
+    return res;
+  }
+  instance_extensions = malloc(len);
+  res = xrGetVulkanInstanceExtensionsKHR(instance, wine_instance->systemId, len, &len, instance_extensions);
+  if (res != XR_SUCCESS) {
+    WINE_WARN("xrGetVulkanInstanceExtensionsKHR failed: %d\n", res);
+    free(instance_extensions);
+    return res;
+  }
+
+  res = xrGetVulkanGraphicsDeviceKHR(instance, wine_instance->systemId, vk_instance, &wine_instance->vk_phys_dev);
+  if (res != XR_SUCCESS) {
+    WINE_WARN("xrGetVulkanGraphicsDeviceKHR failed: %d\n", res);
+    return res;
+  }
+
+  res = xrGetVulkanDeviceExtensionsKHR(instance, wine_instance->systemId, 0, &len, NULL);
+  if (res != XR_SUCCESS) {
+    WINE_WARN("pxrGetVulkanDeviceExtensionsKHR fail: %d\n", res);
+    return res;
+  }
+  device_extensions = malloc(len);
+  res = xrGetVulkanDeviceExtensionsKHR(instance, wine_instance->systemId, len, &len, device_extensions);
+  if (res != XR_SUCCESS) {
+    WINE_WARN("pxrGetVulkanDeviceExtensionsKHR fail: %d\n", res);
+    free(device_extensions);
+    return res;
+  }
+  free(device_extensions);
+
+  return XR_SUCCESS;
+}
+
+XrResult WINAPI xrCreateSession(XrInstance instance, const XrSessionCreateInfo *createInfo, XrSession *session) {
+  wine_XrInstance *wine_instance = wine_instance_from_handle(instance);
+  wine_XrSession *wine_session = calloc(1, sizeof(wine_XrSession));
+  XrSessionCreateInfo our_create_info = *createInfo;
+  XrGraphicsBindingVulkanKHR our_vk_binding;
+  struct xrCreateSession_params params = {
+      .instance = instance,
+      .createInfo = &our_create_info,
+      .session = &wine_session->host_session,
+  };
+  XrResult res;
+  NTSTATUS _status;
+  uint32_t session_type = 0;
+
+  TRACE("%p, %p, %p\n", instance, createInfo, session);
+
+  if (createInfo->next) {
+    switch (((XrBaseInStructure *)createInfo->next)->type) {
+      case XR_TYPE_GRAPHICS_BINDING_VULKAN2_KHR /* == XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR */: {
+        session_type = SESSION_TYPE_VULKAN;
+        break;
+      }
+      case XR_TYPE_GRAPHICS_BINDING_D3D11_KHR: {
+        const XrGraphicsBindingD3D11KHR *their_d3d11_binding = (const XrGraphicsBindingD3D11KHR *)createInfo->next;
+        HRESULT hr;
+
+        hr = ID3D11Device_QueryInterface(their_d3d11_binding->device, &IID_IDXGIVkInteropDevice2,
+                                         (void **)&wine_instance->dxvk_device);
+        if (FAILED(hr)) {
+          WARN("Given ID3D11Device doesn't support IDXGIVkInteropDevice. Only DXVK is supported.\n");
+          return XR_ERROR_VALIDATION_FAILURE;
+        }
+
+        our_vk_binding.type = XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR;
+        our_vk_binding.next = NULL;
+
+        wine_instance->dxvk_device->lpVtbl->GetVulkanHandles(wine_instance->dxvk_device, &our_vk_binding.instance,
+                                                             &our_vk_binding.physicalDevice, &our_vk_binding.device);
+
+        wine_instance->dxvk_device->lpVtbl->GetSubmissionQueue2(
+            wine_instance->dxvk_device, NULL, &our_vk_binding.queueIndex, &our_vk_binding.queueFamilyIndex);
+
+        if ((res = do_vulkan_init(wine_instance, our_vk_binding.instance)) != XR_SUCCESS) {
+          return res;
+        }
+
+        our_vk_binding.physicalDevice = wine_instance->vk_phys_dev;
+        our_create_info = *createInfo;
+        our_create_info.next = &our_vk_binding;
+        session_type = SESSION_TYPE_D3D11;
+
+        break;
+      }
+      case XR_TYPE_GRAPHICS_BINDING_D3D12_KHR: {
+        const XrGraphicsBindingD3D12KHR *their_d3d12_binding = createInfo->next;
+        VkCommandPoolCreateInfo command_pool_create_info = {
+            .sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO,
+            .flags = 0,
+            .pNext = NULL,
+        };
+        HRESULT hr;
+        UINT32 queue_index;
+        VkQueueFlags queue_flags;
+        ID3D12DeviceExt1 *device_ext;
+        hr = ID3D12Device_QueryInterface(their_d3d12_binding->device, &IID_ID3D12DXVKInteropDevice2,
+                                         (void **)&wine_instance->d3d12_device2);
+        if (SUCCEEDED(hr))
+          wine_instance->d3d12_device = (ID3D12DXVKInteropDevice *)wine_instance->d3d12_device2;
+        else
+          hr = ID3D12Device_QueryInterface(their_d3d12_binding->device, &IID_ID3D12DXVKInteropDevice,
+                                           (void **)&wine_instance->d3d12_device);
+        if (FAILED(hr)) {
+          WARN("Given ID3D12Device doesn't support ID3D12DXVKInteropDevice. Only vkd3d-proton is supported.\n");
+          return XR_ERROR_VALIDATION_FAILURE;
+        }
+        hr = ID3D12Device_QueryInterface(their_d3d12_binding->device, &IID_ID3D12DeviceExt1, (void **)&device_ext);
+        if (FAILED(hr)) {
+          WARN("Given ID3D12Device doesn't support ID3D12DeviceExt1. Only vkd3d-proton is supported.\n");
+          return XR_ERROR_VALIDATION_FAILURE;
+        }
+
+        our_vk_binding.type = XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR;
+        our_vk_binding.next = NULL;
+
+        wine_instance->d3d12_queue = their_d3d12_binding->queue;
+        their_d3d12_binding->queue->lpVtbl->AddRef(their_d3d12_binding->queue);
+
+        wine_instance->d3d12_device->lpVtbl->GetVulkanHandles(wine_instance->d3d12_device, &our_vk_binding.instance,
+                                                              &our_vk_binding.physicalDevice, &our_vk_binding.device);
+        device_ext->lpVtbl->GetVulkanQueueInfoEx(device_ext, their_d3d12_binding->queue, &wine_instance->vk_queue,
+                                                 &queue_index, &queue_flags, &our_vk_binding.queueFamilyIndex);
+        device_ext->lpVtbl->Release(device_ext);
+
+        wine_instance->vk_device = our_vk_binding.device;
+        our_vk_binding.queueIndex = queue_index;
+        if ((res = do_vulkan_init(wine_instance, our_vk_binding.instance)) != XR_SUCCESS) {
+          return res;
+        }
+
+        our_vk_binding.physicalDevice = wine_instance->vk_phys_dev;
+
+        our_create_info = *createInfo;
+        our_create_info.next = &our_vk_binding;
+
+        command_pool_create_info.queueFamilyIndex = our_vk_binding.queueFamilyIndex;
+        if (vkCreateCommandPool(wine_instance->vk_device, &command_pool_create_info, NULL,
+                                &wine_instance->vk_command_pool) != VK_SUCCESS) {
+          WARN("vkCreateCommandPool failed\n");
+          return XR_ERROR_RUNTIME_FAILURE;
+        }
+
+        session_type = SESSION_TYPE_D3D12;
+
+        break;
+      }
+      default:
+        WARN("Unhandled graphics binding type: %d\n", ((XrBaseInStructure *)createInfo->next)->type);
+        break;
+    }
+  }
+
+  _status = UNIX_CALL(xrCreateSession, &params);
+  assert(!_status && "xrCreateSession");
+
+  if (params.result != XR_SUCCESS) {
+    WARN("xrCreateSession failed: %d\n", res);
+    free(wine_session);
+    return params.result;
+  }
+
+  wine_session->instance = wine_instance;
+  wine_session->session_type = session_type;
+
+  EnterCriticalSection(&session_list_lock);
+
+  list_add_tail(&session_list, &wine_session->entry);
+
+  LeaveCriticalSection(&session_list_lock);
+
+  *session = (XrSession)wine_session;
+
+  return XR_SUCCESS;
+}
+
+XrResult WINAPI xrDestroySession(XrSession session) {
+  wine_XrSession *wine_session = wine_session_from_handle(session);
+  struct xrDestroySession_params params = {.session = session};
+  NTSTATUS _status;
+
+  TRACE("%p\n", session);
+  _status = UNIX_CALL(xrDestroySession, &params);
+  assert(!_status && "xrDestroySession");
+  if (params.result != XR_SUCCESS) {
+    WARN("xrDestroySession failed: %d\n", params.result);
+    return params.result;
+  }
+
+  free(wine_session);
+  return XR_SUCCESS;
+}
+
+XrResult WINAPI xrPollEvent(XrInstance instance, XrEventDataBuffer *eventData) {
+  struct xrPollEvent_params params = {.instance = instance, .eventData = eventData};
+  NTSTATUS _status;
+
+  WINE_TRACE("%p, %p\n", instance, eventData);
+
+  _status = UNIX_CALL(xrPollEvent, &params);
+  assert(!_status && "xrPollEvent");
+
+  WINE_TRACE("eventData->type %#x\n", eventData->type);
+
+  if (params.result == XR_SUCCESS) {
+    switch (eventData->type) {
+      case XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED: {
+        XrEventDataInteractionProfileChanged *evt = (XrEventDataInteractionProfileChanged *)eventData;
+        evt->session = (XrSession)get_wrapped_XrSession(evt->session);
+        break;
+      }
+      case XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED: {
+        XrEventDataSessionStateChanged *evt = (XrEventDataSessionStateChanged *)eventData;
+        evt->session = (XrSession)get_wrapped_XrSession(evt->session);
+        break;
+      }
+      case XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR: {
+        XrEventDataVisibilityMaskChangedKHR *evt = (XrEventDataVisibilityMaskChangedKHR *)eventData;
+        evt->session = (XrSession)get_wrapped_XrSession(evt->session);
+        break;
+      }
+      case XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING: {
+        XrEventDataReferenceSpaceChangePending *evt = (XrEventDataReferenceSpaceChangePending *)eventData;
+        evt->session = (XrSession)get_wrapped_XrSession(evt->session);
+        break;
+      }
+      case XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT: {
+        XrEventDataUserPresenceChangedEXT *evt = (XrEventDataUserPresenceChangedEXT *)eventData;
+        evt->session = (XrSession)get_wrapped_XrSession(evt->session);
+        break;
+      }
+      case XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML: {
+        XrEventDataLocalizationChangedML *evt = (XrEventDataLocalizationChangedML *)eventData;
+        evt->session = (XrSession)get_wrapped_XrSession(evt->session);
+        break;
+      }
+      default:
+        break;
+    }
+  }
+
+  return params.result;
+}
+XrResult WINAPI xrGetSystem(XrInstance instance, const XrSystemGetInfo *getInfo, XrSystemId *systemId) {
+  wine_XrInstance *wine_instance = wine_instance_from_handle(instance);
+  struct xrGetSystem_params params = {.instance = instance, .getInfo = getInfo, .systemId = systemId};
+  NTSTATUS _status;
+
+  TRACE("%p, %p, %p\n", instance, getInfo, systemId);
+  _status = UNIX_CALL(xrGetSystem, &params);
+  assert(!_status && "xrGetSystem");
+  if (params.result != XR_SUCCESS) {
+    return params.result;
+  }
+
+  wine_instance->systemId = *systemId;
+  return params.result;
+}
+
+static BOOL is_vulkan_format_depth(VkFormat format) {
+  switch (format) {
+    case VK_FORMAT_B8G8R8A8_SRGB:
+    case VK_FORMAT_B8G8R8A8_UNORM:
+    case VK_FORMAT_R8G8B8A8_SRGB:
+    case VK_FORMAT_R8G8B8A8_UNORM:
+    case VK_FORMAT_R32G32B32A32_SFLOAT:
+    case VK_FORMAT_R32G32B32_SFLOAT:
+    case VK_FORMAT_R16G16B16A16_SFLOAT:
+    case VK_FORMAT_A2B10G10R10_UNORM_PACK32:
+      return FALSE;
+    case VK_FORMAT_D32_SFLOAT:
+    case VK_FORMAT_D16_UNORM:
+    case VK_FORMAT_D24_UNORM_S8_UINT:
+    case VK_FORMAT_D32_SFLOAT_S8_UINT:
+      return TRUE;
+
+    default:
+      WARN("Unknown vulkan format %#x", format);
+      return FALSE;
+  }
+}
+
+int64_t map_format_dxgi_to_vulkan(int64_t format) {
+  switch (format) {
+    case DXGI_FORMAT_B8G8R8A8_UNORM_SRGB:
+      return VK_FORMAT_B8G8R8A8_SRGB;
+
+    case DXGI_FORMAT_B8G8R8A8_UNORM:
+      return VK_FORMAT_B8G8R8A8_UNORM;
+
+    case DXGI_FORMAT_R8G8B8A8_UNORM_SRGB:
+      return VK_FORMAT_R8G8B8A8_SRGB;
+
+    case DXGI_FORMAT_R8G8B8A8_UNORM:
+      return VK_FORMAT_R8G8B8A8_UNORM;
+
+    case DXGI_FORMAT_R32G32B32A32_FLOAT:
+      return VK_FORMAT_R32G32B32A32_SFLOAT;
+
+    case DXGI_FORMAT_R32G32B32_FLOAT:
+      return VK_FORMAT_R32G32B32_SFLOAT;
+
+    case DXGI_FORMAT_R16G16B16A16_FLOAT:
+      return VK_FORMAT_R16G16B16A16_SFLOAT;
+
+    case DXGI_FORMAT_R10G10B10A2_UNORM:
+      return VK_FORMAT_A2B10G10R10_UNORM_PACK32;
+
+    case DXGI_FORMAT_D32_FLOAT:
+      return VK_FORMAT_D32_SFLOAT;
+
+    case DXGI_FORMAT_D16_UNORM:
+      return VK_FORMAT_D16_UNORM;
+
+    case DXGI_FORMAT_D24_UNORM_S8_UINT:
+      return VK_FORMAT_D24_UNORM_S8_UINT;
+
+    case DXGI_FORMAT_D32_FLOAT_S8X24_UINT:
+      return VK_FORMAT_D32_SFLOAT_S8_UINT;
+
+    default:
+      WARN("Unable to map DXGI format (%lu) to Vulkan format\n", (long)format);
+      return VK_FORMAT_UNDEFINED;
+  }
+}
+
+int64_t map_format_vulkan_to_dxgi(int64_t format) {
+  switch (format) {
+    case VK_FORMAT_B8G8R8A8_SRGB:
+      return DXGI_FORMAT_B8G8R8A8_UNORM_SRGB;
+
+    case VK_FORMAT_B8G8R8A8_UNORM:
+      return DXGI_FORMAT_B8G8R8A8_UNORM;
+
+    case VK_FORMAT_R8G8B8A8_SRGB:
+      return DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
+
+    case VK_FORMAT_R8G8B8A8_UNORM:
+      return DXGI_FORMAT_R8G8B8A8_UNORM;
+
+    case VK_FORMAT_R32G32B32A32_SFLOAT:
+      return DXGI_FORMAT_R32G32B32A32_FLOAT;
+
+    case VK_FORMAT_R32G32B32_SFLOAT:
+      return DXGI_FORMAT_R32G32B32_FLOAT;
+
+    case VK_FORMAT_R16G16B16A16_SFLOAT:
+      return DXGI_FORMAT_R16G16B16A16_FLOAT;
+
+    case VK_FORMAT_A2B10G10R10_UNORM_PACK32:
+      return DXGI_FORMAT_R10G10B10A2_UNORM;
+
+    case VK_FORMAT_D32_SFLOAT:
+      return DXGI_FORMAT_D32_FLOAT;
+
+    case VK_FORMAT_D16_UNORM:
+      return DXGI_FORMAT_D16_UNORM;
+
+    case VK_FORMAT_D24_UNORM_S8_UINT:
+      return DXGI_FORMAT_D24_UNORM_S8_UINT;
+
+    case VK_FORMAT_D32_SFLOAT_S8_UINT:
+      return DXGI_FORMAT_D32_FLOAT_S8X24_UINT;
+
+    default:
+      WARN("Unable to map Vulkan format (%lu) to DXGI format\n", (long)format);
+      return DXGI_FORMAT_UNKNOWN;
+  }
+}
+
+XrResult WINAPI xrEnumerateSwapchainFormats(XrSession session,
+                                            uint32_t formatCapacityInput,
+                                            uint32_t *formatCountOutput,
+                                            int64_t *formats) {
+  wine_XrSession *wine_session = wine_session_from_handle(session);
+  uint32_t real_format_count;
+  int64_t *real_formats;
+  uint32_t i, o;
+  struct xrEnumerateSwapchainFormats_params params = {
+      .session = session,
+      .formatCapacityInput = formatCapacityInput,
+      .formatCountOutput = formatCountOutput,
+      .formats = formats,
+  };
+  NTSTATUS _status;
+
+  TRACE("%p, %u, %p, %p\n", session, formatCapacityInput, formatCountOutput, formats);
+
+  if (wine_session->session_type != SESSION_TYPE_D3D11 && wine_session->session_type != SESSION_TYPE_D3D12) {
+    _status = UNIX_CALL(xrEnumerateSwapchainFormats, &params);
+    assert(!_status && "xrEnumerateSwapchainFormats");
+    return params.result;
+  }
+
+  params.formatCapacityInput = 0;
+  params.formatCountOutput = &real_format_count;
+  params.formats = NULL;
+
+  _status = UNIX_CALL(xrEnumerateSwapchainFormats, &params);
+  assert(!_status && "xrEnumerateSwapchainFormats");
+  if (params.result != XR_SUCCESS) {
+    return params.result;
+  }
+
+  real_formats = malloc(sizeof(*real_formats) * real_format_count);
+
+  params.formatCapacityInput = real_format_count;
+  params.formats = real_formats;
+
+  _status = UNIX_CALL(xrEnumerateSwapchainFormats, &params);
+  assert(!_status && "xrEnumerateSwapchainFormats");
+  if (params.result != XR_SUCCESS) {
+    goto done;
+  }
+
+  o = 0;
+  for (i = 0; i < real_format_count; ++i) {
+    int64_t mapped = map_format_vulkan_to_dxgi(real_formats[i]);
+
+    if (mapped == DXGI_FORMAT_UNKNOWN) {
+      continue;
+    }
+
+    if (formatCapacityInput && formats) {
+      if (o < formatCapacityInput) {
+        formats[o] = mapped;
+      } else {
+        params.result = XR_ERROR_SIZE_INSUFFICIENT;
+      }
+    }
+    ++o;
+  }
+  *formatCountOutput = o;
+
+done:
+  free(real_formats);
+  return params.result;
+}
+
+XrResult WINAPI xrCreateSwapchain(XrSession session, const XrSwapchainCreateInfo *createInfo, XrSwapchain *swapchain) {
+  wine_XrSession *wine_session = wine_session_from_handle(session);
+  wine_XrSwapchain *wine_swapchain = calloc(1, sizeof(wine_XrSwapchain));
+  XrSwapchainCreateInfo our_createInfo = *createInfo;
+  struct xrCreateSwapchain_params params = {
+      .session = session, .createInfo = &our_createInfo, .swapchain = &wine_swapchain->host_swapchain};
+  NTSTATUS _status;
+
+  wine_swapchain->create_info = *createInfo;
+
+  TRACE("%p, %p, %p\n", session, createInfo, swapchain);
+
+  if (wine_session->session_type == SESSION_TYPE_D3D11 || wine_session->session_type == SESSION_TYPE_D3D12) {
+    BOOL format_is_depth;
+    our_createInfo.format = map_format_dxgi_to_vulkan(createInfo->format);
+    if (our_createInfo.format == VK_FORMAT_UNDEFINED) {
+      ERR("unable to set Vulkan format\n");
+      free(wine_swapchain);
+      return XR_ERROR_SWAPCHAIN_FORMAT_UNSUPPORTED;
+    }
+
+    our_createInfo.usageFlags |= XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT;
+
+    format_is_depth = is_vulkan_format_depth(our_createInfo.format);
+    if ((createInfo->usageFlags & XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT) && format_is_depth) {
+      WARN("Swapchain has a color attachment usage, but it's format is for depth\n");
+    }
+    if ((createInfo->usageFlags & XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) && !format_is_depth) {
+      WARN("Swapchain has a depth/stencil usage, but it's format is for color\n");
+    }
+  }
+
+  _status = UNIX_CALL(xrCreateSwapchain, &params);
+  assert(!_status && "xrCreateSwapchain");
+  if (params.result != XR_SUCCESS) {
+    WARN("xrCreateSwapchain failed: %d\n", params.result);
+    free(wine_swapchain);
+    return params.result;
+  }
+
+  wine_swapchain->session = wine_session;
+  *swapchain = (XrSwapchain)wine_swapchain;
+
+  return XR_SUCCESS;
+}
+
+static void release_d3d12_resources(wine_XrSwapchain *swapchain, uint32_t image_count) {
+  wine_XrInstance *instance = swapchain->session->instance;
+  XrSwapchainImageD3D12KHR *d3d12_images = (XrSwapchainImageD3D12KHR *)swapchain->images;
+  UINT i;
+  if (!image_count) {
+    return;
+  }
+
+  for (i = 0; i < image_count; i++) {
+    if (d3d12_images[i].texture) {
+      d3d12_images[i].texture->lpVtbl->Release(d3d12_images[i].texture);
+    }
+  }
+  vkFreeCommandBuffers(instance->vk_device, instance->vk_command_pool, image_count, swapchain->cmd_release);
+  vkFreeCommandBuffers(instance->vk_device, instance->vk_command_pool, image_count, swapchain->cmd_acquire);
+  free(swapchain->cmd_release);
+  free(swapchain->cmd_acquire);
+  free(swapchain->acquired);
+  free(swapchain->acquired_indices);
+}
+
+XrResult WINAPI xrDestroySwapchain(XrSwapchain swapchain) {
+  wine_XrSwapchain *wine_swapchain = wine_swapchain_from_handle(swapchain);
+  struct xrDestroySwapchain_params params = {.swapchain = swapchain};
+  NTSTATUS _status;
+
+  TRACE("%p\n", swapchain);
+
+  _status = UNIX_CALL(xrDestroySwapchain, &params);
+  assert(!_status && "xrDestroySwapchain");
+  if (params.result != XR_SUCCESS) {
+    WARN("xrDestroySwapchain failed: %d\n", params.result);
+    return params.result;
+  }
+
+  if (wine_swapchain->image_count) {
+    UINT i;
+    if (wine_swapchain->session->session_type == SESSION_TYPE_D3D11) {
+      XrSwapchainImageD3D11KHR *d3d11_images = (XrSwapchainImageD3D11KHR *)wine_swapchain->images;
+      for (i = 0; i < wine_swapchain->image_count; i++) {
+        d3d11_images[i].texture->lpVtbl->Release(d3d11_images[i].texture);
+      }
+    } else if (wine_swapchain->session->session_type == SESSION_TYPE_D3D12) {
+      release_d3d12_resources(wine_swapchain, wine_swapchain->image_count);
+    }
+    free(wine_swapchain->images);
+    wine_swapchain->image_count = 0;
+  }
+
+  free(wine_swapchain);
+
+  return XR_SUCCESS;
+}
+
+static D3D11_USAGE d3d11usage_from_XrSwapchainUsageFlags(XrSwapchainUsageFlags flags) {
+  static const D3D11_USAGE supported_flags = XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT |
+                                             XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT |
+                                             XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT | XR_SWAPCHAIN_USAGE_SAMPLED_BIT;
+  D3D11_USAGE ret = 0;
+
+  if (flags & ~supported_flags) {
+    WINE_FIXME("Unhandled flags %#lx.\n", (long)flags);
+  }
+
+  if (flags & XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT) {
+    ret |= D3D11_BIND_RENDER_TARGET;
+  }
+  if (flags & XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) {
+    ret |= D3D11_BIND_DEPTH_STENCIL;
+  }
+  if (flags & XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT) {
+    ret |= D3D11_BIND_UNORDERED_ACCESS;
+  }
+  if (flags & XR_SWAPCHAIN_USAGE_SAMPLED_BIT) {
+    ret |= D3D11_BIND_SHADER_RESOURCE;
+  }
+
+  return ret;
+}
+
+static VkResult record_transition_command(wine_XrInstance *instance,
+                                          VkImage image,
+                                          VkImageSubresourceRange subresource,
+                                          VkImageLayout from,
+                                          VkImageLayout to,
+                                          VkCommandBuffer *out_cmd) {
+  VkResult ret;
+  VkCommandBufferAllocateInfo command_buffer_allocate_info = {
+      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO,
+      .level = VK_COMMAND_BUFFER_LEVEL_PRIMARY,
+      .commandPool = instance->vk_command_pool,
+      .commandBufferCount = 1,
+  };
+  VkCommandBufferBeginInfo begin_info = {
+      .sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO,
+      .flags = 0,
+  };
+  VkImageMemoryBarrier barrier = {
+      .sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER,
+      .oldLayout = from,
+      .newLayout = to,
+      .srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
+      .dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED,
+      .image = image,
+      .subresourceRange = subresource,
+      .srcAccessMask = VK_ACCESS_MEMORY_WRITE_BIT,
+      .dstAccessMask = VK_ACCESS_MEMORY_READ_BIT,
+  };
+
+  *out_cmd = VK_NULL_HANDLE;
+  if (from == to) {
+    return VK_SUCCESS;
+  }
+
+  if ((ret = vkAllocateCommandBuffers(instance->vk_device, &command_buffer_allocate_info, out_cmd)) != VK_SUCCESS) {
+    return ret;
+  }
+  if ((ret = vkBeginCommandBuffer(*out_cmd, &begin_info)) != VK_SUCCESS) {
+    return ret;
+  }
+  vkCmdPipelineBarrier(*out_cmd, VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT, 0, 0, NULL, 0,
+                       NULL, 1, &barrier);
+  return vkEndCommandBuffer(*out_cmd);
+}
+
+XrResult WINAPI xrEnumerateSwapchainImages(XrSwapchain swapchain,
+                                           uint32_t imageCapacityInput,
+                                           uint32_t *imageCountOutput,
+                                           XrSwapchainImageBaseHeader *images) {
+  wine_XrSwapchain *wine_swapchain = wine_swapchain_from_handle(swapchain);
+  wine_XrInstance *wine_instance = wine_swapchain->session->instance;
+  XrSwapchainImageVulkanKHR *our_vk;
+  HRESULT hr;
+  size_t image_size = 0;
+  uint32_t i;
+  struct xrEnumerateSwapchainImages_params params = {
+      .swapchain = swapchain,
+      .imageCapacityInput = imageCapacityInput,
+      .imageCountOutput = imageCountOutput,
+      .images = images,
+  };
+  NTSTATUS _status;
+
+  TRACE("%p, %u, %p, %p\n", swapchain, imageCapacityInput, imageCountOutput, images);
+  if (wine_swapchain->session->session_type != SESSION_TYPE_D3D11 &&
+      wine_swapchain->session->session_type != SESSION_TYPE_D3D12) {
+    _status = UNIX_CALL(xrEnumerateSwapchainImages, &params);
+    assert(!_status && "xrEnumerateSwapchainImages");
+    return params.result;
+  }
+
+  if (!wine_swapchain->image_count) {
+    uint32_t image_count;
+    params.imageCapacityInput = 0;
+    params.imageCountOutput = &image_count;
+    params.images = NULL;
+    _status = UNIX_CALL(xrEnumerateSwapchainImages, &params);
+    assert(!_status && "xrEnumerateSwapchainImages");
+    if (params.result != XR_SUCCESS) {
+      return params.result;
+    }
+
+    our_vk = malloc(sizeof(*our_vk) * image_count);
+    for (i = 0; i < image_count; ++i) {
+      our_vk[i].type = XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR;
+      our_vk[i].next = NULL;
+    }
+
+    params.imageCapacityInput = image_count;
+    params.images = (XrSwapchainImageBaseHeader *)our_vk;
+    _status = UNIX_CALL(xrEnumerateSwapchainImages, &params);
+    assert(!_status && "xrEnumerateSwapchainImages");
+    if (params.result != XR_SUCCESS) {
+      free(our_vk);
+      return params.result;
+    }
+
+    if (wine_swapchain->session->session_type == SESSION_TYPE_D3D11) {
+      XrSwapchainImageD3D11KHR *our_d3d11;
+      D3D11_TEXTURE2D_DESC1 desc;
+
+      desc.Width = wine_swapchain->create_info.width;
+      desc.Height = wine_swapchain->create_info.height;
+      desc.MipLevels = wine_swapchain->create_info.mipCount;
+      desc.ArraySize = wine_swapchain->create_info.arraySize;
+      desc.Format = wine_swapchain->create_info.format;
+      TRACE("creating dxvk texture with dxgi format %d (%x)\n", desc.Format, desc.Format);
+      desc.SampleDesc.Count = wine_swapchain->create_info.sampleCount;
+      desc.SampleDesc.Quality = 0;
+      desc.Usage = D3D11_USAGE_DEFAULT;
+      desc.BindFlags = d3d11usage_from_XrSwapchainUsageFlags(wine_swapchain->create_info.usageFlags);
+      desc.CPUAccessFlags = 0;
+      desc.MiscFlags = 0;
+      desc.TextureLayout = D3D11_TEXTURE_LAYOUT_UNDEFINED;
+
+      our_d3d11 = malloc(sizeof(XrSwapchainImageD3D11KHR) * image_count);
+      for (i = 0; i < image_count; ++i) {
+        hr = wine_instance->dxvk_device->lpVtbl->CreateTexture2DFromVkImage(wine_instance->dxvk_device, &desc,
+                                                                            our_vk[i].image, &our_d3d11[i].texture);
+        if (FAILED(hr)) {
+          UINT j;
+          for (j = 0; j < i; ++j) {
+            our_d3d11[i].texture->lpVtbl->Release(our_d3d11[i].texture);
+          }
+          free(our_d3d11);
+          free(our_vk);
+          WARN("Failed to create DXVK texture from VkImage: %08x\n", hr);
+          return XR_ERROR_RUNTIME_FAILURE;
+        }
+        TRACE("Successfully allocated texture %p\n", our_d3d11[i].texture);
+      }
+      wine_swapchain->images = (XrSwapchainImageBaseHeader *)our_d3d11;
+    } else if (wine_swapchain->session->session_type == SESSION_TYPE_D3D12) {
+      XrSwapchainImageD3D12KHR *our_d3d12;
+      D3D12_RESOURCE_DESC1 desc;
+      ID3D12DeviceExt1 *device_ext;
+      HRESULT hr = wine_instance->d3d12_device->lpVtbl->QueryInterface(wine_instance->d3d12_device,
+                                                                       &IID_ID3D12DeviceExt1, (void **)&device_ext);
+      BOOL format_is_depth = is_vulkan_format_depth(map_format_dxgi_to_vulkan(wine_swapchain->create_info.format));
+      BOOL succeeded = TRUE;
+      const D3D12_RESOURCE_STATES incoming_state =
+          format_is_depth ? D3D12_RESOURCE_STATE_DEPTH_WRITE : D3D12_RESOURCE_STATE_RENDER_TARGET;
+      const VkImageLayout vk_layout =
+          format_is_depth ? VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL : VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL;
+      const VkImageSubresourceRange subresource = {
+          .layerCount = wine_swapchain->create_info.arraySize,
+          .baseArrayLayer = 0,
+          .levelCount = wine_swapchain->create_info.mipCount,
+          .baseMipLevel = 0,
+          .aspectMask =
+              format_is_depth ? (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT) : VK_IMAGE_ASPECT_COLOR_BIT,
+      };
+      if (FAILED(hr)) {
+        ERR("Cannot get vkd3d-proton interface: %08x\n", hr);
+        return XR_ERROR_VALIDATION_FAILURE;
+      }
+
+      desc.Alignment = 0;
+      desc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
+      desc.Width = wine_swapchain->create_info.width;
+      desc.Height = wine_swapchain->create_info.height;
+      desc.MipLevels = wine_swapchain->create_info.mipCount;
+      desc.DepthOrArraySize = wine_swapchain->create_info.arraySize;
+      desc.Format = wine_swapchain->create_info.format;
+      TRACE("creating vkd3d-proton texture with dxgi format %d (%x)\n", desc.Format, desc.Format);
+      desc.SampleDesc.Count = wine_swapchain->create_info.sampleCount;
+      desc.SampleDesc.Quality = 0;
+      desc.Layout = D3D12_TEXTURE_LAYOUT_UNKNOWN;
+      desc.Flags = 0;
+      if (!format_is_depth) {
+        desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;
+      } else {
+        desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;
+        if (!(wine_swapchain->create_info.usageFlags & XR_SWAPCHAIN_USAGE_SAMPLED_BIT)) {
+          desc.Flags |= D3D12_RESOURCE_FLAG_DENY_SHADER_RESOURCE;
+        }
+      }
+      if (wine_swapchain->create_info.usageFlags & XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT) {
+        desc.Flags |= D3D12_RESOURCE_FLAG_ALLOW_UNORDERED_ACCESS;
+      }
+
+      our_d3d12 = calloc(1, sizeof(XrSwapchainImageD3D12KHR) * image_count);
+      for (i = 0; i < image_count; ++i) {
+        hr = device_ext->lpVtbl->CreateResourceFromBorrowedHandle(device_ext, &desc, our_vk[i].image,
+                                                                  &our_d3d12[i].texture);
+        if (FAILED(hr)) {
+          ERR("Failed to create vkd3d-proton texture from VkImage: %08x\n", hr);
+          succeeded = FALSE;
+          break;
+        }
+        TRACE("Successfully allocated texture %p\n", our_d3d12[i].texture);
+      }
+      device_ext->lpVtbl->Release(device_ext);
+
+      if (succeeded) {
+        wine_swapchain->acquired = calloc(1, sizeof(BOOL) * image_count);
+        wine_swapchain->acquired_indices = malloc(sizeof(uint32_t) * (image_count + 1));
+        wine_swapchain->acquired_count = wine_swapchain->acquired_start = 0;
+        wine_swapchain->images = (XrSwapchainImageBaseHeader *)our_d3d12;
+
+        wine_swapchain->cmd_release = calloc(1, sizeof(VkCommandBuffer) * image_count);
+        wine_swapchain->cmd_acquire = calloc(1, sizeof(VkCommandBuffer) * image_count);
+        for (i = 0; i < image_count; i++) {
+          VkImageLayout d3d12_vk_layout;
+          wine_instance->d3d12_device->lpVtbl->GetVulkanImageLayout(wine_instance->d3d12_device, our_d3d12[i].texture,
+                                                                    incoming_state, &d3d12_vk_layout);
+          if (record_transition_command(wine_instance, our_vk[i].image, subresource, d3d12_vk_layout, vk_layout,
+                                        &wine_swapchain->cmd_release[i]) != VK_SUCCESS ||
+              record_transition_command(wine_instance, our_vk[i].image, subresource, vk_layout, d3d12_vk_layout,
+                                        &wine_swapchain->cmd_acquire[i]) != VK_SUCCESS) {
+            ERR("Failed to create command buffer for layout transition\n");
+            succeeded = FALSE;
+            break;
+          }
+        }
+      }
+      if (!succeeded) {
+        release_d3d12_resources(wine_swapchain, image_count);
+        free(wine_swapchain->images);
+        wine_swapchain->images = NULL;
+        free(our_vk);
+        return XR_ERROR_RUNTIME_FAILURE;
+      }
+    }
+    free(our_vk);
+    wine_swapchain->image_count = image_count;
+    TRACE("image count %d\n", image_count);
+  }
+
+  *imageCountOutput = wine_swapchain->image_count;
+  if (wine_swapchain->session->session_type == SESSION_TYPE_D3D11) {
+    image_size = sizeof(XrSwapchainImageD3D11KHR);
+  } else if (wine_swapchain->session->session_type == SESSION_TYPE_D3D12) {
+    image_size = sizeof(XrSwapchainImageD3D12KHR);
+  }
+  memcpy(images, wine_swapchain->images, image_size * min(wine_swapchain->image_count, imageCapacityInput));
+  return XR_SUCCESS;
+}
+
+static void lock_d3d_queue(wine_XrInstance *instance, BOOL drain_queue)
+{
+    if (instance->dxvk_device)
+    {
+        if (drain_queue)
+            instance->dxvk_device->lpVtbl->FlushRenderingCommands(instance->dxvk_device);
+        instance->dxvk_device->lpVtbl->LockSubmissionQueue(instance->dxvk_device);
+    }
+    else if (!drain_queue && instance->d3d12_device2)
+        instance->d3d12_device2->lpVtbl->LockVulkanQueue(instance->d3d12_device2, instance->d3d12_queue);
+    else if (instance->d3d12_device)
+        instance->d3d12_device->lpVtbl->LockCommandQueue(instance->d3d12_device, instance->d3d12_queue);
+}
+
+static void unlock_d3d_queue(wine_XrInstance *instance, BOOL drain_queue)
+{
+    if (instance->dxvk_device)
+        instance->dxvk_device->lpVtbl->ReleaseSubmissionQueue(instance->dxvk_device);
+    else if (!drain_queue && instance->d3d12_device2)
+        instance->d3d12_device2->lpVtbl->UnlockVulkanQueue(instance->d3d12_device2, instance->d3d12_queue);
+    else if (instance->d3d12_device)
+        instance->d3d12_device->lpVtbl->UnlockCommandQueue(instance->d3d12_device, instance->d3d12_queue);
+}
+
+XrResult WINAPI xrAcquireSwapchainImage(XrSwapchain swapchain,
+                                        const XrSwapchainImageAcquireInfo *acquireInfo,
+                                        uint32_t *index) {
+  wine_XrSwapchain *wine_swapchain = wine_swapchain_from_handle(swapchain);
+  wine_XrInstance *wine_instance = wine_swapchain->session->instance;
+  struct xrAcquireSwapchainImage_params params = {
+      .swapchain = swapchain,
+      .acquireInfo = acquireInfo,
+      .index = index,
+  };
+  NTSTATUS _status;
+
+  TRACE("%p, %p, %p image count %d, acquired %d\n", swapchain, acquireInfo, index, wine_swapchain->image_count,
+        wine_swapchain->acquired_count);
+
+  if (wine_instance->d3d12_device && wine_swapchain->acquired_count >= wine_swapchain->image_count)
+  {
+      WARN("Application has acquired all images but still tries to acquire more.\n");
+      return XR_ERROR_CALL_ORDER_INVALID;
+  }
+
+  lock_d3d_queue(wine_instance, FALSE);
+
+  _status = UNIX_CALL(xrAcquireSwapchainImage, &params);
+  assert(!_status && "xrAcquireSwapchainImage");
+
+  if (!wine_instance->d3d12_device) {
+    unlock_d3d_queue(wine_instance, FALSE);
+    return params.result;
+  }
+
+  if (params.result == XR_SUCCESS) {
+    if (!wine_swapchain->acquired[*index] && wine_swapchain->cmd_acquire[*index] != VK_NULL_HANDLE) {
+      VkSubmitInfo submit_info = {
+          .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
+          .commandBufferCount = 1,
+          .pCommandBuffers = &wine_swapchain->cmd_acquire[*index],
+      };
+
+      vkQueueSubmit(wine_instance->vk_queue, 1, &submit_info, VK_NULL_HANDLE);
+    }
+
+    if (!wine_swapchain->acquired[*index]) {
+      uint32_t next = (wine_swapchain->acquired_start + wine_swapchain->acquired_count) % wine_swapchain->image_count;
+      wine_swapchain->acquired[*index] = TRUE;
+      wine_swapchain->acquired_indices[next] = *index;
+      wine_swapchain->acquired_count += 1;
+    } else {
+      WARN("the application acquired the same image (index %d) again!?", *index);
+    }
+  }
+  unlock_d3d_queue(wine_instance, FALSE);
+  return params.result;
+}
+
+XrResult WINAPI xrReleaseSwapchainImage(XrSwapchain swapchain, const XrSwapchainImageReleaseInfo *releaseInfo) {
+  wine_XrSwapchain *wine_swapchain = wine_swapchain_from_handle(swapchain);
+  wine_XrInstance *wine_instance = wine_swapchain->session->instance;
+  uint32_t index = ~0u;
+  struct xrReleaseSwapchainImage_params params = {
+      .swapchain = swapchain,
+      .releaseInfo = releaseInfo,
+  };
+  NTSTATUS _status;
+
+  TRACE("%p, %p\n", swapchain, releaseInfo);
+
+  if (wine_instance->d3d12_device && !wine_swapchain->acquired_count)
+  {
+    WARN("Application tried to release a swapchain image without having acquired it first.\n");
+    return XR_ERROR_CALL_ORDER_INVALID;
+  }
+
+  lock_d3d_queue(wine_instance, TRUE);
+
+  if (wine_instance->d3d12_device)
+  {
+    index = wine_swapchain->acquired_indices[wine_swapchain->acquired_start];
+    if (wine_swapchain->cmd_release[index] != VK_NULL_HANDLE) {
+      VkSubmitInfo submit_info = {
+          .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
+          .commandBufferCount = 1,
+          .pCommandBuffers = &wine_swapchain->cmd_release[index],
+      };
+
+      vkQueueSubmit(wine_instance->vk_queue, 1, &submit_info, VK_NULL_HANDLE);
+    }
+  }
+
+  _status = UNIX_CALL(xrReleaseSwapchainImage, &params);
+  assert(!_status && "xrReleaseSwapchainImage");
+  if (!wine_instance->d3d12_device) {
+    unlock_d3d_queue(wine_instance, TRUE);
+    return params.result;
+  }
+
+  if (params.result != XR_SUCCESS && wine_swapchain->cmd_release[index] != VK_NULL_HANDLE) {
+    VkSubmitInfo submit_info = {
+        .sType = VK_STRUCTURE_TYPE_SUBMIT_INFO,
+        .commandBufferCount = 1,
+        .pCommandBuffers = &wine_swapchain->cmd_acquire[index],
+    };
+    WARN("xrReleaseSwapchainImage failed, reverting layout transition\n");
+    vkQueueSubmit(wine_instance->vk_queue, 1, &submit_info, VK_NULL_HANDLE);
+  }
+  if (params.result == XR_SUCCESS) {
+    wine_swapchain->acquired[index] = FALSE;
+    wine_swapchain->acquired_start = (wine_swapchain->acquired_start + 1) % wine_swapchain->image_count;
+    wine_swapchain->acquired_count -= 1;
+  }
+  unlock_d3d_queue(wine_instance, TRUE);
+  return params.result;
+}
+
+XrResult WINAPI xrBeginFrame(XrSession session, const XrFrameBeginInfo *frameBeginInfo) {
+  wine_XrSession *wine_session = wine_session_from_handle(session);
+  struct xrBeginFrame_params params = {
+      .session = session,
+      .frameBeginInfo = frameBeginInfo,
+  };
+  NTSTATUS _status;
+
+  TRACE("%p, %p\n", session, frameBeginInfo);
+
+  lock_d3d_queue(wine_session->instance, FALSE);
+  _status = UNIX_CALL(xrBeginFrame, &params);
+  assert(!_status && "xrBeginFrame");
+  unlock_d3d_queue(wine_session->instance, FALSE);
+  return params.result;
+}
+
+static XrCompositionLayerBaseHeader *convert_XrCompositionLayer(wine_XrSession *wine_session,
+                                                                const XrCompositionLayerBaseHeader *in_layer,
+                                                                CompositionLayer *out_layer,
+                                                                uint32_t *view_idx,
+                                                                uint32_t *view_info_idx) {
+  uint32_t i;
+
+  TRACE("Type %u, pNext %p.\n", in_layer->type, in_layer->next);
+
+  switch (in_layer->type) {
+    case XR_TYPE_COMPOSITION_LAYER_CUBE_KHR: {
+      out_layer->cube = *(const XrCompositionLayerCubeKHR *)in_layer;
+      out_layer->cube.swapchain = wine_swapchain_from_handle(out_layer->cube.swapchain)->host_swapchain;
+      break;
+    }
+
+    case XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR:
+      out_layer->cylinder = *(const XrCompositionLayerCylinderKHR *)in_layer;
+      out_layer->cylinder.subImage.swapchain =
+          wine_swapchain_from_handle(out_layer->cylinder.subImage.swapchain)->host_swapchain;
+      break;
+
+    case XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR:
+      out_layer->depth_info = *(const XrCompositionLayerDepthInfoKHR *)in_layer;
+      out_layer->depth_info.subImage.swapchain =
+          wine_swapchain_from_handle(out_layer->depth_info.subImage.swapchain)->host_swapchain;
+      break;
+
+    case XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR:
+      out_layer->equirect = *(const XrCompositionLayerEquirectKHR *)in_layer;
+      out_layer->equirect.subImage.swapchain =
+          wine_swapchain_from_handle(out_layer->equirect.subImage.swapchain)->host_swapchain;
+      break;
+
+    case XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR:
+      out_layer->equirect2 = *(const XrCompositionLayerEquirect2KHR *)in_layer;
+      out_layer->equirect2.subImage.swapchain =
+          wine_swapchain_from_handle(out_layer->equirect2.subImage.swapchain)->host_swapchain;
+      break;
+
+    case XR_TYPE_COMPOSITION_LAYER_PROJECTION: {
+      const XrCompositionLayerProjectionView *view;
+      unsigned int view_info_count;
+
+      out_layer->projection = *(const XrCompositionLayerProjection *)in_layer;
+
+      view_info_count = 0;
+      for (i = 0; i < out_layer->projection.viewCount; ++i) {
+        view = &((XrCompositionLayerProjection *)in_layer)->views[i];
+        while ((view = view->next)) {
+          ++view_info_count;
+        }
+      }
+
+      if (out_layer->projection.viewCount + *view_idx > wine_session->projection_view_count) {
+        wine_session->projection_view_count = out_layer->projection.viewCount + *view_idx;
+        wine_session->projection_views =
+            realloc(wine_session->projection_views,
+                    sizeof(XrCompositionLayerProjectionView) * wine_session->projection_view_count);
+      }
+
+      if (view_info_count + *view_info_idx > wine_session->view_info_count) {
+        wine_session->view_info_count += view_info_count;
+        wine_session->view_infos =
+            realloc(wine_session->view_infos, sizeof(*wine_session->view_infos) * wine_session->view_info_count);
+      }
+
+      out_layer->projection.views = &wine_session->projection_views[*view_idx];
+      memcpy((void *)out_layer->projection.views, ((const XrCompositionLayerProjection *)in_layer)->views,
+             sizeof(XrCompositionLayerProjectionView) * out_layer->projection.viewCount);
+      view_info_count = 0;
+      for (i = 0; i < out_layer->projection.viewCount; ++i) {
+        view = &out_layer->projection.views[i];
+        if (view->type != XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW) {
+          WARN("Unexpected view type %u.\n", view->type);
+        }
+
+        ((XrCompositionLayerProjectionView *)view)->subImage.swapchain =
+            wine_swapchain_from_handle(view->subImage.swapchain)->host_swapchain;
+        while (view->next) {
+          TRACE("Projection view type %u.\n", ((XrCompositionLayerProjectionView *)view->next)->type);
+          switch (((XrCompositionLayerProjectionView *)view->next)->type) {
+            case XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR: {
+              XrCompositionLayerDepthInfoKHR *out_depth_info, *in_depth_info;
+
+              in_depth_info = (XrCompositionLayerDepthInfoKHR *)view->next;
+              out_depth_info = &wine_session->view_infos[*view_info_idx + view_info_count].depth_info;
+              *out_depth_info = *in_depth_info;
+              out_depth_info->subImage.swapchain =
+                  wine_swapchain_from_handle(out_depth_info->subImage.swapchain)->host_swapchain;
+              ((XrCompositionLayerProjectionView *)view)->next = out_depth_info;
+              break;
+            }
+            case XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB: {
+              XrCompositionLayerSpaceWarpInfoFB *out_warp_info, *in_warp_info;
+
+              in_warp_info = (XrCompositionLayerSpaceWarpInfoFB *)view->next;
+              out_warp_info = &wine_session->view_infos[*view_info_idx + view_info_count].space_warp_info;
+              *out_warp_info = *in_warp_info;
+              out_warp_info->motionVectorSubImage.swapchain =
+                  wine_swapchain_from_handle(out_warp_info->motionVectorSubImage.swapchain)->host_swapchain;
+              out_warp_info->depthSubImage.swapchain =
+                  wine_swapchain_from_handle(out_warp_info->depthSubImage.swapchain)->host_swapchain;
+              ((XrCompositionLayerProjectionView *)view)->next = out_warp_info;
+              break;
+            }
+            default:
+              WARN("Unknown view info type %u.\n", view->type);
+              break;
+          }
+          ++view_info_count;
+          view = view->next;
+        }
+      }
+
+      *view_idx += out_layer->projection.viewCount;
+      *view_info_idx += view_info_count;
+      break;
+    }
+    case XR_TYPE_COMPOSITION_LAYER_QUAD:
+      out_layer->quad = *(const XrCompositionLayerQuad *)in_layer;
+      out_layer->quad.subImage.swapchain =
+          wine_swapchain_from_handle(out_layer->quad.subImage.swapchain)->host_swapchain;
+      break;
+
+    default:
+      WARN("Unknown composition in_layer type: %d\n", in_layer->type);
+      return (XrCompositionLayerBaseHeader *)in_layer;
+  }
+
+  return (XrCompositionLayerBaseHeader *)out_layer;
+}
+
+XrResult WINAPI xrEndFrame(XrSession session, const XrFrameEndInfo *frameEndInfo) {
+  wine_XrSession *wine_session = wine_session_from_handle(session);
+  XrFrameEndInfo our_frameEndInfo;
+  struct xrEndFrame_params params = {
+      .session = session,
+      .frameEndInfo = &our_frameEndInfo,
+  };
+  uint32_t i, view_idx = 0, view_info_idx = 0;
+  NTSTATUS _status;
+
+  TRACE("%p, %p\n", session, frameEndInfo);
+
+  if (frameEndInfo->layerCount > wine_session->composition_layer_count) {
+    free(wine_session->composition_layers);
+    wine_session->composition_layers = malloc(frameEndInfo->layerCount * sizeof(*wine_session->composition_layers));
+    free(wine_session->composition_layer_ptrs);
+    wine_session->composition_layer_ptrs =
+        malloc(frameEndInfo->layerCount * sizeof(*wine_session->composition_layer_ptrs));
+    wine_session->composition_layer_count = frameEndInfo->layerCount;
+  }
+
+  for (i = 0; i < frameEndInfo->layerCount; ++i) {
+    wine_session->composition_layer_ptrs[i] = convert_XrCompositionLayer(
+        wine_session, frameEndInfo->layers[i], &wine_session->composition_layers[i], &view_idx, &view_info_idx);
+  }
+
+  our_frameEndInfo = *frameEndInfo;
+  our_frameEndInfo.layers = (const XrCompositionLayerBaseHeader *const *)wine_session->composition_layer_ptrs;
+
+  lock_d3d_queue(wine_session->instance, FALSE);
+  _status = UNIX_CALL(xrEndFrame, &params);
+  assert(!_status && "xrEndFrame");
+
+  unlock_d3d_queue(wine_session->instance, FALSE);
+  return params.result;
+}
+
+XrResult WINAPI xrConvertTimeToWin32PerformanceCounterKHR(XrInstance instance,
+                                                          XrTime time,
+                                                          LARGE_INTEGER *performanceCounter) {
+  FIXME("unimplemented\n");
+  /* FIXME */
+  return XR_ERROR_INITIALIZATION_FAILED;
+}
+
+XrResult WINAPI xrConvertWin32PerformanceCounterToTimeKHR(XrInstance instance,
+                                                          const LARGE_INTEGER *performanceCounter,
+                                                          XrTime *time) {
+  FIXME("unimplemented\n");
+  /* FIXME */
+  return XR_ERROR_INITIALIZATION_FAILED;
+}
+
+XrResult WINAPI xrGetD3D11GraphicsRequirementsKHR(XrInstance instance,
+                                                  XrSystemId systemId,
+                                                  XrGraphicsRequirementsD3D11KHR *graphicsRequirements) {
+  IDXGIFactory1 *factory;
+  IDXGIAdapter *adapter;
+  DXGI_ADAPTER_DESC adapter_desc;
+  HRESULT hr;
+  DWORD i;
+
+  TRACE("\n");
+
+  hr = CreateDXGIFactory1(&IID_IDXGIFactory1, (void **)&factory);
+  if (FAILED(hr)) {
+    WARN("CreateDXGIFactory1 failed: %08x\n", hr);
+    return XR_ERROR_INITIALIZATION_FAILED;
+  }
+
+  i = 0;
+  while ((hr = IDXGIFactory1_EnumAdapters(factory, i++, &adapter)) == S_OK) {
+    hr = IDXGIAdapter_GetDesc(adapter, &adapter_desc);
+    if (FAILED(hr)) {
+      WARN("GetDesc failed: %08x\n", hr);
+      IDXGIAdapter_Release(adapter);
+      continue;
+    }
+
+    IDXGIAdapter_Release(adapter);
+
+    /* FIXME: what if we have two of the same adapters? */
+    if (adapter_desc.VendorId == g_physdev_vid && adapter_desc.DeviceId == g_physdev_pid) {
+      TRACE("Found DXGI adapter for %#04x:%#04x\n", g_physdev_vid, g_physdev_pid);
+      break;
+    }
+  }
+
+  if (hr == S_OK) {
+    graphicsRequirements->adapterLuid = adapter_desc.AdapterLuid;
+  } else {
+    WARN("Couldn't find matching DXGI adapter for given VkPhysicalDevice! Choosing first one...\n");
+
+    hr = IDXGIFactory1_EnumAdapters(factory, 0, &adapter);
+    if (FAILED(hr)) {
+      WARN("EnumAdapters(0) failed: %08x\n", hr);
+      IDXGIFactory1_Release(factory);
+      return XR_ERROR_INITIALIZATION_FAILED;
+    }
+
+    hr = IDXGIAdapter_GetDesc(adapter, &adapter_desc);
+    if (FAILED(hr)) {
+      WARN("GetDesc(0) failed: %08x\n", hr);
+      IDXGIAdapter_Release(adapter);
+      IDXGIFactory1_Release(factory);
+      return XR_ERROR_INITIALIZATION_FAILED;
+    }
+
+    IDXGIAdapter_Release(adapter);
+
+    graphicsRequirements->adapterLuid = adapter_desc.AdapterLuid;
+  }
+
+  IDXGIFactory1_Release(factory);
+
+  /* XXX */
+  graphicsRequirements->minFeatureLevel = D3D_FEATURE_LEVEL_10_0;
+
+  return XR_SUCCESS;
+}
+
+XrResult WINAPI xrGetD3D12GraphicsRequirementsKHR(XrInstance instance,
+                                                  XrSystemId systemId,
+                                                  XrGraphicsRequirementsD3D12KHR *graphicsRequirements) {
+  XrGraphicsRequirementsD3D11KHR requirements;
+  XrResult result = xrGetD3D11GraphicsRequirementsKHR(instance, systemId, &requirements);
+  if (result != XR_SUCCESS) {
+    return result;
+  }
+  graphicsRequirements->adapterLuid = requirements.adapterLuid;
+  graphicsRequirements->minFeatureLevel = D3D_FEATURE_LEVEL_11_0;
+  return XR_SUCCESS;
+}
+
+XrResult WINAPI xrCreateApiLayerInstance(const XrInstanceCreateInfo *info,
+                                         const XrApiLayerCreateInfo *layerInfo,
+                                         XrInstance *instance) {
+  TRACE("%p, %p, %p\n", info, layerInfo, instance);
+
+  return xrCreateInstance(info, instance);
+}
+
+XrResult WINAPI xrCreateVulkanInstanceKHR(XrInstance instance,
+                                          const XrVulkanInstanceCreateInfoKHR *createInfo,
+                                          VkInstance *vulkanInstance,
+                                          VkResult *vulkanResult) {
+  struct vk_create_callback_context context;
+  VkCreateInfoWineInstanceCallback callback;
+  VkInstanceCreateInfo vulkan_create_info;
+
+  TRACE("instance %p, createInfo %p, vulkanInstance %p, vulkanResult %p.\n", instance, createInfo, vulkanInstance,
+        vulkanResult);
+
+  if (createInfo->createFlags) {
+    WARN("Unexpected flags %#lx.\n", (long)createInfo->createFlags);
+  }
+
+  context.wine_instance = instance;
+  context.create_info = (UINT64)createInfo;
+
+  vulkan_create_info = *createInfo->vulkanCreateInfo;
+  callback.sType = VK_STRUCTURE_TYPE_CREATE_INFO_WINE_INSTANCE_CALLBACK;
+  callback.native_create_callback = (PFN_native_vkCreateInstance)g_vk_create_instance_callback;
+  callback.context = &context;
+  callback.pNext = vulkan_create_info.pNext;
+  vulkan_create_info.pNext = &callback;
+
+  *vulkanResult = vkCreateInstance(&vulkan_create_info, createInfo->vulkanAllocator, vulkanInstance);
+
+  if (context.ret == XR_SUCCESS && *vulkanResult != VK_SUCCESS) {
+    WARN("winevulkan instance creation failed after native xrCreateVulkanInstanceKHR() success.\n");
+  }
+
+  TRACE("result %d, vk result %d.\n", context.ret, *vulkanResult);
+  return context.ret;
+}
+
+XrResult WINAPI xrCreateVulkanDeviceKHR(XrInstance instance,
+                                        const XrVulkanDeviceCreateInfoKHR *createInfo,
+                                        VkDevice *vulkanDevice,
+                                        VkResult *vulkanResult) {
+  struct vk_create_callback_context context;
+  VkCreateInfoWineDeviceCallback callback;
+  VkDeviceCreateInfo vulkan_create_info;
+
+  TRACE("instance %p, createInfo %p, vulkanDevice %p, vulkanResult %p.\n", instance, createInfo, vulkanDevice,
+        vulkanResult);
+
+  if (createInfo->createFlags) {
+    WARN("Unexpected flags %#lx.\n", (long)createInfo->createFlags);
+  }
+
+  context.wine_instance = instance;
+  context.create_info = (UINT64)createInfo;
+
+  vulkan_create_info = *createInfo->vulkanCreateInfo;
+  callback.sType = VK_STRUCTURE_TYPE_CREATE_INFO_WINE_DEVICE_CALLBACK;
+  callback.native_create_callback = (PFN_native_vkCreateDevice)g_vk_create_device_callback;
+  callback.context = &context;
+  callback.pNext = vulkan_create_info.pNext;
+  vulkan_create_info.pNext = &callback;
+
+  *vulkanResult =
+      vkCreateDevice(createInfo->vulkanPhysicalDevice, &vulkan_create_info, createInfo->vulkanAllocator, vulkanDevice);
+
+  if (context.ret == XR_SUCCESS && *vulkanResult != VK_SUCCESS) {
+    WARN("winevulkan instance creation failed after native xrCreateVulkanInstanceKHR() success.\n");
+  }
+
+  TRACE("result %d, vk result %d.\n", context.ret, *vulkanResult);
+  return context.ret;
+}
+
+XrResult WINAPI xrGetInstanceProcAddr(XrInstance instance, const char *fn_name, PFN_xrVoidFunction *out_fn) {
+  struct is_available_instance_function_openxr_params params =
+  {
+    .instance = instance,
+    .name = fn_name,
+  };
+  NTSTATUS _status;
+
+  TRACE("%s\n", fn_name);
+
+  _status = UNIX_CALL(is_available_instance_function, &params);
+  assert(!_status && "is_available_instance_function");
+
+  if (params.ret)
+  {
+    WARN("is_available_instance_function failed for %s, ret %d\n", fn_name, params.ret);
+    return params.ret;
+  }
+
+  *out_fn = wine_xr_get_instance_proc_addr(fn_name);
+  if (!*out_fn) {
+    WARN("Unable to find requested function: %s\n", fn_name);
+    return XR_ERROR_FUNCTION_UNSUPPORTED;
+  }
+
+  return XR_SUCCESS;
+}
+
+XrResult WINAPI xrNegotiateLoaderRuntimeInterface(const XrNegotiateLoaderInfo *info,
+                                                  XrNegotiateRuntimeRequest *request) {
+  const XrNegotiateLoaderInfo *loaderInfo = (const XrNegotiateLoaderInfo *)info;
+  XrNegotiateRuntimeRequest *runtimeRequest = (XrNegotiateRuntimeRequest *)request;
+  XrResult res;
+
+  TRACE("%p %p\n", loaderInfo, runtimeRequest);
+
+  if (!loaderInfo || !runtimeRequest) {
+    return XR_ERROR_INITIALIZATION_FAILED;
+  }
+
+  if ((res = wine_openxr_init_once()) != XR_SUCCESS) {
+    TRACE("could not initialize openxr: %d\n", res);
+    return res;
+  }
+
+  if (loaderInfo->structType != XR_LOADER_INTERFACE_STRUCT_LOADER_INFO ||
+      loaderInfo->structVersion != XR_LOADER_INFO_STRUCT_VERSION ||
+      loaderInfo->structSize != sizeof(XrNegotiateLoaderInfo)) {
+    return XR_ERROR_VALIDATION_FAILURE;
+  }
+
+  if (loaderInfo->minInterfaceVersion > XR_CURRENT_LOADER_RUNTIME_VERSION ||
+      loaderInfo->maxInterfaceVersion < XR_CURRENT_LOADER_RUNTIME_VERSION) {
+    return XR_ERROR_VALIDATION_FAILURE;
+  }
+
+  if (runtimeRequest->structType != XR_LOADER_INTERFACE_STRUCT_RUNTIME_REQUEST ||
+      runtimeRequest->structVersion != XR_RUNTIME_INFO_STRUCT_VERSION ||
+      runtimeRequest->structSize != sizeof(XrNegotiateRuntimeRequest)) {
+    return XR_ERROR_VALIDATION_FAILURE;
+  }
+
+  runtimeRequest->runtimeInterfaceVersion = XR_CURRENT_LOADER_RUNTIME_VERSION;
+  runtimeRequest->getInstanceProcAddr = (PFN_xrGetInstanceProcAddr)&xrGetInstanceProcAddr;
+  runtimeRequest->runtimeApiVersion = api_version;
+
+  return XR_SUCCESS;
+}
+
+XrResult WINAPI xrGetVulkanDeviceExtensionsKHR(XrInstance instance, XrSystemId systemId, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer)
+{
+    struct xrGetVulkanDeviceExtensionsKHR_params params;
+    NTSTATUS _status;
+
+    /* Even while returning fixed string still call the host function, that is a part of OpenXR over Vulkan
+     * expected initialization sequence. */
+    params.instance = instance;
+    params.systemId = systemId;
+    params.bufferCapacityInput = bufferCapacityInput;
+    params.bufferCountOutput = bufferCountOutput;
+    params.buffer = buffer;
+    _status = UNIX_CALL(xrGetVulkanDeviceExtensionsKHR, &params);
+    assert(!_status && "xrGetVulkanDeviceExtensionsKHR");
+
+    if (params.result == XR_SUCCESS && bufferCapacityInput)
+    {
+        __wine_set_unix_env(WINE_VULKAN_DEVICE_VARIABLE, buffer);
+        strcpy(buffer, WINE_VULKAN_DEVICE_EXTENSION_NAME);
+        *bufferCountOutput = sizeof(WINE_VULKAN_DEVICE_EXTENSION_NAME);
+        TRACE("returning %s.\n", buffer);
+    }
+    else if ((params.result == XR_SUCCESS || params.result == XR_ERROR_SIZE_INSUFFICIENT)
+            && *bufferCountOutput < sizeof(WINE_VULKAN_DEVICE_EXTENSION_NAME))
+    {
+        *bufferCountOutput = sizeof(WINE_VULKAN_DEVICE_EXTENSION_NAME);
+    }
+
+    return params.result;
+}
+
+
+/* wineopenxr API */
+XrResult WINAPI __wineopenxr_GetVulkanInstanceExtensions(uint32_t buflen, uint32_t *outlen, char *buf) {
+  XrResult res;
+
+  TRACE("\n");
+
+  if ((res = wine_openxr_init_once()) != XR_SUCCESS) {
+    TRACE("could not initialize openxr: %d\n", res);
+    return res;
+  }
+
+  if (buflen < strlen(g_instance_extensions) + 1 || !buf) {
+    *outlen = strlen(g_instance_extensions) + 1;
+    return XR_SUCCESS;
+  }
+
+  *outlen = strlen(g_instance_extensions) + 1;
+  strcpy(buf, g_instance_extensions);
+
+  return XR_SUCCESS;
+}
+
+/* wineopenxr API */
+XrResult WINAPI __wineopenxr_GetVulkanDeviceExtensions(uint32_t buflen, uint32_t *outlen, char *buf) {
+  XrResult res;
+
+  TRACE("\n");
+
+  if ((res = wine_openxr_init_once()) != XR_SUCCESS) {
+    TRACE("could not initialize openxr: %d\n", res);
+    return res;
+  }
+
+  if (buflen < strlen(WINE_VULKAN_DEVICE_EXTENSION_NAME) + 1 || !buf) {
+    *outlen = strlen(WINE_VULKAN_DEVICE_EXTENSION_NAME) + 1;
+    return XR_SUCCESS;
+  }
+
+  *outlen = strlen(WINE_VULKAN_DEVICE_EXTENSION_NAME) + 1;
+  strcpy(buf, WINE_VULKAN_DEVICE_EXTENSION_NAME);
+
+  return XR_SUCCESS;
+}
+
+BOOL CDECL wineopenxr_init_registry(void)
+{
+    char *xr_inst_ext, *xr_dev_ext;
+    uint32_t vid, pid;
+    LSTATUS status;
+    HKEY vr_key;
+
+    if ((status = RegOpenKeyExA( HKEY_CURRENT_USER, "Software\\Wine\\VR", 0, KEY_ALL_ACCESS, &vr_key )))
+    {
+        WARN( "Could not open key, status %#x.\n", status );
+        return FALSE;
+    }
+
+    if (!get_extensions( &xr_inst_ext, &xr_dev_ext, &vid, &pid ))
+    {
+        TRACE( "Got XR extensions.\n" );
+        if ((status = RegSetValueExA( vr_key, "openxr_vulkan_instance_extensions", 0, REG_SZ,
+                                      (BYTE *)xr_inst_ext, strlen( xr_inst_ext ) + 1 )))
+            ERR( "Could not set openxr_vulkan_instance_extensions value, status %#x.\n", status );
+        if ((status = RegSetValueExA( vr_key, "openxr_vulkan_device_extensions", 0, REG_SZ,
+                                      (BYTE *)xr_dev_ext, strlen( xr_dev_ext ) + 1 )))
+            ERR( "Could not set openxr_vulkan_device_extensions value, status %#x.\n", status );
+        if ((status = RegSetValueExA( vr_key, "openxr_vulkan_device_vid", 0, REG_DWORD,
+                                      (BYTE *)&vid, sizeof(vid) )))
+            ERR( "Could not set openxr_vulkan_device_vid value, status %#x.\n", status );
+        if ((status = RegSetValueExA( vr_key, "openxr_vulkan_device_pid", 0, REG_DWORD,
+                                      (BYTE *)&pid, sizeof(pid) )))
+            ERR( "Could not set openxr_vulkan_device_pid value, status %#x.\n", status );
+    }
+
+    TRACE( "Initialized OpenXR registry entries\n" );
+    RegCloseKey( vr_key );
+    return TRUE;
+}
diff --git a/dlls/wineopenxr/openxr_loader.h b/dlls/wineopenxr/openxr_loader.h
new file mode 100644
index 00000000000..6ff476eb0b6
--- /dev/null
+++ b/dlls/wineopenxr/openxr_loader.h
@@ -0,0 +1,127 @@
+#ifndef __WINE_OPENXR_LOADER_H
+#define __WINE_OPENXR_LOADER_H
+
+#include <stdarg.h>
+#include <stdlib.h>
+
+#define COBJMACROS
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include <assert.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include "windef.h"
+#include "winbase.h"
+#include "wine/debug.h"
+#include "wine/list.h"
+#include "wine/unixlib.h"
+#include "wine/vulkan.h"
+
+#include "d3d11.h"
+#include "d3d11_3.h"
+#include "d3d12.h"
+#include "dxgi.h"
+#include "wineopenxr.h"
+#include "loader_thunks.h"
+
+static const char WINE_VULKAN_DEVICE_EXTENSION_NAME[] = "VK_WINE_openxr_device_extensions";
+static const char WINE_VULKAN_DEVICE_VARIABLE[] = "__WINE_OPENXR_VK_DEVICE_EXTENSIONS";
+
+struct IDXGIVkInteropDevice2;
+typedef struct IDXGIVkInteropDevice2 IDXGIVkInteropDevice2;
+typedef struct ID3D12DXVKInteropDevice ID3D12DXVKInteropDevice;
+typedef struct ID3D12DXVKInteropDevice2 ID3D12DXVKInteropDevice2;
+
+struct vk_create_callback_context {
+  XrInstance wine_instance;
+  UINT64 create_info;
+  XrResult ret;
+};
+
+struct init_openxr_params {
+  HMODULE winevulkan;
+  UINT64 create_instance_callback;
+  UINT64 create_device_callback;
+};
+
+struct is_available_instance_function_openxr_params {
+  XrInstance instance;
+  const char *name;
+  XrResult ret;
+};
+
+typedef struct {
+  XrInstance host_instance;
+  VkInstance vk_instance;
+  VkPhysicalDevice vk_phys_dev;
+
+  XrSystemId systemId;
+
+  IDXGIVkInteropDevice2 *dxvk_device;
+  ID3D12DXVKInteropDevice *d3d12_device;
+  ID3D12DXVKInteropDevice2 *d3d12_device2;
+  ID3D12CommandQueue *d3d12_queue;
+
+  VkDevice vk_device;
+  VkQueue vk_queue;
+  VkCommandPool vk_command_pool;
+} wine_XrInstance;
+
+static inline wine_XrInstance *wine_instance_from_handle(XrInstance handle) {
+  return (wine_XrInstance *)(uintptr_t)handle;
+}
+
+union CompositionLayer;
+typedef union CompositionLayer CompositionLayer;
+
+typedef union {
+  XrCompositionLayerDepthInfoKHR depth_info;
+  XrCompositionLayerSpaceWarpInfoFB space_warp_info;
+} view_info;
+
+typedef struct {
+  XrSession host_session;
+  wine_XrInstance *instance;
+  uint32_t session_type;
+  struct list entry;
+  uint32_t composition_layer_count;
+  CompositionLayer *composition_layers;
+  XrCompositionLayerBaseHeader **composition_layer_ptrs;
+
+  uint32_t projection_view_count, view_info_count;
+  XrCompositionLayerProjectionView *projection_views;
+  view_info *view_infos;
+} wine_XrSession;
+
+static inline wine_XrSession *wine_session_from_handle(XrSession handle) {
+  return (wine_XrSession *)(uintptr_t)handle;
+}
+
+typedef struct {
+  XrSwapchain host_swapchain;
+  wine_XrSession *session;
+  XrSwapchainImageBaseHeader *images;
+  uint32_t image_count;
+  uint32_t acquired_count, acquired_start;
+  BOOL *acquired;
+  uint32_t *acquired_indices;
+
+  XrSwapchainCreateInfo create_info;
+  VkCommandBuffer *cmd_release;
+  VkCommandBuffer *cmd_acquire;
+} wine_XrSwapchain;
+
+static inline wine_XrSwapchain *wine_swapchain_from_handle(XrSwapchain handle) {
+  return (wine_XrSwapchain *)(uintptr_t)handle;
+}
+
+void *wine_xr_get_instance_proc_addr(const char *name);
+
+struct openxr_func {
+  const char *name;
+  void *func;
+};
+
+#define UNIX_CALL(code, params) WINE_UNIX_CALL(unix_##code, params)
+
+#endif /* __WINE_OPENXR_LOADER_H */
diff --git a/dlls/wineopenxr/openxr_private.h b/dlls/wineopenxr/openxr_private.h
new file mode 100644
index 00000000000..18e064a77a1
--- /dev/null
+++ b/dlls/wineopenxr/openxr_private.h
@@ -0,0 +1,60 @@
+#ifndef __WINE_OPENXR_PRIVATE_H
+#define __WINE_OPENXR_PRIVATE_H
+
+#define WINE_XR_HOST
+
+#include <pthread.h>
+#include <stdbool.h>
+
+#include "openxr_loader.h"
+#include "openxr_thunks.h"
+
+extern struct openxr_instance_funcs g_xr_host_instance_dispatch_table;
+
+struct conversion_context {
+  char buffer[2048];
+  uint32_t used;
+  struct list alloc_entries;
+};
+
+static inline void init_conversion_context(struct conversion_context *pool) {
+  pool->used = 0;
+  list_init(&pool->alloc_entries);
+}
+
+static inline void free_conversion_context(struct conversion_context *pool) {
+  struct list *entry, *next;
+  LIST_FOR_EACH_SAFE(entry, next, &pool->alloc_entries)
+  free(entry);
+}
+
+static inline void *conversion_context_alloc(struct conversion_context *pool, size_t size) {
+  if (pool->used + size <= sizeof(pool->buffer)) {
+    void *ret = pool->buffer + pool->used;
+    pool->used += (size + sizeof(UINT64) - 1) & ~(sizeof(UINT64) - 1);
+    return ret;
+  } else {
+    struct list *entry;
+    if (!(entry = malloc(sizeof(*entry) + size))) {
+      return NULL;
+    }
+    list_add_tail(&pool->alloc_entries, entry);
+    return entry + 1;
+  }
+}
+
+NTSTATUS init_openxr(void *args);
+NTSTATUS is_available_instance_function_openxr(void *args);
+NTSTATUS get_vk_create_callback_ptrs(void *args);
+extern void register_dispatchable_handle(uint64_t handle, struct openxr_instance_funcs *funcs);
+extern void unregister_dispatchable_handle(uint64_t handle);
+extern struct openxr_instance_funcs *get_dispatch_table(uint64_t handle);
+
+#define MEMDUP(ctx, dst, src, count)                               \
+  dst = conversion_context_alloc((ctx), sizeof(*(dst)) * (count)); \
+  memcpy((void *)(dst), (src), sizeof(*(dst)) * (count));
+#define MEMDUP_VOID(ctx, dst, src, size)       \
+  dst = conversion_context_alloc((ctx), size); \
+  memcpy((void *)(dst), (src), size);
+
+#endif /* __WINE_OPENXR_PRIVATE_H */
diff --git a/dlls/wineopenxr/openxr_thunks.c b/dlls/wineopenxr/openxr_thunks.c
new file mode 100644
index 00000000000..4773fbb692c
--- /dev/null
+++ b/dlls/wineopenxr/openxr_thunks.c
@@ -0,0 +1,5448 @@
+/* Automatically generated from Vulkan xr.xml; DO NOT EDIT!
+ *
+ * This file is generated from Vulkan xr.xml file covered
+ * by the following copyright and permission notice:
+ *
+ * Copyright (c) 2017-2025 The Khronos Group Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0 OR MIT
+ *
+ * ------------------------------------------------------------------------
+ *
+ * This file, xr.xml, is the OpenXR API Registry. It is a critically important
+ * and normative part of the OpenXR Specification, including a canonical
+ * machine-readable definition of the API, parameter and member validation
+ * language incorporated into the Specification and reference pages, and other
+ * material which is registered by Khronos, such as tags used by extension and
+ * layer authors. The only authoritative version of xr.xml is the one
+ * maintained in the default branch of the Khronos OpenXR GitHub project.
+ *
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <stdlib.h>
+
+#include "openxr_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(openxr);
+
+#ifdef _WIN64
+static inline void convert_XrInstanceCreateInfo_win64_to_host(struct conversion_context *ctx, const XrInstanceCreateInfo *in, XrInstanceCreateInfo *out)
+{
+    const XrBaseInStructure *in_header;
+    XrBaseOutStructure *out_header = (void *)out;
+
+    if (!in) return;
+
+    out->type = in->type;
+    out->next = NULL;
+    out->createFlags = in->createFlags;
+    out->applicationInfo = in->applicationInfo;
+    out->enabledApiLayerCount = in->enabledApiLayerCount;
+    out->enabledApiLayerNames = in->enabledApiLayerNames;
+    out->enabledExtensionCount = in->enabledExtensionCount;
+    out->enabledExtensionNames = in->enabledExtensionNames;
+
+    for (in_header = (void *)in->next; in_header; in_header = (void *)in_header->next)
+    {
+        switch (in_header->type)
+        {
+        default:
+            if ((in_header->type >> 16) == 0x7ead)
+            {
+                XrBaseOutStructure *out_ext = conversion_context_alloc(ctx, 32);
+                memcpy(out_ext, in_header, 32);
+                out_ext->next = NULL;
+                out_header->next = (void *)out_ext;
+                out_header = (void *)out_ext;
+            }
+            else
+            {
+                FIXME("Unhandled type %u.\n", in_header->type);
+            }
+            break;
+        }
+    }
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrAcquireEnvironmentDepthImageMETA(void *args)
+{
+    struct xrAcquireEnvironmentDepthImageMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->environmentDepthProvider, params->acquireInfo, params->environmentDepthImage);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrAcquireEnvironmentDepthImageMETA(params->environmentDepthProvider, params->acquireInfo, params->environmentDepthImage);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrAcquireSwapchainImage(void *args)
+{
+    struct xrAcquireSwapchainImage_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->swapchain, params->acquireInfo, params->index);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrAcquireSwapchainImage(wine_swapchain_from_handle(params->swapchain)->host_swapchain, params->acquireInfo, params->index);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrAllocateWorldMeshBufferML(void *args)
+{
+    struct xrAllocateWorldMeshBufferML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->detector, params->size, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrAllocateWorldMeshBufferML(params->detector, params->size, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrApplyForceFeedbackCurlMNDX(void *args)
+{
+    struct xrApplyForceFeedbackCurlMNDX_params *params = args;
+
+    TRACE("%p, %p\n", params->handTracker, params->locations);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrApplyForceFeedbackCurlMNDX(params->handTracker, params->locations);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrApplyHapticFeedback(void *args)
+{
+    struct xrApplyHapticFeedback_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->hapticActionInfo, params->hapticFeedback);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrApplyHapticFeedback(wine_session_from_handle(params->session)->host_session, params->hapticActionInfo, params->hapticFeedback);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrAttachSessionActionSets(void *args)
+{
+    struct xrAttachSessionActionSets_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->attachInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrAttachSessionActionSets(wine_session_from_handle(params->session)->host_session, params->attachInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrBeginFrame(void *args)
+{
+    struct xrBeginFrame_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->frameBeginInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrBeginFrame(wine_session_from_handle(params->session)->host_session, params->frameBeginInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrBeginPlaneDetectionEXT(void *args)
+{
+    struct xrBeginPlaneDetectionEXT_params *params = args;
+
+    TRACE("%p, %p\n", params->planeDetector, params->beginInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrBeginPlaneDetectionEXT(params->planeDetector, params->beginInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrBeginSession(void *args)
+{
+    struct xrBeginSession_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->beginInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrBeginSession(wine_session_from_handle(params->session)->host_session, params->beginInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCancelFutureEXT(void *args)
+{
+    struct xrCancelFutureEXT_params *params = args;
+
+    TRACE("%p, %p\n", params->instance, params->cancelInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCancelFutureEXT(wine_instance_from_handle(params->instance)->host_instance, params->cancelInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCaptureSceneAsyncBD(void *args)
+{
+    struct xrCaptureSceneAsyncBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->info, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCaptureSceneAsyncBD(params->provider, params->info, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCaptureSceneCompleteBD(void *args)
+{
+    struct xrCaptureSceneCompleteBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCaptureSceneCompleteBD(params->provider, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrChangeVirtualKeyboardTextContextMETA(void *args)
+{
+    struct xrChangeVirtualKeyboardTextContextMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->keyboard, params->changeInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrChangeVirtualKeyboardTextContextMETA(params->keyboard, params->changeInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrClearSpatialAnchorStoreMSFT(void *args)
+{
+    struct xrClearSpatialAnchorStoreMSFT_params *params = args;
+
+    TRACE("%p\n", params->spatialAnchorStore);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrClearSpatialAnchorStoreMSFT(params->spatialAnchorStore);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrComputeNewSceneMSFT(void *args)
+{
+    struct xrComputeNewSceneMSFT_params *params = args;
+
+    TRACE("%p, %p\n", params->sceneObserver, params->computeInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrComputeNewSceneMSFT(params->sceneObserver, params->computeInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateAction(void *args)
+{
+    struct xrCreateAction_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->actionSet, params->createInfo, params->action);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateAction(params->actionSet, params->createInfo, params->action);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateActionSet(void *args)
+{
+    struct xrCreateActionSet_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->instance, params->createInfo, params->actionSet);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateActionSet(wine_instance_from_handle(params->instance)->host_instance, params->createInfo, params->actionSet);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateActionSpace(void *args)
+{
+    struct xrCreateActionSpace_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->space);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateActionSpace(wine_session_from_handle(params->session)->host_session, params->createInfo, params->space);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateAnchorSpaceANDROID(void *args)
+{
+    struct xrCreateAnchorSpaceANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->anchorOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateAnchorSpaceANDROID(wine_session_from_handle(params->session)->host_session, params->createInfo, params->anchorOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateAnchorSpaceBD(void *args)
+{
+    struct xrCreateAnchorSpaceBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->space);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateAnchorSpaceBD(wine_session_from_handle(params->session)->host_session, params->createInfo, params->space);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateBodyTrackerBD(void *args)
+{
+    struct xrCreateBodyTrackerBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->bodyTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateBodyTrackerBD(wine_session_from_handle(params->session)->host_session, params->createInfo, params->bodyTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateBodyTrackerFB(void *args)
+{
+    struct xrCreateBodyTrackerFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->bodyTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateBodyTrackerFB(wine_session_from_handle(params->session)->host_session, params->createInfo, params->bodyTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateBodyTrackerHTC(void *args)
+{
+    struct xrCreateBodyTrackerHTC_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->bodyTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateBodyTrackerHTC(wine_session_from_handle(params->session)->host_session, params->createInfo, params->bodyTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateDeviceAnchorPersistenceANDROID(void *args)
+{
+    struct xrCreateDeviceAnchorPersistenceANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->outHandle);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateDeviceAnchorPersistenceANDROID(wine_session_from_handle(params->session)->host_session, params->createInfo, params->outHandle);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateEnvironmentDepthProviderMETA(void *args)
+{
+    struct xrCreateEnvironmentDepthProviderMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->environmentDepthProvider);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateEnvironmentDepthProviderMETA(wine_session_from_handle(params->session)->host_session, params->createInfo, params->environmentDepthProvider);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateEnvironmentDepthSwapchainMETA(void *args)
+{
+    struct xrCreateEnvironmentDepthSwapchainMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->environmentDepthProvider, params->createInfo, params->swapchain);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateEnvironmentDepthSwapchainMETA(params->environmentDepthProvider, params->createInfo, params->swapchain);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateExportedLocalizationMapML(void *args)
+{
+    struct xrCreateExportedLocalizationMapML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->mapUuid, params->map);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateExportedLocalizationMapML(wine_session_from_handle(params->session)->host_session, params->mapUuid, params->map);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateEyeTrackerFB(void *args)
+{
+    struct xrCreateEyeTrackerFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->eyeTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateEyeTrackerFB(wine_session_from_handle(params->session)->host_session, params->createInfo, params->eyeTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateFaceTracker2FB(void *args)
+{
+    struct xrCreateFaceTracker2FB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->faceTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateFaceTracker2FB(wine_session_from_handle(params->session)->host_session, params->createInfo, params->faceTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateFaceTrackerFB(void *args)
+{
+    struct xrCreateFaceTrackerFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->faceTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateFaceTrackerFB(wine_session_from_handle(params->session)->host_session, params->createInfo, params->faceTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateFacialExpressionClientML(void *args)
+{
+    struct xrCreateFacialExpressionClientML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->facialExpressionClient);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateFacialExpressionClientML(wine_session_from_handle(params->session)->host_session, params->createInfo, params->facialExpressionClient);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateFacialTrackerHTC(void *args)
+{
+    struct xrCreateFacialTrackerHTC_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->facialTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateFacialTrackerHTC(wine_session_from_handle(params->session)->host_session, params->createInfo, params->facialTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateFoveationProfileFB(void *args)
+{
+    struct xrCreateFoveationProfileFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->profile);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateFoveationProfileFB(wine_session_from_handle(params->session)->host_session, params->createInfo, params->profile);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateGeometryInstanceFB(void *args)
+{
+    struct xrCreateGeometryInstanceFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->outGeometryInstance);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateGeometryInstanceFB(wine_session_from_handle(params->session)->host_session, params->createInfo, params->outGeometryInstance);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateHandMeshSpaceMSFT(void *args)
+{
+    struct xrCreateHandMeshSpaceMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->handTracker, params->createInfo, params->space);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateHandMeshSpaceMSFT(params->handTracker, params->createInfo, params->space);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateHandTrackerEXT(void *args)
+{
+    struct xrCreateHandTrackerEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->handTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateHandTrackerEXT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->handTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateInstance(void *args)
+{
+    struct xrCreateInstance_params *params = args;
+    XrInstanceCreateInfo createInfo_host;
+    struct conversion_context local_ctx;
+    struct conversion_context *ctx = &local_ctx;
+
+    TRACE("%p, %p\n", params->createInfo, params->instance);
+
+    init_conversion_context(ctx);
+    convert_XrInstanceCreateInfo_win64_to_host(ctx, params->createInfo, &createInfo_host);
+    params->result = wine_xrCreateInstance(&createInfo_host, params->instance);
+    free_conversion_context(ctx);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateKeyboardSpaceFB(void *args)
+{
+    struct xrCreateKeyboardSpaceFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->keyboardSpace);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateKeyboardSpaceFB(wine_session_from_handle(params->session)->host_session, params->createInfo, params->keyboardSpace);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateMarkerDetectorML(void *args)
+{
+    struct xrCreateMarkerDetectorML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->markerDetector);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateMarkerDetectorML(wine_session_from_handle(params->session)->host_session, params->createInfo, params->markerDetector);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateMarkerSpaceML(void *args)
+{
+    struct xrCreateMarkerSpaceML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->space);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateMarkerSpaceML(wine_session_from_handle(params->session)->host_session, params->createInfo, params->space);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateMarkerSpaceVARJO(void *args)
+{
+    struct xrCreateMarkerSpaceVARJO_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->space);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateMarkerSpaceVARJO(wine_session_from_handle(params->session)->host_session, params->createInfo, params->space);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreatePassthroughColorLutMETA(void *args)
+{
+    struct xrCreatePassthroughColorLutMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->passthrough, params->createInfo, params->colorLut);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreatePassthroughColorLutMETA(params->passthrough, params->createInfo, params->colorLut);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreatePassthroughFB(void *args)
+{
+    struct xrCreatePassthroughFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->outPassthrough);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreatePassthroughFB(wine_session_from_handle(params->session)->host_session, params->createInfo, params->outPassthrough);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreatePassthroughHTC(void *args)
+{
+    struct xrCreatePassthroughHTC_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->passthrough);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreatePassthroughHTC(wine_session_from_handle(params->session)->host_session, params->createInfo, params->passthrough);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreatePassthroughLayerFB(void *args)
+{
+    struct xrCreatePassthroughLayerFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->outLayer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreatePassthroughLayerFB(wine_session_from_handle(params->session)->host_session, params->createInfo, params->outLayer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreatePersistedAnchorSpaceANDROID(void *args)
+{
+    struct xrCreatePersistedAnchorSpaceANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->handle, params->createInfo, params->anchorOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreatePersistedAnchorSpaceANDROID(params->handle, params->createInfo, params->anchorOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreatePlaneDetectorEXT(void *args)
+{
+    struct xrCreatePlaneDetectorEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->planeDetector);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreatePlaneDetectorEXT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->planeDetector);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateReferenceSpace(void *args)
+{
+    struct xrCreateReferenceSpace_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->space);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateReferenceSpace(wine_session_from_handle(params->session)->host_session, params->createInfo, params->space);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateRenderModelAssetEXT(void *args)
+{
+    struct xrCreateRenderModelAssetEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->asset);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateRenderModelAssetEXT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->asset);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateRenderModelEXT(void *args)
+{
+    struct xrCreateRenderModelEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->renderModel);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateRenderModelEXT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->renderModel);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateRenderModelSpaceEXT(void *args)
+{
+    struct xrCreateRenderModelSpaceEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->space);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateRenderModelSpaceEXT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->space);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSceneMSFT(void *args)
+{
+    struct xrCreateSceneMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->sceneObserver, params->createInfo, params->scene);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSceneMSFT(params->sceneObserver, params->createInfo, params->scene);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSceneObserverMSFT(void *args)
+{
+    struct xrCreateSceneObserverMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->sceneObserver);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSceneObserverMSFT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->sceneObserver);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSenseDataProviderBD(void *args)
+{
+    struct xrCreateSenseDataProviderBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->provider);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSenseDataProviderBD(wine_session_from_handle(params->session)->host_session, params->createInfo, params->provider);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSession(void *args)
+{
+    struct xrCreateSession_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->instance, params->createInfo, params->session);
+
+    params->result = wine_xrCreateSession(params->instance, params->createInfo, params->session);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpaceUserFB(void *args)
+{
+    struct xrCreateSpaceUserFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->user);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpaceUserFB(wine_session_from_handle(params->session)->host_session, params->info, params->user);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorAsyncBD(void *args)
+{
+    struct xrCreateSpatialAnchorAsyncBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->info, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorAsyncBD(params->provider, params->info, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorCompleteBD(void *args)
+{
+    struct xrCreateSpatialAnchorCompleteBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorCompleteBD(params->provider, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorEXT(void *args)
+{
+    struct xrCreateSpatialAnchorEXT_params *params = args;
+
+    TRACE("%p, %p, %p, %p\n", params->spatialContext, params->createInfo, params->anchorEntityId, params->anchorEntity);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorEXT(params->spatialContext, params->createInfo, params->anchorEntityId, params->anchorEntity);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorFB(void *args)
+{
+    struct xrCreateSpatialAnchorFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorFB(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorFromPersistedNameMSFT(void *args)
+{
+    struct xrCreateSpatialAnchorFromPersistedNameMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->spatialAnchorCreateInfo, params->spatialAnchor);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorFromPersistedNameMSFT(wine_session_from_handle(params->session)->host_session, params->spatialAnchorCreateInfo, params->spatialAnchor);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorHTC(void *args)
+{
+    struct xrCreateSpatialAnchorHTC_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->anchor);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorHTC(wine_session_from_handle(params->session)->host_session, params->createInfo, params->anchor);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorMSFT(void *args)
+{
+    struct xrCreateSpatialAnchorMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->anchor);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorMSFT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->anchor);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorSpaceMSFT(void *args)
+{
+    struct xrCreateSpatialAnchorSpaceMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->space);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorSpaceMSFT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->space);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorStoreConnectionMSFT(void *args)
+{
+    struct xrCreateSpatialAnchorStoreConnectionMSFT_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->spatialAnchorStore);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorStoreConnectionMSFT(wine_session_from_handle(params->session)->host_session, params->spatialAnchorStore);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorsAsyncML(void *args)
+{
+    struct xrCreateSpatialAnchorsAsyncML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorsAsyncML(wine_session_from_handle(params->session)->host_session, params->createInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorsCompleteML(void *args)
+{
+    struct xrCreateSpatialAnchorsCompleteML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorsCompleteML(wine_session_from_handle(params->session)->host_session, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialAnchorsStorageML(void *args)
+{
+    struct xrCreateSpatialAnchorsStorageML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->storage);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialAnchorsStorageML(wine_session_from_handle(params->session)->host_session, params->createInfo, params->storage);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialContextAsyncEXT(void *args)
+{
+    struct xrCreateSpatialContextAsyncEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialContextAsyncEXT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialContextCompleteEXT(void *args)
+{
+    struct xrCreateSpatialContextCompleteEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialContextCompleteEXT(wine_session_from_handle(params->session)->host_session, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialDiscoverySnapshotAsyncEXT(void *args)
+{
+    struct xrCreateSpatialDiscoverySnapshotAsyncEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->spatialContext, params->createInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialDiscoverySnapshotAsyncEXT(params->spatialContext, params->createInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialDiscoverySnapshotCompleteEXT(void *args)
+{
+    struct xrCreateSpatialDiscoverySnapshotCompleteEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->spatialContext, params->createSnapshotCompletionInfo, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialDiscoverySnapshotCompleteEXT(params->spatialContext, params->createSnapshotCompletionInfo, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialEntityAnchorBD(void *args)
+{
+    struct xrCreateSpatialEntityAnchorBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->createInfo, params->anchor);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialEntityAnchorBD(params->provider, params->createInfo, params->anchor);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialEntityFromIdEXT(void *args)
+{
+    struct xrCreateSpatialEntityFromIdEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->spatialContext, params->createInfo, params->spatialEntity);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialEntityFromIdEXT(params->spatialContext, params->createInfo, params->spatialEntity);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialGraphNodeSpaceMSFT(void *args)
+{
+    struct xrCreateSpatialGraphNodeSpaceMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->space);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialGraphNodeSpaceMSFT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->space);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialPersistenceContextAsyncEXT(void *args)
+{
+    struct xrCreateSpatialPersistenceContextAsyncEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialPersistenceContextAsyncEXT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialPersistenceContextCompleteEXT(void *args)
+{
+    struct xrCreateSpatialPersistenceContextCompleteEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialPersistenceContextCompleteEXT(wine_session_from_handle(params->session)->host_session, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSpatialUpdateSnapshotEXT(void *args)
+{
+    struct xrCreateSpatialUpdateSnapshotEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->spatialContext, params->createInfo, params->snapshot);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateSpatialUpdateSnapshotEXT(params->spatialContext, params->createInfo, params->snapshot);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateSwapchain(void *args)
+{
+    struct xrCreateSwapchain_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->swapchain);
+
+    params->result = wine_xrCreateSwapchain(params->session, params->createInfo, params->swapchain);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateTrackableTrackerANDROID(void *args)
+{
+    struct xrCreateTrackableTrackerANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->trackableTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateTrackableTrackerANDROID(wine_session_from_handle(params->session)->host_session, params->createInfo, params->trackableTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateTriangleMeshFB(void *args)
+{
+    struct xrCreateTriangleMeshFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->outTriangleMesh);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateTriangleMeshFB(wine_session_from_handle(params->session)->host_session, params->createInfo, params->outTriangleMesh);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateVirtualKeyboardMETA(void *args)
+{
+    struct xrCreateVirtualKeyboardMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->keyboard);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateVirtualKeyboardMETA(wine_session_from_handle(params->session)->host_session, params->createInfo, params->keyboard);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateVirtualKeyboardSpaceMETA(void *args)
+{
+    struct xrCreateVirtualKeyboardSpaceMETA_params *params = args;
+
+    TRACE("%p, %p, %p, %p\n", params->session, params->keyboard, params->createInfo, params->keyboardSpace);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateVirtualKeyboardSpaceMETA(wine_session_from_handle(params->session)->host_session, params->keyboard, params->createInfo, params->keyboardSpace);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrCreateWorldMeshDetectorML(void *args)
+{
+    struct xrCreateWorldMeshDetectorML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->detector);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrCreateWorldMeshDetectorML(wine_session_from_handle(params->session)->host_session, params->createInfo, params->detector);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDeleteSpatialAnchorsAsyncML(void *args)
+{
+    struct xrDeleteSpatialAnchorsAsyncML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->storage, params->deleteInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDeleteSpatialAnchorsAsyncML(params->storage, params->deleteInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDeleteSpatialAnchorsCompleteML(void *args)
+{
+    struct xrDeleteSpatialAnchorsCompleteML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->storage, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDeleteSpatialAnchorsCompleteML(params->storage, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDeserializeSceneMSFT(void *args)
+{
+    struct xrDeserializeSceneMSFT_params *params = args;
+
+    TRACE("%p, %p\n", params->sceneObserver, params->deserializeInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDeserializeSceneMSFT(params->sceneObserver, params->deserializeInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyAction(void *args)
+{
+    struct xrDestroyAction_params *params = args;
+
+    TRACE("%p\n", params->action);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyAction(params->action);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyActionSet(void *args)
+{
+    struct xrDestroyActionSet_params *params = args;
+
+    TRACE("%p\n", params->actionSet);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyActionSet(params->actionSet);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyAnchorBD(void *args)
+{
+    struct xrDestroyAnchorBD_params *params = args;
+
+    TRACE("%p\n", params->anchor);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyAnchorBD(params->anchor);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyBodyTrackerBD(void *args)
+{
+    struct xrDestroyBodyTrackerBD_params *params = args;
+
+    TRACE("%p\n", params->bodyTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyBodyTrackerBD(params->bodyTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyBodyTrackerFB(void *args)
+{
+    struct xrDestroyBodyTrackerFB_params *params = args;
+
+    TRACE("%p\n", params->bodyTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyBodyTrackerFB(params->bodyTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyBodyTrackerHTC(void *args)
+{
+    struct xrDestroyBodyTrackerHTC_params *params = args;
+
+    TRACE("%p\n", params->bodyTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyBodyTrackerHTC(params->bodyTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyDeviceAnchorPersistenceANDROID(void *args)
+{
+    struct xrDestroyDeviceAnchorPersistenceANDROID_params *params = args;
+
+    TRACE("%p\n", params->handle);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyDeviceAnchorPersistenceANDROID(params->handle);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyEnvironmentDepthProviderMETA(void *args)
+{
+    struct xrDestroyEnvironmentDepthProviderMETA_params *params = args;
+
+    TRACE("%p\n", params->environmentDepthProvider);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyEnvironmentDepthProviderMETA(params->environmentDepthProvider);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyEnvironmentDepthSwapchainMETA(void *args)
+{
+    struct xrDestroyEnvironmentDepthSwapchainMETA_params *params = args;
+
+    TRACE("%p\n", params->swapchain);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyEnvironmentDepthSwapchainMETA(params->swapchain);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyExportedLocalizationMapML(void *args)
+{
+    struct xrDestroyExportedLocalizationMapML_params *params = args;
+
+    TRACE("%p\n", params->map);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyExportedLocalizationMapML(params->map);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyEyeTrackerFB(void *args)
+{
+    struct xrDestroyEyeTrackerFB_params *params = args;
+
+    TRACE("%p\n", params->eyeTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyEyeTrackerFB(params->eyeTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyFaceTracker2FB(void *args)
+{
+    struct xrDestroyFaceTracker2FB_params *params = args;
+
+    TRACE("%p\n", params->faceTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyFaceTracker2FB(params->faceTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyFaceTrackerFB(void *args)
+{
+    struct xrDestroyFaceTrackerFB_params *params = args;
+
+    TRACE("%p\n", params->faceTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyFaceTrackerFB(params->faceTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyFacialExpressionClientML(void *args)
+{
+    struct xrDestroyFacialExpressionClientML_params *params = args;
+
+    TRACE("%p\n", params->facialExpressionClient);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyFacialExpressionClientML(params->facialExpressionClient);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyFacialTrackerHTC(void *args)
+{
+    struct xrDestroyFacialTrackerHTC_params *params = args;
+
+    TRACE("%p\n", params->facialTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyFacialTrackerHTC(params->facialTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyFoveationProfileFB(void *args)
+{
+    struct xrDestroyFoveationProfileFB_params *params = args;
+
+    TRACE("%p\n", params->profile);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyFoveationProfileFB(params->profile);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyGeometryInstanceFB(void *args)
+{
+    struct xrDestroyGeometryInstanceFB_params *params = args;
+
+    TRACE("%p\n", params->instance);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyGeometryInstanceFB(params->instance);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyHandTrackerEXT(void *args)
+{
+    struct xrDestroyHandTrackerEXT_params *params = args;
+
+    TRACE("%p\n", params->handTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyHandTrackerEXT(params->handTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyInstance(void *args)
+{
+    struct xrDestroyInstance_params *params = args;
+
+    TRACE("%p\n", params->instance);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyInstance(wine_instance_from_handle(params->instance)->host_instance);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyMarkerDetectorML(void *args)
+{
+    struct xrDestroyMarkerDetectorML_params *params = args;
+
+    TRACE("%p\n", params->markerDetector);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyMarkerDetectorML(params->markerDetector);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyPassthroughColorLutMETA(void *args)
+{
+    struct xrDestroyPassthroughColorLutMETA_params *params = args;
+
+    TRACE("%p\n", params->colorLut);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyPassthroughColorLutMETA(params->colorLut);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyPassthroughFB(void *args)
+{
+    struct xrDestroyPassthroughFB_params *params = args;
+
+    TRACE("%p\n", params->passthrough);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyPassthroughFB(params->passthrough);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyPassthroughHTC(void *args)
+{
+    struct xrDestroyPassthroughHTC_params *params = args;
+
+    TRACE("%p\n", params->passthrough);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyPassthroughHTC(params->passthrough);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyPassthroughLayerFB(void *args)
+{
+    struct xrDestroyPassthroughLayerFB_params *params = args;
+
+    TRACE("%p\n", params->layer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyPassthroughLayerFB(params->layer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyPlaneDetectorEXT(void *args)
+{
+    struct xrDestroyPlaneDetectorEXT_params *params = args;
+
+    TRACE("%p\n", params->planeDetector);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyPlaneDetectorEXT(params->planeDetector);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyRenderModelAssetEXT(void *args)
+{
+    struct xrDestroyRenderModelAssetEXT_params *params = args;
+
+    TRACE("%p\n", params->asset);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyRenderModelAssetEXT(params->asset);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyRenderModelEXT(void *args)
+{
+    struct xrDestroyRenderModelEXT_params *params = args;
+
+    TRACE("%p\n", params->renderModel);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyRenderModelEXT(params->renderModel);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySceneMSFT(void *args)
+{
+    struct xrDestroySceneMSFT_params *params = args;
+
+    TRACE("%p\n", params->scene);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySceneMSFT(params->scene);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySceneObserverMSFT(void *args)
+{
+    struct xrDestroySceneObserverMSFT_params *params = args;
+
+    TRACE("%p\n", params->sceneObserver);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySceneObserverMSFT(params->sceneObserver);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySenseDataProviderBD(void *args)
+{
+    struct xrDestroySenseDataProviderBD_params *params = args;
+
+    TRACE("%p\n", params->provider);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySenseDataProviderBD(params->provider);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySenseDataSnapshotBD(void *args)
+{
+    struct xrDestroySenseDataSnapshotBD_params *params = args;
+
+    TRACE("%p\n", params->snapshot);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySenseDataSnapshotBD(params->snapshot);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySession(void *args)
+{
+    struct xrDestroySession_params *params = args;
+
+    TRACE("%p\n", params->session);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySession(wine_session_from_handle(params->session)->host_session);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySpace(void *args)
+{
+    struct xrDestroySpace_params *params = args;
+
+    TRACE("%p\n", params->space);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySpace(params->space);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySpaceUserFB(void *args)
+{
+    struct xrDestroySpaceUserFB_params *params = args;
+
+    TRACE("%p\n", params->user);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySpaceUserFB(params->user);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySpatialAnchorMSFT(void *args)
+{
+    struct xrDestroySpatialAnchorMSFT_params *params = args;
+
+    TRACE("%p\n", params->anchor);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySpatialAnchorMSFT(params->anchor);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySpatialAnchorStoreConnectionMSFT(void *args)
+{
+    struct xrDestroySpatialAnchorStoreConnectionMSFT_params *params = args;
+
+    TRACE("%p\n", params->spatialAnchorStore);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySpatialAnchorStoreConnectionMSFT(params->spatialAnchorStore);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySpatialAnchorsStorageML(void *args)
+{
+    struct xrDestroySpatialAnchorsStorageML_params *params = args;
+
+    TRACE("%p\n", params->storage);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySpatialAnchorsStorageML(params->storage);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySpatialContextEXT(void *args)
+{
+    struct xrDestroySpatialContextEXT_params *params = args;
+
+    TRACE("%p\n", params->spatialContext);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySpatialContextEXT(params->spatialContext);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySpatialEntityEXT(void *args)
+{
+    struct xrDestroySpatialEntityEXT_params *params = args;
+
+    TRACE("%p\n", params->spatialEntity);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySpatialEntityEXT(params->spatialEntity);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySpatialGraphNodeBindingMSFT(void *args)
+{
+    struct xrDestroySpatialGraphNodeBindingMSFT_params *params = args;
+
+    TRACE("%p\n", params->nodeBinding);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySpatialGraphNodeBindingMSFT(params->nodeBinding);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySpatialPersistenceContextEXT(void *args)
+{
+    struct xrDestroySpatialPersistenceContextEXT_params *params = args;
+
+    TRACE("%p\n", params->persistenceContext);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySpatialPersistenceContextEXT(params->persistenceContext);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySpatialSnapshotEXT(void *args)
+{
+    struct xrDestroySpatialSnapshotEXT_params *params = args;
+
+    TRACE("%p\n", params->snapshot);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySpatialSnapshotEXT(params->snapshot);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroySwapchain(void *args)
+{
+    struct xrDestroySwapchain_params *params = args;
+
+    TRACE("%p\n", params->swapchain);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroySwapchain(wine_swapchain_from_handle(params->swapchain)->host_swapchain);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyTrackableTrackerANDROID(void *args)
+{
+    struct xrDestroyTrackableTrackerANDROID_params *params = args;
+
+    TRACE("%p\n", params->trackableTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyTrackableTrackerANDROID(params->trackableTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyTriangleMeshFB(void *args)
+{
+    struct xrDestroyTriangleMeshFB_params *params = args;
+
+    TRACE("%p\n", params->mesh);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyTriangleMeshFB(params->mesh);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyVirtualKeyboardMETA(void *args)
+{
+    struct xrDestroyVirtualKeyboardMETA_params *params = args;
+
+    TRACE("%p\n", params->keyboard);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyVirtualKeyboardMETA(params->keyboard);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDestroyWorldMeshDetectorML(void *args)
+{
+    struct xrDestroyWorldMeshDetectorML_params *params = args;
+
+    TRACE("%p\n", params->detector);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDestroyWorldMeshDetectorML(params->detector);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDiscoverSpacesMETA(void *args)
+{
+    struct xrDiscoverSpacesMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDiscoverSpacesMETA(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDownloadSharedSpatialAnchorAsyncBD(void *args)
+{
+    struct xrDownloadSharedSpatialAnchorAsyncBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->info, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDownloadSharedSpatialAnchorAsyncBD(params->provider, params->info, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrDownloadSharedSpatialAnchorCompleteBD(void *args)
+{
+    struct xrDownloadSharedSpatialAnchorCompleteBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrDownloadSharedSpatialAnchorCompleteBD(params->provider, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnableLocalizationEventsML(void *args)
+{
+    struct xrEnableLocalizationEventsML_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->info);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnableLocalizationEventsML(wine_session_from_handle(params->session)->host_session, params->info);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnableUserCalibrationEventsML(void *args)
+{
+    struct xrEnableUserCalibrationEventsML_params *params = args;
+
+    TRACE("%p, %p\n", params->instance, params->enableInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnableUserCalibrationEventsML(wine_instance_from_handle(params->instance)->host_instance, params->enableInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEndFrame(void *args)
+{
+    struct xrEndFrame_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->frameEndInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEndFrame(wine_session_from_handle(params->session)->host_session, params->frameEndInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEndSession(void *args)
+{
+    struct xrEndSession_params *params = args;
+
+    TRACE("%p\n", params->session);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEndSession(wine_session_from_handle(params->session)->host_session);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateApiLayerProperties(void *args)
+{
+    struct xrEnumerateApiLayerProperties_params *params = args;
+
+    TRACE("%u, %p, %p\n", params->propertyCapacityInput, params->propertyCountOutput, params->properties);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateApiLayerProperties(params->propertyCapacityInput, params->propertyCountOutput, params->properties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateBoundSourcesForAction(void *args)
+{
+    struct xrEnumerateBoundSourcesForAction_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->session, params->enumerateInfo, params->sourceCapacityInput, params->sourceCountOutput, params->sources);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateBoundSourcesForAction(wine_session_from_handle(params->session)->host_session, params->enumerateInfo, params->sourceCapacityInput, params->sourceCountOutput, params->sources);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateColorSpacesFB(void *args)
+{
+    struct xrEnumerateColorSpacesFB_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->session, params->colorSpaceCapacityInput, params->colorSpaceCountOutput, params->colorSpaces);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateColorSpacesFB(wine_session_from_handle(params->session)->host_session, params->colorSpaceCapacityInput, params->colorSpaceCountOutput, params->colorSpaces);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateDisplayRefreshRatesFB(void *args)
+{
+    struct xrEnumerateDisplayRefreshRatesFB_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->session, params->displayRefreshRateCapacityInput, params->displayRefreshRateCountOutput, params->displayRefreshRates);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateDisplayRefreshRatesFB(wine_session_from_handle(params->session)->host_session, params->displayRefreshRateCapacityInput, params->displayRefreshRateCountOutput, params->displayRefreshRates);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateEnvironmentBlendModes(void *args)
+{
+    struct xrEnumerateEnvironmentBlendModes_params *params = args;
+
+    TRACE("%p, 0x%s, %#x, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->viewConfigurationType, params->environmentBlendModeCapacityInput, params->environmentBlendModeCountOutput, params->environmentBlendModes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateEnvironmentBlendModes(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->viewConfigurationType, params->environmentBlendModeCapacityInput, params->environmentBlendModeCountOutput, params->environmentBlendModes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateEnvironmentDepthSwapchainImagesMETA(void *args)
+{
+    struct xrEnumerateEnvironmentDepthSwapchainImagesMETA_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->swapchain, params->imageCapacityInput, params->imageCountOutput, params->images);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateEnvironmentDepthSwapchainImagesMETA(params->swapchain, params->imageCapacityInput, params->imageCountOutput, params->images);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateExternalCamerasOCULUS(void *args)
+{
+    struct xrEnumerateExternalCamerasOCULUS_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->session, params->cameraCapacityInput, params->cameraCountOutput, params->cameras);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateExternalCamerasOCULUS(wine_session_from_handle(params->session)->host_session, params->cameraCapacityInput, params->cameraCountOutput, params->cameras);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateInstanceExtensionProperties(void *args)
+{
+    struct xrEnumerateInstanceExtensionProperties_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->layerName, params->propertyCapacityInput, params->propertyCountOutput, params->properties);
+
+    params->result = wine_xrEnumerateInstanceExtensionProperties(params->layerName, params->propertyCapacityInput, params->propertyCountOutput, params->properties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateInteractionRenderModelIdsEXT(void *args)
+{
+    struct xrEnumerateInteractionRenderModelIdsEXT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->session, params->getInfo, params->renderModelIdCapacityInput, params->renderModelIdCountOutput, params->renderModelIds);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateInteractionRenderModelIdsEXT(wine_session_from_handle(params->session)->host_session, params->getInfo, params->renderModelIdCapacityInput, params->renderModelIdCountOutput, params->renderModelIds);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumeratePerformanceMetricsCounterPathsMETA(void *args)
+{
+    struct xrEnumeratePerformanceMetricsCounterPathsMETA_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->instance, params->counterPathCapacityInput, params->counterPathCountOutput, params->counterPaths);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumeratePerformanceMetricsCounterPathsMETA(wine_instance_from_handle(params->instance)->host_instance, params->counterPathCapacityInput, params->counterPathCountOutput, params->counterPaths);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumeratePersistedAnchorsANDROID(void *args)
+{
+    struct xrEnumeratePersistedAnchorsANDROID_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->handle, params->anchorIdCapacityInput, params->anchorIdCountOutput, params->anchorIds);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumeratePersistedAnchorsANDROID(params->handle, params->anchorIdCapacityInput, params->anchorIdCountOutput, params->anchorIds);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumeratePersistedSpatialAnchorNamesMSFT(void *args)
+{
+    struct xrEnumeratePersistedSpatialAnchorNamesMSFT_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->spatialAnchorStore, params->spatialAnchorNameCapacityInput, params->spatialAnchorNameCountOutput, params->spatialAnchorNames);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumeratePersistedSpatialAnchorNamesMSFT(params->spatialAnchorStore, params->spatialAnchorNameCapacityInput, params->spatialAnchorNameCountOutput, params->spatialAnchorNames);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateRaycastSupportedTrackableTypesANDROID(void *args)
+{
+    struct xrEnumerateRaycastSupportedTrackableTypesANDROID_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->trackableTypeCapacityInput, params->trackableTypeCountOutput, params->trackableTypes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateRaycastSupportedTrackableTypesANDROID(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->trackableTypeCapacityInput, params->trackableTypeCountOutput, params->trackableTypes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateReferenceSpaces(void *args)
+{
+    struct xrEnumerateReferenceSpaces_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->session, params->spaceCapacityInput, params->spaceCountOutput, params->spaces);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateReferenceSpaces(wine_session_from_handle(params->session)->host_session, params->spaceCapacityInput, params->spaceCountOutput, params->spaces);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateRenderModelPathsFB(void *args)
+{
+    struct xrEnumerateRenderModelPathsFB_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->session, params->pathCapacityInput, params->pathCountOutput, params->paths);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateRenderModelPathsFB(wine_session_from_handle(params->session)->host_session, params->pathCapacityInput, params->pathCountOutput, params->paths);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateRenderModelSubactionPathsEXT(void *args)
+{
+    struct xrEnumerateRenderModelSubactionPathsEXT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->renderModel, params->info, params->pathCapacityInput, params->pathCountOutput, params->paths);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateRenderModelSubactionPathsEXT(params->renderModel, params->info, params->pathCapacityInput, params->pathCountOutput, params->paths);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateReprojectionModesMSFT(void *args)
+{
+    struct xrEnumerateReprojectionModesMSFT_params *params = args;
+
+    TRACE("%p, 0x%s, %#x, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->viewConfigurationType, params->modeCapacityInput, params->modeCountOutput, params->modes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateReprojectionModesMSFT(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->viewConfigurationType, params->modeCapacityInput, params->modeCountOutput, params->modes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSceneComputeFeaturesMSFT(void *args)
+{
+    struct xrEnumerateSceneComputeFeaturesMSFT_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->featureCapacityInput, params->featureCountOutput, params->features);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSceneComputeFeaturesMSFT(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->featureCapacityInput, params->featureCountOutput, params->features);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSpaceSupportedComponentsFB(void *args)
+{
+    struct xrEnumerateSpaceSupportedComponentsFB_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->space, params->componentTypeCapacityInput, params->componentTypeCountOutput, params->componentTypes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSpaceSupportedComponentsFB(params->space, params->componentTypeCapacityInput, params->componentTypeCountOutput, params->componentTypes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSpatialCapabilitiesEXT(void *args)
+{
+    struct xrEnumerateSpatialCapabilitiesEXT_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->capabilityCapacityInput, params->capabilityCountOutput, params->capabilities);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSpatialCapabilitiesEXT(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->capabilityCapacityInput, params->capabilityCountOutput, params->capabilities);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSpatialCapabilityComponentTypesEXT(void *args)
+{
+    struct xrEnumerateSpatialCapabilityComponentTypesEXT_params *params = args;
+
+    TRACE("%p, 0x%s, %#x, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->capability, params->capabilityComponents);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSpatialCapabilityComponentTypesEXT(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->capability, params->capabilityComponents);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSpatialCapabilityFeaturesEXT(void *args)
+{
+    struct xrEnumerateSpatialCapabilityFeaturesEXT_params *params = args;
+
+    TRACE("%p, 0x%s, %#x, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->capability, params->capabilityFeatureCapacityInput, params->capabilityFeatureCountOutput, params->capabilityFeatures);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSpatialCapabilityFeaturesEXT(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->capability, params->capabilityFeatureCapacityInput, params->capabilityFeatureCountOutput, params->capabilityFeatures);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSpatialEntityComponentTypesBD(void *args)
+{
+    struct xrEnumerateSpatialEntityComponentTypesBD_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->snapshot, wine_dbgstr_longlong(params->entityId), params->componentTypeCapacityInput, params->componentTypeCountOutput, params->componentTypes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSpatialEntityComponentTypesBD(params->snapshot, params->entityId, params->componentTypeCapacityInput, params->componentTypeCountOutput, params->componentTypes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSpatialPersistenceScopesEXT(void *args)
+{
+    struct xrEnumerateSpatialPersistenceScopesEXT_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->persistenceScopeCapacityInput, params->persistenceScopeCountOutput, params->persistenceScopes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSpatialPersistenceScopesEXT(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->persistenceScopeCapacityInput, params->persistenceScopeCountOutput, params->persistenceScopes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSupportedAnchorTrackableTypesANDROID(void *args)
+{
+    struct xrEnumerateSupportedAnchorTrackableTypesANDROID_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->trackableTypeCapacityInput, params->trackableTypeCountOutput, params->trackableTypes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSupportedAnchorTrackableTypesANDROID(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->trackableTypeCapacityInput, params->trackableTypeCountOutput, params->trackableTypes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSupportedPersistenceAnchorTypesANDROID(void *args)
+{
+    struct xrEnumerateSupportedPersistenceAnchorTypesANDROID_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->trackableTypeCapacityInput, params->trackableTypeCountOutput, params->trackableTypes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSupportedPersistenceAnchorTypesANDROID(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->trackableTypeCapacityInput, params->trackableTypeCountOutput, params->trackableTypes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSupportedTrackableTypesANDROID(void *args)
+{
+    struct xrEnumerateSupportedTrackableTypesANDROID_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->trackableTypeCapacityInput, params->trackableTypeCountOutput, params->trackableTypes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSupportedTrackableTypesANDROID(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->trackableTypeCapacityInput, params->trackableTypeCountOutput, params->trackableTypes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSwapchainFormats(void *args)
+{
+    struct xrEnumerateSwapchainFormats_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->session, params->formatCapacityInput, params->formatCountOutput, params->formats);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSwapchainFormats(wine_session_from_handle(params->session)->host_session, params->formatCapacityInput, params->formatCountOutput, params->formats);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateSwapchainImages(void *args)
+{
+    struct xrEnumerateSwapchainImages_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->swapchain, params->imageCapacityInput, params->imageCountOutput, params->images);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateSwapchainImages(wine_swapchain_from_handle(params->swapchain)->host_swapchain, params->imageCapacityInput, params->imageCountOutput, params->images);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateViewConfigurationViews(void *args)
+{
+    struct xrEnumerateViewConfigurationViews_params *params = args;
+
+    TRACE("%p, 0x%s, %#x, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->viewConfigurationType, params->viewCapacityInput, params->viewCountOutput, params->views);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateViewConfigurationViews(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->viewConfigurationType, params->viewCapacityInput, params->viewCountOutput, params->views);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateViewConfigurations(void *args)
+{
+    struct xrEnumerateViewConfigurations_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->viewConfigurationTypeCapacityInput, params->viewConfigurationTypeCountOutput, params->viewConfigurationTypes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateViewConfigurations(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->viewConfigurationTypeCapacityInput, params->viewConfigurationTypeCountOutput, params->viewConfigurationTypes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEnumerateViveTrackerPathsHTCX(void *args)
+{
+    struct xrEnumerateViveTrackerPathsHTCX_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->instance, params->pathCapacityInput, params->pathCountOutput, params->paths);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEnumerateViveTrackerPathsHTCX(wine_instance_from_handle(params->instance)->host_instance, params->pathCapacityInput, params->pathCountOutput, params->paths);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEraseSpaceFB(void *args)
+{
+    struct xrEraseSpaceFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEraseSpaceFB(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrEraseSpacesMETA(void *args)
+{
+    struct xrEraseSpacesMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrEraseSpacesMETA(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrFreeWorldMeshBufferML(void *args)
+{
+    struct xrFreeWorldMeshBufferML_params *params = args;
+
+    TRACE("%p, %p\n", params->detector, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrFreeWorldMeshBufferML(params->detector, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGeometryInstanceSetTransformFB(void *args)
+{
+    struct xrGeometryInstanceSetTransformFB_params *params = args;
+
+    TRACE("%p, %p\n", params->instance, params->transformation);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGeometryInstanceSetTransformFB(params->instance, params->transformation);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetActionStateBoolean(void *args)
+{
+    struct xrGetActionStateBoolean_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->getInfo, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetActionStateBoolean(wine_session_from_handle(params->session)->host_session, params->getInfo, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetActionStateFloat(void *args)
+{
+    struct xrGetActionStateFloat_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->getInfo, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetActionStateFloat(wine_session_from_handle(params->session)->host_session, params->getInfo, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetActionStatePose(void *args)
+{
+    struct xrGetActionStatePose_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->getInfo, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetActionStatePose(wine_session_from_handle(params->session)->host_session, params->getInfo, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetActionStateVector2f(void *args)
+{
+    struct xrGetActionStateVector2f_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->getInfo, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetActionStateVector2f(wine_session_from_handle(params->session)->host_session, params->getInfo, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetAllTrackablesANDROID(void *args)
+{
+    struct xrGetAllTrackablesANDROID_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->trackableTracker, params->trackableCapacityInput, params->trackableCountOutput, params->trackables);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetAllTrackablesANDROID(params->trackableTracker, params->trackableCapacityInput, params->trackableCountOutput, params->trackables);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetAnchorPersistStateANDROID(void *args)
+{
+    struct xrGetAnchorPersistStateANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->handle, params->anchorId, params->persistState);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetAnchorPersistStateANDROID(params->handle, params->anchorId, params->persistState);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetAnchorUuidBD(void *args)
+{
+    struct xrGetAnchorUuidBD_params *params = args;
+
+    TRACE("%p, %p\n", params->anchor, params->uuid);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetAnchorUuidBD(params->anchor, params->uuid);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetAudioInputDeviceGuidOculus(void *args)
+{
+    struct xrGetAudioInputDeviceGuidOculus_params *params = args;
+
+    TRACE("%p, %p\n", params->instance, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetAudioInputDeviceGuidOculus(wine_instance_from_handle(params->instance)->host_instance, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetAudioOutputDeviceGuidOculus(void *args)
+{
+    struct xrGetAudioOutputDeviceGuidOculus_params *params = args;
+
+    TRACE("%p, %p\n", params->instance, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetAudioOutputDeviceGuidOculus(wine_instance_from_handle(params->instance)->host_instance, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetBodySkeletonFB(void *args)
+{
+    struct xrGetBodySkeletonFB_params *params = args;
+
+    TRACE("%p, %p\n", params->bodyTracker, params->skeleton);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetBodySkeletonFB(params->bodyTracker, params->skeleton);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetBodySkeletonHTC(void *args)
+{
+    struct xrGetBodySkeletonHTC_params *params = args;
+
+    TRACE("%p, %p, %u, %p\n", params->bodyTracker, params->baseSpace, params->skeletonGenerationId, params->skeleton);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetBodySkeletonHTC(params->bodyTracker, params->baseSpace, params->skeletonGenerationId, params->skeleton);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetControllerModelKeyMSFT(void *args)
+{
+    struct xrGetControllerModelKeyMSFT_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->session, wine_dbgstr_longlong(params->topLevelUserPath), params->controllerModelKeyState);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetControllerModelKeyMSFT(wine_session_from_handle(params->session)->host_session, params->topLevelUserPath, params->controllerModelKeyState);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetControllerModelPropertiesMSFT(void *args)
+{
+    struct xrGetControllerModelPropertiesMSFT_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->session, wine_dbgstr_longlong(params->modelKey), params->properties);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetControllerModelPropertiesMSFT(wine_session_from_handle(params->session)->host_session, params->modelKey, params->properties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetControllerModelStateMSFT(void *args)
+{
+    struct xrGetControllerModelStateMSFT_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->session, wine_dbgstr_longlong(params->modelKey), params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetControllerModelStateMSFT(wine_session_from_handle(params->session)->host_session, params->modelKey, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetCurrentInteractionProfile(void *args)
+{
+    struct xrGetCurrentInteractionProfile_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->session, wine_dbgstr_longlong(params->topLevelUserPath), params->interactionProfile);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetCurrentInteractionProfile(wine_session_from_handle(params->session)->host_session, params->topLevelUserPath, params->interactionProfile);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetDeviceSampleRateFB(void *args)
+{
+    struct xrGetDeviceSampleRateFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->hapticActionInfo, params->deviceSampleRate);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetDeviceSampleRateFB(wine_session_from_handle(params->session)->host_session, params->hapticActionInfo, params->deviceSampleRate);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetDisplayRefreshRateFB(void *args)
+{
+    struct xrGetDisplayRefreshRateFB_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->displayRefreshRate);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetDisplayRefreshRateFB(wine_session_from_handle(params->session)->host_session, params->displayRefreshRate);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetEnvironmentDepthSwapchainStateMETA(void *args)
+{
+    struct xrGetEnvironmentDepthSwapchainStateMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->swapchain, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetEnvironmentDepthSwapchainStateMETA(params->swapchain, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetExportedLocalizationMapDataML(void *args)
+{
+    struct xrGetExportedLocalizationMapDataML_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->map, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetExportedLocalizationMapDataML(params->map, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetEyeGazesFB(void *args)
+{
+    struct xrGetEyeGazesFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->eyeTracker, params->gazeInfo, params->eyeGazes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetEyeGazesFB(params->eyeTracker, params->gazeInfo, params->eyeGazes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetFaceExpressionWeights2FB(void *args)
+{
+    struct xrGetFaceExpressionWeights2FB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->faceTracker, params->expressionInfo, params->expressionWeights);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetFaceExpressionWeights2FB(params->faceTracker, params->expressionInfo, params->expressionWeights);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetFaceExpressionWeightsFB(void *args)
+{
+    struct xrGetFaceExpressionWeightsFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->faceTracker, params->expressionInfo, params->expressionWeights);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetFaceExpressionWeightsFB(params->faceTracker, params->expressionInfo, params->expressionWeights);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetFacialExpressionBlendShapePropertiesML(void *args)
+{
+    struct xrGetFacialExpressionBlendShapePropertiesML_params *params = args;
+
+    TRACE("%p, %p, %u, %p\n", params->facialExpressionClient, params->blendShapeGetInfo, params->blendShapeCount, params->blendShapes);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetFacialExpressionBlendShapePropertiesML(params->facialExpressionClient, params->blendShapeGetInfo, params->blendShapeCount, params->blendShapes);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetFacialExpressionsHTC(void *args)
+{
+    struct xrGetFacialExpressionsHTC_params *params = args;
+
+    TRACE("%p, %p\n", params->facialTracker, params->facialExpressions);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetFacialExpressionsHTC(params->facialTracker, params->facialExpressions);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetFoveationEyeTrackedStateMETA(void *args)
+{
+    struct xrGetFoveationEyeTrackedStateMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->foveationState);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetFoveationEyeTrackedStateMETA(wine_session_from_handle(params->session)->host_session, params->foveationState);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetHandMeshFB(void *args)
+{
+    struct xrGetHandMeshFB_params *params = args;
+
+    TRACE("%p, %p\n", params->handTracker, params->mesh);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetHandMeshFB(params->handTracker, params->mesh);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetInputSourceLocalizedName(void *args)
+{
+    struct xrGetInputSourceLocalizedName_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->session, params->getInfo, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetInputSourceLocalizedName(wine_session_from_handle(params->session)->host_session, params->getInfo, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetInstanceProperties(void *args)
+{
+    struct xrGetInstanceProperties_params *params = args;
+
+    TRACE("%p, %p\n", params->instance, params->instanceProperties);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetInstanceProperties(wine_instance_from_handle(params->instance)->host_instance, params->instanceProperties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetMarkerDetectorStateML(void *args)
+{
+    struct xrGetMarkerDetectorStateML_params *params = args;
+
+    TRACE("%p, %p\n", params->markerDetector, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetMarkerDetectorStateML(params->markerDetector, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetMarkerLengthML(void *args)
+{
+    struct xrGetMarkerLengthML_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->markerDetector, wine_dbgstr_longlong(params->marker), params->meters);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetMarkerLengthML(params->markerDetector, params->marker, params->meters);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetMarkerNumberML(void *args)
+{
+    struct xrGetMarkerNumberML_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->markerDetector, wine_dbgstr_longlong(params->marker), params->number);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetMarkerNumberML(params->markerDetector, params->marker, params->number);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetMarkerReprojectionErrorML(void *args)
+{
+    struct xrGetMarkerReprojectionErrorML_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->markerDetector, wine_dbgstr_longlong(params->marker), params->reprojectionErrorMeters);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetMarkerReprojectionErrorML(params->markerDetector, params->marker, params->reprojectionErrorMeters);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetMarkerSizeVARJO(void *args)
+{
+    struct xrGetMarkerSizeVARJO_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->session, wine_dbgstr_longlong(params->markerId), params->size);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetMarkerSizeVARJO(wine_session_from_handle(params->session)->host_session, params->markerId, params->size);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetMarkerStringML(void *args)
+{
+    struct xrGetMarkerStringML_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->markerDetector, wine_dbgstr_longlong(params->marker), params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetMarkerStringML(params->markerDetector, params->marker, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetMarkersML(void *args)
+{
+    struct xrGetMarkersML_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->markerDetector, params->markerCapacityInput, params->markerCountOutput, params->markers);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetMarkersML(params->markerDetector, params->markerCapacityInput, params->markerCountOutput, params->markers);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetOpenGLGraphicsRequirementsKHR(void *args)
+{
+    struct xrGetOpenGLGraphicsRequirementsKHR_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->graphicsRequirements);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetOpenGLGraphicsRequirementsKHR(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->graphicsRequirements);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetPassthroughCameraStateANDROID(void *args)
+{
+    struct xrGetPassthroughCameraStateANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->getInfo, params->cameraStateOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetPassthroughCameraStateANDROID(wine_session_from_handle(params->session)->host_session, params->getInfo, params->cameraStateOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetPassthroughPreferencesMETA(void *args)
+{
+    struct xrGetPassthroughPreferencesMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->preferences);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetPassthroughPreferencesMETA(wine_session_from_handle(params->session)->host_session, params->preferences);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetPerformanceMetricsStateMETA(void *args)
+{
+    struct xrGetPerformanceMetricsStateMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetPerformanceMetricsStateMETA(wine_session_from_handle(params->session)->host_session, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetPlaneDetectionStateEXT(void *args)
+{
+    struct xrGetPlaneDetectionStateEXT_params *params = args;
+
+    TRACE("%p, %p\n", params->planeDetector, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetPlaneDetectionStateEXT(params->planeDetector, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetPlaneDetectionsEXT(void *args)
+{
+    struct xrGetPlaneDetectionsEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->planeDetector, params->info, params->locations);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetPlaneDetectionsEXT(params->planeDetector, params->info, params->locations);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetPlanePolygonBufferEXT(void *args)
+{
+    struct xrGetPlanePolygonBufferEXT_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p\n", params->planeDetector, wine_dbgstr_longlong(params->planeId), params->polygonBufferIndex, params->polygonBuffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetPlanePolygonBufferEXT(params->planeDetector, params->planeId, params->polygonBufferIndex, params->polygonBuffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetQueriedSenseDataBD(void *args)
+{
+    struct xrGetQueriedSenseDataBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->snapshot, params->getInfo, params->queriedSenseData);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetQueriedSenseDataBD(params->snapshot, params->getInfo, params->queriedSenseData);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetRecommendedLayerResolutionMETA(void *args)
+{
+    struct xrGetRecommendedLayerResolutionMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->resolution);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetRecommendedLayerResolutionMETA(wine_session_from_handle(params->session)->host_session, params->info, params->resolution);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetReferenceSpaceBoundsRect(void *args)
+{
+    struct xrGetReferenceSpaceBoundsRect_params *params = args;
+
+    TRACE("%p, %#x, %p\n", params->session, params->referenceSpaceType, params->bounds);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetReferenceSpaceBoundsRect(wine_session_from_handle(params->session)->host_session, params->referenceSpaceType, params->bounds);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetRenderModelAssetDataEXT(void *args)
+{
+    struct xrGetRenderModelAssetDataEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->asset, params->getInfo, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetRenderModelAssetDataEXT(params->asset, params->getInfo, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetRenderModelAssetPropertiesEXT(void *args)
+{
+    struct xrGetRenderModelAssetPropertiesEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->asset, params->getInfo, params->properties);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetRenderModelAssetPropertiesEXT(params->asset, params->getInfo, params->properties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetRenderModelPoseTopLevelUserPathEXT(void *args)
+{
+    struct xrGetRenderModelPoseTopLevelUserPathEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->renderModel, params->info, params->topLevelUserPath);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetRenderModelPoseTopLevelUserPathEXT(params->renderModel, params->info, params->topLevelUserPath);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetRenderModelPropertiesEXT(void *args)
+{
+    struct xrGetRenderModelPropertiesEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->renderModel, params->getInfo, params->properties);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetRenderModelPropertiesEXT(params->renderModel, params->getInfo, params->properties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetRenderModelPropertiesFB(void *args)
+{
+    struct xrGetRenderModelPropertiesFB_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->session, wine_dbgstr_longlong(params->path), params->properties);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetRenderModelPropertiesFB(wine_session_from_handle(params->session)->host_session, params->path, params->properties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetRenderModelStateEXT(void *args)
+{
+    struct xrGetRenderModelStateEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->renderModel, params->getInfo, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetRenderModelStateEXT(params->renderModel, params->getInfo, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSceneComponentsMSFT(void *args)
+{
+    struct xrGetSceneComponentsMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->scene, params->getInfo, params->components);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSceneComponentsMSFT(params->scene, params->getInfo, params->components);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSceneComputeStateMSFT(void *args)
+{
+    struct xrGetSceneComputeStateMSFT_params *params = args;
+
+    TRACE("%p, %p\n", params->sceneObserver, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSceneComputeStateMSFT(params->sceneObserver, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSceneMarkerDecodedStringMSFT(void *args)
+{
+    struct xrGetSceneMarkerDecodedStringMSFT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->scene, params->markerId, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSceneMarkerDecodedStringMSFT(params->scene, params->markerId, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSceneMarkerRawDataMSFT(void *args)
+{
+    struct xrGetSceneMarkerRawDataMSFT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->scene, params->markerId, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSceneMarkerRawDataMSFT(params->scene, params->markerId, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSceneMeshBuffersMSFT(void *args)
+{
+    struct xrGetSceneMeshBuffersMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->scene, params->getInfo, params->buffers);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSceneMeshBuffersMSFT(params->scene, params->getInfo, params->buffers);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSenseDataProviderStateBD(void *args)
+{
+    struct xrGetSenseDataProviderStateBD_params *params = args;
+
+    TRACE("%p, %p\n", params->provider, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSenseDataProviderStateBD(params->provider, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSerializedSceneFragmentDataMSFT(void *args)
+{
+    struct xrGetSerializedSceneFragmentDataMSFT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->scene, params->getInfo, params->countInput, params->readOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSerializedSceneFragmentDataMSFT(params->scene, params->getInfo, params->countInput, params->readOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpaceBoundary2DFB(void *args)
+{
+    struct xrGetSpaceBoundary2DFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->space, params->boundary2DOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpaceBoundary2DFB(wine_session_from_handle(params->session)->host_session, params->space, params->boundary2DOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpaceBoundingBox2DFB(void *args)
+{
+    struct xrGetSpaceBoundingBox2DFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->space, params->boundingBox2DOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpaceBoundingBox2DFB(wine_session_from_handle(params->session)->host_session, params->space, params->boundingBox2DOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpaceBoundingBox3DFB(void *args)
+{
+    struct xrGetSpaceBoundingBox3DFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->space, params->boundingBox3DOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpaceBoundingBox3DFB(wine_session_from_handle(params->session)->host_session, params->space, params->boundingBox3DOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpaceComponentStatusFB(void *args)
+{
+    struct xrGetSpaceComponentStatusFB_params *params = args;
+
+    TRACE("%p, %#x, %p\n", params->space, params->componentType, params->status);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpaceComponentStatusFB(params->space, params->componentType, params->status);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpaceContainerFB(void *args)
+{
+    struct xrGetSpaceContainerFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->space, params->spaceContainerOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpaceContainerFB(wine_session_from_handle(params->session)->host_session, params->space, params->spaceContainerOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpaceRoomLayoutFB(void *args)
+{
+    struct xrGetSpaceRoomLayoutFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->space, params->roomLayoutOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpaceRoomLayoutFB(wine_session_from_handle(params->session)->host_session, params->space, params->roomLayoutOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpaceSemanticLabelsFB(void *args)
+{
+    struct xrGetSpaceSemanticLabelsFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->space, params->semanticLabelsOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpaceSemanticLabelsFB(wine_session_from_handle(params->session)->host_session, params->space, params->semanticLabelsOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpaceTriangleMeshMETA(void *args)
+{
+    struct xrGetSpaceTriangleMeshMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->space, params->getInfo, params->triangleMeshOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpaceTriangleMeshMETA(params->space, params->getInfo, params->triangleMeshOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpaceUserIdFB(void *args)
+{
+    struct xrGetSpaceUserIdFB_params *params = args;
+
+    TRACE("%p, %p\n", params->user, params->userId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpaceUserIdFB(params->user, params->userId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpaceUuidFB(void *args)
+{
+    struct xrGetSpaceUuidFB_params *params = args;
+
+    TRACE("%p, %p\n", params->space, params->uuid);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpaceUuidFB(params->space, params->uuid);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialAnchorNameHTC(void *args)
+{
+    struct xrGetSpatialAnchorNameHTC_params *params = args;
+
+    TRACE("%p, %p\n", params->anchor, params->name);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialAnchorNameHTC(params->anchor, params->name);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialAnchorStateML(void *args)
+{
+    struct xrGetSpatialAnchorStateML_params *params = args;
+
+    TRACE("%p, %p\n", params->anchor, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialAnchorStateML(params->anchor, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialBufferFloatEXT(void *args)
+{
+    struct xrGetSpatialBufferFloatEXT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialBufferFloatEXT(params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialBufferStringEXT(void *args)
+{
+    struct xrGetSpatialBufferStringEXT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialBufferStringEXT(params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialBufferUint16EXT(void *args)
+{
+    struct xrGetSpatialBufferUint16EXT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialBufferUint16EXT(params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialBufferUint32EXT(void *args)
+{
+    struct xrGetSpatialBufferUint32EXT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialBufferUint32EXT(params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialBufferUint8EXT(void *args)
+{
+    struct xrGetSpatialBufferUint8EXT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialBufferUint8EXT(params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialBufferVector2fEXT(void *args)
+{
+    struct xrGetSpatialBufferVector2fEXT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialBufferVector2fEXT(params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialBufferVector3fEXT(void *args)
+{
+    struct xrGetSpatialBufferVector3fEXT_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialBufferVector3fEXT(params->snapshot, params->info, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialEntityComponentDataBD(void *args)
+{
+    struct xrGetSpatialEntityComponentDataBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->snapshot, params->getInfo, params->componentData);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialEntityComponentDataBD(params->snapshot, params->getInfo, params->componentData);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialEntityUuidBD(void *args)
+{
+    struct xrGetSpatialEntityUuidBD_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->snapshot, wine_dbgstr_longlong(params->entityId), params->uuid);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialEntityUuidBD(params->snapshot, params->entityId, params->uuid);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSpatialGraphNodeBindingPropertiesMSFT(void *args)
+{
+    struct xrGetSpatialGraphNodeBindingPropertiesMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->nodeBinding, params->getInfo, params->properties);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSpatialGraphNodeBindingPropertiesMSFT(params->nodeBinding, params->getInfo, params->properties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSwapchainStateFB(void *args)
+{
+    struct xrGetSwapchainStateFB_params *params = args;
+
+    TRACE("%p, %p\n", params->swapchain, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSwapchainStateFB(wine_swapchain_from_handle(params->swapchain)->host_swapchain, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSystem(void *args)
+{
+    struct xrGetSystem_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->instance, params->getInfo, params->systemId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSystem(wine_instance_from_handle(params->instance)->host_instance, params->getInfo, params->systemId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetSystemProperties(void *args)
+{
+    struct xrGetSystemProperties_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->properties);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetSystemProperties(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->properties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetTrackableMarkerANDROID(void *args)
+{
+    struct xrGetTrackableMarkerANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->tracker, params->getInfo, params->markerOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetTrackableMarkerANDROID(params->tracker, params->getInfo, params->markerOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetTrackableObjectANDROID(void *args)
+{
+    struct xrGetTrackableObjectANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->tracker, params->getInfo, params->objectOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetTrackableObjectANDROID(params->tracker, params->getInfo, params->objectOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetTrackablePlaneANDROID(void *args)
+{
+    struct xrGetTrackablePlaneANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->trackableTracker, params->getInfo, params->planeOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetTrackablePlaneANDROID(params->trackableTracker, params->getInfo, params->planeOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetViewConfigurationProperties(void *args)
+{
+    struct xrGetViewConfigurationProperties_params *params = args;
+
+    TRACE("%p, 0x%s, %#x, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->viewConfigurationType, params->configurationProperties);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetViewConfigurationProperties(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->viewConfigurationType, params->configurationProperties);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVirtualKeyboardDirtyTexturesMETA(void *args)
+{
+    struct xrGetVirtualKeyboardDirtyTexturesMETA_params *params = args;
+
+    TRACE("%p, %u, %p, %p\n", params->keyboard, params->textureIdCapacityInput, params->textureIdCountOutput, params->textureIds);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetVirtualKeyboardDirtyTexturesMETA(params->keyboard, params->textureIdCapacityInput, params->textureIdCountOutput, params->textureIds);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVirtualKeyboardModelAnimationStatesMETA(void *args)
+{
+    struct xrGetVirtualKeyboardModelAnimationStatesMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->keyboard, params->animationStates);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetVirtualKeyboardModelAnimationStatesMETA(params->keyboard, params->animationStates);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVirtualKeyboardScaleMETA(void *args)
+{
+    struct xrGetVirtualKeyboardScaleMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->keyboard, params->scale);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetVirtualKeyboardScaleMETA(params->keyboard, params->scale);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVirtualKeyboardTextureDataMETA(void *args)
+{
+    struct xrGetVirtualKeyboardTextureDataMETA_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->keyboard, wine_dbgstr_longlong(params->textureId), params->textureData);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetVirtualKeyboardTextureDataMETA(params->keyboard, params->textureId, params->textureData);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVisibilityMaskKHR(void *args)
+{
+    struct xrGetVisibilityMaskKHR_params *params = args;
+
+    TRACE("%p, %#x, %u, %#x, %p\n", params->session, params->viewConfigurationType, params->viewIndex, params->visibilityMaskType, params->visibilityMask);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetVisibilityMaskKHR(wine_session_from_handle(params->session)->host_session, params->viewConfigurationType, params->viewIndex, params->visibilityMaskType, params->visibilityMask);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVulkanDeviceExtensionsKHR(void *args)
+{
+    struct xrGetVulkanDeviceExtensionsKHR_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetVulkanDeviceExtensionsKHR(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVulkanGraphicsDevice2KHR(void *args)
+{
+    struct xrGetVulkanGraphicsDevice2KHR_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->instance, params->getInfo, params->vulkanPhysicalDevice);
+
+    params->result = wine_xrGetVulkanGraphicsDevice2KHR(params->instance, params->getInfo, params->vulkanPhysicalDevice);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVulkanGraphicsDeviceKHR(void *args)
+{
+    struct xrGetVulkanGraphicsDeviceKHR_params *params = args;
+
+    TRACE("%p, 0x%s, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->vkInstance, params->vkPhysicalDevice);
+
+    params->result = wine_xrGetVulkanGraphicsDeviceKHR(params->instance, params->systemId, params->vkInstance, params->vkPhysicalDevice);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVulkanGraphicsRequirements2KHR(void *args)
+{
+    struct xrGetVulkanGraphicsRequirements2KHR_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->graphicsRequirements);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetVulkanGraphicsRequirements2KHR(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->graphicsRequirements);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVulkanGraphicsRequirementsKHR(void *args)
+{
+    struct xrGetVulkanGraphicsRequirementsKHR_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->graphicsRequirements);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetVulkanGraphicsRequirementsKHR(wine_instance_from_handle(params->instance)->host_instance, params->systemId, params->graphicsRequirements);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetVulkanInstanceExtensionsKHR(void *args)
+{
+    struct xrGetVulkanInstanceExtensionsKHR_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->systemId), params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = wine_xrGetVulkanInstanceExtensionsKHR(params->instance, params->systemId, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrGetWorldMeshBufferRecommendSizeML(void *args)
+{
+    struct xrGetWorldMeshBufferRecommendSizeML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->detector, params->sizeInfo, params->size);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrGetWorldMeshBufferRecommendSizeML(params->detector, params->sizeInfo, params->size);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrImportLocalizationMapML(void *args)
+{
+    struct xrImportLocalizationMapML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->importInfo, params->mapUuid);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrImportLocalizationMapML(wine_session_from_handle(params->session)->host_session, params->importInfo, params->mapUuid);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLoadControllerModelMSFT(void *args)
+{
+    struct xrLoadControllerModelMSFT_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->session, wine_dbgstr_longlong(params->modelKey), params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLoadControllerModelMSFT(wine_session_from_handle(params->session)->host_session, params->modelKey, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLoadRenderModelFB(void *args)
+{
+    struct xrLoadRenderModelFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLoadRenderModelFB(wine_session_from_handle(params->session)->host_session, params->info, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLocateBodyJointsBD(void *args)
+{
+    struct xrLocateBodyJointsBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->bodyTracker, params->locateInfo, params->locations);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLocateBodyJointsBD(params->bodyTracker, params->locateInfo, params->locations);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLocateBodyJointsFB(void *args)
+{
+    struct xrLocateBodyJointsFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->bodyTracker, params->locateInfo, params->locations);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLocateBodyJointsFB(params->bodyTracker, params->locateInfo, params->locations);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLocateBodyJointsHTC(void *args)
+{
+    struct xrLocateBodyJointsHTC_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->bodyTracker, params->locateInfo, params->locations);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLocateBodyJointsHTC(params->bodyTracker, params->locateInfo, params->locations);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLocateHandJointsEXT(void *args)
+{
+    struct xrLocateHandJointsEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->handTracker, params->locateInfo, params->locations);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLocateHandJointsEXT(params->handTracker, params->locateInfo, params->locations);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLocateSceneComponentsMSFT(void *args)
+{
+    struct xrLocateSceneComponentsMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->scene, params->locateInfo, params->locations);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLocateSceneComponentsMSFT(params->scene, params->locateInfo, params->locations);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLocateSpace(void *args)
+{
+    struct xrLocateSpace_params *params = args;
+
+    TRACE("%p, %p, 0x%s, %p\n", params->space, params->baseSpace, wine_dbgstr_longlong(params->time), params->location);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLocateSpace(params->space, params->baseSpace, params->time, params->location);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLocateSpaces(void *args)
+{
+    struct xrLocateSpaces_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->locateInfo, params->spaceLocations);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLocateSpaces(wine_session_from_handle(params->session)->host_session, params->locateInfo, params->spaceLocations);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLocateSpacesKHR(void *args)
+{
+    struct xrLocateSpacesKHR_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->locateInfo, params->spaceLocations);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLocateSpacesKHR(wine_session_from_handle(params->session)->host_session, params->locateInfo, params->spaceLocations);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrLocateViews(void *args)
+{
+    struct xrLocateViews_params *params = args;
+
+    TRACE("%p, %p, %p, %u, %p, %p\n", params->session, params->viewLocateInfo, params->viewState, params->viewCapacityInput, params->viewCountOutput, params->views);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrLocateViews(wine_session_from_handle(params->session)->host_session, params->viewLocateInfo, params->viewState, params->viewCapacityInput, params->viewCountOutput, params->views);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPassthroughLayerPauseFB(void *args)
+{
+    struct xrPassthroughLayerPauseFB_params *params = args;
+
+    TRACE("%p\n", params->layer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPassthroughLayerPauseFB(params->layer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPassthroughLayerResumeFB(void *args)
+{
+    struct xrPassthroughLayerResumeFB_params *params = args;
+
+    TRACE("%p\n", params->layer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPassthroughLayerResumeFB(params->layer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPassthroughLayerSetKeyboardHandsIntensityFB(void *args)
+{
+    struct xrPassthroughLayerSetKeyboardHandsIntensityFB_params *params = args;
+
+    TRACE("%p, %p\n", params->layer, params->intensity);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPassthroughLayerSetKeyboardHandsIntensityFB(params->layer, params->intensity);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPassthroughLayerSetStyleFB(void *args)
+{
+    struct xrPassthroughLayerSetStyleFB_params *params = args;
+
+    TRACE("%p, %p\n", params->layer, params->style);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPassthroughLayerSetStyleFB(params->layer, params->style);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPassthroughPauseFB(void *args)
+{
+    struct xrPassthroughPauseFB_params *params = args;
+
+    TRACE("%p\n", params->passthrough);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPassthroughPauseFB(params->passthrough);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPassthroughStartFB(void *args)
+{
+    struct xrPassthroughStartFB_params *params = args;
+
+    TRACE("%p\n", params->passthrough);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPassthroughStartFB(params->passthrough);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPathToString(void *args)
+{
+    struct xrPathToString_params *params = args;
+
+    TRACE("%p, 0x%s, %u, %p, %p\n", params->instance, wine_dbgstr_longlong(params->path), params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPathToString(wine_instance_from_handle(params->instance)->host_instance, params->path, params->bufferCapacityInput, params->bufferCountOutput, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPauseSimultaneousHandsAndControllersTrackingMETA(void *args)
+{
+    struct xrPauseSimultaneousHandsAndControllersTrackingMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->pauseInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPauseSimultaneousHandsAndControllersTrackingMETA(wine_session_from_handle(params->session)->host_session, params->pauseInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPerfSettingsSetPerformanceLevelEXT(void *args)
+{
+    struct xrPerfSettingsSetPerformanceLevelEXT_params *params = args;
+
+    TRACE("%p, %#x, %#x\n", params->session, params->domain, params->level);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPerfSettingsSetPerformanceLevelEXT(wine_session_from_handle(params->session)->host_session, params->domain, params->level);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPersistAnchorANDROID(void *args)
+{
+    struct xrPersistAnchorANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->handle, params->persistedInfo, params->anchorIdOutput);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPersistAnchorANDROID(params->handle, params->persistedInfo, params->anchorIdOutput);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPersistSpatialAnchorAsyncBD(void *args)
+{
+    struct xrPersistSpatialAnchorAsyncBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->info, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPersistSpatialAnchorAsyncBD(params->provider, params->info, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPersistSpatialAnchorCompleteBD(void *args)
+{
+    struct xrPersistSpatialAnchorCompleteBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPersistSpatialAnchorCompleteBD(params->provider, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPersistSpatialAnchorMSFT(void *args)
+{
+    struct xrPersistSpatialAnchorMSFT_params *params = args;
+
+    TRACE("%p, %p\n", params->spatialAnchorStore, params->spatialAnchorPersistenceInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPersistSpatialAnchorMSFT(params->spatialAnchorStore, params->spatialAnchorPersistenceInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPersistSpatialEntityAsyncEXT(void *args)
+{
+    struct xrPersistSpatialEntityAsyncEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->persistenceContext, params->persistInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPersistSpatialEntityAsyncEXT(params->persistenceContext, params->persistInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPersistSpatialEntityCompleteEXT(void *args)
+{
+    struct xrPersistSpatialEntityCompleteEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->persistenceContext, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPersistSpatialEntityCompleteEXT(params->persistenceContext, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPollEvent(void *args)
+{
+    struct xrPollEvent_params *params = args;
+
+    TRACE("%p, %p\n", params->instance, params->eventData);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPollEvent(wine_instance_from_handle(params->instance)->host_instance, params->eventData);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPollFutureEXT(void *args)
+{
+    struct xrPollFutureEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->instance, params->pollInfo, params->pollResult);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPollFutureEXT(wine_instance_from_handle(params->instance)->host_instance, params->pollInfo, params->pollResult);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPublishSpatialAnchorsAsyncML(void *args)
+{
+    struct xrPublishSpatialAnchorsAsyncML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->storage, params->publishInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPublishSpatialAnchorsAsyncML(params->storage, params->publishInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrPublishSpatialAnchorsCompleteML(void *args)
+{
+    struct xrPublishSpatialAnchorsCompleteML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->storage, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrPublishSpatialAnchorsCompleteML(params->storage, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrQueryLocalizationMapsML(void *args)
+{
+    struct xrQueryLocalizationMapsML_params *params = args;
+
+    TRACE("%p, %p, %u, %p, %p\n", params->session, params->queryInfo, params->mapCapacityInput, params->mapCountOutput, params->maps);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrQueryLocalizationMapsML(wine_session_from_handle(params->session)->host_session, params->queryInfo, params->mapCapacityInput, params->mapCountOutput, params->maps);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrQueryPerformanceMetricsCounterMETA(void *args)
+{
+    struct xrQueryPerformanceMetricsCounterMETA_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->session, wine_dbgstr_longlong(params->counterPath), params->counter);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrQueryPerformanceMetricsCounterMETA(wine_session_from_handle(params->session)->host_session, params->counterPath, params->counter);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrQuerySenseDataAsyncBD(void *args)
+{
+    struct xrQuerySenseDataAsyncBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->queryInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrQuerySenseDataAsyncBD(params->provider, params->queryInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrQuerySenseDataCompleteBD(void *args)
+{
+    struct xrQuerySenseDataCompleteBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrQuerySenseDataCompleteBD(params->provider, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrQuerySpacesFB(void *args)
+{
+    struct xrQuerySpacesFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrQuerySpacesFB(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrQuerySpatialAnchorsAsyncML(void *args)
+{
+    struct xrQuerySpatialAnchorsAsyncML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->storage, params->queryInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrQuerySpatialAnchorsAsyncML(params->storage, params->queryInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrQuerySpatialAnchorsCompleteML(void *args)
+{
+    struct xrQuerySpatialAnchorsCompleteML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->storage, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrQuerySpatialAnchorsCompleteML(params->storage, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrQuerySpatialComponentDataEXT(void *args)
+{
+    struct xrQuerySpatialComponentDataEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->snapshot, params->queryCondition, params->queryResult);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrQuerySpatialComponentDataEXT(params->snapshot, params->queryCondition, params->queryResult);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrQuerySystemTrackedKeyboardFB(void *args)
+{
+    struct xrQuerySystemTrackedKeyboardFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->queryInfo, params->keyboard);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrQuerySystemTrackedKeyboardFB(wine_session_from_handle(params->session)->host_session, params->queryInfo, params->keyboard);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRaycastANDROID(void *args)
+{
+    struct xrRaycastANDROID_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->rayInfo, params->results);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRaycastANDROID(wine_session_from_handle(params->session)->host_session, params->rayInfo, params->results);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrReleaseSwapchainImage(void *args)
+{
+    struct xrReleaseSwapchainImage_params *params = args;
+
+    TRACE("%p, %p\n", params->swapchain, params->releaseInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrReleaseSwapchainImage(wine_swapchain_from_handle(params->swapchain)->host_swapchain, params->releaseInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRequestDisplayRefreshRateFB(void *args)
+{
+    struct xrRequestDisplayRefreshRateFB_params *params = args;
+
+    TRACE("%p, %f\n", params->session, params->displayRefreshRate);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRequestDisplayRefreshRateFB(wine_session_from_handle(params->session)->host_session, params->displayRefreshRate);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRequestExitSession(void *args)
+{
+    struct xrRequestExitSession_params *params = args;
+
+    TRACE("%p\n", params->session);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRequestExitSession(wine_session_from_handle(params->session)->host_session);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRequestMapLocalizationML(void *args)
+{
+    struct xrRequestMapLocalizationML_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->requestInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRequestMapLocalizationML(wine_session_from_handle(params->session)->host_session, params->requestInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRequestSceneCaptureFB(void *args)
+{
+    struct xrRequestSceneCaptureFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRequestSceneCaptureFB(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRequestWorldMeshAsyncML(void *args)
+{
+    struct xrRequestWorldMeshAsyncML_params *params = args;
+
+    TRACE("%p, %p, %p, %p\n", params->detector, params->getInfo, params->buffer, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRequestWorldMeshAsyncML(params->detector, params->getInfo, params->buffer, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRequestWorldMeshCompleteML(void *args)
+{
+    struct xrRequestWorldMeshCompleteML_params *params = args;
+
+    TRACE("%p, %p, %p, %p\n", params->detector, params->completionInfo, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRequestWorldMeshCompleteML(params->detector, params->completionInfo, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRequestWorldMeshStateAsyncML(void *args)
+{
+    struct xrRequestWorldMeshStateAsyncML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->detector, params->stateRequest, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRequestWorldMeshStateAsyncML(params->detector, params->stateRequest, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRequestWorldMeshStateCompleteML(void *args)
+{
+    struct xrRequestWorldMeshStateCompleteML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->detector, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRequestWorldMeshStateCompleteML(params->detector, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrResetBodyTrackingCalibrationMETA(void *args)
+{
+    struct xrResetBodyTrackingCalibrationMETA_params *params = args;
+
+    TRACE("%p\n", params->bodyTracker);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrResetBodyTrackingCalibrationMETA(params->bodyTracker);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrResultToString(void *args)
+{
+    struct xrResultToString_params *params = args;
+
+    TRACE("%p, %#x, %p\n", params->instance, params->value, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrResultToString(wine_instance_from_handle(params->instance)->host_instance, params->value, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrResumeSimultaneousHandsAndControllersTrackingMETA(void *args)
+{
+    struct xrResumeSimultaneousHandsAndControllersTrackingMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->resumeInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrResumeSimultaneousHandsAndControllersTrackingMETA(wine_session_from_handle(params->session)->host_session, params->resumeInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRetrieveSpaceDiscoveryResultsMETA(void *args)
+{
+    struct xrRetrieveSpaceDiscoveryResultsMETA_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->session, wine_dbgstr_longlong(params->requestId), params->results);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRetrieveSpaceDiscoveryResultsMETA(wine_session_from_handle(params->session)->host_session, params->requestId, params->results);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrRetrieveSpaceQueryResultsFB(void *args)
+{
+    struct xrRetrieveSpaceQueryResultsFB_params *params = args;
+
+    TRACE("%p, 0x%s, %p\n", params->session, wine_dbgstr_longlong(params->requestId), params->results);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrRetrieveSpaceQueryResultsFB(wine_session_from_handle(params->session)->host_session, params->requestId, params->results);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSaveSpaceFB(void *args)
+{
+    struct xrSaveSpaceFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSaveSpaceFB(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSaveSpaceListFB(void *args)
+{
+    struct xrSaveSpaceListFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSaveSpaceListFB(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSaveSpacesMETA(void *args)
+{
+    struct xrSaveSpacesMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSaveSpacesMETA(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSendVirtualKeyboardInputMETA(void *args)
+{
+    struct xrSendVirtualKeyboardInputMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->keyboard, params->info, params->interactorRootPose);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSendVirtualKeyboardInputMETA(params->keyboard, params->info, params->interactorRootPose);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetColorSpaceFB(void *args)
+{
+    struct xrSetColorSpaceFB_params *params = args;
+
+    TRACE("%p, %#x\n", params->session, params->colorSpace);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetColorSpaceFB(wine_session_from_handle(params->session)->host_session, params->colorSpace);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetDigitalLensControlALMALENCE(void *args)
+{
+    struct xrSetDigitalLensControlALMALENCE_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->digitalLensControl);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetDigitalLensControlALMALENCE(wine_session_from_handle(params->session)->host_session, params->digitalLensControl);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetEnvironmentDepthEstimationVARJO(void *args)
+{
+    struct xrSetEnvironmentDepthEstimationVARJO_params *params = args;
+
+    TRACE("%p, %u\n", params->session, params->enabled);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetEnvironmentDepthEstimationVARJO(wine_session_from_handle(params->session)->host_session, params->enabled);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetEnvironmentDepthHandRemovalMETA(void *args)
+{
+    struct xrSetEnvironmentDepthHandRemovalMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->environmentDepthProvider, params->setInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetEnvironmentDepthHandRemovalMETA(params->environmentDepthProvider, params->setInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetInputDeviceActiveEXT(void *args)
+{
+    struct xrSetInputDeviceActiveEXT_params *params = args;
+
+    TRACE("%p, 0x%s, 0x%s, %u\n", params->session, wine_dbgstr_longlong(params->interactionProfile), wine_dbgstr_longlong(params->topLevelPath), params->isActive);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetInputDeviceActiveEXT(wine_session_from_handle(params->session)->host_session, params->interactionProfile, params->topLevelPath, params->isActive);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetInputDeviceLocationEXT(void *args)
+{
+    struct xrSetInputDeviceLocationEXT_params *params = args;
+
+    TRACE("%p, 0x%s, 0x%s, %p, {{%f, %f, %f, %f}, {%f %f %f}}\n", params->session, wine_dbgstr_longlong(params->topLevelPath), wine_dbgstr_longlong(params->inputSourcePath), params->space, params->pose.orientation.x, params->pose.orientation.y, params->pose.orientation.z, params->pose.orientation.w, params->pose.position.x, params->pose.position.y, params->pose.position.z);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetInputDeviceLocationEXT(wine_session_from_handle(params->session)->host_session, params->topLevelPath, params->inputSourcePath, params->space, params->pose);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetInputDeviceStateBoolEXT(void *args)
+{
+    struct xrSetInputDeviceStateBoolEXT_params *params = args;
+
+    TRACE("%p, 0x%s, 0x%s, %u\n", params->session, wine_dbgstr_longlong(params->topLevelPath), wine_dbgstr_longlong(params->inputSourcePath), params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetInputDeviceStateBoolEXT(wine_session_from_handle(params->session)->host_session, params->topLevelPath, params->inputSourcePath, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetInputDeviceStateFloatEXT(void *args)
+{
+    struct xrSetInputDeviceStateFloatEXT_params *params = args;
+
+    TRACE("%p, 0x%s, 0x%s, %f\n", params->session, wine_dbgstr_longlong(params->topLevelPath), wine_dbgstr_longlong(params->inputSourcePath), params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetInputDeviceStateFloatEXT(wine_session_from_handle(params->session)->host_session, params->topLevelPath, params->inputSourcePath, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetInputDeviceStateVector2fEXT(void *args)
+{
+    struct xrSetInputDeviceStateVector2fEXT_params *params = args;
+
+    TRACE("%p, 0x%s, 0x%s, %f, %f\n", params->session, wine_dbgstr_longlong(params->topLevelPath), wine_dbgstr_longlong(params->inputSourcePath), params->state.x, params->state.y);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetInputDeviceStateVector2fEXT(wine_session_from_handle(params->session)->host_session, params->topLevelPath, params->inputSourcePath, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetMarkerTrackingPredictionVARJO(void *args)
+{
+    struct xrSetMarkerTrackingPredictionVARJO_params *params = args;
+
+    TRACE("%p, 0x%s, %u\n", params->session, wine_dbgstr_longlong(params->markerId), params->enable);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetMarkerTrackingPredictionVARJO(wine_session_from_handle(params->session)->host_session, params->markerId, params->enable);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetMarkerTrackingTimeoutVARJO(void *args)
+{
+    struct xrSetMarkerTrackingTimeoutVARJO_params *params = args;
+
+    TRACE("%p, 0x%s, 0x%s\n", params->session, wine_dbgstr_longlong(params->markerId), wine_dbgstr_longlong(params->timeout));
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetMarkerTrackingTimeoutVARJO(wine_session_from_handle(params->session)->host_session, params->markerId, params->timeout);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetMarkerTrackingVARJO(void *args)
+{
+    struct xrSetMarkerTrackingVARJO_params *params = args;
+
+    TRACE("%p, %u\n", params->session, params->enabled);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetMarkerTrackingVARJO(wine_session_from_handle(params->session)->host_session, params->enabled);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetPerformanceMetricsStateMETA(void *args)
+{
+    struct xrSetPerformanceMetricsStateMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetPerformanceMetricsStateMETA(wine_session_from_handle(params->session)->host_session, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetSpaceComponentStatusFB(void *args)
+{
+    struct xrSetSpaceComponentStatusFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->space, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetSpaceComponentStatusFB(params->space, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetSystemNotificationsML(void *args)
+{
+    struct xrSetSystemNotificationsML_params *params = args;
+
+    TRACE("%p, %p\n", params->instance, params->info);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetSystemNotificationsML(wine_instance_from_handle(params->instance)->host_instance, params->info);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetTrackingOptimizationSettingsHintQCOM(void *args)
+{
+    struct xrSetTrackingOptimizationSettingsHintQCOM_params *params = args;
+
+    TRACE("%p, %#x, %#x\n", params->session, params->domain, params->hint);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetTrackingOptimizationSettingsHintQCOM(wine_session_from_handle(params->session)->host_session, params->domain, params->hint);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetViewOffsetVARJO(void *args)
+{
+    struct xrSetViewOffsetVARJO_params *params = args;
+
+    TRACE("%p, %f\n", params->session, params->offset);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetViewOffsetVARJO(wine_session_from_handle(params->session)->host_session, params->offset);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSetVirtualKeyboardModelVisibilityMETA(void *args)
+{
+    struct xrSetVirtualKeyboardModelVisibilityMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->keyboard, params->modelVisibility);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSetVirtualKeyboardModelVisibilityMETA(params->keyboard, params->modelVisibility);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrShareSpacesFB(void *args)
+{
+    struct xrShareSpacesFB_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrShareSpacesFB(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrShareSpacesMETA(void *args)
+{
+    struct xrShareSpacesMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrShareSpacesMETA(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrShareSpatialAnchorAsyncBD(void *args)
+{
+    struct xrShareSpatialAnchorAsyncBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->info, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrShareSpatialAnchorAsyncBD(params->provider, params->info, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrShareSpatialAnchorCompleteBD(void *args)
+{
+    struct xrShareSpatialAnchorCompleteBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrShareSpatialAnchorCompleteBD(params->provider, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSnapshotMarkerDetectorML(void *args)
+{
+    struct xrSnapshotMarkerDetectorML_params *params = args;
+
+    TRACE("%p, %p\n", params->markerDetector, params->snapshotInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSnapshotMarkerDetectorML(params->markerDetector, params->snapshotInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStartColocationAdvertisementMETA(void *args)
+{
+    struct xrStartColocationAdvertisementMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->advertisementRequestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStartColocationAdvertisementMETA(wine_session_from_handle(params->session)->host_session, params->info, params->advertisementRequestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStartColocationDiscoveryMETA(void *args)
+{
+    struct xrStartColocationDiscoveryMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->discoveryRequestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStartColocationDiscoveryMETA(wine_session_from_handle(params->session)->host_session, params->info, params->discoveryRequestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStartEnvironmentDepthProviderMETA(void *args)
+{
+    struct xrStartEnvironmentDepthProviderMETA_params *params = args;
+
+    TRACE("%p\n", params->environmentDepthProvider);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStartEnvironmentDepthProviderMETA(params->environmentDepthProvider);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStartSenseDataProviderAsyncBD(void *args)
+{
+    struct xrStartSenseDataProviderAsyncBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->startInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStartSenseDataProviderAsyncBD(params->provider, params->startInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStartSenseDataProviderCompleteBD(void *args)
+{
+    struct xrStartSenseDataProviderCompleteBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStartSenseDataProviderCompleteBD(wine_session_from_handle(params->session)->host_session, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStopColocationAdvertisementMETA(void *args)
+{
+    struct xrStopColocationAdvertisementMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStopColocationAdvertisementMETA(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStopColocationDiscoveryMETA(void *args)
+{
+    struct xrStopColocationDiscoveryMETA_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->info, params->requestId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStopColocationDiscoveryMETA(wine_session_from_handle(params->session)->host_session, params->info, params->requestId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStopEnvironmentDepthProviderMETA(void *args)
+{
+    struct xrStopEnvironmentDepthProviderMETA_params *params = args;
+
+    TRACE("%p\n", params->environmentDepthProvider);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStopEnvironmentDepthProviderMETA(params->environmentDepthProvider);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStopHapticFeedback(void *args)
+{
+    struct xrStopHapticFeedback_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->hapticActionInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStopHapticFeedback(wine_session_from_handle(params->session)->host_session, params->hapticActionInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStopSenseDataProviderBD(void *args)
+{
+    struct xrStopSenseDataProviderBD_params *params = args;
+
+    TRACE("%p\n", params->provider);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStopSenseDataProviderBD(params->provider);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStringToPath(void *args)
+{
+    struct xrStringToPath_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->instance, params->pathString, params->path);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStringToPath(wine_instance_from_handle(params->instance)->host_instance, params->pathString, params->path);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStructureTypeToString(void *args)
+{
+    struct xrStructureTypeToString_params *params = args;
+
+    TRACE("%p, %#x, %p\n", params->instance, params->value, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStructureTypeToString(wine_instance_from_handle(params->instance)->host_instance, params->value, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrStructureTypeToString2KHR(void *args)
+{
+    struct xrStructureTypeToString2KHR_params *params = args;
+
+    TRACE("%p, %#x, %p\n", params->instance, params->value, params->buffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrStructureTypeToString2KHR(wine_instance_from_handle(params->instance)->host_instance, params->value, params->buffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSuggestBodyTrackingCalibrationOverrideMETA(void *args)
+{
+    struct xrSuggestBodyTrackingCalibrationOverrideMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->bodyTracker, params->calibrationInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSuggestBodyTrackingCalibrationOverrideMETA(params->bodyTracker, params->calibrationInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSuggestInteractionProfileBindings(void *args)
+{
+    struct xrSuggestInteractionProfileBindings_params *params = args;
+
+    TRACE("%p, %p\n", params->instance, params->suggestedBindings);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSuggestInteractionProfileBindings(wine_instance_from_handle(params->instance)->host_instance, params->suggestedBindings);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSuggestVirtualKeyboardLocationMETA(void *args)
+{
+    struct xrSuggestVirtualKeyboardLocationMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->keyboard, params->locationInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSuggestVirtualKeyboardLocationMETA(params->keyboard, params->locationInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrSyncActions(void *args)
+{
+    struct xrSyncActions_params *params = args;
+
+    TRACE("%p, %p\n", params->session, params->syncInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrSyncActions(wine_session_from_handle(params->session)->host_session, params->syncInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrThermalGetTemperatureTrendEXT(void *args)
+{
+    struct xrThermalGetTemperatureTrendEXT_params *params = args;
+
+    TRACE("%p, %#x, %p, %p, %p\n", params->session, params->domain, params->notificationLevel, params->tempHeadroom, params->tempSlope);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrThermalGetTemperatureTrendEXT(wine_session_from_handle(params->session)->host_session, params->domain, params->notificationLevel, params->tempHeadroom, params->tempSlope);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrTriangleMeshBeginUpdateFB(void *args)
+{
+    struct xrTriangleMeshBeginUpdateFB_params *params = args;
+
+    TRACE("%p\n", params->mesh);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrTriangleMeshBeginUpdateFB(params->mesh);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrTriangleMeshBeginVertexBufferUpdateFB(void *args)
+{
+    struct xrTriangleMeshBeginVertexBufferUpdateFB_params *params = args;
+
+    TRACE("%p, %p\n", params->mesh, params->outVertexCount);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrTriangleMeshBeginVertexBufferUpdateFB(params->mesh, params->outVertexCount);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrTriangleMeshEndUpdateFB(void *args)
+{
+    struct xrTriangleMeshEndUpdateFB_params *params = args;
+
+    TRACE("%p, %u, %u\n", params->mesh, params->vertexCount, params->triangleCount);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrTriangleMeshEndUpdateFB(params->mesh, params->vertexCount, params->triangleCount);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrTriangleMeshEndVertexBufferUpdateFB(void *args)
+{
+    struct xrTriangleMeshEndVertexBufferUpdateFB_params *params = args;
+
+    TRACE("%p\n", params->mesh);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrTriangleMeshEndVertexBufferUpdateFB(params->mesh);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrTriangleMeshGetIndexBufferFB(void *args)
+{
+    struct xrTriangleMeshGetIndexBufferFB_params *params = args;
+
+    TRACE("%p, %p\n", params->mesh, params->outIndexBuffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrTriangleMeshGetIndexBufferFB(params->mesh, params->outIndexBuffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrTriangleMeshGetVertexBufferFB(void *args)
+{
+    struct xrTriangleMeshGetVertexBufferFB_params *params = args;
+
+    TRACE("%p, %p\n", params->mesh, params->outVertexBuffer);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrTriangleMeshGetVertexBufferFB(params->mesh, params->outVertexBuffer);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrTryCreateSpatialGraphStaticNodeBindingMSFT(void *args)
+{
+    struct xrTryCreateSpatialGraphStaticNodeBindingMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->createInfo, params->nodeBinding);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrTryCreateSpatialGraphStaticNodeBindingMSFT(wine_session_from_handle(params->session)->host_session, params->createInfo, params->nodeBinding);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUnpersistAnchorANDROID(void *args)
+{
+    struct xrUnpersistAnchorANDROID_params *params = args;
+
+    TRACE("%p, %p\n", params->handle, params->anchorId);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUnpersistAnchorANDROID(params->handle, params->anchorId);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUnpersistSpatialAnchorAsyncBD(void *args)
+{
+    struct xrUnpersistSpatialAnchorAsyncBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->info, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUnpersistSpatialAnchorAsyncBD(params->provider, params->info, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUnpersistSpatialAnchorCompleteBD(void *args)
+{
+    struct xrUnpersistSpatialAnchorCompleteBD_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->provider, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUnpersistSpatialAnchorCompleteBD(params->provider, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUnpersistSpatialAnchorMSFT(void *args)
+{
+    struct xrUnpersistSpatialAnchorMSFT_params *params = args;
+
+    TRACE("%p, %p\n", params->spatialAnchorStore, params->spatialAnchorPersistenceName);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUnpersistSpatialAnchorMSFT(params->spatialAnchorStore, params->spatialAnchorPersistenceName);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUnpersistSpatialEntityAsyncEXT(void *args)
+{
+    struct xrUnpersistSpatialEntityAsyncEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->persistenceContext, params->unpersistInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUnpersistSpatialEntityAsyncEXT(params->persistenceContext, params->unpersistInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUnpersistSpatialEntityCompleteEXT(void *args)
+{
+    struct xrUnpersistSpatialEntityCompleteEXT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->persistenceContext, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUnpersistSpatialEntityCompleteEXT(params->persistenceContext, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUpdateHandMeshMSFT(void *args)
+{
+    struct xrUpdateHandMeshMSFT_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->handTracker, params->updateInfo, params->handMesh);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUpdateHandMeshMSFT(params->handTracker, params->updateInfo, params->handMesh);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUpdatePassthroughColorLutMETA(void *args)
+{
+    struct xrUpdatePassthroughColorLutMETA_params *params = args;
+
+    TRACE("%p, %p\n", params->colorLut, params->updateInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUpdatePassthroughColorLutMETA(params->colorLut, params->updateInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUpdateSpatialAnchorsExpirationAsyncML(void *args)
+{
+    struct xrUpdateSpatialAnchorsExpirationAsyncML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->storage, params->updateInfo, params->future);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUpdateSpatialAnchorsExpirationAsyncML(params->storage, params->updateInfo, params->future);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUpdateSpatialAnchorsExpirationCompleteML(void *args)
+{
+    struct xrUpdateSpatialAnchorsExpirationCompleteML_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->storage, params->future, params->completion);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUpdateSpatialAnchorsExpirationCompleteML(params->storage, params->future, params->completion);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrUpdateSwapchainFB(void *args)
+{
+    struct xrUpdateSwapchainFB_params *params = args;
+
+    TRACE("%p, %p\n", params->swapchain, params->state);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrUpdateSwapchainFB(wine_swapchain_from_handle(params->swapchain)->host_swapchain, params->state);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrWaitFrame(void *args)
+{
+    struct xrWaitFrame_params *params = args;
+
+    TRACE("%p, %p, %p\n", params->session, params->frameWaitInfo, params->frameState);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrWaitFrame(wine_session_from_handle(params->session)->host_session, params->frameWaitInfo, params->frameState);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+#ifdef _WIN64
+static NTSTATUS thunk64_xrWaitSwapchainImage(void *args)
+{
+    struct xrWaitSwapchainImage_params *params = args;
+
+    TRACE("%p, %p\n", params->swapchain, params->waitInfo);
+
+    params->result = g_xr_host_instance_dispatch_table.p_xrWaitSwapchainImage(wine_swapchain_from_handle(params->swapchain)->host_swapchain, params->waitInfo);
+    return STATUS_SUCCESS;
+}
+#endif /* _WIN64 */
+
+static const char * const xr_extensions[] =
+{
+    "XR_ALMALENCE_digital_lens_control",
+    "XR_ANDROID_device_anchor_persistence",
+    "XR_ANDROID_passthrough_camera_state",
+    "XR_ANDROID_raycast",
+    "XR_ANDROID_trackables",
+    "XR_ANDROID_trackables_marker",
+    "XR_ANDROID_trackables_object",
+    "XR_BD_body_tracking",
+    "XR_BD_controller_interaction",
+    "XR_BD_future_progress",
+    "XR_BD_spatial_anchor",
+    "XR_BD_spatial_anchor_sharing",
+    "XR_BD_spatial_mesh",
+    "XR_BD_spatial_plane",
+    "XR_BD_spatial_scene",
+    "XR_BD_spatial_sensing",
+    "XR_EPIC_view_configuration_fov",
+    "XR_EXTX_overlay",
+    "XR_EXT_active_action_set_priority",
+    "XR_EXT_composition_layer_inverted_alpha",
+    "XR_EXT_conformance_automation",
+    "XR_EXT_dpad_binding",
+    "XR_EXT_eye_gaze_interaction",
+    "XR_EXT_frame_synthesis",
+    "XR_EXT_future",
+    "XR_EXT_hand_interaction",
+    "XR_EXT_hand_joints_motion_range",
+    "XR_EXT_hand_tracking",
+    "XR_EXT_hand_tracking_data_source",
+    "XR_EXT_hp_mixed_reality_controller",
+    "XR_EXT_interaction_render_model",
+    "XR_EXT_loader_init_properties",
+    "XR_EXT_local_floor",
+    "XR_EXT_palm_pose",
+    "XR_EXT_performance_settings",
+    "XR_EXT_plane_detection",
+    "XR_EXT_render_model",
+    "XR_EXT_samsung_odyssey_controller",
+    "XR_EXT_spatial_anchor",
+    "XR_EXT_spatial_entity",
+    "XR_EXT_spatial_marker_tracking",
+    "XR_EXT_spatial_persistence",
+    "XR_EXT_spatial_persistence_operations",
+    "XR_EXT_spatial_plane_tracking",
+    "XR_EXT_thermal_query",
+    "XR_EXT_user_presence",
+    "XR_EXT_uuid",
+    "XR_EXT_view_configuration_depth_range",
+    "XR_EXT_win32_appcontainer_compatible",
+    "XR_FB_body_tracking",
+    "XR_FB_color_space",
+    "XR_FB_composition_layer_alpha_blend",
+    "XR_FB_composition_layer_depth_test",
+    "XR_FB_composition_layer_image_layout",
+    "XR_FB_composition_layer_secure_content",
+    "XR_FB_composition_layer_settings",
+    "XR_FB_display_refresh_rate",
+    "XR_FB_eye_tracking_social",
+    "XR_FB_face_tracking",
+    "XR_FB_face_tracking2",
+    "XR_FB_foveation",
+    "XR_FB_foveation_configuration",
+    "XR_FB_foveation_vulkan",
+    "XR_FB_hand_tracking_aim",
+    "XR_FB_hand_tracking_capsules",
+    "XR_FB_hand_tracking_mesh",
+    "XR_FB_haptic_amplitude_envelope",
+    "XR_FB_haptic_pcm",
+    "XR_FB_keyboard_tracking",
+    "XR_FB_passthrough",
+    "XR_FB_passthrough_keyboard_hands",
+    "XR_FB_render_model",
+    "XR_FB_scene",
+    "XR_FB_scene_capture",
+    "XR_FB_space_warp",
+    "XR_FB_spatial_entity",
+    "XR_FB_spatial_entity_container",
+    "XR_FB_spatial_entity_query",
+    "XR_FB_spatial_entity_sharing",
+    "XR_FB_spatial_entity_storage",
+    "XR_FB_spatial_entity_storage_batch",
+    "XR_FB_spatial_entity_user",
+    "XR_FB_swapchain_update_state",
+    "XR_FB_swapchain_update_state_vulkan",
+    "XR_FB_touch_controller_pro",
+    "XR_FB_touch_controller_proximity",
+    "XR_FB_triangle_mesh",
+    "XR_HTCX_vive_tracker_interaction",
+    "XR_HTC_anchor",
+    "XR_HTC_body_tracking",
+    "XR_HTC_facial_tracking",
+    "XR_HTC_hand_interaction",
+    "XR_HTC_passthrough",
+    "XR_HTC_vive_cosmos_controller_interaction",
+    "XR_HTC_vive_focus3_controller_interaction",
+    "XR_HTC_vive_wrist_tracker_interaction",
+    "XR_HUAWEI_controller_interaction",
+    "XR_KHR_D3D11_enable",
+    "XR_KHR_D3D12_enable",
+    "XR_KHR_binding_modification",
+    "XR_KHR_composition_layer_color_scale_bias",
+    "XR_KHR_composition_layer_cube",
+    "XR_KHR_composition_layer_cylinder",
+    "XR_KHR_composition_layer_depth",
+    "XR_KHR_composition_layer_equirect",
+    "XR_KHR_composition_layer_equirect2",
+    "XR_KHR_extended_struct_name_lengths",
+    "XR_KHR_generic_controller",
+    "XR_KHR_locate_spaces",
+    "XR_KHR_maintenance1",
+    "XR_KHR_opengl_enable",
+    "XR_KHR_swapchain_usage_input_attachment_bit",
+    "XR_KHR_visibility_mask",
+    "XR_KHR_vulkan_enable",
+    "XR_KHR_vulkan_enable2",
+    "XR_KHR_vulkan_swapchain_format_list",
+    "XR_KHR_win32_convert_performance_counter_time",
+    "XR_LOGITECH_mx_ink_stylus_interaction",
+    "XR_META_automatic_layer_filter",
+    "XR_META_body_tracking_calibration",
+    "XR_META_body_tracking_full_body",
+    "XR_META_colocation_discovery",
+    "XR_META_detached_controllers",
+    "XR_META_environment_depth",
+    "XR_META_foveation_eye_tracked",
+    "XR_META_hand_tracking_microgestures",
+    "XR_META_headset_id",
+    "XR_META_local_dimming",
+    "XR_META_passthrough_color_lut",
+    "XR_META_passthrough_layer_resumed_event",
+    "XR_META_passthrough_preferences",
+    "XR_META_performance_metrics",
+    "XR_META_recommended_layer_resolution",
+    "XR_META_simultaneous_hands_and_controllers",
+    "XR_META_spatial_entity_discovery",
+    "XR_META_spatial_entity_group_sharing",
+    "XR_META_spatial_entity_mesh",
+    "XR_META_spatial_entity_persistence",
+    "XR_META_spatial_entity_sharing",
+    "XR_META_touch_controller_plus",
+    "XR_META_virtual_keyboard",
+    "XR_META_vulkan_swapchain_create_info",
+    "XR_ML_facial_expression",
+    "XR_ML_frame_end_info",
+    "XR_ML_global_dimmer",
+    "XR_ML_localization_map",
+    "XR_ML_marker_understanding",
+    "XR_ML_ml2_controller_interaction",
+    "XR_ML_spatial_anchors",
+    "XR_ML_spatial_anchors_storage",
+    "XR_ML_system_notifications",
+    "XR_ML_user_calibration",
+    "XR_ML_view_configuration_depth_range_change",
+    "XR_ML_world_mesh_detection",
+    "XR_MNDX_force_feedback_curl",
+    "XR_MND_headless",
+    "XR_MND_swapchain_usage_input_attachment_bit",
+    "XR_MSFT_composition_layer_reprojection",
+    "XR_MSFT_controller_model",
+    "XR_MSFT_first_person_observer",
+    "XR_MSFT_hand_interaction",
+    "XR_MSFT_hand_tracking_mesh",
+    "XR_MSFT_holographic_window_attachment",
+    "XR_MSFT_scene_marker",
+    "XR_MSFT_scene_understanding",
+    "XR_MSFT_scene_understanding_serialization",
+    "XR_MSFT_secondary_view_configuration",
+    "XR_MSFT_spatial_anchor",
+    "XR_MSFT_spatial_anchor_persistence",
+    "XR_MSFT_spatial_graph_bridge",
+    "XR_MSFT_unbounded_reference_space",
+    "XR_OCULUS_android_session_state_enable",
+    "XR_OCULUS_audio_device_guid",
+    "XR_OCULUS_external_camera",
+    "XR_OPPO_controller_interaction",
+    "XR_QCOM_tracking_optimization_settings",
+    "XR_ULTRALEAP_hand_tracking_forearm",
+    "XR_VALVE_analog_threshold",
+    "XR_VARJO_composition_layer_depth_test",
+    "XR_VARJO_environment_depth_estimation",
+    "XR_VARJO_foveated_rendering",
+    "XR_VARJO_marker_tracking",
+    "XR_VARJO_quad_views",
+    "XR_VARJO_view_offset",
+    "XR_VARJO_xr4_controller_interaction",
+    "XR_YVR_controller_interaction",
+};
+
+BOOL wine_xr_extension_supported(const char *name)
+{
+    unsigned int i;
+    for (i = 0; i < ARRAY_SIZE(xr_extensions); i++)
+    {
+        if (strcmp(xr_extensions[i], name) == 0)
+            return TRUE;
+    }
+    return FALSE;
+}
+
+BOOL wine_xr_is_type_wrapped(XrObjectType type)
+{
+    return FALSE ||
+        type == XR_OBJECT_TYPE_INSTANCE ||
+        type == XR_OBJECT_TYPE_SESSION ||
+        type == XR_OBJECT_TYPE_SWAPCHAIN;
+}
+
+#ifdef _WIN64
+
+const unixlib_entry_t __wine_unix_call_funcs[] =
+{
+    init_openxr,
+    is_available_instance_function_openxr,
+    thunk64_xrAcquireEnvironmentDepthImageMETA,
+    thunk64_xrAcquireSwapchainImage,
+    thunk64_xrAllocateWorldMeshBufferML,
+    thunk64_xrApplyForceFeedbackCurlMNDX,
+    thunk64_xrApplyHapticFeedback,
+    thunk64_xrAttachSessionActionSets,
+    thunk64_xrBeginFrame,
+    thunk64_xrBeginPlaneDetectionEXT,
+    thunk64_xrBeginSession,
+    thunk64_xrCancelFutureEXT,
+    thunk64_xrCaptureSceneAsyncBD,
+    thunk64_xrCaptureSceneCompleteBD,
+    thunk64_xrChangeVirtualKeyboardTextContextMETA,
+    thunk64_xrClearSpatialAnchorStoreMSFT,
+    thunk64_xrComputeNewSceneMSFT,
+    thunk64_xrCreateAction,
+    thunk64_xrCreateActionSet,
+    thunk64_xrCreateActionSpace,
+    thunk64_xrCreateAnchorSpaceANDROID,
+    thunk64_xrCreateAnchorSpaceBD,
+    thunk64_xrCreateBodyTrackerBD,
+    thunk64_xrCreateBodyTrackerFB,
+    thunk64_xrCreateBodyTrackerHTC,
+    thunk64_xrCreateDeviceAnchorPersistenceANDROID,
+    thunk64_xrCreateEnvironmentDepthProviderMETA,
+    thunk64_xrCreateEnvironmentDepthSwapchainMETA,
+    thunk64_xrCreateExportedLocalizationMapML,
+    thunk64_xrCreateEyeTrackerFB,
+    thunk64_xrCreateFaceTracker2FB,
+    thunk64_xrCreateFaceTrackerFB,
+    thunk64_xrCreateFacialExpressionClientML,
+    thunk64_xrCreateFacialTrackerHTC,
+    thunk64_xrCreateFoveationProfileFB,
+    thunk64_xrCreateGeometryInstanceFB,
+    thunk64_xrCreateHandMeshSpaceMSFT,
+    thunk64_xrCreateHandTrackerEXT,
+    thunk64_xrCreateInstance,
+    thunk64_xrCreateKeyboardSpaceFB,
+    thunk64_xrCreateMarkerDetectorML,
+    thunk64_xrCreateMarkerSpaceML,
+    thunk64_xrCreateMarkerSpaceVARJO,
+    thunk64_xrCreatePassthroughColorLutMETA,
+    thunk64_xrCreatePassthroughFB,
+    thunk64_xrCreatePassthroughHTC,
+    thunk64_xrCreatePassthroughLayerFB,
+    thunk64_xrCreatePersistedAnchorSpaceANDROID,
+    thunk64_xrCreatePlaneDetectorEXT,
+    thunk64_xrCreateReferenceSpace,
+    thunk64_xrCreateRenderModelAssetEXT,
+    thunk64_xrCreateRenderModelEXT,
+    thunk64_xrCreateRenderModelSpaceEXT,
+    thunk64_xrCreateSceneMSFT,
+    thunk64_xrCreateSceneObserverMSFT,
+    thunk64_xrCreateSenseDataProviderBD,
+    thunk64_xrCreateSession,
+    thunk64_xrCreateSpaceUserFB,
+    thunk64_xrCreateSpatialAnchorAsyncBD,
+    thunk64_xrCreateSpatialAnchorCompleteBD,
+    thunk64_xrCreateSpatialAnchorEXT,
+    thunk64_xrCreateSpatialAnchorFB,
+    thunk64_xrCreateSpatialAnchorFromPersistedNameMSFT,
+    thunk64_xrCreateSpatialAnchorHTC,
+    thunk64_xrCreateSpatialAnchorMSFT,
+    thunk64_xrCreateSpatialAnchorSpaceMSFT,
+    thunk64_xrCreateSpatialAnchorStoreConnectionMSFT,
+    thunk64_xrCreateSpatialAnchorsAsyncML,
+    thunk64_xrCreateSpatialAnchorsCompleteML,
+    thunk64_xrCreateSpatialAnchorsStorageML,
+    thunk64_xrCreateSpatialContextAsyncEXT,
+    thunk64_xrCreateSpatialContextCompleteEXT,
+    thunk64_xrCreateSpatialDiscoverySnapshotAsyncEXT,
+    thunk64_xrCreateSpatialDiscoverySnapshotCompleteEXT,
+    thunk64_xrCreateSpatialEntityAnchorBD,
+    thunk64_xrCreateSpatialEntityFromIdEXT,
+    thunk64_xrCreateSpatialGraphNodeSpaceMSFT,
+    thunk64_xrCreateSpatialPersistenceContextAsyncEXT,
+    thunk64_xrCreateSpatialPersistenceContextCompleteEXT,
+    thunk64_xrCreateSpatialUpdateSnapshotEXT,
+    thunk64_xrCreateSwapchain,
+    thunk64_xrCreateTrackableTrackerANDROID,
+    thunk64_xrCreateTriangleMeshFB,
+    thunk64_xrCreateVirtualKeyboardMETA,
+    thunk64_xrCreateVirtualKeyboardSpaceMETA,
+    thunk64_xrCreateWorldMeshDetectorML,
+    thunk64_xrDeleteSpatialAnchorsAsyncML,
+    thunk64_xrDeleteSpatialAnchorsCompleteML,
+    thunk64_xrDeserializeSceneMSFT,
+    thunk64_xrDestroyAction,
+    thunk64_xrDestroyActionSet,
+    thunk64_xrDestroyAnchorBD,
+    thunk64_xrDestroyBodyTrackerBD,
+    thunk64_xrDestroyBodyTrackerFB,
+    thunk64_xrDestroyBodyTrackerHTC,
+    thunk64_xrDestroyDeviceAnchorPersistenceANDROID,
+    thunk64_xrDestroyEnvironmentDepthProviderMETA,
+    thunk64_xrDestroyEnvironmentDepthSwapchainMETA,
+    thunk64_xrDestroyExportedLocalizationMapML,
+    thunk64_xrDestroyEyeTrackerFB,
+    thunk64_xrDestroyFaceTracker2FB,
+    thunk64_xrDestroyFaceTrackerFB,
+    thunk64_xrDestroyFacialExpressionClientML,
+    thunk64_xrDestroyFacialTrackerHTC,
+    thunk64_xrDestroyFoveationProfileFB,
+    thunk64_xrDestroyGeometryInstanceFB,
+    thunk64_xrDestroyHandTrackerEXT,
+    thunk64_xrDestroyInstance,
+    thunk64_xrDestroyMarkerDetectorML,
+    thunk64_xrDestroyPassthroughColorLutMETA,
+    thunk64_xrDestroyPassthroughFB,
+    thunk64_xrDestroyPassthroughHTC,
+    thunk64_xrDestroyPassthroughLayerFB,
+    thunk64_xrDestroyPlaneDetectorEXT,
+    thunk64_xrDestroyRenderModelAssetEXT,
+    thunk64_xrDestroyRenderModelEXT,
+    thunk64_xrDestroySceneMSFT,
+    thunk64_xrDestroySceneObserverMSFT,
+    thunk64_xrDestroySenseDataProviderBD,
+    thunk64_xrDestroySenseDataSnapshotBD,
+    thunk64_xrDestroySession,
+    thunk64_xrDestroySpace,
+    thunk64_xrDestroySpaceUserFB,
+    thunk64_xrDestroySpatialAnchorMSFT,
+    thunk64_xrDestroySpatialAnchorStoreConnectionMSFT,
+    thunk64_xrDestroySpatialAnchorsStorageML,
+    thunk64_xrDestroySpatialContextEXT,
+    thunk64_xrDestroySpatialEntityEXT,
+    thunk64_xrDestroySpatialGraphNodeBindingMSFT,
+    thunk64_xrDestroySpatialPersistenceContextEXT,
+    thunk64_xrDestroySpatialSnapshotEXT,
+    thunk64_xrDestroySwapchain,
+    thunk64_xrDestroyTrackableTrackerANDROID,
+    thunk64_xrDestroyTriangleMeshFB,
+    thunk64_xrDestroyVirtualKeyboardMETA,
+    thunk64_xrDestroyWorldMeshDetectorML,
+    thunk64_xrDiscoverSpacesMETA,
+    thunk64_xrDownloadSharedSpatialAnchorAsyncBD,
+    thunk64_xrDownloadSharedSpatialAnchorCompleteBD,
+    thunk64_xrEnableLocalizationEventsML,
+    thunk64_xrEnableUserCalibrationEventsML,
+    thunk64_xrEndFrame,
+    thunk64_xrEndSession,
+    thunk64_xrEnumerateApiLayerProperties,
+    thunk64_xrEnumerateBoundSourcesForAction,
+    thunk64_xrEnumerateColorSpacesFB,
+    thunk64_xrEnumerateDisplayRefreshRatesFB,
+    thunk64_xrEnumerateEnvironmentBlendModes,
+    thunk64_xrEnumerateEnvironmentDepthSwapchainImagesMETA,
+    thunk64_xrEnumerateExternalCamerasOCULUS,
+    thunk64_xrEnumerateInstanceExtensionProperties,
+    thunk64_xrEnumerateInteractionRenderModelIdsEXT,
+    thunk64_xrEnumeratePerformanceMetricsCounterPathsMETA,
+    thunk64_xrEnumeratePersistedAnchorsANDROID,
+    thunk64_xrEnumeratePersistedSpatialAnchorNamesMSFT,
+    thunk64_xrEnumerateRaycastSupportedTrackableTypesANDROID,
+    thunk64_xrEnumerateReferenceSpaces,
+    thunk64_xrEnumerateRenderModelPathsFB,
+    thunk64_xrEnumerateRenderModelSubactionPathsEXT,
+    thunk64_xrEnumerateReprojectionModesMSFT,
+    thunk64_xrEnumerateSceneComputeFeaturesMSFT,
+    thunk64_xrEnumerateSpaceSupportedComponentsFB,
+    thunk64_xrEnumerateSpatialCapabilitiesEXT,
+    thunk64_xrEnumerateSpatialCapabilityComponentTypesEXT,
+    thunk64_xrEnumerateSpatialCapabilityFeaturesEXT,
+    thunk64_xrEnumerateSpatialEntityComponentTypesBD,
+    thunk64_xrEnumerateSpatialPersistenceScopesEXT,
+    thunk64_xrEnumerateSupportedAnchorTrackableTypesANDROID,
+    thunk64_xrEnumerateSupportedPersistenceAnchorTypesANDROID,
+    thunk64_xrEnumerateSupportedTrackableTypesANDROID,
+    thunk64_xrEnumerateSwapchainFormats,
+    thunk64_xrEnumerateSwapchainImages,
+    thunk64_xrEnumerateViewConfigurationViews,
+    thunk64_xrEnumerateViewConfigurations,
+    thunk64_xrEnumerateViveTrackerPathsHTCX,
+    thunk64_xrEraseSpaceFB,
+    thunk64_xrEraseSpacesMETA,
+    thunk64_xrFreeWorldMeshBufferML,
+    thunk64_xrGeometryInstanceSetTransformFB,
+    thunk64_xrGetActionStateBoolean,
+    thunk64_xrGetActionStateFloat,
+    thunk64_xrGetActionStatePose,
+    thunk64_xrGetActionStateVector2f,
+    thunk64_xrGetAllTrackablesANDROID,
+    thunk64_xrGetAnchorPersistStateANDROID,
+    thunk64_xrGetAnchorUuidBD,
+    thunk64_xrGetAudioInputDeviceGuidOculus,
+    thunk64_xrGetAudioOutputDeviceGuidOculus,
+    thunk64_xrGetBodySkeletonFB,
+    thunk64_xrGetBodySkeletonHTC,
+    thunk64_xrGetControllerModelKeyMSFT,
+    thunk64_xrGetControllerModelPropertiesMSFT,
+    thunk64_xrGetControllerModelStateMSFT,
+    thunk64_xrGetCurrentInteractionProfile,
+    thunk64_xrGetDeviceSampleRateFB,
+    thunk64_xrGetDisplayRefreshRateFB,
+    thunk64_xrGetEnvironmentDepthSwapchainStateMETA,
+    thunk64_xrGetExportedLocalizationMapDataML,
+    thunk64_xrGetEyeGazesFB,
+    thunk64_xrGetFaceExpressionWeights2FB,
+    thunk64_xrGetFaceExpressionWeightsFB,
+    thunk64_xrGetFacialExpressionBlendShapePropertiesML,
+    thunk64_xrGetFacialExpressionsHTC,
+    thunk64_xrGetFoveationEyeTrackedStateMETA,
+    thunk64_xrGetHandMeshFB,
+    thunk64_xrGetInputSourceLocalizedName,
+    thunk64_xrGetInstanceProperties,
+    thunk64_xrGetMarkerDetectorStateML,
+    thunk64_xrGetMarkerLengthML,
+    thunk64_xrGetMarkerNumberML,
+    thunk64_xrGetMarkerReprojectionErrorML,
+    thunk64_xrGetMarkerSizeVARJO,
+    thunk64_xrGetMarkerStringML,
+    thunk64_xrGetMarkersML,
+    thunk64_xrGetOpenGLGraphicsRequirementsKHR,
+    thunk64_xrGetPassthroughCameraStateANDROID,
+    thunk64_xrGetPassthroughPreferencesMETA,
+    thunk64_xrGetPerformanceMetricsStateMETA,
+    thunk64_xrGetPlaneDetectionStateEXT,
+    thunk64_xrGetPlaneDetectionsEXT,
+    thunk64_xrGetPlanePolygonBufferEXT,
+    thunk64_xrGetQueriedSenseDataBD,
+    thunk64_xrGetRecommendedLayerResolutionMETA,
+    thunk64_xrGetReferenceSpaceBoundsRect,
+    thunk64_xrGetRenderModelAssetDataEXT,
+    thunk64_xrGetRenderModelAssetPropertiesEXT,
+    thunk64_xrGetRenderModelPoseTopLevelUserPathEXT,
+    thunk64_xrGetRenderModelPropertiesEXT,
+    thunk64_xrGetRenderModelPropertiesFB,
+    thunk64_xrGetRenderModelStateEXT,
+    thunk64_xrGetSceneComponentsMSFT,
+    thunk64_xrGetSceneComputeStateMSFT,
+    thunk64_xrGetSceneMarkerDecodedStringMSFT,
+    thunk64_xrGetSceneMarkerRawDataMSFT,
+    thunk64_xrGetSceneMeshBuffersMSFT,
+    thunk64_xrGetSenseDataProviderStateBD,
+    thunk64_xrGetSerializedSceneFragmentDataMSFT,
+    thunk64_xrGetSpaceBoundary2DFB,
+    thunk64_xrGetSpaceBoundingBox2DFB,
+    thunk64_xrGetSpaceBoundingBox3DFB,
+    thunk64_xrGetSpaceComponentStatusFB,
+    thunk64_xrGetSpaceContainerFB,
+    thunk64_xrGetSpaceRoomLayoutFB,
+    thunk64_xrGetSpaceSemanticLabelsFB,
+    thunk64_xrGetSpaceTriangleMeshMETA,
+    thunk64_xrGetSpaceUserIdFB,
+    thunk64_xrGetSpaceUuidFB,
+    thunk64_xrGetSpatialAnchorNameHTC,
+    thunk64_xrGetSpatialAnchorStateML,
+    thunk64_xrGetSpatialBufferFloatEXT,
+    thunk64_xrGetSpatialBufferStringEXT,
+    thunk64_xrGetSpatialBufferUint16EXT,
+    thunk64_xrGetSpatialBufferUint32EXT,
+    thunk64_xrGetSpatialBufferUint8EXT,
+    thunk64_xrGetSpatialBufferVector2fEXT,
+    thunk64_xrGetSpatialBufferVector3fEXT,
+    thunk64_xrGetSpatialEntityComponentDataBD,
+    thunk64_xrGetSpatialEntityUuidBD,
+    thunk64_xrGetSpatialGraphNodeBindingPropertiesMSFT,
+    thunk64_xrGetSwapchainStateFB,
+    thunk64_xrGetSystem,
+    thunk64_xrGetSystemProperties,
+    thunk64_xrGetTrackableMarkerANDROID,
+    thunk64_xrGetTrackableObjectANDROID,
+    thunk64_xrGetTrackablePlaneANDROID,
+    thunk64_xrGetViewConfigurationProperties,
+    thunk64_xrGetVirtualKeyboardDirtyTexturesMETA,
+    thunk64_xrGetVirtualKeyboardModelAnimationStatesMETA,
+    thunk64_xrGetVirtualKeyboardScaleMETA,
+    thunk64_xrGetVirtualKeyboardTextureDataMETA,
+    thunk64_xrGetVisibilityMaskKHR,
+    thunk64_xrGetVulkanDeviceExtensionsKHR,
+    thunk64_xrGetVulkanGraphicsDevice2KHR,
+    thunk64_xrGetVulkanGraphicsDeviceKHR,
+    thunk64_xrGetVulkanGraphicsRequirements2KHR,
+    thunk64_xrGetVulkanGraphicsRequirementsKHR,
+    thunk64_xrGetVulkanInstanceExtensionsKHR,
+    thunk64_xrGetWorldMeshBufferRecommendSizeML,
+    thunk64_xrImportLocalizationMapML,
+    thunk64_xrLoadControllerModelMSFT,
+    thunk64_xrLoadRenderModelFB,
+    thunk64_xrLocateBodyJointsBD,
+    thunk64_xrLocateBodyJointsFB,
+    thunk64_xrLocateBodyJointsHTC,
+    thunk64_xrLocateHandJointsEXT,
+    thunk64_xrLocateSceneComponentsMSFT,
+    thunk64_xrLocateSpace,
+    thunk64_xrLocateSpaces,
+    thunk64_xrLocateSpacesKHR,
+    thunk64_xrLocateViews,
+    thunk64_xrPassthroughLayerPauseFB,
+    thunk64_xrPassthroughLayerResumeFB,
+    thunk64_xrPassthroughLayerSetKeyboardHandsIntensityFB,
+    thunk64_xrPassthroughLayerSetStyleFB,
+    thunk64_xrPassthroughPauseFB,
+    thunk64_xrPassthroughStartFB,
+    thunk64_xrPathToString,
+    thunk64_xrPauseSimultaneousHandsAndControllersTrackingMETA,
+    thunk64_xrPerfSettingsSetPerformanceLevelEXT,
+    thunk64_xrPersistAnchorANDROID,
+    thunk64_xrPersistSpatialAnchorAsyncBD,
+    thunk64_xrPersistSpatialAnchorCompleteBD,
+    thunk64_xrPersistSpatialAnchorMSFT,
+    thunk64_xrPersistSpatialEntityAsyncEXT,
+    thunk64_xrPersistSpatialEntityCompleteEXT,
+    thunk64_xrPollEvent,
+    thunk64_xrPollFutureEXT,
+    thunk64_xrPublishSpatialAnchorsAsyncML,
+    thunk64_xrPublishSpatialAnchorsCompleteML,
+    thunk64_xrQueryLocalizationMapsML,
+    thunk64_xrQueryPerformanceMetricsCounterMETA,
+    thunk64_xrQuerySenseDataAsyncBD,
+    thunk64_xrQuerySenseDataCompleteBD,
+    thunk64_xrQuerySpacesFB,
+    thunk64_xrQuerySpatialAnchorsAsyncML,
+    thunk64_xrQuerySpatialAnchorsCompleteML,
+    thunk64_xrQuerySpatialComponentDataEXT,
+    thunk64_xrQuerySystemTrackedKeyboardFB,
+    thunk64_xrRaycastANDROID,
+    thunk64_xrReleaseSwapchainImage,
+    thunk64_xrRequestDisplayRefreshRateFB,
+    thunk64_xrRequestExitSession,
+    thunk64_xrRequestMapLocalizationML,
+    thunk64_xrRequestSceneCaptureFB,
+    thunk64_xrRequestWorldMeshAsyncML,
+    thunk64_xrRequestWorldMeshCompleteML,
+    thunk64_xrRequestWorldMeshStateAsyncML,
+    thunk64_xrRequestWorldMeshStateCompleteML,
+    thunk64_xrResetBodyTrackingCalibrationMETA,
+    thunk64_xrResultToString,
+    thunk64_xrResumeSimultaneousHandsAndControllersTrackingMETA,
+    thunk64_xrRetrieveSpaceDiscoveryResultsMETA,
+    thunk64_xrRetrieveSpaceQueryResultsFB,
+    thunk64_xrSaveSpaceFB,
+    thunk64_xrSaveSpaceListFB,
+    thunk64_xrSaveSpacesMETA,
+    thunk64_xrSendVirtualKeyboardInputMETA,
+    thunk64_xrSetColorSpaceFB,
+    thunk64_xrSetDigitalLensControlALMALENCE,
+    thunk64_xrSetEnvironmentDepthEstimationVARJO,
+    thunk64_xrSetEnvironmentDepthHandRemovalMETA,
+    thunk64_xrSetInputDeviceActiveEXT,
+    thunk64_xrSetInputDeviceLocationEXT,
+    thunk64_xrSetInputDeviceStateBoolEXT,
+    thunk64_xrSetInputDeviceStateFloatEXT,
+    thunk64_xrSetInputDeviceStateVector2fEXT,
+    thunk64_xrSetMarkerTrackingPredictionVARJO,
+    thunk64_xrSetMarkerTrackingTimeoutVARJO,
+    thunk64_xrSetMarkerTrackingVARJO,
+    thunk64_xrSetPerformanceMetricsStateMETA,
+    thunk64_xrSetSpaceComponentStatusFB,
+    thunk64_xrSetSystemNotificationsML,
+    thunk64_xrSetTrackingOptimizationSettingsHintQCOM,
+    thunk64_xrSetViewOffsetVARJO,
+    thunk64_xrSetVirtualKeyboardModelVisibilityMETA,
+    thunk64_xrShareSpacesFB,
+    thunk64_xrShareSpacesMETA,
+    thunk64_xrShareSpatialAnchorAsyncBD,
+    thunk64_xrShareSpatialAnchorCompleteBD,
+    thunk64_xrSnapshotMarkerDetectorML,
+    thunk64_xrStartColocationAdvertisementMETA,
+    thunk64_xrStartColocationDiscoveryMETA,
+    thunk64_xrStartEnvironmentDepthProviderMETA,
+    thunk64_xrStartSenseDataProviderAsyncBD,
+    thunk64_xrStartSenseDataProviderCompleteBD,
+    thunk64_xrStopColocationAdvertisementMETA,
+    thunk64_xrStopColocationDiscoveryMETA,
+    thunk64_xrStopEnvironmentDepthProviderMETA,
+    thunk64_xrStopHapticFeedback,
+    thunk64_xrStopSenseDataProviderBD,
+    thunk64_xrStringToPath,
+    thunk64_xrStructureTypeToString,
+    thunk64_xrStructureTypeToString2KHR,
+    thunk64_xrSuggestBodyTrackingCalibrationOverrideMETA,
+    thunk64_xrSuggestInteractionProfileBindings,
+    thunk64_xrSuggestVirtualKeyboardLocationMETA,
+    thunk64_xrSyncActions,
+    thunk64_xrThermalGetTemperatureTrendEXT,
+    thunk64_xrTriangleMeshBeginUpdateFB,
+    thunk64_xrTriangleMeshBeginVertexBufferUpdateFB,
+    thunk64_xrTriangleMeshEndUpdateFB,
+    thunk64_xrTriangleMeshEndVertexBufferUpdateFB,
+    thunk64_xrTriangleMeshGetIndexBufferFB,
+    thunk64_xrTriangleMeshGetVertexBufferFB,
+    thunk64_xrTryCreateSpatialGraphStaticNodeBindingMSFT,
+    thunk64_xrUnpersistAnchorANDROID,
+    thunk64_xrUnpersistSpatialAnchorAsyncBD,
+    thunk64_xrUnpersistSpatialAnchorCompleteBD,
+    thunk64_xrUnpersistSpatialAnchorMSFT,
+    thunk64_xrUnpersistSpatialEntityAsyncEXT,
+    thunk64_xrUnpersistSpatialEntityCompleteEXT,
+    thunk64_xrUpdateHandMeshMSFT,
+    thunk64_xrUpdatePassthroughColorLutMETA,
+    thunk64_xrUpdateSpatialAnchorsExpirationAsyncML,
+    thunk64_xrUpdateSpatialAnchorsExpirationCompleteML,
+    thunk64_xrUpdateSwapchainFB,
+    thunk64_xrWaitFrame,
+    thunk64_xrWaitSwapchainImage,
+};
+C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);
+
+#endif /* _WIN64 */
+
+C_ASSERT(ARRAYSIZE(__wine_unix_call_funcs) == unix_count);
diff --git a/dlls/wineopenxr/openxr_thunks.h b/dlls/wineopenxr/openxr_thunks.h
new file mode 100644
index 00000000000..f487f96df6a
--- /dev/null
+++ b/dlls/wineopenxr/openxr_thunks.h
@@ -0,0 +1,839 @@
+/* Automatically generated from Vulkan xr.xml; DO NOT EDIT!
+ *
+ * This file is generated from Vulkan xr.xml file covered
+ * by the following copyright and permission notice:
+ *
+ * Copyright (c) 2017-2025 The Khronos Group Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0 OR MIT
+ *
+ * ------------------------------------------------------------------------
+ *
+ * This file, xr.xml, is the OpenXR API Registry. It is a critically important
+ * and normative part of the OpenXR Specification, including a canonical
+ * machine-readable definition of the API, parameter and member validation
+ * language incorporated into the Specification and reference pages, and other
+ * material which is registered by Khronos, such as tags used by extension and
+ * layer authors. The only authoritative version of xr.xml is the one
+ * maintained in the default branch of the Khronos OpenXR GitHub project.
+ *
+ */
+
+#ifndef __WINE_OPENXR_THUNKS_H
+#define __WINE_OPENXR_THUNKS_H
+
+#define WINE_XR_VERSION XR_API_VERSION_1_1
+
+/* Functions for which we have custom implementations outside of the thunks. */
+XrResult wine_xrCreateInstance(const XrInstanceCreateInfo *createInfo, XrInstance *instance);
+XrResult wine_xrCreateSession(XrInstance instance, const XrSessionCreateInfo *createInfo, XrSession *session);
+XrResult wine_xrCreateSwapchain(XrSession session, const XrSwapchainCreateInfo *createInfo, XrSwapchain *swapchain);
+XrResult wine_xrEnumerateInstanceExtensionProperties(const char *layerName, uint32_t propertyCapacityInput, uint32_t *propertyCountOutput, XrExtensionProperties *properties);
+XrResult wine_xrGetVulkanGraphicsDevice2KHR(XrInstance instance, const XrVulkanGraphicsDeviceGetInfoKHR *getInfo, VkPhysicalDevice *vulkanPhysicalDevice);
+XrResult wine_xrGetVulkanGraphicsDeviceKHR(XrInstance instance, XrSystemId systemId, VkInstance vkInstance, VkPhysicalDevice *vkPhysicalDevice);
+XrResult wine_xrGetVulkanInstanceExtensionsKHR(XrInstance instance, XrSystemId systemId, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer);
+
+/* For use by xrInstance and children */
+struct openxr_instance_funcs
+{
+    XrResult (*p_xrAcquireEnvironmentDepthImageMETA)(XrEnvironmentDepthProviderMETA, const XrEnvironmentDepthImageAcquireInfoMETA *, XrEnvironmentDepthImageMETA *);
+    XrResult (*p_xrAcquireSwapchainImage)(XrSwapchain, const XrSwapchainImageAcquireInfo *, uint32_t *);
+    XrResult (*p_xrAllocateWorldMeshBufferML)(XrWorldMeshDetectorML, const XrWorldMeshBufferSizeML *, XrWorldMeshBufferML *);
+    XrResult (*p_xrApplyForceFeedbackCurlMNDX)(XrHandTrackerEXT, const XrForceFeedbackCurlApplyLocationsMNDX *);
+    XrResult (*p_xrApplyHapticFeedback)(XrSession, const XrHapticActionInfo *, const XrHapticBaseHeader *);
+    XrResult (*p_xrAttachSessionActionSets)(XrSession, const XrSessionActionSetsAttachInfo *);
+    XrResult (*p_xrBeginFrame)(XrSession, const XrFrameBeginInfo *);
+    XrResult (*p_xrBeginPlaneDetectionEXT)(XrPlaneDetectorEXT, const XrPlaneDetectorBeginInfoEXT *);
+    XrResult (*p_xrBeginSession)(XrSession, const XrSessionBeginInfo *);
+    XrResult (*p_xrCancelFutureEXT)(XrInstance, const XrFutureCancelInfoEXT *);
+    XrResult (*p_xrCaptureSceneAsyncBD)(XrSenseDataProviderBD, const XrSceneCaptureInfoBD *, XrFutureEXT *);
+    XrResult (*p_xrCaptureSceneCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrFutureCompletionEXT *);
+    XrResult (*p_xrChangeVirtualKeyboardTextContextMETA)(XrVirtualKeyboardMETA, const XrVirtualKeyboardTextContextChangeInfoMETA *);
+    XrResult (*p_xrClearSpatialAnchorStoreMSFT)(XrSpatialAnchorStoreConnectionMSFT);
+    XrResult (*p_xrComputeNewSceneMSFT)(XrSceneObserverMSFT, const XrNewSceneComputeInfoMSFT *);
+    XrResult (*p_xrCreateAction)(XrActionSet, const XrActionCreateInfo *, XrAction *);
+    XrResult (*p_xrCreateActionSet)(XrInstance, const XrActionSetCreateInfo *, XrActionSet *);
+    XrResult (*p_xrCreateActionSpace)(XrSession, const XrActionSpaceCreateInfo *, XrSpace *);
+    XrResult (*p_xrCreateAnchorSpaceANDROID)(XrSession, const XrAnchorSpaceCreateInfoANDROID *, XrSpace *);
+    XrResult (*p_xrCreateAnchorSpaceBD)(XrSession, const XrAnchorSpaceCreateInfoBD *, XrSpace *);
+    XrResult (*p_xrCreateApiLayerInstance)(const XrInstanceCreateInfo *, const XrApiLayerCreateInfo *, XrInstance *);
+    XrResult (*p_xrCreateBodyTrackerBD)(XrSession, const XrBodyTrackerCreateInfoBD *, XrBodyTrackerBD *);
+    XrResult (*p_xrCreateBodyTrackerFB)(XrSession, const XrBodyTrackerCreateInfoFB *, XrBodyTrackerFB *);
+    XrResult (*p_xrCreateBodyTrackerHTC)(XrSession, const XrBodyTrackerCreateInfoHTC *, XrBodyTrackerHTC *);
+    XrResult (*p_xrCreateDeviceAnchorPersistenceANDROID)(XrSession, const XrDeviceAnchorPersistenceCreateInfoANDROID *, XrDeviceAnchorPersistenceANDROID *);
+    XrResult (*p_xrCreateEnvironmentDepthProviderMETA)(XrSession, const XrEnvironmentDepthProviderCreateInfoMETA *, XrEnvironmentDepthProviderMETA *);
+    XrResult (*p_xrCreateEnvironmentDepthSwapchainMETA)(XrEnvironmentDepthProviderMETA, const XrEnvironmentDepthSwapchainCreateInfoMETA *, XrEnvironmentDepthSwapchainMETA *);
+    XrResult (*p_xrCreateExportedLocalizationMapML)(XrSession, const XrUuidEXT *, XrExportedLocalizationMapML *);
+    XrResult (*p_xrCreateEyeTrackerFB)(XrSession, const XrEyeTrackerCreateInfoFB *, XrEyeTrackerFB *);
+    XrResult (*p_xrCreateFaceTracker2FB)(XrSession, const XrFaceTrackerCreateInfo2FB *, XrFaceTracker2FB *);
+    XrResult (*p_xrCreateFaceTrackerFB)(XrSession, const XrFaceTrackerCreateInfoFB *, XrFaceTrackerFB *);
+    XrResult (*p_xrCreateFacialExpressionClientML)(XrSession, const XrFacialExpressionClientCreateInfoML *, XrFacialExpressionClientML *);
+    XrResult (*p_xrCreateFacialTrackerHTC)(XrSession, const XrFacialTrackerCreateInfoHTC *, XrFacialTrackerHTC *);
+    XrResult (*p_xrCreateFoveationProfileFB)(XrSession, const XrFoveationProfileCreateInfoFB *, XrFoveationProfileFB *);
+    XrResult (*p_xrCreateGeometryInstanceFB)(XrSession, const XrGeometryInstanceCreateInfoFB *, XrGeometryInstanceFB *);
+    XrResult (*p_xrCreateHandMeshSpaceMSFT)(XrHandTrackerEXT, const XrHandMeshSpaceCreateInfoMSFT *, XrSpace *);
+    XrResult (*p_xrCreateHandTrackerEXT)(XrSession, const XrHandTrackerCreateInfoEXT *, XrHandTrackerEXT *);
+    XrResult (*p_xrCreateKeyboardSpaceFB)(XrSession, const XrKeyboardSpaceCreateInfoFB *, XrSpace *);
+    XrResult (*p_xrCreateMarkerDetectorML)(XrSession, const XrMarkerDetectorCreateInfoML *, XrMarkerDetectorML *);
+    XrResult (*p_xrCreateMarkerSpaceML)(XrSession, const XrMarkerSpaceCreateInfoML *, XrSpace *);
+    XrResult (*p_xrCreateMarkerSpaceVARJO)(XrSession, const XrMarkerSpaceCreateInfoVARJO *, XrSpace *);
+    XrResult (*p_xrCreatePassthroughColorLutMETA)(XrPassthroughFB, const XrPassthroughColorLutCreateInfoMETA *, XrPassthroughColorLutMETA *);
+    XrResult (*p_xrCreatePassthroughFB)(XrSession, const XrPassthroughCreateInfoFB *, XrPassthroughFB *);
+    XrResult (*p_xrCreatePassthroughHTC)(XrSession, const XrPassthroughCreateInfoHTC *, XrPassthroughHTC *);
+    XrResult (*p_xrCreatePassthroughLayerFB)(XrSession, const XrPassthroughLayerCreateInfoFB *, XrPassthroughLayerFB *);
+    XrResult (*p_xrCreatePersistedAnchorSpaceANDROID)(XrDeviceAnchorPersistenceANDROID, const XrPersistedAnchorSpaceCreateInfoANDROID *, XrSpace *);
+    XrResult (*p_xrCreatePlaneDetectorEXT)(XrSession, const XrPlaneDetectorCreateInfoEXT *, XrPlaneDetectorEXT *);
+    XrResult (*p_xrCreateReferenceSpace)(XrSession, const XrReferenceSpaceCreateInfo *, XrSpace *);
+    XrResult (*p_xrCreateRenderModelAssetEXT)(XrSession, const XrRenderModelAssetCreateInfoEXT *, XrRenderModelAssetEXT *);
+    XrResult (*p_xrCreateRenderModelEXT)(XrSession, const XrRenderModelCreateInfoEXT *, XrRenderModelEXT *);
+    XrResult (*p_xrCreateRenderModelSpaceEXT)(XrSession, const XrRenderModelSpaceCreateInfoEXT *, XrSpace *);
+    XrResult (*p_xrCreateSceneMSFT)(XrSceneObserverMSFT, const XrSceneCreateInfoMSFT *, XrSceneMSFT *);
+    XrResult (*p_xrCreateSceneObserverMSFT)(XrSession, const XrSceneObserverCreateInfoMSFT *, XrSceneObserverMSFT *);
+    XrResult (*p_xrCreateSenseDataProviderBD)(XrSession, const XrSenseDataProviderCreateInfoBD *, XrSenseDataProviderBD *);
+    XrResult (*p_xrCreateSession)(XrInstance, const XrSessionCreateInfo *, XrSession *);
+    XrResult (*p_xrCreateSpaceUserFB)(XrSession, const XrSpaceUserCreateInfoFB *, XrSpaceUserFB *);
+    XrResult (*p_xrCreateSpatialAnchorAsyncBD)(XrSenseDataProviderBD, const XrSpatialAnchorCreateInfoBD *, XrFutureEXT *);
+    XrResult (*p_xrCreateSpatialAnchorCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrSpatialAnchorCreateCompletionBD *);
+    XrResult (*p_xrCreateSpatialAnchorEXT)(XrSpatialContextEXT, const XrSpatialAnchorCreateInfoEXT *, XrSpatialEntityIdEXT *, XrSpatialEntityEXT *);
+    XrResult (*p_xrCreateSpatialAnchorFB)(XrSession, const XrSpatialAnchorCreateInfoFB *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrCreateSpatialAnchorFromPersistedNameMSFT)(XrSession, const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT *, XrSpatialAnchorMSFT *);
+    XrResult (*p_xrCreateSpatialAnchorHTC)(XrSession, const XrSpatialAnchorCreateInfoHTC *, XrSpace *);
+    XrResult (*p_xrCreateSpatialAnchorMSFT)(XrSession, const XrSpatialAnchorCreateInfoMSFT *, XrSpatialAnchorMSFT *);
+    XrResult (*p_xrCreateSpatialAnchorSpaceMSFT)(XrSession, const XrSpatialAnchorSpaceCreateInfoMSFT *, XrSpace *);
+    XrResult (*p_xrCreateSpatialAnchorStoreConnectionMSFT)(XrSession, XrSpatialAnchorStoreConnectionMSFT *);
+    XrResult (*p_xrCreateSpatialAnchorsAsyncML)(XrSession, const XrSpatialAnchorsCreateInfoBaseHeaderML *, XrFutureEXT *);
+    XrResult (*p_xrCreateSpatialAnchorsCompleteML)(XrSession, XrFutureEXT, XrCreateSpatialAnchorsCompletionML *);
+    XrResult (*p_xrCreateSpatialAnchorsStorageML)(XrSession, const XrSpatialAnchorsCreateStorageInfoML *, XrSpatialAnchorsStorageML *);
+    XrResult (*p_xrCreateSpatialContextAsyncEXT)(XrSession, const XrSpatialContextCreateInfoEXT *, XrFutureEXT *);
+    XrResult (*p_xrCreateSpatialContextCompleteEXT)(XrSession, XrFutureEXT, XrCreateSpatialContextCompletionEXT *);
+    XrResult (*p_xrCreateSpatialDiscoverySnapshotAsyncEXT)(XrSpatialContextEXT, const XrSpatialDiscoverySnapshotCreateInfoEXT *, XrFutureEXT *);
+    XrResult (*p_xrCreateSpatialDiscoverySnapshotCompleteEXT)(XrSpatialContextEXT, const XrCreateSpatialDiscoverySnapshotCompletionInfoEXT *, XrCreateSpatialDiscoverySnapshotCompletionEXT *);
+    XrResult (*p_xrCreateSpatialEntityAnchorBD)(XrSenseDataProviderBD, const XrSpatialEntityAnchorCreateInfoBD *, XrAnchorBD *);
+    XrResult (*p_xrCreateSpatialEntityFromIdEXT)(XrSpatialContextEXT, const XrSpatialEntityFromIdCreateInfoEXT *, XrSpatialEntityEXT *);
+    XrResult (*p_xrCreateSpatialGraphNodeSpaceMSFT)(XrSession, const XrSpatialGraphNodeSpaceCreateInfoMSFT *, XrSpace *);
+    XrResult (*p_xrCreateSpatialPersistenceContextAsyncEXT)(XrSession, const XrSpatialPersistenceContextCreateInfoEXT *, XrFutureEXT *);
+    XrResult (*p_xrCreateSpatialPersistenceContextCompleteEXT)(XrSession, XrFutureEXT, XrCreateSpatialPersistenceContextCompletionEXT *);
+    XrResult (*p_xrCreateSpatialUpdateSnapshotEXT)(XrSpatialContextEXT, const XrSpatialUpdateSnapshotCreateInfoEXT *, XrSpatialSnapshotEXT *);
+    XrResult (*p_xrCreateSwapchain)(XrSession, const XrSwapchainCreateInfo *, XrSwapchain *);
+    XrResult (*p_xrCreateTrackableTrackerANDROID)(XrSession, const XrTrackableTrackerCreateInfoANDROID *, XrTrackableTrackerANDROID *);
+    XrResult (*p_xrCreateTriangleMeshFB)(XrSession, const XrTriangleMeshCreateInfoFB *, XrTriangleMeshFB *);
+    XrResult (*p_xrCreateVirtualKeyboardMETA)(XrSession, const XrVirtualKeyboardCreateInfoMETA *, XrVirtualKeyboardMETA *);
+    XrResult (*p_xrCreateVirtualKeyboardSpaceMETA)(XrSession, XrVirtualKeyboardMETA, const XrVirtualKeyboardSpaceCreateInfoMETA *, XrSpace *);
+    XrResult (*p_xrCreateVulkanDeviceKHR)(XrInstance, const XrVulkanDeviceCreateInfoKHR *, VkDevice *, VkResult *);
+    XrResult (*p_xrCreateVulkanInstanceKHR)(XrInstance, const XrVulkanInstanceCreateInfoKHR *, VkInstance *, VkResult *);
+    XrResult (*p_xrCreateWorldMeshDetectorML)(XrSession, const XrWorldMeshDetectorCreateInfoML *, XrWorldMeshDetectorML *);
+    XrResult (*p_xrDeleteSpatialAnchorsAsyncML)(XrSpatialAnchorsStorageML, const XrSpatialAnchorsDeleteInfoML *, XrFutureEXT *);
+    XrResult (*p_xrDeleteSpatialAnchorsCompleteML)(XrSpatialAnchorsStorageML, XrFutureEXT, XrSpatialAnchorsDeleteCompletionML *);
+    XrResult (*p_xrDeserializeSceneMSFT)(XrSceneObserverMSFT, const XrSceneDeserializeInfoMSFT *);
+    XrResult (*p_xrDestroyAction)(XrAction);
+    XrResult (*p_xrDestroyActionSet)(XrActionSet);
+    XrResult (*p_xrDestroyAnchorBD)(XrAnchorBD);
+    XrResult (*p_xrDestroyBodyTrackerBD)(XrBodyTrackerBD);
+    XrResult (*p_xrDestroyBodyTrackerFB)(XrBodyTrackerFB);
+    XrResult (*p_xrDestroyBodyTrackerHTC)(XrBodyTrackerHTC);
+    XrResult (*p_xrDestroyDeviceAnchorPersistenceANDROID)(XrDeviceAnchorPersistenceANDROID);
+    XrResult (*p_xrDestroyEnvironmentDepthProviderMETA)(XrEnvironmentDepthProviderMETA);
+    XrResult (*p_xrDestroyEnvironmentDepthSwapchainMETA)(XrEnvironmentDepthSwapchainMETA);
+    XrResult (*p_xrDestroyExportedLocalizationMapML)(XrExportedLocalizationMapML);
+    XrResult (*p_xrDestroyEyeTrackerFB)(XrEyeTrackerFB);
+    XrResult (*p_xrDestroyFaceTracker2FB)(XrFaceTracker2FB);
+    XrResult (*p_xrDestroyFaceTrackerFB)(XrFaceTrackerFB);
+    XrResult (*p_xrDestroyFacialExpressionClientML)(XrFacialExpressionClientML);
+    XrResult (*p_xrDestroyFacialTrackerHTC)(XrFacialTrackerHTC);
+    XrResult (*p_xrDestroyFoveationProfileFB)(XrFoveationProfileFB);
+    XrResult (*p_xrDestroyGeometryInstanceFB)(XrGeometryInstanceFB);
+    XrResult (*p_xrDestroyHandTrackerEXT)(XrHandTrackerEXT);
+    XrResult (*p_xrDestroyInstance)(XrInstance);
+    XrResult (*p_xrDestroyMarkerDetectorML)(XrMarkerDetectorML);
+    XrResult (*p_xrDestroyPassthroughColorLutMETA)(XrPassthroughColorLutMETA);
+    XrResult (*p_xrDestroyPassthroughFB)(XrPassthroughFB);
+    XrResult (*p_xrDestroyPassthroughHTC)(XrPassthroughHTC);
+    XrResult (*p_xrDestroyPassthroughLayerFB)(XrPassthroughLayerFB);
+    XrResult (*p_xrDestroyPlaneDetectorEXT)(XrPlaneDetectorEXT);
+    XrResult (*p_xrDestroyRenderModelAssetEXT)(XrRenderModelAssetEXT);
+    XrResult (*p_xrDestroyRenderModelEXT)(XrRenderModelEXT);
+    XrResult (*p_xrDestroySceneMSFT)(XrSceneMSFT);
+    XrResult (*p_xrDestroySceneObserverMSFT)(XrSceneObserverMSFT);
+    XrResult (*p_xrDestroySenseDataProviderBD)(XrSenseDataProviderBD);
+    XrResult (*p_xrDestroySenseDataSnapshotBD)(XrSenseDataSnapshotBD);
+    XrResult (*p_xrDestroySession)(XrSession);
+    XrResult (*p_xrDestroySpace)(XrSpace);
+    XrResult (*p_xrDestroySpaceUserFB)(XrSpaceUserFB);
+    XrResult (*p_xrDestroySpatialAnchorMSFT)(XrSpatialAnchorMSFT);
+    XrResult (*p_xrDestroySpatialAnchorStoreConnectionMSFT)(XrSpatialAnchorStoreConnectionMSFT);
+    XrResult (*p_xrDestroySpatialAnchorsStorageML)(XrSpatialAnchorsStorageML);
+    XrResult (*p_xrDestroySpatialContextEXT)(XrSpatialContextEXT);
+    XrResult (*p_xrDestroySpatialEntityEXT)(XrSpatialEntityEXT);
+    XrResult (*p_xrDestroySpatialGraphNodeBindingMSFT)(XrSpatialGraphNodeBindingMSFT);
+    XrResult (*p_xrDestroySpatialPersistenceContextEXT)(XrSpatialPersistenceContextEXT);
+    XrResult (*p_xrDestroySpatialSnapshotEXT)(XrSpatialSnapshotEXT);
+    XrResult (*p_xrDestroySwapchain)(XrSwapchain);
+    XrResult (*p_xrDestroyTrackableTrackerANDROID)(XrTrackableTrackerANDROID);
+    XrResult (*p_xrDestroyTriangleMeshFB)(XrTriangleMeshFB);
+    XrResult (*p_xrDestroyVirtualKeyboardMETA)(XrVirtualKeyboardMETA);
+    XrResult (*p_xrDestroyWorldMeshDetectorML)(XrWorldMeshDetectorML);
+    XrResult (*p_xrDiscoverSpacesMETA)(XrSession, const XrSpaceDiscoveryInfoMETA *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrDownloadSharedSpatialAnchorAsyncBD)(XrSenseDataProviderBD, const XrSharedSpatialAnchorDownloadInfoBD *, XrFutureEXT *);
+    XrResult (*p_xrDownloadSharedSpatialAnchorCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrFutureCompletionEXT *);
+    XrResult (*p_xrEnableLocalizationEventsML)(XrSession, const XrLocalizationEnableEventsInfoML *);
+    XrResult (*p_xrEnableUserCalibrationEventsML)(XrInstance, const XrUserCalibrationEnableEventsInfoML *);
+    XrResult (*p_xrEndFrame)(XrSession, const XrFrameEndInfo *);
+    XrResult (*p_xrEndSession)(XrSession);
+    XrResult (*p_xrEnumerateApiLayerProperties)(uint32_t, uint32_t *, XrApiLayerProperties *);
+    XrResult (*p_xrEnumerateBoundSourcesForAction)(XrSession, const XrBoundSourcesForActionEnumerateInfo *, uint32_t, uint32_t *, XrPath *);
+    XrResult (*p_xrEnumerateColorSpacesFB)(XrSession, uint32_t, uint32_t *, XrColorSpaceFB *);
+    XrResult (*p_xrEnumerateDisplayRefreshRatesFB)(XrSession, uint32_t, uint32_t *, float *);
+    XrResult (*p_xrEnumerateEnvironmentBlendModes)(XrInstance, XrSystemId, XrViewConfigurationType, uint32_t, uint32_t *, XrEnvironmentBlendMode *);
+    XrResult (*p_xrEnumerateEnvironmentDepthSwapchainImagesMETA)(XrEnvironmentDepthSwapchainMETA, uint32_t, uint32_t *, XrSwapchainImageBaseHeader *);
+    XrResult (*p_xrEnumerateExternalCamerasOCULUS)(XrSession, uint32_t, uint32_t *, XrExternalCameraOCULUS *);
+    XrResult (*p_xrEnumerateInteractionRenderModelIdsEXT)(XrSession, const XrInteractionRenderModelIdsEnumerateInfoEXT *, uint32_t, uint32_t *, XrRenderModelIdEXT *);
+    XrResult (*p_xrEnumeratePerformanceMetricsCounterPathsMETA)(XrInstance, uint32_t, uint32_t *, XrPath *);
+    XrResult (*p_xrEnumeratePersistedAnchorsANDROID)(XrDeviceAnchorPersistenceANDROID, uint32_t, uint32_t *, XrUuidEXT *);
+    XrResult (*p_xrEnumeratePersistedSpatialAnchorNamesMSFT)(XrSpatialAnchorStoreConnectionMSFT, uint32_t, uint32_t *, XrSpatialAnchorPersistenceNameMSFT *);
+    XrResult (*p_xrEnumerateRaycastSupportedTrackableTypesANDROID)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrTrackableTypeANDROID *);
+    XrResult (*p_xrEnumerateReferenceSpaces)(XrSession, uint32_t, uint32_t *, XrReferenceSpaceType *);
+    XrResult (*p_xrEnumerateRenderModelPathsFB)(XrSession, uint32_t, uint32_t *, XrRenderModelPathInfoFB *);
+    XrResult (*p_xrEnumerateRenderModelSubactionPathsEXT)(XrRenderModelEXT, const XrInteractionRenderModelSubactionPathInfoEXT *, uint32_t, uint32_t *, XrPath *);
+    XrResult (*p_xrEnumerateReprojectionModesMSFT)(XrInstance, XrSystemId, XrViewConfigurationType, uint32_t, uint32_t *, XrReprojectionModeMSFT *);
+    XrResult (*p_xrEnumerateSceneComputeFeaturesMSFT)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrSceneComputeFeatureMSFT *);
+    XrResult (*p_xrEnumerateSpaceSupportedComponentsFB)(XrSpace, uint32_t, uint32_t *, XrSpaceComponentTypeFB *);
+    XrResult (*p_xrEnumerateSpatialCapabilitiesEXT)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrSpatialCapabilityEXT *);
+    XrResult (*p_xrEnumerateSpatialCapabilityComponentTypesEXT)(XrInstance, XrSystemId, XrSpatialCapabilityEXT, XrSpatialCapabilityComponentTypesEXT *);
+    XrResult (*p_xrEnumerateSpatialCapabilityFeaturesEXT)(XrInstance, XrSystemId, XrSpatialCapabilityEXT, uint32_t, uint32_t *, XrSpatialCapabilityFeatureEXT *);
+    XrResult (*p_xrEnumerateSpatialEntityComponentTypesBD)(XrSenseDataSnapshotBD, XrSpatialEntityIdBD, uint32_t, uint32_t *, XrSpatialEntityComponentTypeBD *);
+    XrResult (*p_xrEnumerateSpatialPersistenceScopesEXT)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrSpatialPersistenceScopeEXT *);
+    XrResult (*p_xrEnumerateSupportedAnchorTrackableTypesANDROID)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrTrackableTypeANDROID *);
+    XrResult (*p_xrEnumerateSupportedPersistenceAnchorTypesANDROID)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrTrackableTypeANDROID *);
+    XrResult (*p_xrEnumerateSupportedTrackableTypesANDROID)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrTrackableTypeANDROID *);
+    XrResult (*p_xrEnumerateSwapchainFormats)(XrSession, uint32_t, uint32_t *, int64_t *);
+    XrResult (*p_xrEnumerateSwapchainImages)(XrSwapchain, uint32_t, uint32_t *, XrSwapchainImageBaseHeader *);
+    XrResult (*p_xrEnumerateViewConfigurationViews)(XrInstance, XrSystemId, XrViewConfigurationType, uint32_t, uint32_t *, XrViewConfigurationView *);
+    XrResult (*p_xrEnumerateViewConfigurations)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrViewConfigurationType *);
+    XrResult (*p_xrEnumerateViveTrackerPathsHTCX)(XrInstance, uint32_t, uint32_t *, XrViveTrackerPathsHTCX *);
+    XrResult (*p_xrEraseSpaceFB)(XrSession, const XrSpaceEraseInfoFB *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrEraseSpacesMETA)(XrSession, const XrSpacesEraseInfoMETA *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrFreeWorldMeshBufferML)(XrWorldMeshDetectorML, const XrWorldMeshBufferML *);
+    XrResult (*p_xrGeometryInstanceSetTransformFB)(XrGeometryInstanceFB, const XrGeometryInstanceTransformFB *);
+    XrResult (*p_xrGetActionStateBoolean)(XrSession, const XrActionStateGetInfo *, XrActionStateBoolean *);
+    XrResult (*p_xrGetActionStateFloat)(XrSession, const XrActionStateGetInfo *, XrActionStateFloat *);
+    XrResult (*p_xrGetActionStatePose)(XrSession, const XrActionStateGetInfo *, XrActionStatePose *);
+    XrResult (*p_xrGetActionStateVector2f)(XrSession, const XrActionStateGetInfo *, XrActionStateVector2f *);
+    XrResult (*p_xrGetAllTrackablesANDROID)(XrTrackableTrackerANDROID, uint32_t, uint32_t *, XrTrackableANDROID *);
+    XrResult (*p_xrGetAnchorPersistStateANDROID)(XrDeviceAnchorPersistenceANDROID, const XrUuidEXT *, XrAnchorPersistStateANDROID *);
+    XrResult (*p_xrGetAnchorUuidBD)(XrAnchorBD, XrUuidEXT *);
+    XrResult (*p_xrGetAudioInputDeviceGuidOculus)(XrInstance, wchar_t[]);
+    XrResult (*p_xrGetAudioOutputDeviceGuidOculus)(XrInstance, wchar_t[]);
+    XrResult (*p_xrGetBodySkeletonFB)(XrBodyTrackerFB, XrBodySkeletonFB *);
+    XrResult (*p_xrGetBodySkeletonHTC)(XrBodyTrackerHTC, XrSpace, uint32_t, XrBodySkeletonHTC *);
+    XrResult (*p_xrGetControllerModelKeyMSFT)(XrSession, XrPath, XrControllerModelKeyStateMSFT *);
+    XrResult (*p_xrGetControllerModelPropertiesMSFT)(XrSession, XrControllerModelKeyMSFT, XrControllerModelPropertiesMSFT *);
+    XrResult (*p_xrGetControllerModelStateMSFT)(XrSession, XrControllerModelKeyMSFT, XrControllerModelStateMSFT *);
+    XrResult (*p_xrGetCurrentInteractionProfile)(XrSession, XrPath, XrInteractionProfileState *);
+    XrResult (*p_xrGetDeviceSampleRateFB)(XrSession, const XrHapticActionInfo *, XrDevicePcmSampleRateGetInfoFB *);
+    XrResult (*p_xrGetDisplayRefreshRateFB)(XrSession, float *);
+    XrResult (*p_xrGetEnvironmentDepthSwapchainStateMETA)(XrEnvironmentDepthSwapchainMETA, XrEnvironmentDepthSwapchainStateMETA *);
+    XrResult (*p_xrGetExportedLocalizationMapDataML)(XrExportedLocalizationMapML, uint32_t, uint32_t *, char *);
+    XrResult (*p_xrGetEyeGazesFB)(XrEyeTrackerFB, const XrEyeGazesInfoFB *, XrEyeGazesFB *);
+    XrResult (*p_xrGetFaceExpressionWeights2FB)(XrFaceTracker2FB, const XrFaceExpressionInfo2FB *, XrFaceExpressionWeights2FB *);
+    XrResult (*p_xrGetFaceExpressionWeightsFB)(XrFaceTrackerFB, const XrFaceExpressionInfoFB *, XrFaceExpressionWeightsFB *);
+    XrResult (*p_xrGetFacialExpressionBlendShapePropertiesML)(XrFacialExpressionClientML, const XrFacialExpressionBlendShapeGetInfoML *, uint32_t, XrFacialExpressionBlendShapePropertiesML *);
+    XrResult (*p_xrGetFacialExpressionsHTC)(XrFacialTrackerHTC, XrFacialExpressionsHTC *);
+    XrResult (*p_xrGetFoveationEyeTrackedStateMETA)(XrSession, XrFoveationEyeTrackedStateMETA *);
+    XrResult (*p_xrGetHandMeshFB)(XrHandTrackerEXT, XrHandTrackingMeshFB *);
+    XrResult (*p_xrGetInputSourceLocalizedName)(XrSession, const XrInputSourceLocalizedNameGetInfo *, uint32_t, uint32_t *, char *);
+    XrResult (*p_xrGetInstanceProperties)(XrInstance, XrInstanceProperties *);
+    XrResult (*p_xrGetMarkerDetectorStateML)(XrMarkerDetectorML, XrMarkerDetectorStateML *);
+    XrResult (*p_xrGetMarkerLengthML)(XrMarkerDetectorML, XrMarkerML, float *);
+    XrResult (*p_xrGetMarkerNumberML)(XrMarkerDetectorML, XrMarkerML, uint64_t *);
+    XrResult (*p_xrGetMarkerReprojectionErrorML)(XrMarkerDetectorML, XrMarkerML, float *);
+    XrResult (*p_xrGetMarkerSizeVARJO)(XrSession, uint64_t, XrExtent2Df *);
+    XrResult (*p_xrGetMarkerStringML)(XrMarkerDetectorML, XrMarkerML, uint32_t, uint32_t *, char *);
+    XrResult (*p_xrGetMarkersML)(XrMarkerDetectorML, uint32_t, uint32_t *, XrMarkerML *);
+    XrResult (*p_xrGetOpenGLGraphicsRequirementsKHR)(XrInstance, XrSystemId, XrGraphicsRequirementsOpenGLKHR *);
+    XrResult (*p_xrGetPassthroughCameraStateANDROID)(XrSession, const XrPassthroughCameraStateGetInfoANDROID *, XrPassthroughCameraStateANDROID *);
+    XrResult (*p_xrGetPassthroughPreferencesMETA)(XrSession, XrPassthroughPreferencesMETA *);
+    XrResult (*p_xrGetPerformanceMetricsStateMETA)(XrSession, XrPerformanceMetricsStateMETA *);
+    XrResult (*p_xrGetPlaneDetectionStateEXT)(XrPlaneDetectorEXT, XrPlaneDetectionStateEXT *);
+    XrResult (*p_xrGetPlaneDetectionsEXT)(XrPlaneDetectorEXT, const XrPlaneDetectorGetInfoEXT *, XrPlaneDetectorLocationsEXT *);
+    XrResult (*p_xrGetPlanePolygonBufferEXT)(XrPlaneDetectorEXT, uint64_t, uint32_t, XrPlaneDetectorPolygonBufferEXT *);
+    XrResult (*p_xrGetQueriedSenseDataBD)(XrSenseDataSnapshotBD, XrQueriedSenseDataGetInfoBD *, XrQueriedSenseDataBD *);
+    XrResult (*p_xrGetRecommendedLayerResolutionMETA)(XrSession, const XrRecommendedLayerResolutionGetInfoMETA *, XrRecommendedLayerResolutionMETA *);
+    XrResult (*p_xrGetReferenceSpaceBoundsRect)(XrSession, XrReferenceSpaceType, XrExtent2Df *);
+    XrResult (*p_xrGetRenderModelAssetDataEXT)(XrRenderModelAssetEXT, const XrRenderModelAssetDataGetInfoEXT *, XrRenderModelAssetDataEXT *);
+    XrResult (*p_xrGetRenderModelAssetPropertiesEXT)(XrRenderModelAssetEXT, const XrRenderModelAssetPropertiesGetInfoEXT *, XrRenderModelAssetPropertiesEXT *);
+    XrResult (*p_xrGetRenderModelPoseTopLevelUserPathEXT)(XrRenderModelEXT, const XrInteractionRenderModelTopLevelUserPathGetInfoEXT *, XrPath *);
+    XrResult (*p_xrGetRenderModelPropertiesEXT)(XrRenderModelEXT, const XrRenderModelPropertiesGetInfoEXT *, XrRenderModelPropertiesEXT *);
+    XrResult (*p_xrGetRenderModelPropertiesFB)(XrSession, XrPath, XrRenderModelPropertiesFB *);
+    XrResult (*p_xrGetRenderModelStateEXT)(XrRenderModelEXT, const XrRenderModelStateGetInfoEXT *, XrRenderModelStateEXT *);
+    XrResult (*p_xrGetSceneComponentsMSFT)(XrSceneMSFT, const XrSceneComponentsGetInfoMSFT *, XrSceneComponentsMSFT *);
+    XrResult (*p_xrGetSceneComputeStateMSFT)(XrSceneObserverMSFT, XrSceneComputeStateMSFT *);
+    XrResult (*p_xrGetSceneMarkerDecodedStringMSFT)(XrSceneMSFT, const XrUuidMSFT *, uint32_t, uint32_t *, char *);
+    XrResult (*p_xrGetSceneMarkerRawDataMSFT)(XrSceneMSFT, const XrUuidMSFT *, uint32_t, uint32_t *, uint8_t *);
+    XrResult (*p_xrGetSceneMeshBuffersMSFT)(XrSceneMSFT, const XrSceneMeshBuffersGetInfoMSFT *, XrSceneMeshBuffersMSFT *);
+    XrResult (*p_xrGetSenseDataProviderStateBD)(XrSenseDataProviderBD, XrSenseDataProviderStateBD *);
+    XrResult (*p_xrGetSerializedSceneFragmentDataMSFT)(XrSceneMSFT, const XrSerializedSceneFragmentDataGetInfoMSFT *, uint32_t, uint32_t *, uint8_t *);
+    XrResult (*p_xrGetSpaceBoundary2DFB)(XrSession, XrSpace, XrBoundary2DFB *);
+    XrResult (*p_xrGetSpaceBoundingBox2DFB)(XrSession, XrSpace, XrRect2Df *);
+    XrResult (*p_xrGetSpaceBoundingBox3DFB)(XrSession, XrSpace, XrRect3DfFB *);
+    XrResult (*p_xrGetSpaceComponentStatusFB)(XrSpace, XrSpaceComponentTypeFB, XrSpaceComponentStatusFB *);
+    XrResult (*p_xrGetSpaceContainerFB)(XrSession, XrSpace, XrSpaceContainerFB *);
+    XrResult (*p_xrGetSpaceRoomLayoutFB)(XrSession, XrSpace, XrRoomLayoutFB *);
+    XrResult (*p_xrGetSpaceSemanticLabelsFB)(XrSession, XrSpace, XrSemanticLabelsFB *);
+    XrResult (*p_xrGetSpaceTriangleMeshMETA)(XrSpace, const XrSpaceTriangleMeshGetInfoMETA *, XrSpaceTriangleMeshMETA *);
+    XrResult (*p_xrGetSpaceUserIdFB)(XrSpaceUserFB, XrSpaceUserIdFB *);
+    XrResult (*p_xrGetSpaceUuidFB)(XrSpace, XrUuidEXT *);
+    XrResult (*p_xrGetSpatialAnchorNameHTC)(XrSpace, XrSpatialAnchorNameHTC *);
+    XrResult (*p_xrGetSpatialAnchorStateML)(XrSpace, XrSpatialAnchorStateML *);
+    XrResult (*p_xrGetSpatialBufferFloatEXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, float *);
+    XrResult (*p_xrGetSpatialBufferStringEXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, char *);
+    XrResult (*p_xrGetSpatialBufferUint16EXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, uint16_t *);
+    XrResult (*p_xrGetSpatialBufferUint32EXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, uint32_t *);
+    XrResult (*p_xrGetSpatialBufferUint8EXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, uint8_t *);
+    XrResult (*p_xrGetSpatialBufferVector2fEXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, XrVector2f *);
+    XrResult (*p_xrGetSpatialBufferVector3fEXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, XrVector3f *);
+    XrResult (*p_xrGetSpatialEntityComponentDataBD)(XrSenseDataSnapshotBD, const XrSpatialEntityComponentGetInfoBD *, XrSpatialEntityComponentDataBaseHeaderBD *);
+    XrResult (*p_xrGetSpatialEntityUuidBD)(XrSenseDataSnapshotBD, XrSpatialEntityIdBD, XrUuidEXT *);
+    XrResult (*p_xrGetSpatialGraphNodeBindingPropertiesMSFT)(XrSpatialGraphNodeBindingMSFT, const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT *, XrSpatialGraphNodeBindingPropertiesMSFT *);
+    XrResult (*p_xrGetSwapchainStateFB)(XrSwapchain, XrSwapchainStateBaseHeaderFB *);
+    XrResult (*p_xrGetSystem)(XrInstance, const XrSystemGetInfo *, XrSystemId *);
+    XrResult (*p_xrGetSystemProperties)(XrInstance, XrSystemId, XrSystemProperties *);
+    XrResult (*p_xrGetTrackableMarkerANDROID)(XrTrackableTrackerANDROID, const XrTrackableGetInfoANDROID *, XrTrackableMarkerANDROID *);
+    XrResult (*p_xrGetTrackableObjectANDROID)(XrTrackableTrackerANDROID, const XrTrackableGetInfoANDROID *, XrTrackableObjectANDROID *);
+    XrResult (*p_xrGetTrackablePlaneANDROID)(XrTrackableTrackerANDROID, const XrTrackableGetInfoANDROID *, XrTrackablePlaneANDROID *);
+    XrResult (*p_xrGetViewConfigurationProperties)(XrInstance, XrSystemId, XrViewConfigurationType, XrViewConfigurationProperties *);
+    XrResult (*p_xrGetVirtualKeyboardDirtyTexturesMETA)(XrVirtualKeyboardMETA, uint32_t, uint32_t *, uint64_t *);
+    XrResult (*p_xrGetVirtualKeyboardModelAnimationStatesMETA)(XrVirtualKeyboardMETA, XrVirtualKeyboardModelAnimationStatesMETA *);
+    XrResult (*p_xrGetVirtualKeyboardScaleMETA)(XrVirtualKeyboardMETA, float *);
+    XrResult (*p_xrGetVirtualKeyboardTextureDataMETA)(XrVirtualKeyboardMETA, uint64_t, XrVirtualKeyboardTextureDataMETA *);
+    XrResult (*p_xrGetVisibilityMaskKHR)(XrSession, XrViewConfigurationType, uint32_t, XrVisibilityMaskTypeKHR, XrVisibilityMaskKHR *);
+    XrResult (*p_xrGetVulkanDeviceExtensionsKHR)(XrInstance, XrSystemId, uint32_t, uint32_t *, char *);
+    XrResult (*p_xrGetVulkanGraphicsDevice2KHR)(XrInstance, const XrVulkanGraphicsDeviceGetInfoKHR *, VkPhysicalDevice *);
+    XrResult (*p_xrGetVulkanGraphicsDeviceKHR)(XrInstance, XrSystemId, VkInstance, VkPhysicalDevice *);
+    XrResult (*p_xrGetVulkanGraphicsRequirements2KHR)(XrInstance, XrSystemId, XrGraphicsRequirementsVulkanKHR *);
+    XrResult (*p_xrGetVulkanGraphicsRequirementsKHR)(XrInstance, XrSystemId, XrGraphicsRequirementsVulkanKHR *);
+    XrResult (*p_xrGetVulkanInstanceExtensionsKHR)(XrInstance, XrSystemId, uint32_t, uint32_t *, char *);
+    XrResult (*p_xrGetWorldMeshBufferRecommendSizeML)(XrWorldMeshDetectorML, const XrWorldMeshBufferRecommendedSizeInfoML *, XrWorldMeshBufferSizeML *);
+    XrResult (*p_xrImportLocalizationMapML)(XrSession, const XrLocalizationMapImportInfoML *, XrUuidEXT *);
+    XrResult (*p_xrLoadControllerModelMSFT)(XrSession, XrControllerModelKeyMSFT, uint32_t, uint32_t *, uint8_t *);
+    XrResult (*p_xrLoadRenderModelFB)(XrSession, const XrRenderModelLoadInfoFB *, XrRenderModelBufferFB *);
+    XrResult (*p_xrLocateBodyJointsBD)(XrBodyTrackerBD, const XrBodyJointsLocateInfoBD *, XrBodyJointLocationsBD *);
+    XrResult (*p_xrLocateBodyJointsFB)(XrBodyTrackerFB, const XrBodyJointsLocateInfoFB *, XrBodyJointLocationsFB *);
+    XrResult (*p_xrLocateBodyJointsHTC)(XrBodyTrackerHTC, const XrBodyJointsLocateInfoHTC *, XrBodyJointLocationsHTC *);
+    XrResult (*p_xrLocateHandJointsEXT)(XrHandTrackerEXT, const XrHandJointsLocateInfoEXT *, XrHandJointLocationsEXT *);
+    XrResult (*p_xrLocateSceneComponentsMSFT)(XrSceneMSFT, const XrSceneComponentsLocateInfoMSFT *, XrSceneComponentLocationsMSFT *);
+    XrResult (*p_xrLocateSpace)(XrSpace, XrSpace, XrTime, XrSpaceLocation *);
+    XrResult (*p_xrLocateSpaces)(XrSession, const XrSpacesLocateInfo *, XrSpaceLocations *);
+    XrResult (*p_xrLocateSpacesKHR)(XrSession, const XrSpacesLocateInfo *, XrSpaceLocations *);
+    XrResult (*p_xrLocateViews)(XrSession, const XrViewLocateInfo *, XrViewState *, uint32_t, uint32_t *, XrView *);
+    XrResult (*p_xrNegotiateLoaderRuntimeInterface)(const XrNegotiateLoaderInfo *, XrNegotiateRuntimeRequest *);
+    XrResult (*p_xrPassthroughLayerPauseFB)(XrPassthroughLayerFB);
+    XrResult (*p_xrPassthroughLayerResumeFB)(XrPassthroughLayerFB);
+    XrResult (*p_xrPassthroughLayerSetKeyboardHandsIntensityFB)(XrPassthroughLayerFB, const XrPassthroughKeyboardHandsIntensityFB *);
+    XrResult (*p_xrPassthroughLayerSetStyleFB)(XrPassthroughLayerFB, const XrPassthroughStyleFB *);
+    XrResult (*p_xrPassthroughPauseFB)(XrPassthroughFB);
+    XrResult (*p_xrPassthroughStartFB)(XrPassthroughFB);
+    XrResult (*p_xrPathToString)(XrInstance, XrPath, uint32_t, uint32_t *, char *);
+    XrResult (*p_xrPauseSimultaneousHandsAndControllersTrackingMETA)(XrSession, const XrSimultaneousHandsAndControllersTrackingPauseInfoMETA *);
+    XrResult (*p_xrPerfSettingsSetPerformanceLevelEXT)(XrSession, XrPerfSettingsDomainEXT, XrPerfSettingsLevelEXT);
+    XrResult (*p_xrPersistAnchorANDROID)(XrDeviceAnchorPersistenceANDROID, const XrPersistedAnchorSpaceInfoANDROID *, XrUuidEXT *);
+    XrResult (*p_xrPersistSpatialAnchorAsyncBD)(XrSenseDataProviderBD, const XrSpatialAnchorPersistInfoBD *, XrFutureEXT *);
+    XrResult (*p_xrPersistSpatialAnchorCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrFutureCompletionEXT *);
+    XrResult (*p_xrPersistSpatialAnchorMSFT)(XrSpatialAnchorStoreConnectionMSFT, const XrSpatialAnchorPersistenceInfoMSFT *);
+    XrResult (*p_xrPersistSpatialEntityAsyncEXT)(XrSpatialPersistenceContextEXT, const XrSpatialEntityPersistInfoEXT *, XrFutureEXT *);
+    XrResult (*p_xrPersistSpatialEntityCompleteEXT)(XrSpatialPersistenceContextEXT, XrFutureEXT, XrPersistSpatialEntityCompletionEXT *);
+    XrResult (*p_xrPollEvent)(XrInstance, XrEventDataBuffer *);
+    XrResult (*p_xrPollFutureEXT)(XrInstance, const XrFuturePollInfoEXT *, XrFuturePollResultEXT *);
+    XrResult (*p_xrPublishSpatialAnchorsAsyncML)(XrSpatialAnchorsStorageML, const XrSpatialAnchorsPublishInfoML *, XrFutureEXT *);
+    XrResult (*p_xrPublishSpatialAnchorsCompleteML)(XrSpatialAnchorsStorageML, XrFutureEXT, XrSpatialAnchorsPublishCompletionML *);
+    XrResult (*p_xrQueryLocalizationMapsML)(XrSession, const XrLocalizationMapQueryInfoBaseHeaderML *, uint32_t, uint32_t *, XrLocalizationMapML *);
+    XrResult (*p_xrQueryPerformanceMetricsCounterMETA)(XrSession, XrPath, XrPerformanceMetricsCounterMETA *);
+    XrResult (*p_xrQuerySenseDataAsyncBD)(XrSenseDataProviderBD, const XrSenseDataQueryInfoBD *, XrFutureEXT *);
+    XrResult (*p_xrQuerySenseDataCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrSenseDataQueryCompletionBD *);
+    XrResult (*p_xrQuerySpacesFB)(XrSession, const XrSpaceQueryInfoBaseHeaderFB *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrQuerySpatialAnchorsAsyncML)(XrSpatialAnchorsStorageML, const XrSpatialAnchorsQueryInfoBaseHeaderML *, XrFutureEXT *);
+    XrResult (*p_xrQuerySpatialAnchorsCompleteML)(XrSpatialAnchorsStorageML, XrFutureEXT, XrSpatialAnchorsQueryCompletionML *);
+    XrResult (*p_xrQuerySpatialComponentDataEXT)(XrSpatialSnapshotEXT, const XrSpatialComponentDataQueryConditionEXT *, XrSpatialComponentDataQueryResultEXT *);
+    XrResult (*p_xrQuerySystemTrackedKeyboardFB)(XrSession, const XrKeyboardTrackingQueryFB *, XrKeyboardTrackingDescriptionFB *);
+    XrResult (*p_xrRaycastANDROID)(XrSession, const XrRaycastInfoANDROID *, XrRaycastHitResultsANDROID *);
+    XrResult (*p_xrReleaseSwapchainImage)(XrSwapchain, const XrSwapchainImageReleaseInfo *);
+    XrResult (*p_xrRequestDisplayRefreshRateFB)(XrSession, float);
+    XrResult (*p_xrRequestExitSession)(XrSession);
+    XrResult (*p_xrRequestMapLocalizationML)(XrSession, const XrMapLocalizationRequestInfoML *);
+    XrResult (*p_xrRequestSceneCaptureFB)(XrSession, const XrSceneCaptureRequestInfoFB *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrRequestWorldMeshAsyncML)(XrWorldMeshDetectorML, const XrWorldMeshGetInfoML *, XrWorldMeshBufferML *, XrFutureEXT *);
+    XrResult (*p_xrRequestWorldMeshCompleteML)(XrWorldMeshDetectorML, const XrWorldMeshRequestCompletionInfoML *, XrFutureEXT, XrWorldMeshRequestCompletionML *);
+    XrResult (*p_xrRequestWorldMeshStateAsyncML)(XrWorldMeshDetectorML, const XrWorldMeshStateRequestInfoML *, XrFutureEXT *);
+    XrResult (*p_xrRequestWorldMeshStateCompleteML)(XrWorldMeshDetectorML, XrFutureEXT, XrWorldMeshStateRequestCompletionML *);
+    XrResult (*p_xrResetBodyTrackingCalibrationMETA)(XrBodyTrackerFB);
+    XrResult (*p_xrResultToString)(XrInstance, XrResult, char[]);
+    XrResult (*p_xrResumeSimultaneousHandsAndControllersTrackingMETA)(XrSession, const XrSimultaneousHandsAndControllersTrackingResumeInfoMETA *);
+    XrResult (*p_xrRetrieveSpaceDiscoveryResultsMETA)(XrSession, XrAsyncRequestIdFB, XrSpaceDiscoveryResultsMETA *);
+    XrResult (*p_xrRetrieveSpaceQueryResultsFB)(XrSession, XrAsyncRequestIdFB, XrSpaceQueryResultsFB *);
+    XrResult (*p_xrSaveSpaceFB)(XrSession, const XrSpaceSaveInfoFB *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrSaveSpaceListFB)(XrSession, const XrSpaceListSaveInfoFB *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrSaveSpacesMETA)(XrSession, const XrSpacesSaveInfoMETA *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrSendVirtualKeyboardInputMETA)(XrVirtualKeyboardMETA, const XrVirtualKeyboardInputInfoMETA *, XrPosef *);
+    XrResult (*p_xrSetColorSpaceFB)(XrSession, const XrColorSpaceFB);
+    XrResult (*p_xrSetDigitalLensControlALMALENCE)(XrSession, const XrDigitalLensControlALMALENCE *);
+    XrResult (*p_xrSetEnvironmentDepthEstimationVARJO)(XrSession, XrBool32);
+    XrResult (*p_xrSetEnvironmentDepthHandRemovalMETA)(XrEnvironmentDepthProviderMETA, const XrEnvironmentDepthHandRemovalSetInfoMETA *);
+    XrResult (*p_xrSetInputDeviceActiveEXT)(XrSession, XrPath, XrPath, XrBool32);
+    XrResult (*p_xrSetInputDeviceLocationEXT)(XrSession, XrPath, XrPath, XrSpace, XrPosef);
+    XrResult (*p_xrSetInputDeviceStateBoolEXT)(XrSession, XrPath, XrPath, XrBool32);
+    XrResult (*p_xrSetInputDeviceStateFloatEXT)(XrSession, XrPath, XrPath, float);
+    XrResult (*p_xrSetInputDeviceStateVector2fEXT)(XrSession, XrPath, XrPath, XrVector2f);
+    XrResult (*p_xrSetMarkerTrackingPredictionVARJO)(XrSession, uint64_t, XrBool32);
+    XrResult (*p_xrSetMarkerTrackingTimeoutVARJO)(XrSession, uint64_t, XrDuration);
+    XrResult (*p_xrSetMarkerTrackingVARJO)(XrSession, XrBool32);
+    XrResult (*p_xrSetPerformanceMetricsStateMETA)(XrSession, const XrPerformanceMetricsStateMETA *);
+    XrResult (*p_xrSetSpaceComponentStatusFB)(XrSpace, const XrSpaceComponentStatusSetInfoFB *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrSetSystemNotificationsML)(XrInstance, const XrSystemNotificationsSetInfoML *);
+    XrResult (*p_xrSetTrackingOptimizationSettingsHintQCOM)(XrSession, XrTrackingOptimizationSettingsDomainQCOM, XrTrackingOptimizationSettingsHintQCOM);
+    XrResult (*p_xrSetViewOffsetVARJO)(XrSession, float);
+    XrResult (*p_xrSetVirtualKeyboardModelVisibilityMETA)(XrVirtualKeyboardMETA, const XrVirtualKeyboardModelVisibilitySetInfoMETA *);
+    XrResult (*p_xrShareSpacesFB)(XrSession, const XrSpaceShareInfoFB *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrShareSpacesMETA)(XrSession, const XrShareSpacesInfoMETA *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrShareSpatialAnchorAsyncBD)(XrSenseDataProviderBD, const XrSpatialAnchorShareInfoBD *, XrFutureEXT *);
+    XrResult (*p_xrShareSpatialAnchorCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrFutureCompletionEXT *);
+    XrResult (*p_xrSnapshotMarkerDetectorML)(XrMarkerDetectorML, XrMarkerDetectorSnapshotInfoML *);
+    XrResult (*p_xrStartColocationAdvertisementMETA)(XrSession, const XrColocationAdvertisementStartInfoMETA *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrStartColocationDiscoveryMETA)(XrSession, const XrColocationDiscoveryStartInfoMETA *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrStartEnvironmentDepthProviderMETA)(XrEnvironmentDepthProviderMETA);
+    XrResult (*p_xrStartSenseDataProviderAsyncBD)(XrSenseDataProviderBD, const XrSenseDataProviderStartInfoBD *, XrFutureEXT *);
+    XrResult (*p_xrStartSenseDataProviderCompleteBD)(XrSession, XrFutureEXT, XrFutureCompletionEXT *);
+    XrResult (*p_xrStopColocationAdvertisementMETA)(XrSession, const XrColocationAdvertisementStopInfoMETA *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrStopColocationDiscoveryMETA)(XrSession, const XrColocationDiscoveryStopInfoMETA *, XrAsyncRequestIdFB *);
+    XrResult (*p_xrStopEnvironmentDepthProviderMETA)(XrEnvironmentDepthProviderMETA);
+    XrResult (*p_xrStopHapticFeedback)(XrSession, const XrHapticActionInfo *);
+    XrResult (*p_xrStopSenseDataProviderBD)(XrSenseDataProviderBD);
+    XrResult (*p_xrStringToPath)(XrInstance, const char *, XrPath *);
+    XrResult (*p_xrStructureTypeToString)(XrInstance, XrStructureType, char[]);
+    XrResult (*p_xrStructureTypeToString2KHR)(XrInstance, XrStructureType, char[]);
+    XrResult (*p_xrSuggestBodyTrackingCalibrationOverrideMETA)(XrBodyTrackerFB, const XrBodyTrackingCalibrationInfoMETA *);
+    XrResult (*p_xrSuggestInteractionProfileBindings)(XrInstance, const XrInteractionProfileSuggestedBinding *);
+    XrResult (*p_xrSuggestVirtualKeyboardLocationMETA)(XrVirtualKeyboardMETA, const XrVirtualKeyboardLocationInfoMETA *);
+    XrResult (*p_xrSyncActions)(XrSession, const XrActionsSyncInfo *);
+    XrResult (*p_xrThermalGetTemperatureTrendEXT)(XrSession, XrPerfSettingsDomainEXT, XrPerfSettingsNotificationLevelEXT *, float *, float *);
+    XrResult (*p_xrTriangleMeshBeginUpdateFB)(XrTriangleMeshFB);
+    XrResult (*p_xrTriangleMeshBeginVertexBufferUpdateFB)(XrTriangleMeshFB, uint32_t *);
+    XrResult (*p_xrTriangleMeshEndUpdateFB)(XrTriangleMeshFB, uint32_t, uint32_t);
+    XrResult (*p_xrTriangleMeshEndVertexBufferUpdateFB)(XrTriangleMeshFB);
+    XrResult (*p_xrTriangleMeshGetIndexBufferFB)(XrTriangleMeshFB, uint32_t **);
+    XrResult (*p_xrTriangleMeshGetVertexBufferFB)(XrTriangleMeshFB, XrVector3f **);
+    XrResult (*p_xrTryCreateSpatialGraphStaticNodeBindingMSFT)(XrSession, const XrSpatialGraphStaticNodeBindingCreateInfoMSFT *, XrSpatialGraphNodeBindingMSFT *);
+    XrResult (*p_xrUnpersistAnchorANDROID)(XrDeviceAnchorPersistenceANDROID, const XrUuidEXT *);
+    XrResult (*p_xrUnpersistSpatialAnchorAsyncBD)(XrSenseDataProviderBD, const XrSpatialAnchorUnpersistInfoBD *, XrFutureEXT *);
+    XrResult (*p_xrUnpersistSpatialAnchorCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrFutureCompletionEXT *);
+    XrResult (*p_xrUnpersistSpatialAnchorMSFT)(XrSpatialAnchorStoreConnectionMSFT, const XrSpatialAnchorPersistenceNameMSFT *);
+    XrResult (*p_xrUnpersistSpatialEntityAsyncEXT)(XrSpatialPersistenceContextEXT, const XrSpatialEntityUnpersistInfoEXT *, XrFutureEXT *);
+    XrResult (*p_xrUnpersistSpatialEntityCompleteEXT)(XrSpatialPersistenceContextEXT, XrFutureEXT, XrUnpersistSpatialEntityCompletionEXT *);
+    XrResult (*p_xrUpdateHandMeshMSFT)(XrHandTrackerEXT, const XrHandMeshUpdateInfoMSFT *, XrHandMeshMSFT *);
+    XrResult (*p_xrUpdatePassthroughColorLutMETA)(XrPassthroughColorLutMETA, const XrPassthroughColorLutUpdateInfoMETA *);
+    XrResult (*p_xrUpdateSpatialAnchorsExpirationAsyncML)(XrSpatialAnchorsStorageML, const XrSpatialAnchorsUpdateExpirationInfoML *, XrFutureEXT *);
+    XrResult (*p_xrUpdateSpatialAnchorsExpirationCompleteML)(XrSpatialAnchorsStorageML, XrFutureEXT, XrSpatialAnchorsUpdateExpirationCompletionML *);
+    XrResult (*p_xrUpdateSwapchainFB)(XrSwapchain, const XrSwapchainStateBaseHeaderFB *);
+    XrResult (*p_xrWaitFrame)(XrSession, const XrFrameWaitInfo *, XrFrameState *);
+    XrResult (*p_xrWaitSwapchainImage)(XrSwapchain, const XrSwapchainImageWaitInfo *);
+};
+
+#define ALL_XR_INSTANCE_FUNCS() \
+    USE_XR_FUNC(xrAcquireEnvironmentDepthImageMETA) \
+    USE_XR_FUNC(xrAcquireSwapchainImage) \
+    USE_XR_FUNC(xrAllocateWorldMeshBufferML) \
+    USE_XR_FUNC(xrApplyForceFeedbackCurlMNDX) \
+    USE_XR_FUNC(xrApplyHapticFeedback) \
+    USE_XR_FUNC(xrAttachSessionActionSets) \
+    USE_XR_FUNC(xrBeginFrame) \
+    USE_XR_FUNC(xrBeginPlaneDetectionEXT) \
+    USE_XR_FUNC(xrBeginSession) \
+    USE_XR_FUNC(xrCancelFutureEXT) \
+    USE_XR_FUNC(xrCaptureSceneAsyncBD) \
+    USE_XR_FUNC(xrCaptureSceneCompleteBD) \
+    USE_XR_FUNC(xrChangeVirtualKeyboardTextContextMETA) \
+    USE_XR_FUNC(xrClearSpatialAnchorStoreMSFT) \
+    USE_XR_FUNC(xrComputeNewSceneMSFT) \
+    USE_XR_FUNC(xrCreateAction) \
+    USE_XR_FUNC(xrCreateActionSet) \
+    USE_XR_FUNC(xrCreateActionSpace) \
+    USE_XR_FUNC(xrCreateAnchorSpaceANDROID) \
+    USE_XR_FUNC(xrCreateAnchorSpaceBD) \
+    USE_XR_FUNC(xrCreateApiLayerInstance) \
+    USE_XR_FUNC(xrCreateBodyTrackerBD) \
+    USE_XR_FUNC(xrCreateBodyTrackerFB) \
+    USE_XR_FUNC(xrCreateBodyTrackerHTC) \
+    USE_XR_FUNC(xrCreateDeviceAnchorPersistenceANDROID) \
+    USE_XR_FUNC(xrCreateEnvironmentDepthProviderMETA) \
+    USE_XR_FUNC(xrCreateEnvironmentDepthSwapchainMETA) \
+    USE_XR_FUNC(xrCreateExportedLocalizationMapML) \
+    USE_XR_FUNC(xrCreateEyeTrackerFB) \
+    USE_XR_FUNC(xrCreateFaceTracker2FB) \
+    USE_XR_FUNC(xrCreateFaceTrackerFB) \
+    USE_XR_FUNC(xrCreateFacialExpressionClientML) \
+    USE_XR_FUNC(xrCreateFacialTrackerHTC) \
+    USE_XR_FUNC(xrCreateFoveationProfileFB) \
+    USE_XR_FUNC(xrCreateGeometryInstanceFB) \
+    USE_XR_FUNC(xrCreateHandMeshSpaceMSFT) \
+    USE_XR_FUNC(xrCreateHandTrackerEXT) \
+    USE_XR_FUNC(xrCreateKeyboardSpaceFB) \
+    USE_XR_FUNC(xrCreateMarkerDetectorML) \
+    USE_XR_FUNC(xrCreateMarkerSpaceML) \
+    USE_XR_FUNC(xrCreateMarkerSpaceVARJO) \
+    USE_XR_FUNC(xrCreatePassthroughColorLutMETA) \
+    USE_XR_FUNC(xrCreatePassthroughFB) \
+    USE_XR_FUNC(xrCreatePassthroughHTC) \
+    USE_XR_FUNC(xrCreatePassthroughLayerFB) \
+    USE_XR_FUNC(xrCreatePersistedAnchorSpaceANDROID) \
+    USE_XR_FUNC(xrCreatePlaneDetectorEXT) \
+    USE_XR_FUNC(xrCreateReferenceSpace) \
+    USE_XR_FUNC(xrCreateRenderModelAssetEXT) \
+    USE_XR_FUNC(xrCreateRenderModelEXT) \
+    USE_XR_FUNC(xrCreateRenderModelSpaceEXT) \
+    USE_XR_FUNC(xrCreateSceneMSFT) \
+    USE_XR_FUNC(xrCreateSceneObserverMSFT) \
+    USE_XR_FUNC(xrCreateSenseDataProviderBD) \
+    USE_XR_FUNC(xrCreateSession) \
+    USE_XR_FUNC(xrCreateSpaceUserFB) \
+    USE_XR_FUNC(xrCreateSpatialAnchorAsyncBD) \
+    USE_XR_FUNC(xrCreateSpatialAnchorCompleteBD) \
+    USE_XR_FUNC(xrCreateSpatialAnchorEXT) \
+    USE_XR_FUNC(xrCreateSpatialAnchorFB) \
+    USE_XR_FUNC(xrCreateSpatialAnchorFromPersistedNameMSFT) \
+    USE_XR_FUNC(xrCreateSpatialAnchorHTC) \
+    USE_XR_FUNC(xrCreateSpatialAnchorMSFT) \
+    USE_XR_FUNC(xrCreateSpatialAnchorSpaceMSFT) \
+    USE_XR_FUNC(xrCreateSpatialAnchorStoreConnectionMSFT) \
+    USE_XR_FUNC(xrCreateSpatialAnchorsAsyncML) \
+    USE_XR_FUNC(xrCreateSpatialAnchorsCompleteML) \
+    USE_XR_FUNC(xrCreateSpatialAnchorsStorageML) \
+    USE_XR_FUNC(xrCreateSpatialContextAsyncEXT) \
+    USE_XR_FUNC(xrCreateSpatialContextCompleteEXT) \
+    USE_XR_FUNC(xrCreateSpatialDiscoverySnapshotAsyncEXT) \
+    USE_XR_FUNC(xrCreateSpatialDiscoverySnapshotCompleteEXT) \
+    USE_XR_FUNC(xrCreateSpatialEntityAnchorBD) \
+    USE_XR_FUNC(xrCreateSpatialEntityFromIdEXT) \
+    USE_XR_FUNC(xrCreateSpatialGraphNodeSpaceMSFT) \
+    USE_XR_FUNC(xrCreateSpatialPersistenceContextAsyncEXT) \
+    USE_XR_FUNC(xrCreateSpatialPersistenceContextCompleteEXT) \
+    USE_XR_FUNC(xrCreateSpatialUpdateSnapshotEXT) \
+    USE_XR_FUNC(xrCreateSwapchain) \
+    USE_XR_FUNC(xrCreateTrackableTrackerANDROID) \
+    USE_XR_FUNC(xrCreateTriangleMeshFB) \
+    USE_XR_FUNC(xrCreateVirtualKeyboardMETA) \
+    USE_XR_FUNC(xrCreateVirtualKeyboardSpaceMETA) \
+    USE_XR_FUNC(xrCreateVulkanDeviceKHR) \
+    USE_XR_FUNC(xrCreateVulkanInstanceKHR) \
+    USE_XR_FUNC(xrCreateWorldMeshDetectorML) \
+    USE_XR_FUNC(xrDeleteSpatialAnchorsAsyncML) \
+    USE_XR_FUNC(xrDeleteSpatialAnchorsCompleteML) \
+    USE_XR_FUNC(xrDeserializeSceneMSFT) \
+    USE_XR_FUNC(xrDestroyAction) \
+    USE_XR_FUNC(xrDestroyActionSet) \
+    USE_XR_FUNC(xrDestroyAnchorBD) \
+    USE_XR_FUNC(xrDestroyBodyTrackerBD) \
+    USE_XR_FUNC(xrDestroyBodyTrackerFB) \
+    USE_XR_FUNC(xrDestroyBodyTrackerHTC) \
+    USE_XR_FUNC(xrDestroyDeviceAnchorPersistenceANDROID) \
+    USE_XR_FUNC(xrDestroyEnvironmentDepthProviderMETA) \
+    USE_XR_FUNC(xrDestroyEnvironmentDepthSwapchainMETA) \
+    USE_XR_FUNC(xrDestroyExportedLocalizationMapML) \
+    USE_XR_FUNC(xrDestroyEyeTrackerFB) \
+    USE_XR_FUNC(xrDestroyFaceTracker2FB) \
+    USE_XR_FUNC(xrDestroyFaceTrackerFB) \
+    USE_XR_FUNC(xrDestroyFacialExpressionClientML) \
+    USE_XR_FUNC(xrDestroyFacialTrackerHTC) \
+    USE_XR_FUNC(xrDestroyFoveationProfileFB) \
+    USE_XR_FUNC(xrDestroyGeometryInstanceFB) \
+    USE_XR_FUNC(xrDestroyHandTrackerEXT) \
+    USE_XR_FUNC(xrDestroyInstance) \
+    USE_XR_FUNC(xrDestroyMarkerDetectorML) \
+    USE_XR_FUNC(xrDestroyPassthroughColorLutMETA) \
+    USE_XR_FUNC(xrDestroyPassthroughFB) \
+    USE_XR_FUNC(xrDestroyPassthroughHTC) \
+    USE_XR_FUNC(xrDestroyPassthroughLayerFB) \
+    USE_XR_FUNC(xrDestroyPlaneDetectorEXT) \
+    USE_XR_FUNC(xrDestroyRenderModelAssetEXT) \
+    USE_XR_FUNC(xrDestroyRenderModelEXT) \
+    USE_XR_FUNC(xrDestroySceneMSFT) \
+    USE_XR_FUNC(xrDestroySceneObserverMSFT) \
+    USE_XR_FUNC(xrDestroySenseDataProviderBD) \
+    USE_XR_FUNC(xrDestroySenseDataSnapshotBD) \
+    USE_XR_FUNC(xrDestroySession) \
+    USE_XR_FUNC(xrDestroySpace) \
+    USE_XR_FUNC(xrDestroySpaceUserFB) \
+    USE_XR_FUNC(xrDestroySpatialAnchorMSFT) \
+    USE_XR_FUNC(xrDestroySpatialAnchorStoreConnectionMSFT) \
+    USE_XR_FUNC(xrDestroySpatialAnchorsStorageML) \
+    USE_XR_FUNC(xrDestroySpatialContextEXT) \
+    USE_XR_FUNC(xrDestroySpatialEntityEXT) \
+    USE_XR_FUNC(xrDestroySpatialGraphNodeBindingMSFT) \
+    USE_XR_FUNC(xrDestroySpatialPersistenceContextEXT) \
+    USE_XR_FUNC(xrDestroySpatialSnapshotEXT) \
+    USE_XR_FUNC(xrDestroySwapchain) \
+    USE_XR_FUNC(xrDestroyTrackableTrackerANDROID) \
+    USE_XR_FUNC(xrDestroyTriangleMeshFB) \
+    USE_XR_FUNC(xrDestroyVirtualKeyboardMETA) \
+    USE_XR_FUNC(xrDestroyWorldMeshDetectorML) \
+    USE_XR_FUNC(xrDiscoverSpacesMETA) \
+    USE_XR_FUNC(xrDownloadSharedSpatialAnchorAsyncBD) \
+    USE_XR_FUNC(xrDownloadSharedSpatialAnchorCompleteBD) \
+    USE_XR_FUNC(xrEnableLocalizationEventsML) \
+    USE_XR_FUNC(xrEnableUserCalibrationEventsML) \
+    USE_XR_FUNC(xrEndFrame) \
+    USE_XR_FUNC(xrEndSession) \
+    USE_XR_FUNC(xrEnumerateApiLayerProperties) \
+    USE_XR_FUNC(xrEnumerateBoundSourcesForAction) \
+    USE_XR_FUNC(xrEnumerateColorSpacesFB) \
+    USE_XR_FUNC(xrEnumerateDisplayRefreshRatesFB) \
+    USE_XR_FUNC(xrEnumerateEnvironmentBlendModes) \
+    USE_XR_FUNC(xrEnumerateEnvironmentDepthSwapchainImagesMETA) \
+    USE_XR_FUNC(xrEnumerateExternalCamerasOCULUS) \
+    USE_XR_FUNC(xrEnumerateInteractionRenderModelIdsEXT) \
+    USE_XR_FUNC(xrEnumeratePerformanceMetricsCounterPathsMETA) \
+    USE_XR_FUNC(xrEnumeratePersistedAnchorsANDROID) \
+    USE_XR_FUNC(xrEnumeratePersistedSpatialAnchorNamesMSFT) \
+    USE_XR_FUNC(xrEnumerateRaycastSupportedTrackableTypesANDROID) \
+    USE_XR_FUNC(xrEnumerateReferenceSpaces) \
+    USE_XR_FUNC(xrEnumerateRenderModelPathsFB) \
+    USE_XR_FUNC(xrEnumerateRenderModelSubactionPathsEXT) \
+    USE_XR_FUNC(xrEnumerateReprojectionModesMSFT) \
+    USE_XR_FUNC(xrEnumerateSceneComputeFeaturesMSFT) \
+    USE_XR_FUNC(xrEnumerateSpaceSupportedComponentsFB) \
+    USE_XR_FUNC(xrEnumerateSpatialCapabilitiesEXT) \
+    USE_XR_FUNC(xrEnumerateSpatialCapabilityComponentTypesEXT) \
+    USE_XR_FUNC(xrEnumerateSpatialCapabilityFeaturesEXT) \
+    USE_XR_FUNC(xrEnumerateSpatialEntityComponentTypesBD) \
+    USE_XR_FUNC(xrEnumerateSpatialPersistenceScopesEXT) \
+    USE_XR_FUNC(xrEnumerateSupportedAnchorTrackableTypesANDROID) \
+    USE_XR_FUNC(xrEnumerateSupportedPersistenceAnchorTypesANDROID) \
+    USE_XR_FUNC(xrEnumerateSupportedTrackableTypesANDROID) \
+    USE_XR_FUNC(xrEnumerateSwapchainFormats) \
+    USE_XR_FUNC(xrEnumerateSwapchainImages) \
+    USE_XR_FUNC(xrEnumerateViewConfigurationViews) \
+    USE_XR_FUNC(xrEnumerateViewConfigurations) \
+    USE_XR_FUNC(xrEnumerateViveTrackerPathsHTCX) \
+    USE_XR_FUNC(xrEraseSpaceFB) \
+    USE_XR_FUNC(xrEraseSpacesMETA) \
+    USE_XR_FUNC(xrFreeWorldMeshBufferML) \
+    USE_XR_FUNC(xrGeometryInstanceSetTransformFB) \
+    USE_XR_FUNC(xrGetActionStateBoolean) \
+    USE_XR_FUNC(xrGetActionStateFloat) \
+    USE_XR_FUNC(xrGetActionStatePose) \
+    USE_XR_FUNC(xrGetActionStateVector2f) \
+    USE_XR_FUNC(xrGetAllTrackablesANDROID) \
+    USE_XR_FUNC(xrGetAnchorPersistStateANDROID) \
+    USE_XR_FUNC(xrGetAnchorUuidBD) \
+    USE_XR_FUNC(xrGetAudioInputDeviceGuidOculus) \
+    USE_XR_FUNC(xrGetAudioOutputDeviceGuidOculus) \
+    USE_XR_FUNC(xrGetBodySkeletonFB) \
+    USE_XR_FUNC(xrGetBodySkeletonHTC) \
+    USE_XR_FUNC(xrGetControllerModelKeyMSFT) \
+    USE_XR_FUNC(xrGetControllerModelPropertiesMSFT) \
+    USE_XR_FUNC(xrGetControllerModelStateMSFT) \
+    USE_XR_FUNC(xrGetCurrentInteractionProfile) \
+    USE_XR_FUNC(xrGetDeviceSampleRateFB) \
+    USE_XR_FUNC(xrGetDisplayRefreshRateFB) \
+    USE_XR_FUNC(xrGetEnvironmentDepthSwapchainStateMETA) \
+    USE_XR_FUNC(xrGetExportedLocalizationMapDataML) \
+    USE_XR_FUNC(xrGetEyeGazesFB) \
+    USE_XR_FUNC(xrGetFaceExpressionWeights2FB) \
+    USE_XR_FUNC(xrGetFaceExpressionWeightsFB) \
+    USE_XR_FUNC(xrGetFacialExpressionBlendShapePropertiesML) \
+    USE_XR_FUNC(xrGetFacialExpressionsHTC) \
+    USE_XR_FUNC(xrGetFoveationEyeTrackedStateMETA) \
+    USE_XR_FUNC(xrGetHandMeshFB) \
+    USE_XR_FUNC(xrGetInputSourceLocalizedName) \
+    USE_XR_FUNC(xrGetInstanceProperties) \
+    USE_XR_FUNC(xrGetMarkerDetectorStateML) \
+    USE_XR_FUNC(xrGetMarkerLengthML) \
+    USE_XR_FUNC(xrGetMarkerNumberML) \
+    USE_XR_FUNC(xrGetMarkerReprojectionErrorML) \
+    USE_XR_FUNC(xrGetMarkerSizeVARJO) \
+    USE_XR_FUNC(xrGetMarkerStringML) \
+    USE_XR_FUNC(xrGetMarkersML) \
+    USE_XR_FUNC(xrGetOpenGLGraphicsRequirementsKHR) \
+    USE_XR_FUNC(xrGetPassthroughCameraStateANDROID) \
+    USE_XR_FUNC(xrGetPassthroughPreferencesMETA) \
+    USE_XR_FUNC(xrGetPerformanceMetricsStateMETA) \
+    USE_XR_FUNC(xrGetPlaneDetectionStateEXT) \
+    USE_XR_FUNC(xrGetPlaneDetectionsEXT) \
+    USE_XR_FUNC(xrGetPlanePolygonBufferEXT) \
+    USE_XR_FUNC(xrGetQueriedSenseDataBD) \
+    USE_XR_FUNC(xrGetRecommendedLayerResolutionMETA) \
+    USE_XR_FUNC(xrGetReferenceSpaceBoundsRect) \
+    USE_XR_FUNC(xrGetRenderModelAssetDataEXT) \
+    USE_XR_FUNC(xrGetRenderModelAssetPropertiesEXT) \
+    USE_XR_FUNC(xrGetRenderModelPoseTopLevelUserPathEXT) \
+    USE_XR_FUNC(xrGetRenderModelPropertiesEXT) \
+    USE_XR_FUNC(xrGetRenderModelPropertiesFB) \
+    USE_XR_FUNC(xrGetRenderModelStateEXT) \
+    USE_XR_FUNC(xrGetSceneComponentsMSFT) \
+    USE_XR_FUNC(xrGetSceneComputeStateMSFT) \
+    USE_XR_FUNC(xrGetSceneMarkerDecodedStringMSFT) \
+    USE_XR_FUNC(xrGetSceneMarkerRawDataMSFT) \
+    USE_XR_FUNC(xrGetSceneMeshBuffersMSFT) \
+    USE_XR_FUNC(xrGetSenseDataProviderStateBD) \
+    USE_XR_FUNC(xrGetSerializedSceneFragmentDataMSFT) \
+    USE_XR_FUNC(xrGetSpaceBoundary2DFB) \
+    USE_XR_FUNC(xrGetSpaceBoundingBox2DFB) \
+    USE_XR_FUNC(xrGetSpaceBoundingBox3DFB) \
+    USE_XR_FUNC(xrGetSpaceComponentStatusFB) \
+    USE_XR_FUNC(xrGetSpaceContainerFB) \
+    USE_XR_FUNC(xrGetSpaceRoomLayoutFB) \
+    USE_XR_FUNC(xrGetSpaceSemanticLabelsFB) \
+    USE_XR_FUNC(xrGetSpaceTriangleMeshMETA) \
+    USE_XR_FUNC(xrGetSpaceUserIdFB) \
+    USE_XR_FUNC(xrGetSpaceUuidFB) \
+    USE_XR_FUNC(xrGetSpatialAnchorNameHTC) \
+    USE_XR_FUNC(xrGetSpatialAnchorStateML) \
+    USE_XR_FUNC(xrGetSpatialBufferFloatEXT) \
+    USE_XR_FUNC(xrGetSpatialBufferStringEXT) \
+    USE_XR_FUNC(xrGetSpatialBufferUint16EXT) \
+    USE_XR_FUNC(xrGetSpatialBufferUint32EXT) \
+    USE_XR_FUNC(xrGetSpatialBufferUint8EXT) \
+    USE_XR_FUNC(xrGetSpatialBufferVector2fEXT) \
+    USE_XR_FUNC(xrGetSpatialBufferVector3fEXT) \
+    USE_XR_FUNC(xrGetSpatialEntityComponentDataBD) \
+    USE_XR_FUNC(xrGetSpatialEntityUuidBD) \
+    USE_XR_FUNC(xrGetSpatialGraphNodeBindingPropertiesMSFT) \
+    USE_XR_FUNC(xrGetSwapchainStateFB) \
+    USE_XR_FUNC(xrGetSystem) \
+    USE_XR_FUNC(xrGetSystemProperties) \
+    USE_XR_FUNC(xrGetTrackableMarkerANDROID) \
+    USE_XR_FUNC(xrGetTrackableObjectANDROID) \
+    USE_XR_FUNC(xrGetTrackablePlaneANDROID) \
+    USE_XR_FUNC(xrGetViewConfigurationProperties) \
+    USE_XR_FUNC(xrGetVirtualKeyboardDirtyTexturesMETA) \
+    USE_XR_FUNC(xrGetVirtualKeyboardModelAnimationStatesMETA) \
+    USE_XR_FUNC(xrGetVirtualKeyboardScaleMETA) \
+    USE_XR_FUNC(xrGetVirtualKeyboardTextureDataMETA) \
+    USE_XR_FUNC(xrGetVisibilityMaskKHR) \
+    USE_XR_FUNC(xrGetVulkanDeviceExtensionsKHR) \
+    USE_XR_FUNC(xrGetVulkanGraphicsDevice2KHR) \
+    USE_XR_FUNC(xrGetVulkanGraphicsDeviceKHR) \
+    USE_XR_FUNC(xrGetVulkanGraphicsRequirements2KHR) \
+    USE_XR_FUNC(xrGetVulkanGraphicsRequirementsKHR) \
+    USE_XR_FUNC(xrGetVulkanInstanceExtensionsKHR) \
+    USE_XR_FUNC(xrGetWorldMeshBufferRecommendSizeML) \
+    USE_XR_FUNC(xrImportLocalizationMapML) \
+    USE_XR_FUNC(xrLoadControllerModelMSFT) \
+    USE_XR_FUNC(xrLoadRenderModelFB) \
+    USE_XR_FUNC(xrLocateBodyJointsBD) \
+    USE_XR_FUNC(xrLocateBodyJointsFB) \
+    USE_XR_FUNC(xrLocateBodyJointsHTC) \
+    USE_XR_FUNC(xrLocateHandJointsEXT) \
+    USE_XR_FUNC(xrLocateSceneComponentsMSFT) \
+    USE_XR_FUNC(xrLocateSpace) \
+    USE_XR_FUNC(xrLocateSpaces) \
+    USE_XR_FUNC(xrLocateSpacesKHR) \
+    USE_XR_FUNC(xrLocateViews) \
+    USE_XR_FUNC(xrNegotiateLoaderRuntimeInterface) \
+    USE_XR_FUNC(xrPassthroughLayerPauseFB) \
+    USE_XR_FUNC(xrPassthroughLayerResumeFB) \
+    USE_XR_FUNC(xrPassthroughLayerSetKeyboardHandsIntensityFB) \
+    USE_XR_FUNC(xrPassthroughLayerSetStyleFB) \
+    USE_XR_FUNC(xrPassthroughPauseFB) \
+    USE_XR_FUNC(xrPassthroughStartFB) \
+    USE_XR_FUNC(xrPathToString) \
+    USE_XR_FUNC(xrPauseSimultaneousHandsAndControllersTrackingMETA) \
+    USE_XR_FUNC(xrPerfSettingsSetPerformanceLevelEXT) \
+    USE_XR_FUNC(xrPersistAnchorANDROID) \
+    USE_XR_FUNC(xrPersistSpatialAnchorAsyncBD) \
+    USE_XR_FUNC(xrPersistSpatialAnchorCompleteBD) \
+    USE_XR_FUNC(xrPersistSpatialAnchorMSFT) \
+    USE_XR_FUNC(xrPersistSpatialEntityAsyncEXT) \
+    USE_XR_FUNC(xrPersistSpatialEntityCompleteEXT) \
+    USE_XR_FUNC(xrPollEvent) \
+    USE_XR_FUNC(xrPollFutureEXT) \
+    USE_XR_FUNC(xrPublishSpatialAnchorsAsyncML) \
+    USE_XR_FUNC(xrPublishSpatialAnchorsCompleteML) \
+    USE_XR_FUNC(xrQueryLocalizationMapsML) \
+    USE_XR_FUNC(xrQueryPerformanceMetricsCounterMETA) \
+    USE_XR_FUNC(xrQuerySenseDataAsyncBD) \
+    USE_XR_FUNC(xrQuerySenseDataCompleteBD) \
+    USE_XR_FUNC(xrQuerySpacesFB) \
+    USE_XR_FUNC(xrQuerySpatialAnchorsAsyncML) \
+    USE_XR_FUNC(xrQuerySpatialAnchorsCompleteML) \
+    USE_XR_FUNC(xrQuerySpatialComponentDataEXT) \
+    USE_XR_FUNC(xrQuerySystemTrackedKeyboardFB) \
+    USE_XR_FUNC(xrRaycastANDROID) \
+    USE_XR_FUNC(xrReleaseSwapchainImage) \
+    USE_XR_FUNC(xrRequestDisplayRefreshRateFB) \
+    USE_XR_FUNC(xrRequestExitSession) \
+    USE_XR_FUNC(xrRequestMapLocalizationML) \
+    USE_XR_FUNC(xrRequestSceneCaptureFB) \
+    USE_XR_FUNC(xrRequestWorldMeshAsyncML) \
+    USE_XR_FUNC(xrRequestWorldMeshCompleteML) \
+    USE_XR_FUNC(xrRequestWorldMeshStateAsyncML) \
+    USE_XR_FUNC(xrRequestWorldMeshStateCompleteML) \
+    USE_XR_FUNC(xrResetBodyTrackingCalibrationMETA) \
+    USE_XR_FUNC(xrResultToString) \
+    USE_XR_FUNC(xrResumeSimultaneousHandsAndControllersTrackingMETA) \
+    USE_XR_FUNC(xrRetrieveSpaceDiscoveryResultsMETA) \
+    USE_XR_FUNC(xrRetrieveSpaceQueryResultsFB) \
+    USE_XR_FUNC(xrSaveSpaceFB) \
+    USE_XR_FUNC(xrSaveSpaceListFB) \
+    USE_XR_FUNC(xrSaveSpacesMETA) \
+    USE_XR_FUNC(xrSendVirtualKeyboardInputMETA) \
+    USE_XR_FUNC(xrSetColorSpaceFB) \
+    USE_XR_FUNC(xrSetDigitalLensControlALMALENCE) \
+    USE_XR_FUNC(xrSetEnvironmentDepthEstimationVARJO) \
+    USE_XR_FUNC(xrSetEnvironmentDepthHandRemovalMETA) \
+    USE_XR_FUNC(xrSetInputDeviceActiveEXT) \
+    USE_XR_FUNC(xrSetInputDeviceLocationEXT) \
+    USE_XR_FUNC(xrSetInputDeviceStateBoolEXT) \
+    USE_XR_FUNC(xrSetInputDeviceStateFloatEXT) \
+    USE_XR_FUNC(xrSetInputDeviceStateVector2fEXT) \
+    USE_XR_FUNC(xrSetMarkerTrackingPredictionVARJO) \
+    USE_XR_FUNC(xrSetMarkerTrackingTimeoutVARJO) \
+    USE_XR_FUNC(xrSetMarkerTrackingVARJO) \
+    USE_XR_FUNC(xrSetPerformanceMetricsStateMETA) \
+    USE_XR_FUNC(xrSetSpaceComponentStatusFB) \
+    USE_XR_FUNC(xrSetSystemNotificationsML) \
+    USE_XR_FUNC(xrSetTrackingOptimizationSettingsHintQCOM) \
+    USE_XR_FUNC(xrSetViewOffsetVARJO) \
+    USE_XR_FUNC(xrSetVirtualKeyboardModelVisibilityMETA) \
+    USE_XR_FUNC(xrShareSpacesFB) \
+    USE_XR_FUNC(xrShareSpacesMETA) \
+    USE_XR_FUNC(xrShareSpatialAnchorAsyncBD) \
+    USE_XR_FUNC(xrShareSpatialAnchorCompleteBD) \
+    USE_XR_FUNC(xrSnapshotMarkerDetectorML) \
+    USE_XR_FUNC(xrStartColocationAdvertisementMETA) \
+    USE_XR_FUNC(xrStartColocationDiscoveryMETA) \
+    USE_XR_FUNC(xrStartEnvironmentDepthProviderMETA) \
+    USE_XR_FUNC(xrStartSenseDataProviderAsyncBD) \
+    USE_XR_FUNC(xrStartSenseDataProviderCompleteBD) \
+    USE_XR_FUNC(xrStopColocationAdvertisementMETA) \
+    USE_XR_FUNC(xrStopColocationDiscoveryMETA) \
+    USE_XR_FUNC(xrStopEnvironmentDepthProviderMETA) \
+    USE_XR_FUNC(xrStopHapticFeedback) \
+    USE_XR_FUNC(xrStopSenseDataProviderBD) \
+    USE_XR_FUNC(xrStringToPath) \
+    USE_XR_FUNC(xrStructureTypeToString) \
+    USE_XR_FUNC(xrStructureTypeToString2KHR) \
+    USE_XR_FUNC(xrSuggestBodyTrackingCalibrationOverrideMETA) \
+    USE_XR_FUNC(xrSuggestInteractionProfileBindings) \
+    USE_XR_FUNC(xrSuggestVirtualKeyboardLocationMETA) \
+    USE_XR_FUNC(xrSyncActions) \
+    USE_XR_FUNC(xrThermalGetTemperatureTrendEXT) \
+    USE_XR_FUNC(xrTriangleMeshBeginUpdateFB) \
+    USE_XR_FUNC(xrTriangleMeshBeginVertexBufferUpdateFB) \
+    USE_XR_FUNC(xrTriangleMeshEndUpdateFB) \
+    USE_XR_FUNC(xrTriangleMeshEndVertexBufferUpdateFB) \
+    USE_XR_FUNC(xrTriangleMeshGetIndexBufferFB) \
+    USE_XR_FUNC(xrTriangleMeshGetVertexBufferFB) \
+    USE_XR_FUNC(xrTryCreateSpatialGraphStaticNodeBindingMSFT) \
+    USE_XR_FUNC(xrUnpersistAnchorANDROID) \
+    USE_XR_FUNC(xrUnpersistSpatialAnchorAsyncBD) \
+    USE_XR_FUNC(xrUnpersistSpatialAnchorCompleteBD) \
+    USE_XR_FUNC(xrUnpersistSpatialAnchorMSFT) \
+    USE_XR_FUNC(xrUnpersistSpatialEntityAsyncEXT) \
+    USE_XR_FUNC(xrUnpersistSpatialEntityCompleteEXT) \
+    USE_XR_FUNC(xrUpdateHandMeshMSFT) \
+    USE_XR_FUNC(xrUpdatePassthroughColorLutMETA) \
+    USE_XR_FUNC(xrUpdateSpatialAnchorsExpirationAsyncML) \
+    USE_XR_FUNC(xrUpdateSpatialAnchorsExpirationCompleteML) \
+    USE_XR_FUNC(xrUpdateSwapchainFB) \
+    USE_XR_FUNC(xrWaitFrame) \
+    USE_XR_FUNC(xrWaitSwapchainImage)
+
+#endif /* __WINE_OPENXR_THUNKS_H */
diff --git a/dlls/wineopenxr/vkd3d-proton-interop.h b/dlls/wineopenxr/vkd3d-proton-interop.h
new file mode 100644
index 00000000000..d948090ba80
--- /dev/null
+++ b/dlls/wineopenxr/vkd3d-proton-interop.h
@@ -0,0 +1,308 @@
+/*** Partially copied from autogenerated header by WIDL 6.4 from ../src-vkd3d-proton/include/vkd3d_device_vkd3d_ext.idl ***/
+
+#pragma once
+
+#include <d3d12.h>
+#ifdef __WINESRC__
+#include "wine/vulkan.h"
+#else
+#include <vulkan/vulkan.h>
+#endif
+
+#ifndef __ID3D12DeviceExt1_FWD_DEFINED__
+#define __ID3D12DeviceExt1_FWD_DEFINED__
+typedef interface ID3D12DeviceExt1 ID3D12DeviceExt1;
+#endif
+
+#ifndef __ID3D12DXVKInteropDevice_FWD_DEFINED__
+#define __ID3D12DXVKInteropDevice_FWD_DEFINED__
+typedef interface ID3D12DXVKInteropDevice ID3D12DXVKInteropDevice;
+#endif
+
+#ifndef __ID3D12DXVKInteropDevice2_FWD_DEFINED__
+#define __ID3D12DXVKInteropDevice2_FWD_DEFINED__
+typedef interface ID3D12DXVKInteropDevice2 ID3D12DXVKInteropDevice2;
+#endif
+
+/*****************************************************************************
+ * ID3D12DeviceExt1 interface
+ */
+#ifndef __ID3D12DeviceExt1_INTERFACE_DEFINED__
+#define __ID3D12DeviceExt1_INTERFACE_DEFINED__
+typedef struct D3D12_UAV_INFO D3D12_UAV_INFO;
+typedef struct D3D12_VK_EXTENSION D3D12_VK_EXTENSION;
+typedef struct D3D12_CUBIN_DATA_HANDLE D3D12_CUBIN_DATA_HANDLE;
+
+DEFINE_GUID(IID_ID3D12DeviceExt1, 0x099a73fd, 0x2199, 0x4f45, 0xbf,0x48, 0x0e,0xb8,0x6f,0x6f,0xdb,0x65);
+typedef struct ID3D12DeviceExt1Vtbl {
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        ID3D12DeviceExt1 *This,
+        REFIID riid,
+        void **object);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        ID3D12DeviceExt1 *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        ID3D12DeviceExt1 *This);
+
+    /*** ID3D12DeviceExt methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetVulkanHandles)(
+        ID3D12DeviceExt1 *This,
+        VkInstance *vk_instance,
+        VkPhysicalDevice *vk_physical_device,
+        VkDevice *vk_device);
+
+    BOOL (STDMETHODCALLTYPE *GetExtensionSupport)(
+        ID3D12DeviceExt1 *This,
+        D3D12_VK_EXTENSION extension);
+
+    HRESULT (STDMETHODCALLTYPE *CreateCubinComputeShaderWithName)(
+        ID3D12DeviceExt1 *This,
+        const void *cubin_data,
+        UINT32 cubin_size,
+        UINT32 block_x,
+        UINT32 block_y,
+        UINT32 block_z,
+        const char *shader_name,
+        D3D12_CUBIN_DATA_HANDLE **handle);
+
+    HRESULT (STDMETHODCALLTYPE *DestroyCubinComputeShader)(
+        ID3D12DeviceExt1 *This,
+        D3D12_CUBIN_DATA_HANDLE *handle);
+
+    HRESULT (STDMETHODCALLTYPE *GetCudaTextureObject)(
+        ID3D12DeviceExt1 *This,
+        D3D12_CPU_DESCRIPTOR_HANDLE srv_handle,
+        D3D12_CPU_DESCRIPTOR_HANDLE sampler_handle,
+        UINT32 *cuda_texture_handle);
+
+    HRESULT (STDMETHODCALLTYPE *GetCudaSurfaceObject)(
+        ID3D12DeviceExt1 *This,
+        D3D12_CPU_DESCRIPTOR_HANDLE uav_handle,
+        UINT32 *cuda_surface_handle);
+
+    HRESULT (STDMETHODCALLTYPE *CaptureUAVInfo)(
+        ID3D12DeviceExt1 *This,
+        D3D12_UAV_INFO *uav_info);
+
+    /*** ID3D12DeviceExt1 methods ***/
+    HRESULT (STDMETHODCALLTYPE *CreateResourceFromBorrowedHandle)(
+        ID3D12DeviceExt1 *This,
+        const D3D12_RESOURCE_DESC1 *desc,
+        UINT64 vk_handle,
+        ID3D12Resource **resource);
+
+    HRESULT (STDMETHODCALLTYPE *GetVulkanQueueInfoEx)(
+        ID3D12DeviceExt1 *This,
+        ID3D12CommandQueue *queue,
+        VkQueue *vk_queue,
+        UINT32 *vk_queue_index,
+        UINT32 *vk_queue_flags,
+        UINT32 *vk_queue_family);
+
+    END_INTERFACE
+} ID3D12DeviceExt1Vtbl;
+
+interface ID3D12DeviceExt1 {
+    CONST_VTBL ID3D12DeviceExt1Vtbl* lpVtbl;
+};
+#endif
+
+/*****************************************************************************
+ * ID3D12DXVKInteropDevice interface
+ */
+#ifndef __ID3D12DXVKInteropDevice_INTERFACE_DEFINED__
+#define __ID3D12DXVKInteropDevice_INTERFACE_DEFINED__
+
+DEFINE_GUID(IID_ID3D12DXVKInteropDevice, 0x39da4e09, 0xbd1c, 0x4198, 0x9f,0xae, 0x86,0xbb,0xe3,0xbe,0x41,0xfd);
+typedef struct ID3D12DXVKInteropDeviceVtbl {
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        ID3D12DXVKInteropDevice *This,
+        REFIID riid,
+        void **object);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        ID3D12DXVKInteropDevice *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        ID3D12DXVKInteropDevice *This);
+
+    /*** ID3D12DXVKInteropDevice methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetDXGIAdapter)(
+        ID3D12DXVKInteropDevice *This,
+        REFIID iid,
+        void **object);
+
+    HRESULT (STDMETHODCALLTYPE *GetInstanceExtensions)(
+        ID3D12DXVKInteropDevice *This,
+        UINT *extension_count,
+        const char **extensions);
+
+    HRESULT (STDMETHODCALLTYPE *GetDeviceExtensions)(
+        ID3D12DXVKInteropDevice *This,
+        UINT *extension_count,
+        const char **extensions);
+
+    HRESULT (STDMETHODCALLTYPE *GetDeviceFeatures)(
+        ID3D12DXVKInteropDevice *This,
+        const VkPhysicalDeviceFeatures2 **features);
+
+    HRESULT (STDMETHODCALLTYPE *GetVulkanHandles)(
+        ID3D12DXVKInteropDevice *This,
+        VkInstance *vk_instance,
+        VkPhysicalDevice *vk_physical_device,
+        VkDevice *vk_device);
+
+    HRESULT (STDMETHODCALLTYPE *GetVulkanQueueInfo)(
+        ID3D12DXVKInteropDevice *This,
+        ID3D12CommandQueue *queue,
+        VkQueue *vk_queue,
+        UINT32 *vk_queue_family);
+
+    void (STDMETHODCALLTYPE *GetVulkanImageLayout)(
+        ID3D12DXVKInteropDevice *This,
+        ID3D12Resource *resource,
+        D3D12_RESOURCE_STATES state,
+        VkImageLayout *vk_layout);
+
+    HRESULT (STDMETHODCALLTYPE *GetVulkanResourceInfo)(
+        ID3D12DXVKInteropDevice *This,
+        ID3D12Resource *resource,
+        UINT64 *vk_handle,
+        UINT64 *buffer_offset);
+
+    HRESULT (STDMETHODCALLTYPE *LockCommandQueue)(
+        ID3D12DXVKInteropDevice *This,
+        ID3D12CommandQueue *queue);
+
+    HRESULT (STDMETHODCALLTYPE *UnlockCommandQueue)(
+        ID3D12DXVKInteropDevice *This,
+        ID3D12CommandQueue *queue);
+
+    END_INTERFACE
+} ID3D12DXVKInteropDeviceVtbl;
+
+interface ID3D12DXVKInteropDevice {
+    CONST_VTBL ID3D12DXVKInteropDeviceVtbl* lpVtbl;
+};
+
+DEFINE_GUID(IID_ID3D12DXVKInteropDevice2, 0x90ecf26e, 0xb212, 0x43f5, 0xb6,0x2a, 0x82,0x5a,0xd7,0xb1,0x38,0x5e);
+typedef struct ID3D12DXVKInteropDevice2Vtbl {
+    BEGIN_INTERFACE
+
+    /*** IUnknown methods ***/
+    HRESULT (STDMETHODCALLTYPE *QueryInterface)(
+        ID3D12DXVKInteropDevice2 *This,
+        REFIID riid,
+        void **object);
+
+    ULONG (STDMETHODCALLTYPE *AddRef)(
+        ID3D12DXVKInteropDevice2 *This);
+
+    ULONG (STDMETHODCALLTYPE *Release)(
+        ID3D12DXVKInteropDevice2 *This);
+
+    /*** ID3D12DXVKInteropDevice methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetDXGIAdapter)(
+        ID3D12DXVKInteropDevice2 *This,
+        REFIID iid,
+        void **object);
+
+    HRESULT (STDMETHODCALLTYPE *GetInstanceExtensions)(
+        ID3D12DXVKInteropDevice2 *This,
+        UINT *extension_count,
+        const char **extensions);
+
+    HRESULT (STDMETHODCALLTYPE *GetDeviceExtensions)(
+        ID3D12DXVKInteropDevice2 *This,
+        UINT *extension_count,
+        const char **extensions);
+
+    HRESULT (STDMETHODCALLTYPE *GetDeviceFeatures)(
+        ID3D12DXVKInteropDevice2 *This,
+        const VkPhysicalDeviceFeatures2 **features);
+
+    HRESULT (STDMETHODCALLTYPE *GetVulkanHandles)(
+        ID3D12DXVKInteropDevice2 *This,
+        VkInstance *vk_instance,
+        VkPhysicalDevice *vk_physical_device,
+        VkDevice *vk_device);
+
+    HRESULT (STDMETHODCALLTYPE *GetVulkanQueueInfo)(
+        ID3D12DXVKInteropDevice2 *This,
+        ID3D12CommandQueue *queue,
+        VkQueue *vk_queue,
+        UINT32 *vk_queue_family);
+
+    void (STDMETHODCALLTYPE *GetVulkanImageLayout)(
+        ID3D12DXVKInteropDevice2 *This,
+        ID3D12Resource *resource,
+        D3D12_RESOURCE_STATES state,
+        VkImageLayout *vk_layout);
+
+    HRESULT (STDMETHODCALLTYPE *GetVulkanResourceInfo)(
+        ID3D12DXVKInteropDevice2 *This,
+        ID3D12Resource *resource,
+        UINT64 *vk_handle,
+        UINT64 *buffer_offset);
+
+    HRESULT (STDMETHODCALLTYPE *LockCommandQueue)(
+        ID3D12DXVKInteropDevice2 *This,
+        ID3D12CommandQueue *queue);
+
+    HRESULT (STDMETHODCALLTYPE *UnlockCommandQueue)(
+        ID3D12DXVKInteropDevice2 *This,
+        ID3D12CommandQueue *queue);
+
+    /*** ID3D12DXVKInteropDevice1 methods ***/
+    HRESULT (STDMETHODCALLTYPE *GetVulkanResourceInfo1)(
+        ID3D12DXVKInteropDevice2 *This,
+        ID3D12Resource *resource,
+        UINT64 *vk_handle,
+        UINT64 *buffer_offset,
+        VkFormat *format);
+
+    HRESULT (STDMETHODCALLTYPE *CreateInteropCommandQueue)(
+        ID3D12DXVKInteropDevice2 *This,
+        const D3D12_COMMAND_QUEUE_DESC *pDesc,
+        UINT32 vk_queue_family_index,
+        ID3D12CommandQueue **ppQueue);
+
+    HRESULT (STDMETHODCALLTYPE *CreateInteropCommandAllocator)(
+        ID3D12DXVKInteropDevice2 *This,
+        D3D12_COMMAND_LIST_TYPE type,
+        UINT32 vk_queue_family_index,
+        ID3D12CommandAllocator **ppAllocator);
+
+    HRESULT (STDMETHODCALLTYPE *BeginVkCommandBufferInterop)(
+        ID3D12DXVKInteropDevice2 *This,
+        ID3D12CommandList *pCmdList,
+        VkCommandBuffer *pCommandBuffer);
+
+    HRESULT (STDMETHODCALLTYPE *EndVkCommandBufferInterop)(
+        ID3D12DXVKInteropDevice2 *This,
+        ID3D12CommandList *pCmdList);
+
+    /*** ID3D12DXVKInteropDevice2 methods ***/
+    HRESULT (STDMETHODCALLTYPE *LockVulkanQueue)(
+        ID3D12DXVKInteropDevice2 *This,
+        ID3D12CommandQueue *queue);
+
+    HRESULT (STDMETHODCALLTYPE *UnlockVulkanQueue)(
+        ID3D12DXVKInteropDevice2 *This,
+        ID3D12CommandQueue *queue);
+
+    END_INTERFACE
+} ID3D12DXVKInteropDevice2Vtbl;
+
+interface ID3D12DXVKInteropDevice2 {
+    CONST_VTBL ID3D12DXVKInteropDevice2Vtbl* lpVtbl;
+};
+#endif
diff --git a/dlls/wineopenxr/wineopenxr.h b/dlls/wineopenxr/wineopenxr.h
new file mode 100644
index 00000000000..412cc7cd11d
--- /dev/null
+++ b/dlls/wineopenxr/wineopenxr.h
@@ -0,0 +1,9266 @@
+/* Automatically generated from Vulkan xr.xml; DO NOT EDIT!
+ *
+ * This file is generated from Vulkan xr.xml file covered
+ * by the following copyright and permission notice:
+ *
+ * Copyright (c) 2017-2025 The Khronos Group Inc.
+ *
+ * SPDX-License-Identifier: Apache-2.0 OR MIT
+ *
+ * ------------------------------------------------------------------------
+ *
+ * This file, xr.xml, is the OpenXR API Registry. It is a critically important
+ * and normative part of the OpenXR Specification, including a canonical
+ * machine-readable definition of the API, parameter and member validation
+ * language incorporated into the Specification and reference pages, and other
+ * material which is registered by Khronos, such as tags used by extension and
+ * layer authors. The only authoritative version of xr.xml is the one
+ * maintained in the default branch of the Khronos OpenXR GitHub project.
+ *
+ */
+
+#ifndef __WINE_OPENXR_H
+#define __WINE_OPENXR_H
+
+#include <windef.h>
+#include <stdint.h>
+
+/* Define WINE_XR_HOST to get 'host' headers. */
+#ifdef WINE_XR_HOST
+#define XRAPI_CALL
+#define WINE_XR_ALIGN(x)
+#endif
+
+#ifndef XRAPI_CALL
+#define XRAPI_CALL __stdcall
+#endif
+
+#ifndef XRAPI_PTR
+#define XRAPI_PTR XRAPI_CALL
+#endif
+
+#ifndef WINE_XR_ALIGN
+#define WINE_XR_ALIGN DECLSPEC_ALIGN
+#endif
+
+#if defined(__x86_64__) || defined(__aarch64__)
+#define XR_PTR_SIZE 8
+#endif
+
+#define XR_TRUE 1
+#define XR_FALSE 0
+#define XR_MAX_EXTENSION_NAME_SIZE 128
+#define XR_MAX_API_LAYER_NAME_SIZE 256
+#define XR_MAX_API_LAYER_DESCRIPTION_SIZE 256
+#define XR_MAX_SYSTEM_NAME_SIZE 256
+#define XR_MAX_APPLICATION_NAME_SIZE 128
+#define XR_MAX_ENGINE_NAME_SIZE 128
+#define XR_MAX_RUNTIME_NAME_SIZE 128
+#define XR_MAX_PATH_LENGTH 256
+#define XR_MAX_STRUCTURE_NAME_SIZE 64
+#define XR_MAX_RESULT_STRING_SIZE 64
+#define XR_MAX_GRAPHICS_APIS_SUPPORTED 32
+#define XR_MAX_ACTION_SET_NAME_SIZE 64
+#define XR_MAX_ACTION_NAME_SIZE 64
+#define XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE 128
+#define XR_MAX_LOCALIZED_ACTION_NAME_SIZE 128
+#define XR_UUID_SIZE 16
+#define XR_KHR_composition_layer_cube_SPEC_VERSION 8
+#define XR_KHR_COMPOSITION_LAYER_CUBE_EXTENSION_NAME "XR_KHR_composition_layer_cube"
+#define XR_KHR_composition_layer_depth_SPEC_VERSION 6
+#define XR_KHR_COMPOSITION_LAYER_DEPTH_EXTENSION_NAME "XR_KHR_composition_layer_depth"
+#define XR_KHR_vulkan_swapchain_format_list_SPEC_VERSION 5
+#define XR_KHR_VULKAN_SWAPCHAIN_FORMAT_LIST_EXTENSION_NAME "XR_KHR_vulkan_swapchain_format_list"
+#define XR_EXT_performance_settings_SPEC_VERSION 4
+#define XR_EXT_PERFORMANCE_SETTINGS_EXTENSION_NAME "XR_EXT_performance_settings"
+#define XR_EXT_thermal_query_SPEC_VERSION 2
+#define XR_EXT_THERMAL_QUERY_EXTENSION_NAME "XR_EXT_thermal_query"
+#define XR_KHR_composition_layer_cylinder_SPEC_VERSION 4
+#define XR_KHR_COMPOSITION_LAYER_CYLINDER_EXTENSION_NAME "XR_KHR_composition_layer_cylinder"
+#define XR_KHR_composition_layer_equirect_SPEC_VERSION 3
+#define XR_KHR_COMPOSITION_LAYER_EQUIRECT_EXTENSION_NAME "XR_KHR_composition_layer_equirect"
+#define XR_KHR_opengl_enable_SPEC_VERSION 11
+#define XR_KHR_OPENGL_ENABLE_EXTENSION_NAME "XR_KHR_opengl_enable"
+#define XR_KHR_vulkan_enable_SPEC_VERSION 9
+#define XR_KHR_VULKAN_ENABLE_EXTENSION_NAME "XR_KHR_vulkan_enable"
+#define XR_KHR_D3D11_enable_SPEC_VERSION 10
+#define XR_KHR_D3D11_ENABLE_EXTENSION_NAME "XR_KHR_D3D11_enable"
+#define XR_KHR_D3D12_enable_SPEC_VERSION 10
+#define XR_KHR_D3D12_ENABLE_EXTENSION_NAME "XR_KHR_D3D12_enable"
+#define XR_EXT_eye_gaze_interaction_SPEC_VERSION 2
+#define XR_EXT_EYE_GAZE_INTERACTION_EXTENSION_NAME "XR_EXT_eye_gaze_interaction"
+#define XR_KHR_visibility_mask_SPEC_VERSION 2
+#define XR_KHR_VISIBILITY_MASK_EXTENSION_NAME "XR_KHR_visibility_mask"
+#define XR_EXTX_overlay_SPEC_VERSION 5
+#define XR_EXTX_OVERLAY_EXTENSION_NAME "XR_EXTX_overlay"
+#define XR_KHR_composition_layer_color_scale_bias_SPEC_VERSION 5
+#define XR_KHR_COMPOSITION_LAYER_COLOR_SCALE_BIAS_EXTENSION_NAME "XR_KHR_composition_layer_color_scale_bias"
+#define XR_KHR_win32_convert_performance_counter_time_SPEC_VERSION 1
+#define XR_KHR_WIN32_CONVERT_PERFORMANCE_COUNTER_TIME_EXTENSION_NAME "XR_KHR_win32_convert_performance_counter_time"
+#define XR_VARJO_quad_views_SPEC_VERSION 2
+#define XR_VARJO_QUAD_VIEWS_EXTENSION_NAME "XR_VARJO_quad_views"
+#define XR_MSFT_unbounded_reference_space_SPEC_VERSION 1
+#define XR_MSFT_UNBOUNDED_REFERENCE_SPACE_EXTENSION_NAME "XR_MSFT_unbounded_reference_space"
+#define XR_MSFT_spatial_anchor_SPEC_VERSION 2
+#define XR_MSFT_SPATIAL_ANCHOR_EXTENSION_NAME "XR_MSFT_spatial_anchor"
+#define XR_FB_composition_layer_image_layout_SPEC_VERSION 1
+#define XR_FB_COMPOSITION_LAYER_IMAGE_LAYOUT_EXTENSION_NAME "XR_FB_composition_layer_image_layout"
+#define XR_FB_composition_layer_alpha_blend_SPEC_VERSION 3
+#define XR_FB_COMPOSITION_LAYER_ALPHA_BLEND_EXTENSION_NAME "XR_FB_composition_layer_alpha_blend"
+#define XR_MND_headless_SPEC_VERSION 2
+#define XR_MND_HEADLESS_EXTENSION_NAME "XR_MND_headless"
+#define XR_OCULUS_android_session_state_enable_SPEC_VERSION 1
+#define XR_OCULUS_ANDROID_SESSION_STATE_ENABLE_EXTENSION_NAME "XR_OCULUS_android_session_state_enable"
+#define XR_EXT_view_configuration_depth_range_SPEC_VERSION 1
+#define XR_EXT_VIEW_CONFIGURATION_DEPTH_RANGE_EXTENSION_NAME "XR_EXT_view_configuration_depth_range"
+#define XR_EXT_conformance_automation_SPEC_VERSION 3
+#define XR_EXT_CONFORMANCE_AUTOMATION_EXTENSION_NAME "XR_EXT_conformance_automation"
+#define XR_MSFT_spatial_graph_bridge_SPEC_VERSION 2
+#define XR_MSFT_SPATIAL_GRAPH_BRIDGE_EXTENSION_NAME "XR_MSFT_spatial_graph_bridge"
+#define XR_GUID_SIZE_MSFT 16
+#define XR_MSFT_hand_interaction_SPEC_VERSION 1
+#define XR_MSFT_HAND_INTERACTION_EXTENSION_NAME "XR_MSFT_hand_interaction"
+#define XR_EXT_hand_tracking_SPEC_VERSION 4
+#define XR_EXT_HAND_TRACKING_EXTENSION_NAME "XR_EXT_hand_tracking"
+#define XR_MSFT_hand_tracking_mesh_SPEC_VERSION 4
+#define XR_MSFT_HAND_TRACKING_MESH_EXTENSION_NAME "XR_MSFT_hand_tracking_mesh"
+#define XR_MSFT_secondary_view_configuration_SPEC_VERSION 1
+#define XR_MSFT_SECONDARY_VIEW_CONFIGURATION_EXTENSION_NAME "XR_MSFT_secondary_view_configuration"
+#define XR_MSFT_first_person_observer_SPEC_VERSION 1
+#define XR_MSFT_FIRST_PERSON_OBSERVER_EXTENSION_NAME "XR_MSFT_first_person_observer"
+#define XR_MSFT_controller_model_SPEC_VERSION 2
+#define XR_MSFT_CONTROLLER_MODEL_EXTENSION_NAME "XR_MSFT_controller_model"
+#define XR_MAX_CONTROLLER_MODEL_NODE_NAME_SIZE_MSFT 64
+#define XR_EXT_win32_appcontainer_compatible_SPEC_VERSION 1
+#define XR_EXT_WIN32_APPCONTAINER_COMPATIBLE_EXTENSION_NAME "XR_EXT_win32_appcontainer_compatible"
+#define XR_EPIC_view_configuration_fov_SPEC_VERSION 2
+#define XR_EPIC_VIEW_CONFIGURATION_FOV_EXTENSION_NAME "XR_EPIC_view_configuration_fov"
+#define XR_MSFT_holographic_window_attachment_SPEC_VERSION 1
+#define XR_MSFT_HOLOGRAPHIC_WINDOW_ATTACHMENT_EXTENSION_NAME "XR_MSFT_holographic_window_attachment"
+#define XR_MSFT_composition_layer_reprojection_SPEC_VERSION 1
+#define XR_MSFT_COMPOSITION_LAYER_REPROJECTION_EXTENSION_NAME "XR_MSFT_composition_layer_reprojection"
+#define XR_HUAWEI_controller_interaction_SPEC_VERSION 1
+#define XR_HUAWEI_CONTROLLER_INTERACTION_EXTENSION_NAME "XR_HUAWEI_controller_interaction"
+#define XR_FB_swapchain_update_state_SPEC_VERSION 3
+#define XR_FB_SWAPCHAIN_UPDATE_STATE_EXTENSION_NAME "XR_FB_swapchain_update_state"
+#define XR_FB_composition_layer_secure_content_SPEC_VERSION 1
+#define XR_FB_COMPOSITION_LAYER_SECURE_CONTENT_EXTENSION_NAME "XR_FB_composition_layer_secure_content"
+#define XR_FB_body_tracking_SPEC_VERSION 1
+#define XR_FB_BODY_TRACKING_EXTENSION_NAME "XR_FB_body_tracking"
+#define XR_EXT_dpad_binding_SPEC_VERSION 1
+#define XR_EXT_DPAD_BINDING_EXTENSION_NAME "XR_EXT_dpad_binding"
+#define XR_VALVE_analog_threshold_SPEC_VERSION 2
+#define XR_VALVE_ANALOG_THRESHOLD_EXTENSION_NAME "XR_VALVE_analog_threshold"
+#define XR_EXT_hand_joints_motion_range_SPEC_VERSION 1
+#define XR_EXT_HAND_JOINTS_MOTION_RANGE_EXTENSION_NAME "XR_EXT_hand_joints_motion_range"
+#define XR_KHR_vulkan_enable2_SPEC_VERSION 3
+#define XR_KHR_VULKAN_ENABLE2_EXTENSION_NAME "XR_KHR_vulkan_enable2"
+#define XR_KHR_composition_layer_equirect2_SPEC_VERSION 1
+#define XR_KHR_COMPOSITION_LAYER_EQUIRECT2_EXTENSION_NAME "XR_KHR_composition_layer_equirect2"
+#define XR_EXT_samsung_odyssey_controller_SPEC_VERSION 1
+#define XR_EXT_SAMSUNG_ODYSSEY_CONTROLLER_EXTENSION_NAME "XR_EXT_samsung_odyssey_controller"
+#define XR_EXT_hp_mixed_reality_controller_SPEC_VERSION 1
+#define XR_EXT_HP_MIXED_REALITY_CONTROLLER_EXTENSION_NAME "XR_EXT_hp_mixed_reality_controller"
+#define XR_MND_swapchain_usage_input_attachment_bit_SPEC_VERSION 2
+#define XR_MND_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_EXTENSION_NAME "XR_MND_swapchain_usage_input_attachment_bit"
+#define XR_MSFT_scene_understanding_SPEC_VERSION 2
+#define XR_MSFT_SCENE_UNDERSTANDING_EXTENSION_NAME "XR_MSFT_scene_understanding"
+#define XR_MSFT_scene_understanding_serialization_SPEC_VERSION 2
+#define XR_MSFT_SCENE_UNDERSTANDING_SERIALIZATION_EXTENSION_NAME "XR_MSFT_scene_understanding_serialization"
+#define XR_FB_display_refresh_rate_SPEC_VERSION 1
+#define XR_FB_DISPLAY_REFRESH_RATE_EXTENSION_NAME "XR_FB_display_refresh_rate"
+#define XR_HTC_vive_cosmos_controller_interaction_SPEC_VERSION 1
+#define XR_HTC_VIVE_COSMOS_CONTROLLER_INTERACTION_EXTENSION_NAME "XR_HTC_vive_cosmos_controller_interaction"
+#define XR_HTCX_vive_tracker_interaction_SPEC_VERSION 3
+#define XR_HTCX_VIVE_TRACKER_INTERACTION_EXTENSION_NAME "XR_HTCX_vive_tracker_interaction"
+#define XR_HTC_facial_tracking_SPEC_VERSION 3
+#define XR_HTC_FACIAL_TRACKING_EXTENSION_NAME "XR_HTC_facial_tracking"
+#define XR_HTC_vive_focus3_controller_interaction_SPEC_VERSION 2
+#define XR_HTC_VIVE_FOCUS3_CONTROLLER_INTERACTION_EXTENSION_NAME "XR_HTC_vive_focus3_controller_interaction"
+#define XR_HTC_hand_interaction_SPEC_VERSION 1
+#define XR_HTC_HAND_INTERACTION_EXTENSION_NAME "XR_HTC_hand_interaction"
+#define XR_HTC_vive_wrist_tracker_interaction_SPEC_VERSION 1
+#define XR_HTC_VIVE_WRIST_TRACKER_INTERACTION_EXTENSION_NAME "XR_HTC_vive_wrist_tracker_interaction"
+#define XR_FB_color_space_SPEC_VERSION 3
+#define XR_FB_COLOR_SPACE_EXTENSION_NAME "XR_FB_color_space"
+#define XR_FB_hand_tracking_mesh_SPEC_VERSION 3
+#define XR_FB_HAND_TRACKING_MESH_EXTENSION_NAME "XR_FB_hand_tracking_mesh"
+#define XR_FB_hand_tracking_aim_SPEC_VERSION 2
+#define XR_FB_HAND_TRACKING_AIM_EXTENSION_NAME "XR_FB_hand_tracking_aim"
+#define XR_FB_HAND_TRACKING_CAPSULE_POINT_COUNT XR_HAND_TRACKING_CAPSULE_POINT_COUNT_FB
+#define XR_FB_HAND_TRACKING_CAPSULE_COUNT XR_HAND_TRACKING_CAPSULE_COUNT_FB
+#define XR_FB_hand_tracking_capsules_SPEC_VERSION 3
+#define XR_FB_HAND_TRACKING_CAPSULES_EXTENSION_NAME "XR_FB_hand_tracking_capsules"
+#define XR_HAND_TRACKING_CAPSULE_POINT_COUNT_FB 2
+#define XR_HAND_TRACKING_CAPSULE_COUNT_FB 19
+#define XR_FB_spatial_entity_SPEC_VERSION 3
+#define XR_FB_SPATIAL_ENTITY_EXTENSION_NAME "XR_FB_spatial_entity"
+#define XR_FB_foveation_SPEC_VERSION 1
+#define XR_FB_FOVEATION_EXTENSION_NAME "XR_FB_foveation"
+#define XR_FB_foveation_configuration_SPEC_VERSION 1
+#define XR_FB_FOVEATION_CONFIGURATION_EXTENSION_NAME "XR_FB_foveation_configuration"
+#define XR_FB_keyboard_tracking_SPEC_VERSION 1
+#define XR_FB_KEYBOARD_TRACKING_EXTENSION_NAME "XR_FB_keyboard_tracking"
+#define XR_MAX_KEYBOARD_TRACKING_NAME_SIZE_FB 128
+#define XR_FB_triangle_mesh_SPEC_VERSION 2
+#define XR_FB_TRIANGLE_MESH_EXTENSION_NAME "XR_FB_triangle_mesh"
+#define XR_FB_passthrough_SPEC_VERSION 4
+#define XR_FB_PASSTHROUGH_EXTENSION_NAME "XR_FB_passthrough"
+#define XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB 256
+#define XR_FB_render_model_SPEC_VERSION 4
+#define XR_FB_RENDER_MODEL_EXTENSION_NAME "XR_FB_render_model"
+#define XR_MAX_RENDER_MODEL_NAME_SIZE_FB 64
+#define XR_KHR_binding_modification_SPEC_VERSION 1
+#define XR_KHR_BINDING_MODIFICATION_EXTENSION_NAME "XR_KHR_binding_modification"
+#define XR_VARJO_foveated_rendering_SPEC_VERSION 3
+#define XR_VARJO_FOVEATED_RENDERING_EXTENSION_NAME "XR_VARJO_foveated_rendering"
+#define XR_VARJO_composition_layer_depth_test_SPEC_VERSION 2
+#define XR_VARJO_COMPOSITION_LAYER_DEPTH_TEST_EXTENSION_NAME "XR_VARJO_composition_layer_depth_test"
+#define XR_VARJO_environment_depth_estimation_SPEC_VERSION 1
+#define XR_VARJO_ENVIRONMENT_DEPTH_ESTIMATION_EXTENSION_NAME "XR_VARJO_environment_depth_estimation"
+#define XR_VARJO_marker_tracking_SPEC_VERSION 1
+#define XR_VARJO_MARKER_TRACKING_EXTENSION_NAME "XR_VARJO_marker_tracking"
+#define XR_VARJO_view_offset_SPEC_VERSION 1
+#define XR_VARJO_VIEW_OFFSET_EXTENSION_NAME "XR_VARJO_view_offset"
+#define XR_VARJO_xr4_controller_interaction_SPEC_VERSION 2
+#define XR_VARJO_XR4_CONTROLLER_INTERACTION_EXTENSION_NAME "XR_VARJO_xr4_controller_interaction"
+#define XR_ML_ml2_controller_interaction_SPEC_VERSION 1
+#define XR_ML_ML2_CONTROLLER_INTERACTION_EXTENSION_NAME "XR_ML_ml2_controller_interaction"
+#define XR_ML_frame_end_info_SPEC_VERSION 1
+#define XR_ML_FRAME_END_INFO_EXTENSION_NAME "XR_ML_frame_end_info"
+#define XR_ML_global_dimmer_SPEC_VERSION 1
+#define XR_ML_GLOBAL_DIMMER_EXTENSION_NAME "XR_ML_global_dimmer"
+#define XR_ML_marker_understanding_SPEC_VERSION 1
+#define XR_ML_MARKER_UNDERSTANDING_EXTENSION_NAME "XR_ML_marker_understanding"
+#define XR_ML_localization_map_SPEC_VERSION 1
+#define XR_ML_LOCALIZATION_MAP_EXTENSION_NAME "XR_ML_localization_map"
+#define XR_MAX_LOCALIZATION_MAP_NAME_LENGTH_ML 64
+#define XR_ML_spatial_anchors_SPEC_VERSION 1
+#define XR_ML_SPATIAL_ANCHORS_EXTENSION_NAME "XR_ML_spatial_anchors"
+#define XR_ML_spatial_anchors_storage_SPEC_VERSION 1
+#define XR_ML_SPATIAL_ANCHORS_STORAGE_EXTENSION_NAME "XR_ML_spatial_anchors_storage"
+#define XR_ML_user_calibration_SPEC_VERSION 1
+#define XR_ML_USER_CALIBRATION_EXTENSION_NAME "XR_ML_user_calibration"
+#define XR_MSFT_spatial_anchor_persistence_SPEC_VERSION 2
+#define XR_MSFT_SPATIAL_ANCHOR_PERSISTENCE_EXTENSION_NAME "XR_MSFT_spatial_anchor_persistence"
+#define XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT 256
+#define XR_MSFT_scene_marker_SPEC_VERSION 1
+#define XR_MSFT_SCENE_MARKER_EXTENSION_NAME "XR_MSFT_scene_marker"
+#define XR_KHR_extended_struct_name_lengths_SPEC_VERSION 1
+#define XR_KHR_EXTENDED_STRUCT_NAME_LENGTHS_EXTENSION_NAME "XR_KHR_extended_struct_name_lengths"
+#define XR_MAX_STRUCTURE_NAME_SIZE_EXTENDED_KHR 256
+#define XR_ULTRALEAP_hand_tracking_forearm_SPEC_VERSION 1
+#define XR_ULTRALEAP_HAND_TRACKING_FOREARM_EXTENSION_NAME "XR_ULTRALEAP_hand_tracking_forearm"
+#define XR_FB_spatial_entity_query_SPEC_VERSION 1
+#define XR_FB_SPATIAL_ENTITY_QUERY_EXTENSION_NAME "XR_FB_spatial_entity_query"
+#define XR_FB_spatial_entity_storage_SPEC_VERSION 1
+#define XR_FB_SPATIAL_ENTITY_STORAGE_EXTENSION_NAME "XR_FB_spatial_entity_storage"
+#define XR_OCULUS_audio_device_guid_SPEC_VERSION 1
+#define XR_OCULUS_AUDIO_DEVICE_GUID_EXTENSION_NAME "XR_OCULUS_audio_device_guid"
+#define XR_MAX_AUDIO_DEVICE_STR_SIZE_OCULUS 128
+#define XR_FB_foveation_vulkan_SPEC_VERSION 1
+#define XR_FB_FOVEATION_VULKAN_EXTENSION_NAME "XR_FB_foveation_vulkan"
+#define XR_FB_swapchain_update_state_vulkan_SPEC_VERSION 1
+#define XR_FB_SWAPCHAIN_UPDATE_STATE_VULKAN_EXTENSION_NAME "XR_FB_swapchain_update_state_vulkan"
+#define XR_KHR_swapchain_usage_input_attachment_bit_SPEC_VERSION 3
+#define XR_KHR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_EXTENSION_NAME "XR_KHR_swapchain_usage_input_attachment_bit"
+#define XR_FB_touch_controller_pro_SPEC_VERSION 1
+#define XR_FB_TOUCH_CONTROLLER_PRO_EXTENSION_NAME "XR_FB_touch_controller_pro"
+#define XR_FB_spatial_entity_sharing_SPEC_VERSION 1
+#define XR_FB_SPATIAL_ENTITY_SHARING_EXTENSION_NAME "XR_FB_spatial_entity_sharing"
+#define XR_FB_space_warp_SPEC_VERSION 2
+#define XR_FB_SPACE_WARP_EXTENSION_NAME "XR_FB_space_warp"
+#define XR_FB_haptic_amplitude_envelope_SPEC_VERSION 1
+#define XR_FB_HAPTIC_AMPLITUDE_ENVELOPE_EXTENSION_NAME "XR_FB_haptic_amplitude_envelope"
+#define XR_FB_scene_SPEC_VERSION 4
+#define XR_FB_SCENE_EXTENSION_NAME "XR_FB_scene"
+#define XR_EXT_palm_pose_SPEC_VERSION 3
+#define XR_EXT_PALM_POSE_EXTENSION_NAME "XR_EXT_palm_pose"
+#define XR_ALMALENCE_digital_lens_control_SPEC_VERSION 1
+#define XR_ALMALENCE_DIGITAL_LENS_CONTROL_EXTENSION_NAME "XR_ALMALENCE_digital_lens_control"
+#define XR_FB_scene_capture_SPEC_VERSION 1
+#define XR_FB_SCENE_CAPTURE_EXTENSION_NAME "XR_FB_scene_capture"
+#define XR_FB_spatial_entity_container_SPEC_VERSION 2
+#define XR_FB_SPATIAL_ENTITY_CONTAINER_EXTENSION_NAME "XR_FB_spatial_entity_container"
+#define XR_META_foveation_eye_tracked_SPEC_VERSION 1
+#define XR_META_FOVEATION_EYE_TRACKED_EXTENSION_NAME "XR_META_foveation_eye_tracked"
+#define XR_FOVEATION_CENTER_SIZE_META 2
+#define XR_FB_face_tracking_SPEC_VERSION 1
+#define XR_FB_FACE_TRACKING_EXTENSION_NAME "XR_FB_face_tracking"
+#define XR_FB_eye_tracking_social_SPEC_VERSION 1
+#define XR_FB_EYE_TRACKING_SOCIAL_EXTENSION_NAME "XR_FB_eye_tracking_social"
+#define XR_FB_passthrough_keyboard_hands_SPEC_VERSION 2
+#define XR_FB_PASSTHROUGH_KEYBOARD_HANDS_EXTENSION_NAME "XR_FB_passthrough_keyboard_hands"
+#define XR_FB_composition_layer_settings_SPEC_VERSION 1
+#define XR_FB_COMPOSITION_LAYER_SETTINGS_EXTENSION_NAME "XR_FB_composition_layer_settings"
+#define XR_FB_touch_controller_proximity_SPEC_VERSION 1
+#define XR_FB_TOUCH_CONTROLLER_PROXIMITY_EXTENSION_NAME "XR_FB_touch_controller_proximity"
+#define XR_FB_haptic_pcm_SPEC_VERSION 1
+#define XR_FB_HAPTIC_PCM_EXTENSION_NAME "XR_FB_haptic_pcm"
+#define XR_EXT_frame_synthesis_SPEC_VERSION 1
+#define XR_EXT_FRAME_SYNTHESIS_EXTENSION_NAME "XR_EXT_frame_synthesis"
+#define XR_FB_composition_layer_depth_test_SPEC_VERSION 1
+#define XR_FB_COMPOSITION_LAYER_DEPTH_TEST_EXTENSION_NAME "XR_FB_composition_layer_depth_test"
+#define XR_META_local_dimming_SPEC_VERSION 1
+#define XR_META_LOCAL_DIMMING_EXTENSION_NAME "XR_META_local_dimming"
+#define XR_META_passthrough_preferences_SPEC_VERSION 1
+#define XR_META_PASSTHROUGH_PREFERENCES_EXTENSION_NAME "XR_META_passthrough_preferences"
+#define XR_META_virtual_keyboard_SPEC_VERSION 1
+#define XR_META_VIRTUAL_KEYBOARD_EXTENSION_NAME "XR_META_virtual_keyboard"
+#define XR_MAX_VIRTUAL_KEYBOARD_COMMIT_TEXT_SIZE_META 3992
+#define XR_OCULUS_external_camera_SPEC_VERSION 1
+#define XR_OCULUS_EXTERNAL_CAMERA_EXTENSION_NAME "XR_OCULUS_external_camera"
+#define XR_MAX_EXTERNAL_CAMERA_NAME_SIZE_OCULUS 32
+#define XR_META_vulkan_swapchain_create_info_SPEC_VERSION 1
+#define XR_META_VULKAN_SWAPCHAIN_CREATE_INFO_EXTENSION_NAME "XR_META_vulkan_swapchain_create_info"
+#define XR_META_performance_metrics_SPEC_VERSION 2
+#define XR_META_PERFORMANCE_METRICS_EXTENSION_NAME "XR_META_performance_metrics"
+#define XR_FB_spatial_entity_storage_batch_SPEC_VERSION 1
+#define XR_FB_SPATIAL_ENTITY_STORAGE_BATCH_EXTENSION_NAME "XR_FB_spatial_entity_storage_batch"
+#define XR_META_detached_controllers_SPEC_VERSION 1
+#define XR_META_DETACHED_CONTROLLERS_EXTENSION_NAME "XR_META_detached_controllers"
+#define XR_FB_spatial_entity_user_SPEC_VERSION 1
+#define XR_FB_SPATIAL_ENTITY_USER_EXTENSION_NAME "XR_FB_spatial_entity_user"
+#define XR_META_headset_id_SPEC_VERSION 2
+#define XR_META_HEADSET_ID_EXTENSION_NAME "XR_META_headset_id"
+#define XR_META_spatial_entity_discovery_SPEC_VERSION 1
+#define XR_META_SPATIAL_ENTITY_DISCOVERY_EXTENSION_NAME "XR_META_spatial_entity_discovery"
+#define XR_META_hand_tracking_microgestures_SPEC_VERSION 1
+#define XR_META_HAND_TRACKING_MICROGESTURES_EXTENSION_NAME "XR_META_hand_tracking_microgestures"
+#define XR_META_recommended_layer_resolution_SPEC_VERSION 1
+#define XR_META_RECOMMENDED_LAYER_RESOLUTION_EXTENSION_NAME "XR_META_recommended_layer_resolution"
+#define XR_META_spatial_entity_persistence_SPEC_VERSION 1
+#define XR_META_SPATIAL_ENTITY_PERSISTENCE_EXTENSION_NAME "XR_META_spatial_entity_persistence"
+#define XR_META_passthrough_color_lut_SPEC_VERSION 1
+#define XR_META_PASSTHROUGH_COLOR_LUT_EXTENSION_NAME "XR_META_passthrough_color_lut"
+#define XR_META_spatial_entity_mesh_SPEC_VERSION 1
+#define XR_META_SPATIAL_ENTITY_MESH_EXTENSION_NAME "XR_META_spatial_entity_mesh"
+#define XR_META_automatic_layer_filter_SPEC_VERSION 1
+#define XR_META_AUTOMATIC_LAYER_FILTER_EXTENSION_NAME "XR_META_automatic_layer_filter"
+#define XR_META_body_tracking_full_body_SPEC_VERSION 1
+#define XR_META_BODY_TRACKING_FULL_BODY_EXTENSION_NAME "XR_META_body_tracking_full_body"
+#define XR_META_touch_controller_plus_SPEC_VERSION 1
+#define XR_META_TOUCH_CONTROLLER_PLUS_EXTENSION_NAME "XR_META_touch_controller_plus"
+#define XR_META_passthrough_layer_resumed_event_SPEC_VERSION 1
+#define XR_META_PASSTHROUGH_LAYER_RESUMED_EVENT_EXTENSION_NAME "XR_META_passthrough_layer_resumed_event"
+#define XR_META_body_tracking_calibration_SPEC_VERSION 1
+#define XR_META_BODY_TRACKING_CALIBRATION_EXTENSION_NAME "XR_META_body_tracking_calibration"
+#define XR_FB_face_tracking2_SPEC_VERSION 1
+#define XR_FB_FACE_TRACKING2_EXTENSION_NAME "XR_FB_face_tracking2"
+#define XR_META_spatial_entity_sharing_SPEC_VERSION 1
+#define XR_META_SPATIAL_ENTITY_SHARING_EXTENSION_NAME "XR_META_spatial_entity_sharing"
+#define XR_MAX_SPACES_PER_SHARE_REQUEST_META 32
+#define XR_META_environment_depth_SPEC_VERSION 1
+#define XR_META_ENVIRONMENT_DEPTH_EXTENSION_NAME "XR_META_environment_depth"
+#define XR_EXT_uuid_SPEC_VERSION 1
+#define XR_EXT_UUID_EXTENSION_NAME "XR_EXT_uuid"
+#define XR_UUID_SIZE_EXT 16
+#define XR_EXT_render_model_SPEC_VERSION 1
+#define XR_EXT_RENDER_MODEL_EXTENSION_NAME "XR_EXT_render_model"
+#define XR_NULL_RENDER_MODEL_ID_EXT 0
+#define XR_MAX_RENDER_MODEL_ASSET_NODE_NAME_SIZE_EXT 64
+#define XR_EXT_interaction_render_model_SPEC_VERSION 1
+#define XR_EXT_INTERACTION_RENDER_MODEL_EXTENSION_NAME "XR_EXT_interaction_render_model"
+#define XR_EXT_hand_interaction_SPEC_VERSION 2
+#define XR_EXT_HAND_INTERACTION_EXTENSION_NAME "XR_EXT_hand_interaction"
+#define XR_QCOM_tracking_optimization_settings_SPEC_VERSION 1
+#define XR_QCOM_TRACKING_OPTIMIZATION_SETTINGS_EXTENSION_NAME "XR_QCOM_tracking_optimization_settings"
+#define XR_HTC_passthrough_SPEC_VERSION 1
+#define XR_HTC_PASSTHROUGH_EXTENSION_NAME "XR_HTC_passthrough"
+#define XR_HTC_anchor_SPEC_VERSION 1
+#define XR_HTC_ANCHOR_EXTENSION_NAME "XR_HTC_anchor"
+#define XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_HTC 256
+#define XR_HTC_body_tracking_SPEC_VERSION 1
+#define XR_HTC_BODY_TRACKING_EXTENSION_NAME "XR_HTC_body_tracking"
+#define XR_EXT_active_action_set_priority_SPEC_VERSION 1
+#define XR_EXT_ACTIVE_ACTION_SET_PRIORITY_EXTENSION_NAME "XR_EXT_active_action_set_priority"
+#define XR_MNDX_force_feedback_curl_SPEC_VERSION 1
+#define XR_MNDX_FORCE_FEEDBACK_CURL_EXTENSION_NAME "XR_MNDX_force_feedback_curl"
+#define XR_BD_controller_interaction_SPEC_VERSION 2
+#define XR_BD_CONTROLLER_INTERACTION_EXTENSION_NAME "XR_BD_controller_interaction"
+#define XR_BD_body_tracking_SPEC_VERSION 1
+#define XR_BD_BODY_TRACKING_EXTENSION_NAME "XR_BD_body_tracking"
+#define XR_BD_spatial_sensing_SPEC_VERSION 1
+#define XR_BD_SPATIAL_SENSING_EXTENSION_NAME "XR_BD_spatial_sensing"
+#define XR_BD_spatial_anchor_SPEC_VERSION 2
+#define XR_BD_SPATIAL_ANCHOR_EXTENSION_NAME "XR_BD_spatial_anchor"
+#define XR_BD_spatial_anchor_sharing_SPEC_VERSION 2
+#define XR_BD_SPATIAL_ANCHOR_SHARING_EXTENSION_NAME "XR_BD_spatial_anchor_sharing"
+#define XR_BD_spatial_scene_SPEC_VERSION 1
+#define XR_BD_SPATIAL_SCENE_EXTENSION_NAME "XR_BD_spatial_scene"
+#define XR_BD_spatial_mesh_SPEC_VERSION 1
+#define XR_BD_SPATIAL_MESH_EXTENSION_NAME "XR_BD_spatial_mesh"
+#define XR_BD_future_progress_SPEC_VERSION 1
+#define XR_BD_FUTURE_PROGRESS_EXTENSION_NAME "XR_BD_future_progress"
+#define XR_BD_spatial_plane_SPEC_VERSION 1
+#define XR_BD_SPATIAL_PLANE_EXTENSION_NAME "XR_BD_spatial_plane"
+#define XR_EXT_local_floor_SPEC_VERSION 1
+#define XR_EXT_LOCAL_FLOOR_EXTENSION_NAME "XR_EXT_local_floor"
+#define XR_EXT_hand_tracking_data_source_SPEC_VERSION 1
+#define XR_EXT_HAND_TRACKING_DATA_SOURCE_EXTENSION_NAME "XR_EXT_hand_tracking_data_source"
+#define XR_EXT_plane_detection_SPEC_VERSION 2
+#define XR_EXT_PLANE_DETECTION_EXTENSION_NAME "XR_EXT_plane_detection"
+#define XR_OPPO_controller_interaction_SPEC_VERSION 1
+#define XR_OPPO_CONTROLLER_INTERACTION_EXTENSION_NAME "XR_OPPO_controller_interaction"
+#define XR_ANDROID_trackables_SPEC_VERSION 2
+#define XR_ANDROID_TRACKABLES_EXTENSION_NAME "XR_ANDROID_trackables"
+#define XR_ANDROID_device_anchor_persistence_SPEC_VERSION 1
+#define XR_ANDROID_DEVICE_ANCHOR_PERSISTENCE_EXTENSION_NAME "XR_ANDROID_device_anchor_persistence"
+#define XR_ANDROID_passthrough_camera_state_SPEC_VERSION 1
+#define XR_ANDROID_PASSTHROUGH_CAMERA_STATE_EXTENSION_NAME "XR_ANDROID_passthrough_camera_state"
+#define XR_ANDROID_raycast_SPEC_VERSION 1
+#define XR_ANDROID_RAYCAST_EXTENSION_NAME "XR_ANDROID_raycast"
+#define XR_ANDROID_trackables_object_SPEC_VERSION 1
+#define XR_ANDROID_TRACKABLES_OBJECT_EXTENSION_NAME "XR_ANDROID_trackables_object"
+#define XR_EXT_future_SPEC_VERSION 1
+#define XR_EXT_FUTURE_EXTENSION_NAME "XR_EXT_future"
+#define XR_NULL_FUTURE_EXT 0
+#define XR_EXT_user_presence_SPEC_VERSION 1
+#define XR_EXT_USER_PRESENCE_EXTENSION_NAME "XR_EXT_user_presence"
+#define XR_KHR_locate_spaces_SPEC_VERSION 1
+#define XR_KHR_LOCATE_SPACES_EXTENSION_NAME "XR_KHR_locate_spaces"
+#define XR_ML_system_notifications_SPEC_VERSION 1
+#define XR_ML_SYSTEM_NOTIFICATIONS_EXTENSION_NAME "XR_ML_system_notifications"
+#define XR_ML_world_mesh_detection_SPEC_VERSION 1
+#define XR_ML_WORLD_MESH_DETECTION_EXTENSION_NAME "XR_ML_world_mesh_detection"
+#define XR_ML_facial_expression_SPEC_VERSION 1
+#define XR_ML_FACIAL_EXPRESSION_EXTENSION_NAME "XR_ML_facial_expression"
+#define XR_ML_view_configuration_depth_range_change_SPEC_VERSION 1
+#define XR_ML_VIEW_CONFIGURATION_DEPTH_RANGE_CHANGE_EXTENSION_NAME "XR_ML_view_configuration_depth_range_change"
+#define XR_YVR_controller_interaction_SPEC_VERSION 1
+#define XR_YVR_CONTROLLER_INTERACTION_EXTENSION_NAME "XR_YVR_controller_interaction"
+#define XR_META_simultaneous_hands_and_controllers_SPEC_VERSION 1
+#define XR_META_SIMULTANEOUS_HANDS_AND_CONTROLLERS_EXTENSION_NAME "XR_META_simultaneous_hands_and_controllers"
+#define XR_EXT_composition_layer_inverted_alpha_SPEC_VERSION 1
+#define XR_EXT_COMPOSITION_LAYER_INVERTED_ALPHA_EXTENSION_NAME "XR_EXT_composition_layer_inverted_alpha"
+#define XR_META_colocation_discovery_SPEC_VERSION 1
+#define XR_META_COLOCATION_DISCOVERY_EXTENSION_NAME "XR_META_colocation_discovery"
+#define XR_MAX_COLOCATION_DISCOVERY_BUFFER_SIZE_META 1024
+#define XR_META_spatial_entity_group_sharing_SPEC_VERSION 1
+#define XR_META_SPATIAL_ENTITY_GROUP_SHARING_EXTENSION_NAME "XR_META_spatial_entity_group_sharing"
+#define XR_ANDROID_trackables_marker_SPEC_VERSION 1
+#define XR_ANDROID_TRACKABLES_MARKER_EXTENSION_NAME "XR_ANDROID_trackables_marker"
+#define XR_KHR_maintenance1_SPEC_VERSION 1
+#define XR_KHR_MAINTENANCE1_EXTENSION_NAME "XR_KHR_maintenance1"
+#define XR_KHR_generic_controller_SPEC_VERSION 1
+#define XR_KHR_GENERIC_CONTROLLER_EXTENSION_NAME "XR_KHR_generic_controller"
+#define XR_EXT_spatial_entity_SPEC_VERSION 1
+#define XR_EXT_SPATIAL_ENTITY_EXTENSION_NAME "XR_EXT_spatial_entity"
+#define XR_EXT_spatial_plane_tracking_SPEC_VERSION 1
+#define XR_EXT_SPATIAL_PLANE_TRACKING_EXTENSION_NAME "XR_EXT_spatial_plane_tracking"
+#define XR_EXT_spatial_marker_tracking_SPEC_VERSION 1
+#define XR_EXT_SPATIAL_MARKER_TRACKING_EXTENSION_NAME "XR_EXT_spatial_marker_tracking"
+#define XR_LOGITECH_mx_ink_stylus_interaction_SPEC_VERSION 1
+#define XR_LOGITECH_MX_INK_STYLUS_INTERACTION_EXTENSION_NAME "XR_LOGITECH_mx_ink_stylus_interaction"
+#define XR_EXT_spatial_anchor_SPEC_VERSION 1
+#define XR_EXT_SPATIAL_ANCHOR_EXTENSION_NAME "XR_EXT_spatial_anchor"
+#define XR_EXT_spatial_persistence_SPEC_VERSION 1
+#define XR_EXT_SPATIAL_PERSISTENCE_EXTENSION_NAME "XR_EXT_spatial_persistence"
+#define XR_EXT_spatial_persistence_operations_SPEC_VERSION 1
+#define XR_EXT_SPATIAL_PERSISTENCE_OPERATIONS_EXTENSION_NAME "XR_EXT_spatial_persistence_operations"
+#define XR_EXT_loader_init_properties_SPEC_VERSION 1
+#define XR_EXT_LOADER_INIT_PROPERTIES_EXTENSION_NAME "XR_EXT_loader_init_properties"
+
+
+#define XR_MAKE_VERSION(major, minor, patch) \
+    ((((major) & 0xffffULL) << 48) | (((minor) & 0xffffULL) << 32) | ((patch) & 0xffffffffULL))
+
+#define XR_VERSION_MAJOR(version) (uint16_t)(((uint64_t)(version) >> 48)& 0xffffULL)
+
+#define XR_VERSION_MINOR(version) (uint16_t)(((uint64_t)(version) >> 32) & 0xffffULL)
+
+#define XR_VERSION_PATCH(version) (uint32_t)((uint64_t)(version) & 0xffffffffULL)
+
+
+#define XR_CURRENT_API_VERSION XR_MAKE_VERSION(1, 1, 52)
+
+
+#define XR_API_VERSION_1_0 XR_MAKE_VERSION(1, 0, XR_VERSION_PATCH(XR_CURRENT_API_VERSION))
+
+
+#define XR_API_VERSION_1_1 XR_MAKE_VERSION(1, 1, XR_VERSION_PATCH(XR_CURRENT_API_VERSION))
+
+
+#if !defined(XR_MAY_ALIAS)
+#if defined(__clang__) || (defined(__GNUC__) && (__GNUC__ > 4))
+#define XR_MAY_ALIAS __attribute__((__may_alias__))
+#else
+#define XR_MAY_ALIAS
+#endif
+#endif
+
+
+#if !defined(XR_DEFINE_HANDLE)
+#if (XR_PTR_SIZE == 8)
+    #define XR_DEFINE_HANDLE(object) typedef struct object##_T* object;
+#else
+    #define XR_DEFINE_HANDLE(object) typedef uint64_t object;
+#endif
+#endif
+
+
+#if !defined(XR_NULL_HANDLE)
+#if (XR_PTR_SIZE == 8) && XR_CPP_NULLPTR_SUPPORTED
+    #define XR_NULL_HANDLE nullptr
+#else
+    #define XR_NULL_HANDLE 0
+#endif
+#endif
+
+
+#if !defined(XR_DEFINE_ATOM)
+    #define XR_DEFINE_ATOM(object) typedef uint64_t object;
+#endif
+
+
+#if !defined(XR_DEFINE_OPAQUE_64)
+    #if (XR_PTR_SIZE == 8)
+        #define XR_DEFINE_OPAQUE_64(object) typedef struct object##_T* object;
+    #else
+        #define XR_DEFINE_OPAQUE_64(object) typedef uint64_t object;
+    #endif
+#endif
+
+
+#define XR_EXTENSION_ENUM_BASE 1000000000
+
+
+#define XR_EXTENSION_ENUM_STRIDE 1000
+
+
+#define XR_NULL_PATH 0
+
+
+#define XR_NULL_SYSTEM_ID 0
+
+
+#define XR_SUCCEEDED(result) ((result) >= 0)
+
+
+#define XR_UNQUALIFIED_SUCCESS(result) ((result) == 0)
+
+
+#define XR_FAILED(result) ((result) < 0)
+
+
+#define XR_NO_DURATION 0
+
+
+#define XR_INFINITE_DURATION 0x7fffffffffffffffLL
+
+
+#define XR_MIN_HAPTIC_DURATION -1
+
+
+#define XR_FREQUENCY_UNSPECIFIED 0
+
+
+#define XR_MAX_EVENT_DATA_SIZE sizeof(XrEventDataBuffer)
+
+
+#define XR_MIN_COMPOSITION_LAYERS_SUPPORTED 16
+
+
+#define XR_CURRENT_LOADER_API_LAYER_VERSION 1
+
+
+#define XR_CURRENT_LOADER_RUNTIME_VERSION 1
+
+
+#define XR_LOADER_INFO_STRUCT_VERSION 1
+
+
+#define XR_API_LAYER_INFO_STRUCT_VERSION 1
+
+
+#define XR_RUNTIME_INFO_STRUCT_VERSION 1
+
+
+#define XR_API_LAYER_NEXT_INFO_STRUCT_VERSION 1
+
+
+#define XR_API_LAYER_CREATE_INFO_STRUCT_VERSION 1
+
+
+#define XR_API_LAYER_MAX_SETTINGS_PATH_SIZE 512
+
+
+#define XR_HAND_JOINT_COUNT_EXT 26
+
+
+#define XR_BODY_JOINT_COUNT_BD 24
+
+
+#define XR_BODY_JOINT_WITHOUT_ARM_COUNT_BD 16
+
+
+#define XR_NULL_CONTROLLER_MODEL_KEY_MSFT 0
+
+
+#define XR_NULL_RENDER_MODEL_KEY_FB 0
+
+
+#define XR_FACIAL_EXPRESSION_EYE_COUNT_HTC 14
+
+
+#define XR_FACIAL_EXPRESSION_LIP_COUNT_HTC 37
+
+
+#define XR_HAND_FOREARM_JOINT_COUNT_ULTRALEAP 27
+
+
+#define XR_NULL_TRACKABLE_ANDROID 0
+
+
+#define XR_FACE_EXPRESSSION_SET_DEFAULT_FB XR_FACE_EXPRESSION_SET_DEFAULT_FB
+
+
+#define XR_MAX_HAPTIC_AMPLITUDE_ENVELOPE_SAMPLES_FB 4000u
+
+
+#define XR_MAX_HAPTIC_PCM_BUFFER_SIZE_FB 4000
+
+
+#define XR_NULL_SPATIAL_ENTITY_ID_EXT 0
+
+
+#define XR_NULL_SPATIAL_BUFFER_ID_EXT 0
+
+
+#define XR_BODY_JOINT_COUNT_HTC 26
+XR_DEFINE_HANDLE(XrAction)
+XR_DEFINE_HANDLE(XrActionSet)
+XR_DEFINE_HANDLE(XrAnchorBD)
+XR_DEFINE_HANDLE(XrBodyTrackerBD)
+XR_DEFINE_HANDLE(XrBodyTrackerFB)
+XR_DEFINE_HANDLE(XrBodyTrackerHTC)
+XR_DEFINE_HANDLE(XrDeviceAnchorPersistenceANDROID)
+XR_DEFINE_HANDLE(XrEnvironmentDepthProviderMETA)
+XR_DEFINE_HANDLE(XrEnvironmentDepthSwapchainMETA)
+XR_DEFINE_HANDLE(XrExportedLocalizationMapML)
+XR_DEFINE_HANDLE(XrEyeTrackerFB)
+XR_DEFINE_HANDLE(XrFaceTracker2FB)
+XR_DEFINE_HANDLE(XrFaceTrackerFB)
+XR_DEFINE_HANDLE(XrFacialExpressionClientML)
+XR_DEFINE_HANDLE(XrFacialTrackerHTC)
+XR_DEFINE_HANDLE(XrFoveationProfileFB)
+XR_DEFINE_HANDLE(XrGeometryInstanceFB)
+XR_DEFINE_HANDLE(XrHandTrackerEXT)
+XR_DEFINE_HANDLE(XrInstance)
+XR_DEFINE_HANDLE(XrMarkerDetectorML)
+XR_DEFINE_HANDLE(XrPassthroughColorLutMETA)
+XR_DEFINE_HANDLE(XrPassthroughFB)
+XR_DEFINE_HANDLE(XrPassthroughHTC)
+XR_DEFINE_HANDLE(XrPassthroughLayerFB)
+XR_DEFINE_HANDLE(XrPlaneDetectorEXT)
+XR_DEFINE_HANDLE(XrRenderModelAssetEXT)
+XR_DEFINE_HANDLE(XrRenderModelEXT)
+XR_DEFINE_HANDLE(XrSceneMSFT)
+XR_DEFINE_HANDLE(XrSceneObserverMSFT)
+XR_DEFINE_HANDLE(XrSenseDataProviderBD)
+XR_DEFINE_HANDLE(XrSenseDataSnapshotBD)
+XR_DEFINE_HANDLE(XrSession)
+XR_DEFINE_HANDLE(XrSpace)
+XR_DEFINE_HANDLE(XrSpaceUserFB)
+XR_DEFINE_HANDLE(XrSpatialAnchorMSFT)
+XR_DEFINE_HANDLE(XrSpatialAnchorStoreConnectionMSFT)
+XR_DEFINE_HANDLE(XrSpatialAnchorsStorageML)
+XR_DEFINE_HANDLE(XrSpatialContextEXT)
+XR_DEFINE_HANDLE(XrSpatialEntityEXT)
+XR_DEFINE_HANDLE(XrSpatialGraphNodeBindingMSFT)
+XR_DEFINE_HANDLE(XrSpatialPersistenceContextEXT)
+XR_DEFINE_HANDLE(XrSpatialSnapshotEXT)
+XR_DEFINE_HANDLE(XrSwapchain)
+XR_DEFINE_HANDLE(XrTrackableTrackerANDROID)
+XR_DEFINE_HANDLE(XrTriangleMeshFB)
+XR_DEFINE_HANDLE(XrVirtualKeyboardMETA)
+XR_DEFINE_HANDLE(XrWorldMeshDetectorML)
+
+typedef uint64_t XrAsyncRequestIdFB;
+typedef uint32_t XrBool32;
+typedef uint64_t XrControllerModelKeyMSFT;
+typedef int64_t XrDuration;
+typedef uint64_t XrFlags64;
+typedef struct XrFutureEXT_T* XrFutureEXT;
+typedef uint64_t XrMarkerML;
+typedef uint64_t XrPath;
+typedef uint64_t XrRenderModelIdEXT;
+typedef uint64_t XrRenderModelKeyFB;
+typedef uint64_t XrSpaceUserIdFB;
+typedef uint64_t XrSpatialBufferIdEXT;
+typedef uint64_t XrSpatialEntityIdBD;
+typedef uint64_t XrSpatialEntityIdEXT;
+typedef uint64_t XrSystemId;
+typedef int64_t XrTime;
+typedef uint64_t XrTrackableANDROID;
+typedef uint64_t XrVersion;
+
+typedef XrFlags64 XrAndroidSurfaceSwapchainFlagsFB;
+typedef XrFlags64 XrCompositionLayerFlags;
+typedef XrFlags64 XrCompositionLayerImageLayoutFlagsFB;
+typedef XrFlags64 XrCompositionLayerSecureContentFlagsFB;
+typedef XrFlags64 XrCompositionLayerSettingsFlagsFB;
+typedef XrFlags64 XrCompositionLayerSpaceWarpInfoFlagsFB;
+typedef XrFlags64 XrDebugUtilsMessageSeverityFlagsEXT;
+typedef XrFlags64 XrDebugUtilsMessageTypeFlagsEXT;
+typedef XrFlags64 XrDigitalLensControlFlagsALMALENCE;
+typedef XrFlags64 XrEnvironmentDepthProviderCreateFlagsMETA;
+typedef XrFlags64 XrEnvironmentDepthSwapchainCreateFlagsMETA;
+typedef XrFlags64 XrExternalCameraStatusFlagsOCULUS;
+typedef XrFlags64 XrFacialExpressionBlendShapePropertiesFlagsML;
+typedef XrFlags64 XrFoveationDynamicFlagsHTC;
+typedef XrFlags64 XrFoveationEyeTrackedProfileCreateFlagsMETA;
+typedef XrFlags64 XrFoveationEyeTrackedStateFlagsMETA;
+typedef XrFlags64 XrFrameEndInfoFlagsML;
+typedef XrFlags64 XrFrameSynthesisInfoFlagsEXT;
+typedef XrFlags64 XrGlobalDimmerFrameEndInfoFlagsML;
+typedef XrFlags64 XrHandTrackingAimFlagsFB;
+typedef XrFlags64 XrInputSourceLocalizedNameFlags;
+typedef XrFlags64 XrInstanceCreateFlags;
+typedef XrFlags64 XrKeyboardTrackingFlagsFB;
+typedef XrFlags64 XrKeyboardTrackingQueryFlagsFB;
+typedef XrFlags64 XrLocalizationMapErrorFlagsML;
+typedef XrFlags64 XrOverlayMainSessionFlagsEXTX;
+typedef XrFlags64 XrOverlaySessionCreateFlagsEXTX;
+typedef XrFlags64 XrPassthroughCapabilityFlagsFB;
+typedef XrFlags64 XrPassthroughFlagsFB;
+typedef XrFlags64 XrPassthroughPreferenceFlagsMETA;
+typedef XrFlags64 XrPassthroughStateChangedFlagsFB;
+typedef XrFlags64 XrPerformanceMetricsCounterFlagsMETA;
+typedef XrFlags64 XrPlaneDetectionCapabilityFlagsEXT;
+typedef XrFlags64 XrPlaneDetectorFlagsEXT;
+typedef XrFlags64 XrRenderModelFlagsFB;
+typedef XrFlags64 XrSemanticLabelsSupportFlagsFB;
+typedef XrFlags64 XrSessionCreateFlags;
+typedef XrFlags64 XrSpaceLocationFlags;
+typedef XrFlags64 XrSpaceVelocityFlags;
+typedef XrFlags64 XrSpatialMeshConfigFlagsBD;
+typedef XrFlags64 XrSwapchainCreateFlags;
+typedef XrFlags64 XrSwapchainCreateFoveationFlagsFB;
+typedef XrFlags64 XrSwapchainStateFoveationFlagsFB;
+typedef XrFlags64 XrSwapchainUsageFlags;
+typedef XrFlags64 XrTriangleMeshFlagsFB;
+typedef XrFlags64 XrViewStateFlags;
+typedef XrFlags64 XrVirtualKeyboardInputStateFlagsMETA;
+typedef XrFlags64 XrVulkanDeviceCreateFlagsKHR;
+typedef XrFlags64 XrVulkanInstanceCreateFlagsKHR;
+typedef XrFlags64 XrWorldMeshDetectorFlagsML;
+
+typedef enum XrActionType
+{
+    XR_ACTION_TYPE_BOOLEAN_INPUT = 1,
+    XR_ACTION_TYPE_FLOAT_INPUT = 2,
+    XR_ACTION_TYPE_VECTOR2F_INPUT = 3,
+    XR_ACTION_TYPE_POSE_INPUT = 4,
+    XR_ACTION_TYPE_VIBRATION_OUTPUT = 100,
+    XR_ACTION_TYPE_MAX_ENUM = 0x7fffffff,
+} XrActionType;
+
+typedef enum XrAnchorPersistStateANDROID
+{
+    XR_ANCHOR_PERSIST_STATE_PERSIST_NOT_REQUESTED_ANDROID = 0,
+    XR_ANCHOR_PERSIST_STATE_PERSIST_PENDING_ANDROID = 1,
+    XR_ANCHOR_PERSIST_STATE_PERSISTED_ANDROID = 2,
+    XR_ANCHOR_PERSIST_STATE_ANDROID_MAX_ENUM = 0x7fffffff,
+} XrAnchorPersistStateANDROID;
+
+typedef enum XrBlendFactorFB
+{
+    XR_BLEND_FACTOR_ZERO_FB = 0,
+    XR_BLEND_FACTOR_ONE_FB = 1,
+    XR_BLEND_FACTOR_SRC_ALPHA_FB = 2,
+    XR_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA_FB = 3,
+    XR_BLEND_FACTOR_DST_ALPHA_FB = 4,
+    XR_BLEND_FACTOR_ONE_MINUS_DST_ALPHA_FB = 5,
+    XR_BLEND_FACTOR_FB_MAX_ENUM = 0x7fffffff,
+} XrBlendFactorFB;
+
+typedef enum XrBodyJointBD
+{
+    XR_BODY_JOINT_PELVIS_BD = 0,
+    XR_BODY_JOINT_LEFT_HIP_BD = 1,
+    XR_BODY_JOINT_RIGHT_HIP_BD = 2,
+    XR_BODY_JOINT_SPINE1_BD = 3,
+    XR_BODY_JOINT_LEFT_KNEE_BD = 4,
+    XR_BODY_JOINT_RIGHT_KNEE_BD = 5,
+    XR_BODY_JOINT_SPINE2_BD = 6,
+    XR_BODY_JOINT_LEFT_ANKLE_BD = 7,
+    XR_BODY_JOINT_RIGHT_ANKLE_BD = 8,
+    XR_BODY_JOINT_SPINE3_BD = 9,
+    XR_BODY_JOINT_LEFT_FOOT_BD = 10,
+    XR_BODY_JOINT_RIGHT_FOOT_BD = 11,
+    XR_BODY_JOINT_NECK_BD = 12,
+    XR_BODY_JOINT_LEFT_COLLAR_BD = 13,
+    XR_BODY_JOINT_RIGHT_COLLAR_BD = 14,
+    XR_BODY_JOINT_HEAD_BD = 15,
+    XR_BODY_JOINT_LEFT_SHOULDER_BD = 16,
+    XR_BODY_JOINT_RIGHT_SHOULDER_BD = 17,
+    XR_BODY_JOINT_LEFT_ELBOW_BD = 18,
+    XR_BODY_JOINT_RIGHT_ELBOW_BD = 19,
+    XR_BODY_JOINT_LEFT_WRIST_BD = 20,
+    XR_BODY_JOINT_RIGHT_WRIST_BD = 21,
+    XR_BODY_JOINT_LEFT_HAND_BD = 22,
+    XR_BODY_JOINT_RIGHT_HAND_BD = 23,
+    XR_BODY_JOINT_BD_MAX_ENUM = 0x7fffffff,
+} XrBodyJointBD;
+
+typedef enum XrBodyJointConfidenceHTC
+{
+    XR_BODY_JOINT_CONFIDENCE_NONE_HTC = 0,
+    XR_BODY_JOINT_CONFIDENCE_LOW_HTC = 1,
+    XR_BODY_JOINT_CONFIDENCE_HIGH_HTC = 2,
+    XR_BODY_JOINT_CONFIDENCE_HTC_MAX_ENUM = 0x7fffffff,
+} XrBodyJointConfidenceHTC;
+
+typedef enum XrBodyJointFB
+{
+    XR_BODY_JOINT_NONE_FB = -1,
+    XR_BODY_JOINT_ROOT_FB = 0,
+    XR_BODY_JOINT_HIPS_FB = 1,
+    XR_BODY_JOINT_SPINE_LOWER_FB = 2,
+    XR_BODY_JOINT_SPINE_MIDDLE_FB = 3,
+    XR_BODY_JOINT_SPINE_UPPER_FB = 4,
+    XR_BODY_JOINT_CHEST_FB = 5,
+    XR_BODY_JOINT_NECK_FB = 6,
+    XR_BODY_JOINT_HEAD_FB = 7,
+    XR_BODY_JOINT_LEFT_SHOULDER_FB = 8,
+    XR_BODY_JOINT_LEFT_SCAPULA_FB = 9,
+    XR_BODY_JOINT_LEFT_ARM_UPPER_FB = 10,
+    XR_BODY_JOINT_LEFT_ARM_LOWER_FB = 11,
+    XR_BODY_JOINT_LEFT_HAND_WRIST_TWIST_FB = 12,
+    XR_BODY_JOINT_RIGHT_SHOULDER_FB = 13,
+    XR_BODY_JOINT_RIGHT_SCAPULA_FB = 14,
+    XR_BODY_JOINT_RIGHT_ARM_UPPER_FB = 15,
+    XR_BODY_JOINT_RIGHT_ARM_LOWER_FB = 16,
+    XR_BODY_JOINT_RIGHT_HAND_WRIST_TWIST_FB = 17,
+    XR_BODY_JOINT_LEFT_HAND_PALM_FB = 18,
+    XR_BODY_JOINT_LEFT_HAND_WRIST_FB = 19,
+    XR_BODY_JOINT_LEFT_HAND_THUMB_METACARPAL_FB = 20,
+    XR_BODY_JOINT_LEFT_HAND_THUMB_PROXIMAL_FB = 21,
+    XR_BODY_JOINT_LEFT_HAND_THUMB_DISTAL_FB = 22,
+    XR_BODY_JOINT_LEFT_HAND_THUMB_TIP_FB = 23,
+    XR_BODY_JOINT_LEFT_HAND_INDEX_METACARPAL_FB = 24,
+    XR_BODY_JOINT_LEFT_HAND_INDEX_PROXIMAL_FB = 25,
+    XR_BODY_JOINT_LEFT_HAND_INDEX_INTERMEDIATE_FB = 26,
+    XR_BODY_JOINT_LEFT_HAND_INDEX_DISTAL_FB = 27,
+    XR_BODY_JOINT_LEFT_HAND_INDEX_TIP_FB = 28,
+    XR_BODY_JOINT_LEFT_HAND_MIDDLE_METACARPAL_FB = 29,
+    XR_BODY_JOINT_LEFT_HAND_MIDDLE_PROXIMAL_FB = 30,
+    XR_BODY_JOINT_LEFT_HAND_MIDDLE_INTERMEDIATE_FB = 31,
+    XR_BODY_JOINT_LEFT_HAND_MIDDLE_DISTAL_FB = 32,
+    XR_BODY_JOINT_LEFT_HAND_MIDDLE_TIP_FB = 33,
+    XR_BODY_JOINT_LEFT_HAND_RING_METACARPAL_FB = 34,
+    XR_BODY_JOINT_LEFT_HAND_RING_PROXIMAL_FB = 35,
+    XR_BODY_JOINT_LEFT_HAND_RING_INTERMEDIATE_FB = 36,
+    XR_BODY_JOINT_LEFT_HAND_RING_DISTAL_FB = 37,
+    XR_BODY_JOINT_LEFT_HAND_RING_TIP_FB = 38,
+    XR_BODY_JOINT_LEFT_HAND_LITTLE_METACARPAL_FB = 39,
+    XR_BODY_JOINT_LEFT_HAND_LITTLE_PROXIMAL_FB = 40,
+    XR_BODY_JOINT_LEFT_HAND_LITTLE_INTERMEDIATE_FB = 41,
+    XR_BODY_JOINT_LEFT_HAND_LITTLE_DISTAL_FB = 42,
+    XR_BODY_JOINT_LEFT_HAND_LITTLE_TIP_FB = 43,
+    XR_BODY_JOINT_RIGHT_HAND_PALM_FB = 44,
+    XR_BODY_JOINT_RIGHT_HAND_WRIST_FB = 45,
+    XR_BODY_JOINT_RIGHT_HAND_THUMB_METACARPAL_FB = 46,
+    XR_BODY_JOINT_RIGHT_HAND_THUMB_PROXIMAL_FB = 47,
+    XR_BODY_JOINT_RIGHT_HAND_THUMB_DISTAL_FB = 48,
+    XR_BODY_JOINT_RIGHT_HAND_THUMB_TIP_FB = 49,
+    XR_BODY_JOINT_RIGHT_HAND_INDEX_METACARPAL_FB = 50,
+    XR_BODY_JOINT_RIGHT_HAND_INDEX_PROXIMAL_FB = 51,
+    XR_BODY_JOINT_RIGHT_HAND_INDEX_INTERMEDIATE_FB = 52,
+    XR_BODY_JOINT_RIGHT_HAND_INDEX_DISTAL_FB = 53,
+    XR_BODY_JOINT_RIGHT_HAND_INDEX_TIP_FB = 54,
+    XR_BODY_JOINT_RIGHT_HAND_MIDDLE_METACARPAL_FB = 55,
+    XR_BODY_JOINT_RIGHT_HAND_MIDDLE_PROXIMAL_FB = 56,
+    XR_BODY_JOINT_RIGHT_HAND_MIDDLE_INTERMEDIATE_FB = 57,
+    XR_BODY_JOINT_RIGHT_HAND_MIDDLE_DISTAL_FB = 58,
+    XR_BODY_JOINT_RIGHT_HAND_MIDDLE_TIP_FB = 59,
+    XR_BODY_JOINT_RIGHT_HAND_RING_METACARPAL_FB = 60,
+    XR_BODY_JOINT_RIGHT_HAND_RING_PROXIMAL_FB = 61,
+    XR_BODY_JOINT_RIGHT_HAND_RING_INTERMEDIATE_FB = 62,
+    XR_BODY_JOINT_RIGHT_HAND_RING_DISTAL_FB = 63,
+    XR_BODY_JOINT_RIGHT_HAND_RING_TIP_FB = 64,
+    XR_BODY_JOINT_RIGHT_HAND_LITTLE_METACARPAL_FB = 65,
+    XR_BODY_JOINT_RIGHT_HAND_LITTLE_PROXIMAL_FB = 66,
+    XR_BODY_JOINT_RIGHT_HAND_LITTLE_INTERMEDIATE_FB = 67,
+    XR_BODY_JOINT_RIGHT_HAND_LITTLE_DISTAL_FB = 68,
+    XR_BODY_JOINT_RIGHT_HAND_LITTLE_TIP_FB = 69,
+    XR_BODY_JOINT_COUNT_FB = 70,
+    XR_BODY_JOINT_FB_MAX_ENUM = 0x7fffffff,
+} XrBodyJointFB;
+
+typedef enum XrBodyJointHTC
+{
+    XR_BODY_JOINT_PELVIS_HTC = 0,
+    XR_BODY_JOINT_LEFT_HIP_HTC = 1,
+    XR_BODY_JOINT_LEFT_KNEE_HTC = 2,
+    XR_BODY_JOINT_LEFT_ANKLE_HTC = 3,
+    XR_BODY_JOINT_LEFT_FEET_HTC = 4,
+    XR_BODY_JOINT_RIGHT_HIP_HTC = 5,
+    XR_BODY_JOINT_RIGHT_KNEE_HTC = 6,
+    XR_BODY_JOINT_RIGHT_ANKLE_HTC = 7,
+    XR_BODY_JOINT_RIGHT_FEET_HTC = 8,
+    XR_BODY_JOINT_WAIST_HTC = 9,
+    XR_BODY_JOINT_SPINE_LOWER_HTC = 10,
+    XR_BODY_JOINT_SPINE_MIDDLE_HTC = 11,
+    XR_BODY_JOINT_SPINE_HIGH_HTC = 12,
+    XR_BODY_JOINT_CHEST_HTC = 13,
+    XR_BODY_JOINT_NECK_HTC = 14,
+    XR_BODY_JOINT_HEAD_HTC = 15,
+    XR_BODY_JOINT_LEFT_CLAVICLE_HTC = 16,
+    XR_BODY_JOINT_LEFT_SCAPULA_HTC = 17,
+    XR_BODY_JOINT_LEFT_ARM_HTC = 18,
+    XR_BODY_JOINT_LEFT_ELBOW_HTC = 19,
+    XR_BODY_JOINT_LEFT_WRIST_HTC = 20,
+    XR_BODY_JOINT_RIGHT_CLAVICLE_HTC = 21,
+    XR_BODY_JOINT_RIGHT_SCAPULA_HTC = 22,
+    XR_BODY_JOINT_RIGHT_ARM_HTC = 23,
+    XR_BODY_JOINT_RIGHT_ELBOW_HTC = 24,
+    XR_BODY_JOINT_RIGHT_WRIST_HTC = 25,
+    XR_BODY_JOINT_HTC_MAX_ENUM = 0x7fffffff,
+} XrBodyJointHTC;
+
+typedef enum XrBodyJointSetBD
+{
+    XR_BODY_JOINT_SET_BODY_WITHOUT_ARM_BD = 1,
+    XR_BODY_JOINT_SET_FULL_BODY_JOINTS_BD = 2,
+    XR_BODY_JOINT_SET_BD_MAX_ENUM = 0x7fffffff,
+} XrBodyJointSetBD;
+
+typedef enum XrBodyJointSetFB
+{
+    XR_BODY_JOINT_SET_DEFAULT_FB = 0,
+    XR_BODY_JOINT_SET_FULL_BODY_META = 1000274000,
+    XR_BODY_JOINT_SET_FB_MAX_ENUM = 0x7fffffff,
+} XrBodyJointSetFB;
+
+typedef enum XrBodyJointSetHTC
+{
+    XR_BODY_JOINT_SET_FULL_HTC = 0,
+    XR_BODY_JOINT_SET_HTC_MAX_ENUM = 0x7fffffff,
+} XrBodyJointSetHTC;
+
+typedef enum XrBodyTrackingCalibrationStateMETA
+{
+    XR_BODY_TRACKING_CALIBRATION_STATE_VALID_META = 1,
+    XR_BODY_TRACKING_CALIBRATION_STATE_CALIBRATING_META = 2,
+    XR_BODY_TRACKING_CALIBRATION_STATE_INVALID_META = 3,
+    XR_BODY_TRACKING_CALIBRATION_STATE_META_MAX_ENUM = 0x7fffffff,
+} XrBodyTrackingCalibrationStateMETA;
+
+typedef enum XrColorSpaceFB
+{
+    XR_COLOR_SPACE_UNMANAGED_FB = 0,
+    XR_COLOR_SPACE_REC2020_FB = 1,
+    XR_COLOR_SPACE_REC709_FB = 2,
+    XR_COLOR_SPACE_RIFT_CV1_FB = 3,
+    XR_COLOR_SPACE_RIFT_S_FB = 4,
+    XR_COLOR_SPACE_QUEST_FB = 5,
+    XR_COLOR_SPACE_P3_FB = 6,
+    XR_COLOR_SPACE_ADOBE_RGB_FB = 7,
+    XR_COLOR_SPACE_FB_MAX_ENUM = 0x7fffffff,
+} XrColorSpaceFB;
+
+typedef enum XrCompareOpFB
+{
+    XR_COMPARE_OP_NEVER_FB = 0,
+    XR_COMPARE_OP_LESS_FB = 1,
+    XR_COMPARE_OP_EQUAL_FB = 2,
+    XR_COMPARE_OP_LESS_OR_EQUAL_FB = 3,
+    XR_COMPARE_OP_GREATER_FB = 4,
+    XR_COMPARE_OP_NOT_EQUAL_FB = 5,
+    XR_COMPARE_OP_GREATER_OR_EQUAL_FB = 6,
+    XR_COMPARE_OP_ALWAYS_FB = 7,
+    XR_COMPARE_OP_FB_MAX_ENUM = 0x7fffffff,
+} XrCompareOpFB;
+
+typedef enum XrCompositionLayerFlagBits
+{
+    XR_COMPOSITION_LAYER_CORRECT_CHROMATIC_ABERRATION_BIT = 0x00000001,
+    XR_COMPOSITION_LAYER_BLEND_TEXTURE_SOURCE_ALPHA_BIT = 0x00000002,
+    XR_COMPOSITION_LAYER_UNPREMULTIPLIED_ALPHA_BIT = 0x00000004,
+    XR_COMPOSITION_LAYER_INVERTED_ALPHA_BIT_EXT = 0x00000008,
+    XR_COMPOSITION_LAYER_FLAG_BITS_MAX_ENUM = 0x7fffffff,
+} XrCompositionLayerFlagBits;
+
+typedef enum XrDigitalLensControlFlagBitsALMALENCE
+{
+    XR_DIGITAL_LENS_CONTROL_PROCESSING_DISABLE_BIT_ALMALENCE = 0x00000001,
+    XR_DIGITAL_LENS_CONTROL_FLAG_BITS_ALMALENCE_MAX_ENUM = 0x7fffffff,
+} XrDigitalLensControlFlagBitsALMALENCE;
+
+typedef enum XrEnvironmentBlendMode
+{
+    XR_ENVIRONMENT_BLEND_MODE_OPAQUE = 1,
+    XR_ENVIRONMENT_BLEND_MODE_ADDITIVE = 2,
+    XR_ENVIRONMENT_BLEND_MODE_ALPHA_BLEND = 3,
+    XR_ENVIRONMENT_BLEND_MODE_MAX_ENUM = 0x7fffffff,
+} XrEnvironmentBlendMode;
+
+typedef enum XrEnvironmentDepthProviderCreateFlagBitsMETA
+{
+    XR_ENVIRONMENT_DEPTH_PROVIDER_CREATE_FLAG_BITS_META_MAX_ENUM = 0x7fffffff,
+} XrEnvironmentDepthProviderCreateFlagBitsMETA;
+
+typedef enum XrEnvironmentDepthSwapchainCreateFlagBitsMETA
+{
+    XR_ENVIRONMENT_DEPTH_SWAPCHAIN_CREATE_FLAG_BITS_META_MAX_ENUM = 0x7fffffff,
+} XrEnvironmentDepthSwapchainCreateFlagBitsMETA;
+
+typedef enum XrExternalCameraAttachedToDeviceOCULUS
+{
+    XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_NONE_OCULUS = 0,
+    XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_HMD_OCULUS = 1,
+    XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_LTOUCH_OCULUS = 2,
+    XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_RTOUCH_OCULUS = 3,
+    XR_EXTERNAL_CAMERA_ATTACHED_TO_DEVICE_OCULUS_MAX_ENUM = 0x7fffffff,
+} XrExternalCameraAttachedToDeviceOCULUS;
+
+typedef enum XrExternalCameraStatusFlagBitsOCULUS
+{
+    XR_EXTERNAL_CAMERA_STATUS_CONNECTED_BIT_OCULUS = 0x00000001,
+    XR_EXTERNAL_CAMERA_STATUS_CALIBRATING_BIT_OCULUS = 0x00000002,
+    XR_EXTERNAL_CAMERA_STATUS_CALIBRATION_FAILED_BIT_OCULUS = 0x00000004,
+    XR_EXTERNAL_CAMERA_STATUS_CALIBRATED_BIT_OCULUS = 0x00000008,
+    XR_EXTERNAL_CAMERA_STATUS_CAPTURING_BIT_OCULUS = 0x00000010,
+    XR_EXTERNAL_CAMERA_STATUS_FLAG_BITS_OCULUS_MAX_ENUM = 0x7fffffff,
+} XrExternalCameraStatusFlagBitsOCULUS;
+
+typedef enum XrEyeCalibrationStatusML
+{
+    XR_EYE_CALIBRATION_STATUS_UNKNOWN_ML = 0,
+    XR_EYE_CALIBRATION_STATUS_NONE_ML = 1,
+    XR_EYE_CALIBRATION_STATUS_COARSE_ML = 2,
+    XR_EYE_CALIBRATION_STATUS_FINE_ML = 3,
+    XR_EYE_CALIBRATION_STATUS_ML_MAX_ENUM = 0x7fffffff,
+} XrEyeCalibrationStatusML;
+
+typedef enum XrEyeExpressionHTC
+{
+    XR_EYE_EXPRESSION_LEFT_BLINK_HTC = 0,
+    XR_EYE_EXPRESSION_LEFT_WIDE_HTC = 1,
+    XR_EYE_EXPRESSION_RIGHT_BLINK_HTC = 2,
+    XR_EYE_EXPRESSION_RIGHT_WIDE_HTC = 3,
+    XR_EYE_EXPRESSION_LEFT_SQUEEZE_HTC = 4,
+    XR_EYE_EXPRESSION_RIGHT_SQUEEZE_HTC = 5,
+    XR_EYE_EXPRESSION_LEFT_DOWN_HTC = 6,
+    XR_EYE_EXPRESSION_RIGHT_DOWN_HTC = 7,
+    XR_EYE_EXPRESSION_LEFT_OUT_HTC = 8,
+    XR_EYE_EXPRESSION_RIGHT_IN_HTC = 9,
+    XR_EYE_EXPRESSION_LEFT_IN_HTC = 10,
+    XR_EYE_EXPRESSION_RIGHT_OUT_HTC = 11,
+    XR_EYE_EXPRESSION_LEFT_UP_HTC = 12,
+    XR_EYE_EXPRESSION_RIGHT_UP_HTC = 13,
+    XR_EYE_EXPRESSION_HTC_MAX_ENUM = 0x7fffffff,
+} XrEyeExpressionHTC;
+
+typedef enum XrEyePositionFB
+{
+    XR_EYE_POSITION_LEFT_FB = 0,
+    XR_EYE_POSITION_RIGHT_FB = 1,
+    XR_EYE_POSITION_COUNT_FB = 2,
+    XR_EYE_POSITION_FB_MAX_ENUM = 0x7fffffff,
+} XrEyePositionFB;
+
+typedef enum XrEyeVisibility
+{
+    XR_EYE_VISIBILITY_BOTH = 0,
+    XR_EYE_VISIBILITY_LEFT = 1,
+    XR_EYE_VISIBILITY_RIGHT = 2,
+    XR_EYE_VISIBILITY_MAX_ENUM = 0x7fffffff,
+} XrEyeVisibility;
+
+typedef enum XrFaceConfidence2FB
+{
+    XR_FACE_CONFIDENCE2_LOWER_FACE_FB = 0,
+    XR_FACE_CONFIDENCE2_UPPER_FACE_FB = 1,
+    XR_FACE_CONFIDENCE2_COUNT_FB = 2,
+    XR_FACE_CONFIDENCE_2FB_MAX_ENUM = 0x7fffffff,
+} XrFaceConfidence2FB;
+
+typedef enum XrFaceConfidenceFB
+{
+    XR_FACE_CONFIDENCE_LOWER_FACE_FB = 0,
+    XR_FACE_CONFIDENCE_UPPER_FACE_FB = 1,
+    XR_FACE_CONFIDENCE_COUNT_FB = 2,
+    XR_FACE_CONFIDENCE_FB_MAX_ENUM = 0x7fffffff,
+} XrFaceConfidenceFB;
+
+typedef enum XrFaceExpression2FB
+{
+    XR_FACE_EXPRESSION2_BROW_LOWERER_L_FB = 0,
+    XR_FACE_EXPRESSION2_BROW_LOWERER_R_FB = 1,
+    XR_FACE_EXPRESSION2_CHEEK_PUFF_L_FB = 2,
+    XR_FACE_EXPRESSION2_CHEEK_PUFF_R_FB = 3,
+    XR_FACE_EXPRESSION2_CHEEK_RAISER_L_FB = 4,
+    XR_FACE_EXPRESSION2_CHEEK_RAISER_R_FB = 5,
+    XR_FACE_EXPRESSION2_CHEEK_SUCK_L_FB = 6,
+    XR_FACE_EXPRESSION2_CHEEK_SUCK_R_FB = 7,
+    XR_FACE_EXPRESSION2_CHIN_RAISER_B_FB = 8,
+    XR_FACE_EXPRESSION2_CHIN_RAISER_T_FB = 9,
+    XR_FACE_EXPRESSION2_DIMPLER_L_FB = 10,
+    XR_FACE_EXPRESSION2_DIMPLER_R_FB = 11,
+    XR_FACE_EXPRESSION2_EYES_CLOSED_L_FB = 12,
+    XR_FACE_EXPRESSION2_EYES_CLOSED_R_FB = 13,
+    XR_FACE_EXPRESSION2_EYES_LOOK_DOWN_L_FB = 14,
+    XR_FACE_EXPRESSION2_EYES_LOOK_DOWN_R_FB = 15,
+    XR_FACE_EXPRESSION2_EYES_LOOK_LEFT_L_FB = 16,
+    XR_FACE_EXPRESSION2_EYES_LOOK_LEFT_R_FB = 17,
+    XR_FACE_EXPRESSION2_EYES_LOOK_RIGHT_L_FB = 18,
+    XR_FACE_EXPRESSION2_EYES_LOOK_RIGHT_R_FB = 19,
+    XR_FACE_EXPRESSION2_EYES_LOOK_UP_L_FB = 20,
+    XR_FACE_EXPRESSION2_EYES_LOOK_UP_R_FB = 21,
+    XR_FACE_EXPRESSION2_INNER_BROW_RAISER_L_FB = 22,
+    XR_FACE_EXPRESSION2_INNER_BROW_RAISER_R_FB = 23,
+    XR_FACE_EXPRESSION2_JAW_DROP_FB = 24,
+    XR_FACE_EXPRESSION2_JAW_SIDEWAYS_LEFT_FB = 25,
+    XR_FACE_EXPRESSION2_JAW_SIDEWAYS_RIGHT_FB = 26,
+    XR_FACE_EXPRESSION2_JAW_THRUST_FB = 27,
+    XR_FACE_EXPRESSION2_LID_TIGHTENER_L_FB = 28,
+    XR_FACE_EXPRESSION2_LID_TIGHTENER_R_FB = 29,
+    XR_FACE_EXPRESSION2_LIP_CORNER_DEPRESSOR_L_FB = 30,
+    XR_FACE_EXPRESSION2_LIP_CORNER_DEPRESSOR_R_FB = 31,
+    XR_FACE_EXPRESSION2_LIP_CORNER_PULLER_L_FB = 32,
+    XR_FACE_EXPRESSION2_LIP_CORNER_PULLER_R_FB = 33,
+    XR_FACE_EXPRESSION2_LIP_FUNNELER_LB_FB = 34,
+    XR_FACE_EXPRESSION2_LIP_FUNNELER_LT_FB = 35,
+    XR_FACE_EXPRESSION2_LIP_FUNNELER_RB_FB = 36,
+    XR_FACE_EXPRESSION2_LIP_FUNNELER_RT_FB = 37,
+    XR_FACE_EXPRESSION2_LIP_PRESSOR_L_FB = 38,
+    XR_FACE_EXPRESSION2_LIP_PRESSOR_R_FB = 39,
+    XR_FACE_EXPRESSION2_LIP_PUCKER_L_FB = 40,
+    XR_FACE_EXPRESSION2_LIP_PUCKER_R_FB = 41,
+    XR_FACE_EXPRESSION2_LIP_STRETCHER_L_FB = 42,
+    XR_FACE_EXPRESSION2_LIP_STRETCHER_R_FB = 43,
+    XR_FACE_EXPRESSION2_LIP_SUCK_LB_FB = 44,
+    XR_FACE_EXPRESSION2_LIP_SUCK_LT_FB = 45,
+    XR_FACE_EXPRESSION2_LIP_SUCK_RB_FB = 46,
+    XR_FACE_EXPRESSION2_LIP_SUCK_RT_FB = 47,
+    XR_FACE_EXPRESSION2_LIP_TIGHTENER_L_FB = 48,
+    XR_FACE_EXPRESSION2_LIP_TIGHTENER_R_FB = 49,
+    XR_FACE_EXPRESSION2_LIPS_TOWARD_FB = 50,
+    XR_FACE_EXPRESSION2_LOWER_LIP_DEPRESSOR_L_FB = 51,
+    XR_FACE_EXPRESSION2_LOWER_LIP_DEPRESSOR_R_FB = 52,
+    XR_FACE_EXPRESSION2_MOUTH_LEFT_FB = 53,
+    XR_FACE_EXPRESSION2_MOUTH_RIGHT_FB = 54,
+    XR_FACE_EXPRESSION2_NOSE_WRINKLER_L_FB = 55,
+    XR_FACE_EXPRESSION2_NOSE_WRINKLER_R_FB = 56,
+    XR_FACE_EXPRESSION2_OUTER_BROW_RAISER_L_FB = 57,
+    XR_FACE_EXPRESSION2_OUTER_BROW_RAISER_R_FB = 58,
+    XR_FACE_EXPRESSION2_UPPER_LID_RAISER_L_FB = 59,
+    XR_FACE_EXPRESSION2_UPPER_LID_RAISER_R_FB = 60,
+    XR_FACE_EXPRESSION2_UPPER_LIP_RAISER_L_FB = 61,
+    XR_FACE_EXPRESSION2_UPPER_LIP_RAISER_R_FB = 62,
+    XR_FACE_EXPRESSION2_TONGUE_TIP_INTERDENTAL_FB = 63,
+    XR_FACE_EXPRESSION2_TONGUE_TIP_ALVEOLAR_FB = 64,
+    XR_FACE_EXPRESSION2_TONGUE_FRONT_DORSAL_PALATE_FB = 65,
+    XR_FACE_EXPRESSION2_TONGUE_MID_DORSAL_PALATE_FB = 66,
+    XR_FACE_EXPRESSION2_TONGUE_BACK_DORSAL_VELAR_FB = 67,
+    XR_FACE_EXPRESSION2_TONGUE_OUT_FB = 68,
+    XR_FACE_EXPRESSION2_TONGUE_RETREAT_FB = 69,
+    XR_FACE_EXPRESSION2_COUNT_FB = 70,
+    XR_FACE_EXPRESSION_2FB_MAX_ENUM = 0x7fffffff,
+} XrFaceExpression2FB;
+
+typedef enum XrFaceExpressionFB
+{
+    XR_FACE_EXPRESSION_BROW_LOWERER_L_FB = 0,
+    XR_FACE_EXPRESSION_BROW_LOWERER_R_FB = 1,
+    XR_FACE_EXPRESSION_CHEEK_PUFF_L_FB = 2,
+    XR_FACE_EXPRESSION_CHEEK_PUFF_R_FB = 3,
+    XR_FACE_EXPRESSION_CHEEK_RAISER_L_FB = 4,
+    XR_FACE_EXPRESSION_CHEEK_RAISER_R_FB = 5,
+    XR_FACE_EXPRESSION_CHEEK_SUCK_L_FB = 6,
+    XR_FACE_EXPRESSION_CHEEK_SUCK_R_FB = 7,
+    XR_FACE_EXPRESSION_CHIN_RAISER_B_FB = 8,
+    XR_FACE_EXPRESSION_CHIN_RAISER_T_FB = 9,
+    XR_FACE_EXPRESSION_DIMPLER_L_FB = 10,
+    XR_FACE_EXPRESSION_DIMPLER_R_FB = 11,
+    XR_FACE_EXPRESSION_EYES_CLOSED_L_FB = 12,
+    XR_FACE_EXPRESSION_EYES_CLOSED_R_FB = 13,
+    XR_FACE_EXPRESSION_EYES_LOOK_DOWN_L_FB = 14,
+    XR_FACE_EXPRESSION_EYES_LOOK_DOWN_R_FB = 15,
+    XR_FACE_EXPRESSION_EYES_LOOK_LEFT_L_FB = 16,
+    XR_FACE_EXPRESSION_EYES_LOOK_LEFT_R_FB = 17,
+    XR_FACE_EXPRESSION_EYES_LOOK_RIGHT_L_FB = 18,
+    XR_FACE_EXPRESSION_EYES_LOOK_RIGHT_R_FB = 19,
+    XR_FACE_EXPRESSION_EYES_LOOK_UP_L_FB = 20,
+    XR_FACE_EXPRESSION_EYES_LOOK_UP_R_FB = 21,
+    XR_FACE_EXPRESSION_INNER_BROW_RAISER_L_FB = 22,
+    XR_FACE_EXPRESSION_INNER_BROW_RAISER_R_FB = 23,
+    XR_FACE_EXPRESSION_JAW_DROP_FB = 24,
+    XR_FACE_EXPRESSION_JAW_SIDEWAYS_LEFT_FB = 25,
+    XR_FACE_EXPRESSION_JAW_SIDEWAYS_RIGHT_FB = 26,
+    XR_FACE_EXPRESSION_JAW_THRUST_FB = 27,
+    XR_FACE_EXPRESSION_LID_TIGHTENER_L_FB = 28,
+    XR_FACE_EXPRESSION_LID_TIGHTENER_R_FB = 29,
+    XR_FACE_EXPRESSION_LIP_CORNER_DEPRESSOR_L_FB = 30,
+    XR_FACE_EXPRESSION_LIP_CORNER_DEPRESSOR_R_FB = 31,
+    XR_FACE_EXPRESSION_LIP_CORNER_PULLER_L_FB = 32,
+    XR_FACE_EXPRESSION_LIP_CORNER_PULLER_R_FB = 33,
+    XR_FACE_EXPRESSION_LIP_FUNNELER_LB_FB = 34,
+    XR_FACE_EXPRESSION_LIP_FUNNELER_LT_FB = 35,
+    XR_FACE_EXPRESSION_LIP_FUNNELER_RB_FB = 36,
+    XR_FACE_EXPRESSION_LIP_FUNNELER_RT_FB = 37,
+    XR_FACE_EXPRESSION_LIP_PRESSOR_L_FB = 38,
+    XR_FACE_EXPRESSION_LIP_PRESSOR_R_FB = 39,
+    XR_FACE_EXPRESSION_LIP_PUCKER_L_FB = 40,
+    XR_FACE_EXPRESSION_LIP_PUCKER_R_FB = 41,
+    XR_FACE_EXPRESSION_LIP_STRETCHER_L_FB = 42,
+    XR_FACE_EXPRESSION_LIP_STRETCHER_R_FB = 43,
+    XR_FACE_EXPRESSION_LIP_SUCK_LB_FB = 44,
+    XR_FACE_EXPRESSION_LIP_SUCK_LT_FB = 45,
+    XR_FACE_EXPRESSION_LIP_SUCK_RB_FB = 46,
+    XR_FACE_EXPRESSION_LIP_SUCK_RT_FB = 47,
+    XR_FACE_EXPRESSION_LIP_TIGHTENER_L_FB = 48,
+    XR_FACE_EXPRESSION_LIP_TIGHTENER_R_FB = 49,
+    XR_FACE_EXPRESSION_LIPS_TOWARD_FB = 50,
+    XR_FACE_EXPRESSION_LOWER_LIP_DEPRESSOR_L_FB = 51,
+    XR_FACE_EXPRESSION_LOWER_LIP_DEPRESSOR_R_FB = 52,
+    XR_FACE_EXPRESSION_MOUTH_LEFT_FB = 53,
+    XR_FACE_EXPRESSION_MOUTH_RIGHT_FB = 54,
+    XR_FACE_EXPRESSION_NOSE_WRINKLER_L_FB = 55,
+    XR_FACE_EXPRESSION_NOSE_WRINKLER_R_FB = 56,
+    XR_FACE_EXPRESSION_OUTER_BROW_RAISER_L_FB = 57,
+    XR_FACE_EXPRESSION_OUTER_BROW_RAISER_R_FB = 58,
+    XR_FACE_EXPRESSION_UPPER_LID_RAISER_L_FB = 59,
+    XR_FACE_EXPRESSION_UPPER_LID_RAISER_R_FB = 60,
+    XR_FACE_EXPRESSION_UPPER_LIP_RAISER_L_FB = 61,
+    XR_FACE_EXPRESSION_UPPER_LIP_RAISER_R_FB = 62,
+    XR_FACE_EXPRESSION_COUNT_FB = 63,
+    XR_FACE_EXPRESSION_FB_MAX_ENUM = 0x7fffffff,
+} XrFaceExpressionFB;
+
+typedef enum XrFaceExpressionSet2FB
+{
+    XR_FACE_EXPRESSION_SET2_DEFAULT_FB = 0,
+    XR_FACE_EXPRESSION_SET_2FB_MAX_ENUM = 0x7fffffff,
+} XrFaceExpressionSet2FB;
+
+typedef enum XrFaceExpressionSetFB
+{
+    XR_FACE_EXPRESSION_SET_DEFAULT_FB = 0,
+    XR_FACE_EXPRESSION_SET_FB_MAX_ENUM = 0x7fffffff,
+} XrFaceExpressionSetFB;
+
+typedef enum XrFaceTrackingDataSource2FB
+{
+    XR_FACE_TRACKING_DATA_SOURCE2_VISUAL_FB = 0,
+    XR_FACE_TRACKING_DATA_SOURCE2_AUDIO_FB = 1,
+    XR_FACE_TRACKING_DATA_SOURCE_2FB_MAX_ENUM = 0x7fffffff,
+} XrFaceTrackingDataSource2FB;
+
+typedef enum XrFacialBlendShapeML
+{
+    XR_FACIAL_BLEND_SHAPE_BROW_LOWERER_L_ML = 0,
+    XR_FACIAL_BLEND_SHAPE_BROW_LOWERER_R_ML = 1,
+    XR_FACIAL_BLEND_SHAPE_CHEEK_RAISER_L_ML = 2,
+    XR_FACIAL_BLEND_SHAPE_CHEEK_RAISER_R_ML = 3,
+    XR_FACIAL_BLEND_SHAPE_CHIN_RAISER_ML = 4,
+    XR_FACIAL_BLEND_SHAPE_DIMPLER_L_ML = 5,
+    XR_FACIAL_BLEND_SHAPE_DIMPLER_R_ML = 6,
+    XR_FACIAL_BLEND_SHAPE_EYES_CLOSED_L_ML = 7,
+    XR_FACIAL_BLEND_SHAPE_EYES_CLOSED_R_ML = 8,
+    XR_FACIAL_BLEND_SHAPE_INNER_BROW_RAISER_L_ML = 9,
+    XR_FACIAL_BLEND_SHAPE_INNER_BROW_RAISER_R_ML = 10,
+    XR_FACIAL_BLEND_SHAPE_JAW_DROP_ML = 11,
+    XR_FACIAL_BLEND_SHAPE_LID_TIGHTENER_L_ML = 12,
+    XR_FACIAL_BLEND_SHAPE_LID_TIGHTENER_R_ML = 13,
+    XR_FACIAL_BLEND_SHAPE_LIP_CORNER_DEPRESSOR_L_ML = 14,
+    XR_FACIAL_BLEND_SHAPE_LIP_CORNER_DEPRESSOR_R_ML = 15,
+    XR_FACIAL_BLEND_SHAPE_LIP_CORNER_PULLER_L_ML = 16,
+    XR_FACIAL_BLEND_SHAPE_LIP_CORNER_PULLER_R_ML = 17,
+    XR_FACIAL_BLEND_SHAPE_LIP_FUNNELER_LB_ML = 18,
+    XR_FACIAL_BLEND_SHAPE_LIP_FUNNELER_LT_ML = 19,
+    XR_FACIAL_BLEND_SHAPE_LIP_FUNNELER_RB_ML = 20,
+    XR_FACIAL_BLEND_SHAPE_LIP_FUNNELER_RT_ML = 21,
+    XR_FACIAL_BLEND_SHAPE_LIP_PRESSOR_L_ML = 22,
+    XR_FACIAL_BLEND_SHAPE_LIP_PRESSOR_R_ML = 23,
+    XR_FACIAL_BLEND_SHAPE_LIP_PUCKER_L_ML = 24,
+    XR_FACIAL_BLEND_SHAPE_LIP_PUCKER_R_ML = 25,
+    XR_FACIAL_BLEND_SHAPE_LIP_STRETCHER_L_ML = 26,
+    XR_FACIAL_BLEND_SHAPE_LIP_STRETCHER_R_ML = 27,
+    XR_FACIAL_BLEND_SHAPE_LIP_SUCK_LB_ML = 28,
+    XR_FACIAL_BLEND_SHAPE_LIP_SUCK_LT_ML = 29,
+    XR_FACIAL_BLEND_SHAPE_LIP_SUCK_RB_ML = 30,
+    XR_FACIAL_BLEND_SHAPE_LIP_SUCK_RT_ML = 31,
+    XR_FACIAL_BLEND_SHAPE_LIP_TIGHTENER_L_ML = 32,
+    XR_FACIAL_BLEND_SHAPE_LIP_TIGHTENER_R_ML = 33,
+    XR_FACIAL_BLEND_SHAPE_LIPS_TOWARD_ML = 34,
+    XR_FACIAL_BLEND_SHAPE_LOWER_LIP_DEPRESSOR_L_ML = 35,
+    XR_FACIAL_BLEND_SHAPE_LOWER_LIP_DEPRESSOR_R_ML = 36,
+    XR_FACIAL_BLEND_SHAPE_NOSE_WRINKLER_L_ML = 37,
+    XR_FACIAL_BLEND_SHAPE_NOSE_WRINKLER_R_ML = 38,
+    XR_FACIAL_BLEND_SHAPE_OUTER_BROW_RAISER_L_ML = 39,
+    XR_FACIAL_BLEND_SHAPE_OUTER_BROW_RAISER_R_ML = 40,
+    XR_FACIAL_BLEND_SHAPE_UPPER_LID_RAISER_L_ML = 41,
+    XR_FACIAL_BLEND_SHAPE_UPPER_LID_RAISER_R_ML = 42,
+    XR_FACIAL_BLEND_SHAPE_UPPER_LIP_RAISER_L_ML = 43,
+    XR_FACIAL_BLEND_SHAPE_UPPER_LIP_RAISER_R_ML = 44,
+    XR_FACIAL_BLEND_SHAPE_TONGUE_OUT_ML = 45,
+    XR_FACIAL_BLEND_SHAPE_ML_MAX_ENUM = 0x7fffffff,
+} XrFacialBlendShapeML;
+
+typedef enum XrFacialExpressionBlendShapePropertiesFlagBitsML
+{
+    XR_FACIAL_EXPRESSION_BLEND_SHAPE_PROPERTIES_VALID_BIT_ML = 0x00000001,
+    XR_FACIAL_EXPRESSION_BLEND_SHAPE_PROPERTIES_TRACKED_BIT_ML = 0x00000002,
+    XR_FACIAL_EXPRESSION_BLEND_SHAPE_PROPERTIES_FLAG_BITS_ML_MAX_ENUM = 0x7fffffff,
+} XrFacialExpressionBlendShapePropertiesFlagBitsML;
+
+typedef enum XrFacialTrackingTypeHTC
+{
+    XR_FACIAL_TRACKING_TYPE_EYE_DEFAULT_HTC = 1,
+    XR_FACIAL_TRACKING_TYPE_LIP_DEFAULT_HTC = 2,
+    XR_FACIAL_TRACKING_TYPE_HTC_MAX_ENUM = 0x7fffffff,
+} XrFacialTrackingTypeHTC;
+
+typedef enum XrForceFeedbackCurlLocationMNDX
+{
+    XR_FORCE_FEEDBACK_CURL_LOCATION_THUMB_CURL_MNDX = 0,
+    XR_FORCE_FEEDBACK_CURL_LOCATION_INDEX_CURL_MNDX = 1,
+    XR_FORCE_FEEDBACK_CURL_LOCATION_MIDDLE_CURL_MNDX = 2,
+    XR_FORCE_FEEDBACK_CURL_LOCATION_RING_CURL_MNDX = 3,
+    XR_FORCE_FEEDBACK_CURL_LOCATION_LITTLE_CURL_MNDX = 4,
+    XR_FORCE_FEEDBACK_CURL_LOCATION_MNDX_MAX_ENUM = 0x7fffffff,
+} XrForceFeedbackCurlLocationMNDX;
+
+typedef enum XrFormFactor
+{
+    XR_FORM_FACTOR_HEAD_MOUNTED_DISPLAY = 1,
+    XR_FORM_FACTOR_HANDHELD_DISPLAY = 2,
+    XR_FORM_FACTOR_MAX_ENUM = 0x7fffffff,
+} XrFormFactor;
+
+typedef enum XrFoveationDynamicFB
+{
+    XR_FOVEATION_DYNAMIC_DISABLED_FB = 0,
+    XR_FOVEATION_DYNAMIC_LEVEL_ENABLED_FB = 1,
+    XR_FOVEATION_DYNAMIC_FB_MAX_ENUM = 0x7fffffff,
+} XrFoveationDynamicFB;
+
+typedef enum XrFoveationEyeTrackedProfileCreateFlagBitsMETA
+{
+    XR_FOVEATION_EYE_TRACKED_PROFILE_CREATE_FLAG_BITS_META_MAX_ENUM = 0x7fffffff,
+} XrFoveationEyeTrackedProfileCreateFlagBitsMETA;
+
+typedef enum XrFoveationEyeTrackedStateFlagBitsMETA
+{
+    XR_FOVEATION_EYE_TRACKED_STATE_VALID_BIT_META = 0x00000001,
+    XR_FOVEATION_EYE_TRACKED_STATE_FLAG_BITS_META_MAX_ENUM = 0x7fffffff,
+} XrFoveationEyeTrackedStateFlagBitsMETA;
+
+typedef enum XrFoveationLevelFB
+{
+    XR_FOVEATION_LEVEL_NONE_FB = 0,
+    XR_FOVEATION_LEVEL_LOW_FB = 1,
+    XR_FOVEATION_LEVEL_MEDIUM_FB = 2,
+    XR_FOVEATION_LEVEL_HIGH_FB = 3,
+    XR_FOVEATION_LEVEL_FB_MAX_ENUM = 0x7fffffff,
+} XrFoveationLevelFB;
+
+typedef enum XrFullBodyJointMETA
+{
+    XR_FULL_BODY_JOINT_ROOT_META = 0,
+    XR_FULL_BODY_JOINT_HIPS_META = 1,
+    XR_FULL_BODY_JOINT_SPINE_LOWER_META = 2,
+    XR_FULL_BODY_JOINT_SPINE_MIDDLE_META = 3,
+    XR_FULL_BODY_JOINT_SPINE_UPPER_META = 4,
+    XR_FULL_BODY_JOINT_CHEST_META = 5,
+    XR_FULL_BODY_JOINT_NECK_META = 6,
+    XR_FULL_BODY_JOINT_HEAD_META = 7,
+    XR_FULL_BODY_JOINT_LEFT_SHOULDER_META = 8,
+    XR_FULL_BODY_JOINT_LEFT_SCAPULA_META = 9,
+    XR_FULL_BODY_JOINT_LEFT_ARM_UPPER_META = 10,
+    XR_FULL_BODY_JOINT_LEFT_ARM_LOWER_META = 11,
+    XR_FULL_BODY_JOINT_LEFT_HAND_WRIST_TWIST_META = 12,
+    XR_FULL_BODY_JOINT_RIGHT_SHOULDER_META = 13,
+    XR_FULL_BODY_JOINT_RIGHT_SCAPULA_META = 14,
+    XR_FULL_BODY_JOINT_RIGHT_ARM_UPPER_META = 15,
+    XR_FULL_BODY_JOINT_RIGHT_ARM_LOWER_META = 16,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_WRIST_TWIST_META = 17,
+    XR_FULL_BODY_JOINT_LEFT_HAND_PALM_META = 18,
+    XR_FULL_BODY_JOINT_LEFT_HAND_WRIST_META = 19,
+    XR_FULL_BODY_JOINT_LEFT_HAND_THUMB_METACARPAL_META = 20,
+    XR_FULL_BODY_JOINT_LEFT_HAND_THUMB_PROXIMAL_META = 21,
+    XR_FULL_BODY_JOINT_LEFT_HAND_THUMB_DISTAL_META = 22,
+    XR_FULL_BODY_JOINT_LEFT_HAND_THUMB_TIP_META = 23,
+    XR_FULL_BODY_JOINT_LEFT_HAND_INDEX_METACARPAL_META = 24,
+    XR_FULL_BODY_JOINT_LEFT_HAND_INDEX_PROXIMAL_META = 25,
+    XR_FULL_BODY_JOINT_LEFT_HAND_INDEX_INTERMEDIATE_META = 26,
+    XR_FULL_BODY_JOINT_LEFT_HAND_INDEX_DISTAL_META = 27,
+    XR_FULL_BODY_JOINT_LEFT_HAND_INDEX_TIP_META = 28,
+    XR_FULL_BODY_JOINT_LEFT_HAND_MIDDLE_METACARPAL_META = 29,
+    XR_FULL_BODY_JOINT_LEFT_HAND_MIDDLE_PROXIMAL_META = 30,
+    XR_FULL_BODY_JOINT_LEFT_HAND_MIDDLE_INTERMEDIATE_META = 31,
+    XR_FULL_BODY_JOINT_LEFT_HAND_MIDDLE_DISTAL_META = 32,
+    XR_FULL_BODY_JOINT_LEFT_HAND_MIDDLE_TIP_META = 33,
+    XR_FULL_BODY_JOINT_LEFT_HAND_RING_METACARPAL_META = 34,
+    XR_FULL_BODY_JOINT_LEFT_HAND_RING_PROXIMAL_META = 35,
+    XR_FULL_BODY_JOINT_LEFT_HAND_RING_INTERMEDIATE_META = 36,
+    XR_FULL_BODY_JOINT_LEFT_HAND_RING_DISTAL_META = 37,
+    XR_FULL_BODY_JOINT_LEFT_HAND_RING_TIP_META = 38,
+    XR_FULL_BODY_JOINT_LEFT_HAND_LITTLE_METACARPAL_META = 39,
+    XR_FULL_BODY_JOINT_LEFT_HAND_LITTLE_PROXIMAL_META = 40,
+    XR_FULL_BODY_JOINT_LEFT_HAND_LITTLE_INTERMEDIATE_META = 41,
+    XR_FULL_BODY_JOINT_LEFT_HAND_LITTLE_DISTAL_META = 42,
+    XR_FULL_BODY_JOINT_LEFT_HAND_LITTLE_TIP_META = 43,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_PALM_META = 44,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_WRIST_META = 45,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_THUMB_METACARPAL_META = 46,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_THUMB_PROXIMAL_META = 47,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_THUMB_DISTAL_META = 48,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_THUMB_TIP_META = 49,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_INDEX_METACARPAL_META = 50,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_INDEX_PROXIMAL_META = 51,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_INDEX_INTERMEDIATE_META = 52,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_INDEX_DISTAL_META = 53,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_INDEX_TIP_META = 54,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_MIDDLE_METACARPAL_META = 55,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_MIDDLE_PROXIMAL_META = 56,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_MIDDLE_INTERMEDIATE_META = 57,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_MIDDLE_DISTAL_META = 58,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_MIDDLE_TIP_META = 59,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_RING_METACARPAL_META = 60,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_RING_PROXIMAL_META = 61,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_RING_INTERMEDIATE_META = 62,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_RING_DISTAL_META = 63,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_RING_TIP_META = 64,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_LITTLE_METACARPAL_META = 65,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_LITTLE_PROXIMAL_META = 66,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_LITTLE_INTERMEDIATE_META = 67,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_LITTLE_DISTAL_META = 68,
+    XR_FULL_BODY_JOINT_RIGHT_HAND_LITTLE_TIP_META = 69,
+    XR_FULL_BODY_JOINT_LEFT_UPPER_LEG_META = 70,
+    XR_FULL_BODY_JOINT_LEFT_LOWER_LEG_META = 71,
+    XR_FULL_BODY_JOINT_LEFT_FOOT_ANKLE_TWIST_META = 72,
+    XR_FULL_BODY_JOINT_LEFT_FOOT_ANKLE_META = 73,
+    XR_FULL_BODY_JOINT_LEFT_FOOT_SUBTALAR_META = 74,
+    XR_FULL_BODY_JOINT_LEFT_FOOT_TRANSVERSE_META = 75,
+    XR_FULL_BODY_JOINT_LEFT_FOOT_BALL_META = 76,
+    XR_FULL_BODY_JOINT_RIGHT_UPPER_LEG_META = 77,
+    XR_FULL_BODY_JOINT_RIGHT_LOWER_LEG_META = 78,
+    XR_FULL_BODY_JOINT_RIGHT_FOOT_ANKLE_TWIST_META = 79,
+    XR_FULL_BODY_JOINT_RIGHT_FOOT_ANKLE_META = 80,
+    XR_FULL_BODY_JOINT_RIGHT_FOOT_SUBTALAR_META = 81,
+    XR_FULL_BODY_JOINT_RIGHT_FOOT_TRANSVERSE_META = 82,
+    XR_FULL_BODY_JOINT_RIGHT_FOOT_BALL_META = 83,
+    XR_FULL_BODY_JOINT_COUNT_META = 84,
+    XR_FULL_BODY_JOINT_NONE_META = 85,
+    XR_FULL_BODY_JOINT_META_MAX_ENUM = 0x7fffffff,
+} XrFullBodyJointMETA;
+
+typedef enum XrFutureStateEXT
+{
+    XR_FUTURE_STATE_PENDING_EXT = 1,
+    XR_FUTURE_STATE_READY_EXT = 2,
+    XR_FUTURE_STATE_EXT_MAX_ENUM = 0x7fffffff,
+} XrFutureStateEXT;
+
+typedef enum XrHandEXT
+{
+    XR_HAND_LEFT_EXT = 1,
+    XR_HAND_RIGHT_EXT = 2,
+    XR_HAND_EXT_MAX_ENUM = 0x7fffffff,
+} XrHandEXT;
+
+typedef enum XrHandForearmJointULTRALEAP
+{
+    XR_HAND_FOREARM_JOINT_PALM_ULTRALEAP = 0,
+    XR_HAND_FOREARM_JOINT_WRIST_ULTRALEAP = 1,
+    XR_HAND_FOREARM_JOINT_THUMB_METACARPAL_ULTRALEAP = 2,
+    XR_HAND_FOREARM_JOINT_THUMB_PROXIMAL_ULTRALEAP = 3,
+    XR_HAND_FOREARM_JOINT_THUMB_DISTAL_ULTRALEAP = 4,
+    XR_HAND_FOREARM_JOINT_THUMB_TIP_ULTRALEAP = 5,
+    XR_HAND_FOREARM_JOINT_INDEX_METACARPAL_ULTRALEAP = 6,
+    XR_HAND_FOREARM_JOINT_INDEX_PROXIMAL_ULTRALEAP = 7,
+    XR_HAND_FOREARM_JOINT_INDEX_INTERMEDIATE_ULTRALEAP = 8,
+    XR_HAND_FOREARM_JOINT_INDEX_DISTAL_ULTRALEAP = 9,
+    XR_HAND_FOREARM_JOINT_INDEX_TIP_ULTRALEAP = 10,
+    XR_HAND_FOREARM_JOINT_MIDDLE_METACARPAL_ULTRALEAP = 11,
+    XR_HAND_FOREARM_JOINT_MIDDLE_PROXIMAL_ULTRALEAP = 12,
+    XR_HAND_FOREARM_JOINT_MIDDLE_INTERMEDIATE_ULTRALEAP = 13,
+    XR_HAND_FOREARM_JOINT_MIDDLE_DISTAL_ULTRALEAP = 14,
+    XR_HAND_FOREARM_JOINT_MIDDLE_TIP_ULTRALEAP = 15,
+    XR_HAND_FOREARM_JOINT_RING_METACARPAL_ULTRALEAP = 16,
+    XR_HAND_FOREARM_JOINT_RING_PROXIMAL_ULTRALEAP = 17,
+    XR_HAND_FOREARM_JOINT_RING_INTERMEDIATE_ULTRALEAP = 18,
+    XR_HAND_FOREARM_JOINT_RING_DISTAL_ULTRALEAP = 19,
+    XR_HAND_FOREARM_JOINT_RING_TIP_ULTRALEAP = 20,
+    XR_HAND_FOREARM_JOINT_LITTLE_METACARPAL_ULTRALEAP = 21,
+    XR_HAND_FOREARM_JOINT_LITTLE_PROXIMAL_ULTRALEAP = 22,
+    XR_HAND_FOREARM_JOINT_LITTLE_INTERMEDIATE_ULTRALEAP = 23,
+    XR_HAND_FOREARM_JOINT_LITTLE_DISTAL_ULTRALEAP = 24,
+    XR_HAND_FOREARM_JOINT_LITTLE_TIP_ULTRALEAP = 25,
+    XR_HAND_FOREARM_JOINT_ELBOW_ULTRALEAP = 26,
+    XR_HAND_FOREARM_JOINT_ULTRALEAP_MAX_ENUM = 0x7fffffff,
+} XrHandForearmJointULTRALEAP;
+
+typedef enum XrHandJointEXT
+{
+    XR_HAND_JOINT_PALM_EXT = 0,
+    XR_HAND_JOINT_WRIST_EXT = 1,
+    XR_HAND_JOINT_THUMB_METACARPAL_EXT = 2,
+    XR_HAND_JOINT_THUMB_PROXIMAL_EXT = 3,
+    XR_HAND_JOINT_THUMB_DISTAL_EXT = 4,
+    XR_HAND_JOINT_THUMB_TIP_EXT = 5,
+    XR_HAND_JOINT_INDEX_METACARPAL_EXT = 6,
+    XR_HAND_JOINT_INDEX_PROXIMAL_EXT = 7,
+    XR_HAND_JOINT_INDEX_INTERMEDIATE_EXT = 8,
+    XR_HAND_JOINT_INDEX_DISTAL_EXT = 9,
+    XR_HAND_JOINT_INDEX_TIP_EXT = 10,
+    XR_HAND_JOINT_MIDDLE_METACARPAL_EXT = 11,
+    XR_HAND_JOINT_MIDDLE_PROXIMAL_EXT = 12,
+    XR_HAND_JOINT_MIDDLE_INTERMEDIATE_EXT = 13,
+    XR_HAND_JOINT_MIDDLE_DISTAL_EXT = 14,
+    XR_HAND_JOINT_MIDDLE_TIP_EXT = 15,
+    XR_HAND_JOINT_RING_METACARPAL_EXT = 16,
+    XR_HAND_JOINT_RING_PROXIMAL_EXT = 17,
+    XR_HAND_JOINT_RING_INTERMEDIATE_EXT = 18,
+    XR_HAND_JOINT_RING_DISTAL_EXT = 19,
+    XR_HAND_JOINT_RING_TIP_EXT = 20,
+    XR_HAND_JOINT_LITTLE_METACARPAL_EXT = 21,
+    XR_HAND_JOINT_LITTLE_PROXIMAL_EXT = 22,
+    XR_HAND_JOINT_LITTLE_INTERMEDIATE_EXT = 23,
+    XR_HAND_JOINT_LITTLE_DISTAL_EXT = 24,
+    XR_HAND_JOINT_LITTLE_TIP_EXT = 25,
+    XR_HAND_JOINT_EXT_MAX_ENUM = 0x7fffffff,
+} XrHandJointEXT;
+
+typedef enum XrHandJointSetEXT
+{
+    XR_HAND_JOINT_SET_DEFAULT_EXT = 0,
+    XR_HAND_JOINT_SET_HAND_WITH_FOREARM_ULTRALEAP = 1000149000,
+    XR_HAND_JOINT_SET_EXT_MAX_ENUM = 0x7fffffff,
+} XrHandJointSetEXT;
+
+typedef enum XrHandJointsMotionRangeEXT
+{
+    XR_HAND_JOINTS_MOTION_RANGE_UNOBSTRUCTED_EXT = 1,
+    XR_HAND_JOINTS_MOTION_RANGE_CONFORMING_TO_CONTROLLER_EXT = 2,
+    XR_HAND_JOINTS_MOTION_RANGE_EXT_MAX_ENUM = 0x7fffffff,
+} XrHandJointsMotionRangeEXT;
+
+typedef enum XrHandPoseTypeMSFT
+{
+    XR_HAND_POSE_TYPE_TRACKED_MSFT = 0,
+    XR_HAND_POSE_TYPE_REFERENCE_OPEN_PALM_MSFT = 1,
+    XR_HAND_POSE_TYPE_MSFT_MAX_ENUM = 0x7fffffff,
+} XrHandPoseTypeMSFT;
+
+typedef enum XrHandTrackingDataSourceEXT
+{
+    XR_HAND_TRACKING_DATA_SOURCE_UNOBSTRUCTED_EXT = 1,
+    XR_HAND_TRACKING_DATA_SOURCE_CONTROLLER_EXT = 2,
+    XR_HAND_TRACKING_DATA_SOURCE_EXT_MAX_ENUM = 0x7fffffff,
+} XrHandTrackingDataSourceEXT;
+
+typedef enum XrHeadsetFitStatusML
+{
+    XR_HEADSET_FIT_STATUS_UNKNOWN_ML = 0,
+    XR_HEADSET_FIT_STATUS_NOT_WORN_ML = 1,
+    XR_HEADSET_FIT_STATUS_GOOD_FIT_ML = 2,
+    XR_HEADSET_FIT_STATUS_BAD_FIT_ML = 3,
+    XR_HEADSET_FIT_STATUS_ML_MAX_ENUM = 0x7fffffff,
+} XrHeadsetFitStatusML;
+
+typedef enum XrInputSourceLocalizedNameFlagBits
+{
+    XR_INPUT_SOURCE_LOCALIZED_NAME_USER_PATH_BIT = 0x00000001,
+    XR_INPUT_SOURCE_LOCALIZED_NAME_INTERACTION_PROFILE_BIT = 0x00000002,
+    XR_INPUT_SOURCE_LOCALIZED_NAME_COMPONENT_BIT = 0x00000004,
+    XR_INPUT_SOURCE_LOCALIZED_NAME_FLAG_BITS_MAX_ENUM = 0x7fffffff,
+} XrInputSourceLocalizedNameFlagBits;
+
+typedef enum XrInstanceCreateFlagBits
+{
+    XR_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
+} XrInstanceCreateFlagBits;
+
+typedef enum XrKeyboardTrackingFlagBitsFB
+{
+    XR_KEYBOARD_TRACKING_EXISTS_BIT_FB = 0x00000001,
+    XR_KEYBOARD_TRACKING_LOCAL_BIT_FB = 0x00000002,
+    XR_KEYBOARD_TRACKING_REMOTE_BIT_FB = 0x00000004,
+    XR_KEYBOARD_TRACKING_CONNECTED_BIT_FB = 0x00000008,
+    XR_KEYBOARD_TRACKING_FLAG_BITS_FB_MAX_ENUM = 0x7fffffff,
+} XrKeyboardTrackingFlagBitsFB;
+
+typedef enum XrKeyboardTrackingQueryFlagBitsFB
+{
+    XR_KEYBOARD_TRACKING_QUERY_LOCAL_BIT_FB = 0x00000002,
+    XR_KEYBOARD_TRACKING_QUERY_REMOTE_BIT_FB = 0x00000004,
+    XR_KEYBOARD_TRACKING_QUERY_FLAG_BITS_FB_MAX_ENUM = 0x7fffffff,
+} XrKeyboardTrackingQueryFlagBitsFB;
+
+typedef enum XrLipExpressionHTC
+{
+    XR_LIP_EXPRESSION_JAW_RIGHT_HTC = 0,
+    XR_LIP_EXPRESSION_JAW_LEFT_HTC = 1,
+    XR_LIP_EXPRESSION_JAW_FORWARD_HTC = 2,
+    XR_LIP_EXPRESSION_JAW_OPEN_HTC = 3,
+    XR_LIP_EXPRESSION_MOUTH_APE_SHAPE_HTC = 4,
+    XR_LIP_EXPRESSION_MOUTH_UPPER_RIGHT_HTC = 5,
+    XR_LIP_EXPRESSION_MOUTH_UPPER_LEFT_HTC = 6,
+    XR_LIP_EXPRESSION_MOUTH_LOWER_RIGHT_HTC = 7,
+    XR_LIP_EXPRESSION_MOUTH_LOWER_LEFT_HTC = 8,
+    XR_LIP_EXPRESSION_MOUTH_UPPER_OVERTURN_HTC = 9,
+    XR_LIP_EXPRESSION_MOUTH_LOWER_OVERTURN_HTC = 10,
+    XR_LIP_EXPRESSION_MOUTH_POUT_HTC = 11,
+    XR_LIP_EXPRESSION_MOUTH_RAISER_RIGHT_HTC = 12,
+    XR_LIP_EXPRESSION_MOUTH_RAISER_LEFT_HTC = 13,
+    XR_LIP_EXPRESSION_MOUTH_STRETCHER_RIGHT_HTC = 14,
+    XR_LIP_EXPRESSION_MOUTH_STRETCHER_LEFT_HTC = 15,
+    XR_LIP_EXPRESSION_CHEEK_PUFF_RIGHT_HTC = 16,
+    XR_LIP_EXPRESSION_CHEEK_PUFF_LEFT_HTC = 17,
+    XR_LIP_EXPRESSION_CHEEK_SUCK_HTC = 18,
+    XR_LIP_EXPRESSION_MOUTH_UPPER_UPRIGHT_HTC = 19,
+    XR_LIP_EXPRESSION_MOUTH_UPPER_UPLEFT_HTC = 20,
+    XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNRIGHT_HTC = 21,
+    XR_LIP_EXPRESSION_MOUTH_LOWER_DOWNLEFT_HTC = 22,
+    XR_LIP_EXPRESSION_MOUTH_UPPER_INSIDE_HTC = 23,
+    XR_LIP_EXPRESSION_MOUTH_LOWER_INSIDE_HTC = 24,
+    XR_LIP_EXPRESSION_MOUTH_LOWER_OVERLAY_HTC = 25,
+    XR_LIP_EXPRESSION_TONGUE_LONGSTEP1_HTC = 26,
+    XR_LIP_EXPRESSION_TONGUE_LEFT_HTC = 27,
+    XR_LIP_EXPRESSION_TONGUE_RIGHT_HTC = 28,
+    XR_LIP_EXPRESSION_TONGUE_UP_HTC = 29,
+    XR_LIP_EXPRESSION_TONGUE_DOWN_HTC = 30,
+    XR_LIP_EXPRESSION_TONGUE_ROLL_HTC = 31,
+    XR_LIP_EXPRESSION_TONGUE_LONGSTEP2_HTC = 32,
+    XR_LIP_EXPRESSION_TONGUE_UPRIGHT_MORPH_HTC = 33,
+    XR_LIP_EXPRESSION_TONGUE_UPLEFT_MORPH_HTC = 34,
+    XR_LIP_EXPRESSION_TONGUE_DOWNRIGHT_MORPH_HTC = 35,
+    XR_LIP_EXPRESSION_TONGUE_DOWNLEFT_MORPH_HTC = 36,
+    XR_LIP_EXPRESSION_MOUTH_SMILE_RIGHT_HTC = XR_LIP_EXPRESSION_MOUTH_RAISER_RIGHT_HTC,
+    XR_LIP_EXPRESSION_MOUTH_SMILE_LEFT_HTC = XR_LIP_EXPRESSION_MOUTH_RAISER_LEFT_HTC,
+    XR_LIP_EXPRESSION_MOUTH_SAD_RIGHT_HTC = XR_LIP_EXPRESSION_MOUTH_STRETCHER_RIGHT_HTC,
+    XR_LIP_EXPRESSION_MOUTH_SAD_LEFT_HTC = XR_LIP_EXPRESSION_MOUTH_STRETCHER_LEFT_HTC,
+    XR_LIP_EXPRESSION_HTC_MAX_ENUM = 0x7fffffff,
+} XrLipExpressionHTC;
+
+typedef enum XrLoaderInterfaceStructs
+{
+    XR_LOADER_INTERFACE_STRUCT_UNINTIALIZED = 0,
+    XR_LOADER_INTERFACE_STRUCT_LOADER_INFO = 1,
+    XR_LOADER_INTERFACE_STRUCT_API_LAYER_REQUEST = 2,
+    XR_LOADER_INTERFACE_STRUCT_RUNTIME_REQUEST = 3,
+    XR_LOADER_INTERFACE_STRUCT_API_LAYER_CREATE_INFO = 4,
+    XR_LOADER_INTERFACE_STRUCT_API_LAYER_NEXT_INFO = 5,
+    XR_LOADER_INTERFACE_STRUCTS_MAX_ENUM = 0x7fffffff,
+} XrLoaderInterfaceStructs;
+
+typedef enum XrLocalDimmingModeMETA
+{
+    XR_LOCAL_DIMMING_MODE_OFF_META = 0,
+    XR_LOCAL_DIMMING_MODE_ON_META = 1,
+    XR_LOCAL_DIMMING_MODE_META_MAX_ENUM = 0x7fffffff,
+} XrLocalDimmingModeMETA;
+
+typedef enum XrLocalizationMapConfidenceML
+{
+    XR_LOCALIZATION_MAP_CONFIDENCE_POOR_ML = 0,
+    XR_LOCALIZATION_MAP_CONFIDENCE_FAIR_ML = 1,
+    XR_LOCALIZATION_MAP_CONFIDENCE_GOOD_ML = 2,
+    XR_LOCALIZATION_MAP_CONFIDENCE_EXCELLENT_ML = 3,
+    XR_LOCALIZATION_MAP_CONFIDENCE_ML_MAX_ENUM = 0x7fffffff,
+} XrLocalizationMapConfidenceML;
+
+typedef enum XrLocalizationMapErrorFlagBitsML
+{
+    XR_LOCALIZATION_MAP_ERROR_UNKNOWN_BIT_ML = 0x00000001,
+    XR_LOCALIZATION_MAP_ERROR_OUT_OF_MAPPED_AREA_BIT_ML = 0x00000002,
+    XR_LOCALIZATION_MAP_ERROR_LOW_FEATURE_COUNT_BIT_ML = 0x00000004,
+    XR_LOCALIZATION_MAP_ERROR_EXCESSIVE_MOTION_BIT_ML = 0x00000008,
+    XR_LOCALIZATION_MAP_ERROR_LOW_LIGHT_BIT_ML = 0x00000010,
+    XR_LOCALIZATION_MAP_ERROR_HEADPOSE_BIT_ML = 0x00000020,
+    XR_LOCALIZATION_MAP_ERROR_FLAG_BITS_ML_MAX_ENUM = 0x7fffffff,
+} XrLocalizationMapErrorFlagBitsML;
+
+typedef enum XrLocalizationMapStateML
+{
+    XR_LOCALIZATION_MAP_STATE_NOT_LOCALIZED_ML = 0,
+    XR_LOCALIZATION_MAP_STATE_LOCALIZED_ML = 1,
+    XR_LOCALIZATION_MAP_STATE_LOCALIZATION_PENDING_ML = 2,
+    XR_LOCALIZATION_MAP_STATE_LOCALIZATION_SLEEPING_BEFORE_RETRY_ML = 3,
+    XR_LOCALIZATION_MAP_STATE_ML_MAX_ENUM = 0x7fffffff,
+} XrLocalizationMapStateML;
+
+typedef enum XrLocalizationMapTypeML
+{
+    XR_LOCALIZATION_MAP_TYPE_ON_DEVICE_ML = 0,
+    XR_LOCALIZATION_MAP_TYPE_CLOUD_ML = 1,
+    XR_LOCALIZATION_MAP_TYPE_ML_MAX_ENUM = 0x7fffffff,
+} XrLocalizationMapTypeML;
+
+typedef enum XrMarkerAprilTagDictML
+{
+    XR_MARKER_APRIL_TAG_DICT_16H5_ML = 0,
+    XR_MARKER_APRIL_TAG_DICT_25H9_ML = 1,
+    XR_MARKER_APRIL_TAG_DICT_36H10_ML = 2,
+    XR_MARKER_APRIL_TAG_DICT_36H11_ML = 3,
+    XR_MARKER_APRIL_TAG_DICT_ML_MAX_ENUM = 0x7fffffff,
+} XrMarkerAprilTagDictML;
+
+typedef enum XrMarkerArucoDictML
+{
+    XR_MARKER_ARUCO_DICT_4X4_50_ML = 0,
+    XR_MARKER_ARUCO_DICT_4X4_100_ML = 1,
+    XR_MARKER_ARUCO_DICT_4X4_250_ML = 2,
+    XR_MARKER_ARUCO_DICT_4X4_1000_ML = 3,
+    XR_MARKER_ARUCO_DICT_5X5_50_ML = 4,
+    XR_MARKER_ARUCO_DICT_5X5_100_ML = 5,
+    XR_MARKER_ARUCO_DICT_5X5_250_ML = 6,
+    XR_MARKER_ARUCO_DICT_5X5_1000_ML = 7,
+    XR_MARKER_ARUCO_DICT_6X6_50_ML = 8,
+    XR_MARKER_ARUCO_DICT_6X6_100_ML = 9,
+    XR_MARKER_ARUCO_DICT_6X6_250_ML = 10,
+    XR_MARKER_ARUCO_DICT_6X6_1000_ML = 11,
+    XR_MARKER_ARUCO_DICT_7X7_50_ML = 12,
+    XR_MARKER_ARUCO_DICT_7X7_100_ML = 13,
+    XR_MARKER_ARUCO_DICT_7X7_250_ML = 14,
+    XR_MARKER_ARUCO_DICT_7X7_1000_ML = 15,
+    XR_MARKER_ARUCO_DICT_ML_MAX_ENUM = 0x7fffffff,
+} XrMarkerArucoDictML;
+
+typedef enum XrMarkerDetectorCameraML
+{
+    XR_MARKER_DETECTOR_CAMERA_RGB_CAMERA_ML = 0,
+    XR_MARKER_DETECTOR_CAMERA_WORLD_CAMERAS_ML = 1,
+    XR_MARKER_DETECTOR_CAMERA_ML_MAX_ENUM = 0x7fffffff,
+} XrMarkerDetectorCameraML;
+
+typedef enum XrMarkerDetectorCornerRefineMethodML
+{
+    XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_NONE_ML = 0,
+    XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_SUBPIX_ML = 1,
+    XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_CONTOUR_ML = 2,
+    XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_APRIL_TAG_ML = 3,
+    XR_MARKER_DETECTOR_CORNER_REFINE_METHOD_ML_MAX_ENUM = 0x7fffffff,
+} XrMarkerDetectorCornerRefineMethodML;
+
+typedef enum XrMarkerDetectorFpsML
+{
+    XR_MARKER_DETECTOR_FPS_LOW_ML = 0,
+    XR_MARKER_DETECTOR_FPS_MEDIUM_ML = 1,
+    XR_MARKER_DETECTOR_FPS_HIGH_ML = 2,
+    XR_MARKER_DETECTOR_FPS_MAX_ML = 3,
+    XR_MARKER_DETECTOR_FPS_ML_MAX_ENUM = 0x7fffffff,
+} XrMarkerDetectorFpsML;
+
+typedef enum XrMarkerDetectorFullAnalysisIntervalML
+{
+    XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_MAX_ML = 0,
+    XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_FAST_ML = 1,
+    XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_MEDIUM_ML = 2,
+    XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_SLOW_ML = 3,
+    XR_MARKER_DETECTOR_FULL_ANALYSIS_INTERVAL_ML_MAX_ENUM = 0x7fffffff,
+} XrMarkerDetectorFullAnalysisIntervalML;
+
+typedef enum XrMarkerDetectorProfileML
+{
+    XR_MARKER_DETECTOR_PROFILE_DEFAULT_ML = 0,
+    XR_MARKER_DETECTOR_PROFILE_SPEED_ML = 1,
+    XR_MARKER_DETECTOR_PROFILE_ACCURACY_ML = 2,
+    XR_MARKER_DETECTOR_PROFILE_SMALL_TARGETS_ML = 3,
+    XR_MARKER_DETECTOR_PROFILE_LARGE_FOV_ML = 4,
+    XR_MARKER_DETECTOR_PROFILE_CUSTOM_ML = 5,
+    XR_MARKER_DETECTOR_PROFILE_ML_MAX_ENUM = 0x7fffffff,
+} XrMarkerDetectorProfileML;
+
+typedef enum XrMarkerDetectorResolutionML
+{
+    XR_MARKER_DETECTOR_RESOLUTION_LOW_ML = 0,
+    XR_MARKER_DETECTOR_RESOLUTION_MEDIUM_ML = 1,
+    XR_MARKER_DETECTOR_RESOLUTION_HIGH_ML = 2,
+    XR_MARKER_DETECTOR_RESOLUTION_ML_MAX_ENUM = 0x7fffffff,
+} XrMarkerDetectorResolutionML;
+
+typedef enum XrMarkerDetectorStatusML
+{
+    XR_MARKER_DETECTOR_STATUS_PENDING_ML = 0,
+    XR_MARKER_DETECTOR_STATUS_READY_ML = 1,
+    XR_MARKER_DETECTOR_STATUS_ERROR_ML = 2,
+    XR_MARKER_DETECTOR_STATUS_ML_MAX_ENUM = 0x7fffffff,
+} XrMarkerDetectorStatusML;
+
+typedef enum XrMarkerTypeML
+{
+    XR_MARKER_TYPE_ARUCO_ML = 0,
+    XR_MARKER_TYPE_APRIL_TAG_ML = 1,
+    XR_MARKER_TYPE_QR_ML = 2,
+    XR_MARKER_TYPE_EAN_13_ML = 3,
+    XR_MARKER_TYPE_UPC_A_ML = 4,
+    XR_MARKER_TYPE_CODE_128_ML = 5,
+    XR_MARKER_TYPE_ML_MAX_ENUM = 0x7fffffff,
+} XrMarkerTypeML;
+
+typedef enum XrMeshComputeLodMSFT
+{
+    XR_MESH_COMPUTE_LOD_COARSE_MSFT = 1,
+    XR_MESH_COMPUTE_LOD_MEDIUM_MSFT = 2,
+    XR_MESH_COMPUTE_LOD_FINE_MSFT = 3,
+    XR_MESH_COMPUTE_LOD_UNLIMITED_MSFT = 4,
+    XR_MESH_COMPUTE_LOD_MSFT_MAX_ENUM = 0x7fffffff,
+} XrMeshComputeLodMSFT;
+
+typedef enum XrObjectLabelANDROID
+{
+    XR_OBJECT_LABEL_UNKNOWN_ANDROID = 0,
+    XR_OBJECT_LABEL_KEYBOARD_ANDROID = 1,
+    XR_OBJECT_LABEL_MOUSE_ANDROID = 2,
+    XR_OBJECT_LABEL_LAPTOP_ANDROID = 3,
+    XR_OBJECT_LABEL_ANDROID_MAX_ENUM = 0x7fffffff,
+} XrObjectLabelANDROID;
+
+typedef enum XrObjectType
+{
+    XR_OBJECT_TYPE_UNKNOWN = 0,
+    XR_OBJECT_TYPE_INSTANCE = 1,
+    XR_OBJECT_TYPE_SESSION = 2,
+    XR_OBJECT_TYPE_SWAPCHAIN = 3,
+    XR_OBJECT_TYPE_SPACE = 4,
+    XR_OBJECT_TYPE_ACTION_SET = 5,
+    XR_OBJECT_TYPE_ACTION = 6,
+    XR_OBJECT_TYPE_SPATIAL_ANCHOR_MSFT = 1000039000,
+    XR_OBJECT_TYPE_SPATIAL_GRAPH_NODE_BINDING_MSFT = 1000049000,
+    XR_OBJECT_TYPE_HAND_TRACKER_EXT = 1000051000,
+    XR_OBJECT_TYPE_BODY_TRACKER_FB = 1000076000,
+    XR_OBJECT_TYPE_SCENE_OBSERVER_MSFT = 1000097000,
+    XR_OBJECT_TYPE_SCENE_MSFT = 1000097001,
+    XR_OBJECT_TYPE_FACIAL_TRACKER_HTC = 1000104000,
+    XR_OBJECT_TYPE_FOVEATION_PROFILE_FB = 1000114000,
+    XR_OBJECT_TYPE_TRIANGLE_MESH_FB = 1000117000,
+    XR_OBJECT_TYPE_PASSTHROUGH_FB = 1000118000,
+    XR_OBJECT_TYPE_PASSTHROUGH_LAYER_FB = 1000118002,
+    XR_OBJECT_TYPE_GEOMETRY_INSTANCE_FB = 1000118004,
+    XR_OBJECT_TYPE_MARKER_DETECTOR_ML = 1000138000,
+    XR_OBJECT_TYPE_EXPORTED_LOCALIZATION_MAP_ML = 1000139000,
+    XR_OBJECT_TYPE_SPATIAL_ANCHORS_STORAGE_ML = 1000141000,
+    XR_OBJECT_TYPE_SPATIAL_ANCHOR_STORE_CONNECTION_MSFT = 1000142000,
+    XR_OBJECT_TYPE_FACE_TRACKER_FB = 1000201000,
+    XR_OBJECT_TYPE_EYE_TRACKER_FB = 1000202000,
+    XR_OBJECT_TYPE_VIRTUAL_KEYBOARD_META = 1000219000,
+    XR_OBJECT_TYPE_SPACE_USER_FB = 1000241000,
+    XR_OBJECT_TYPE_PASSTHROUGH_COLOR_LUT_META = 1000266000,
+    XR_OBJECT_TYPE_FACE_TRACKER2_FB = 1000287012,
+    XR_OBJECT_TYPE_ENVIRONMENT_DEPTH_PROVIDER_META = 1000291000,
+    XR_OBJECT_TYPE_ENVIRONMENT_DEPTH_SWAPCHAIN_META = 1000291001,
+    XR_OBJECT_TYPE_RENDER_MODEL_EXT = 1000300000,
+    XR_OBJECT_TYPE_RENDER_MODEL_ASSET_EXT = 1000300001,
+    XR_OBJECT_TYPE_PASSTHROUGH_HTC = 1000317000,
+    XR_OBJECT_TYPE_BODY_TRACKER_HTC = 1000320000,
+    XR_OBJECT_TYPE_BODY_TRACKER_BD = 1000385000,
+    XR_OBJECT_TYPE_SENSE_DATA_PROVIDER_BD = 1000389000,
+    XR_OBJECT_TYPE_SENSE_DATA_SNAPSHOT_BD = 1000389001,
+    XR_OBJECT_TYPE_ANCHOR_BD = 1000389002,
+    XR_OBJECT_TYPE_PLANE_DETECTOR_EXT = 1000429000,
+    XR_OBJECT_TYPE_TRACKABLE_TRACKER_ANDROID = 1000455001,
+    XR_OBJECT_TYPE_DEVICE_ANCHOR_PERSISTENCE_ANDROID = 1000457000,
+    XR_OBJECT_TYPE_WORLD_MESH_DETECTOR_ML = 1000474000,
+    XR_OBJECT_TYPE_FACIAL_EXPRESSION_CLIENT_ML = 1000482000,
+    XR_OBJECT_TYPE_SPATIAL_ENTITY_EXT = 1000740000,
+    XR_OBJECT_TYPE_SPATIAL_CONTEXT_EXT = 1000740001,
+    XR_OBJECT_TYPE_SPATIAL_SNAPSHOT_EXT = 1000740002,
+    XR_OBJECT_TYPE_SPATIAL_PERSISTENCE_CONTEXT_EXT = 1000763000,
+    XR_OBJECT_TYPE_MAX_ENUM = 0x7fffffff,
+} XrObjectType;
+
+typedef enum XrPassthroughCameraStateANDROID
+{
+    XR_PASSTHROUGH_CAMERA_STATE_DISABLED_ANDROID = 0,
+    XR_PASSTHROUGH_CAMERA_STATE_INITIALIZING_ANDROID = 1,
+    XR_PASSTHROUGH_CAMERA_STATE_READY_ANDROID = 2,
+    XR_PASSTHROUGH_CAMERA_STATE_ERROR_ANDROID = 3,
+    XR_PASSTHROUGH_CAMERA_STATE_ANDROID_MAX_ENUM = 0x7fffffff,
+} XrPassthroughCameraStateANDROID;
+
+typedef enum XrPassthroughColorLutChannelsMETA
+{
+    XR_PASSTHROUGH_COLOR_LUT_CHANNELS_RGB_META = 1,
+    XR_PASSTHROUGH_COLOR_LUT_CHANNELS_RGBA_META = 2,
+    XR_PASSTHROUGH_COLOR_LUT_CHANNELS_META_MAX_ENUM = 0x7fffffff,
+} XrPassthroughColorLutChannelsMETA;
+
+typedef enum XrPassthroughFlagBitsFB
+{
+    XR_PASSTHROUGH_IS_RUNNING_AT_CREATION_BIT_FB = 0x00000001,
+    XR_PASSTHROUGH_LAYER_DEPTH_BIT_FB = 0x00000002,
+    XR_PASSTHROUGH_FLAG_BITS_FB_MAX_ENUM = 0x7fffffff,
+} XrPassthroughFlagBitsFB;
+
+typedef enum XrPassthroughFormHTC
+{
+    XR_PASSTHROUGH_FORM_PLANAR_HTC = 0,
+    XR_PASSTHROUGH_FORM_PROJECTED_HTC = 1,
+    XR_PASSTHROUGH_FORM_HTC_MAX_ENUM = 0x7fffffff,
+} XrPassthroughFormHTC;
+
+typedef enum XrPassthroughLayerPurposeFB
+{
+    XR_PASSTHROUGH_LAYER_PURPOSE_RECONSTRUCTION_FB = 0,
+    XR_PASSTHROUGH_LAYER_PURPOSE_PROJECTED_FB = 1,
+    XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_HANDS_FB = 1000203001,
+    XR_PASSTHROUGH_LAYER_PURPOSE_TRACKED_KEYBOARD_MASKED_HANDS_FB = 1000203002,
+    XR_PASSTHROUGH_LAYER_PURPOSE_FB_MAX_ENUM = 0x7fffffff,
+} XrPassthroughLayerPurposeFB;
+
+typedef enum XrPassthroughPreferenceFlagBitsMETA
+{
+    XR_PASSTHROUGH_PREFERENCE_DEFAULT_TO_ACTIVE_BIT_META = 0x00000001,
+    XR_PASSTHROUGH_PREFERENCE_FLAG_BITS_META_MAX_ENUM = 0x7fffffff,
+} XrPassthroughPreferenceFlagBitsMETA;
+
+typedef enum XrPerfSettingsDomainEXT
+{
+    XR_PERF_SETTINGS_DOMAIN_CPU_EXT = 1,
+    XR_PERF_SETTINGS_DOMAIN_GPU_EXT = 2,
+    XR_PERF_SETTINGS_DOMAIN_EXT_MAX_ENUM = 0x7fffffff,
+} XrPerfSettingsDomainEXT;
+
+typedef enum XrPerfSettingsLevelEXT
+{
+    XR_PERF_SETTINGS_LEVEL_POWER_SAVINGS_EXT = 0,
+    XR_PERF_SETTINGS_LEVEL_SUSTAINED_LOW_EXT = 25,
+    XR_PERF_SETTINGS_LEVEL_SUSTAINED_HIGH_EXT = 50,
+    XR_PERF_SETTINGS_LEVEL_BOOST_EXT = 75,
+    XR_PERF_SETTINGS_LEVEL_EXT_MAX_ENUM = 0x7fffffff,
+} XrPerfSettingsLevelEXT;
+
+typedef enum XrPerfSettingsNotificationLevelEXT
+{
+    XR_PERF_SETTINGS_NOTIF_LEVEL_NORMAL_EXT = 0,
+    XR_PERF_SETTINGS_NOTIF_LEVEL_WARNING_EXT = 25,
+    XR_PERF_SETTINGS_NOTIF_LEVEL_IMPAIRED_EXT = 75,
+    XR_PERF_SETTINGS_NOTIFICATION_LEVEL_EXT_MAX_ENUM = 0x7fffffff,
+} XrPerfSettingsNotificationLevelEXT;
+
+typedef enum XrPerfSettingsSubDomainEXT
+{
+    XR_PERF_SETTINGS_SUB_DOMAIN_COMPOSITING_EXT = 1,
+    XR_PERF_SETTINGS_SUB_DOMAIN_RENDERING_EXT = 2,
+    XR_PERF_SETTINGS_SUB_DOMAIN_THERMAL_EXT = 3,
+    XR_PERF_SETTINGS_SUB_DOMAIN_EXT_MAX_ENUM = 0x7fffffff,
+} XrPerfSettingsSubDomainEXT;
+
+typedef enum XrPerformanceMetricsCounterFlagBitsMETA
+{
+    XR_PERFORMANCE_METRICS_COUNTER_ANY_VALUE_VALID_BIT_META = 0x00000001,
+    XR_PERFORMANCE_METRICS_COUNTER_UINT_VALUE_VALID_BIT_META = 0x00000002,
+    XR_PERFORMANCE_METRICS_COUNTER_FLOAT_VALUE_VALID_BIT_META = 0x00000004,
+    XR_PERFORMANCE_METRICS_COUNTER_FLAG_BITS_META_MAX_ENUM = 0x7fffffff,
+} XrPerformanceMetricsCounterFlagBitsMETA;
+
+typedef enum XrPerformanceMetricsCounterUnitMETA
+{
+    XR_PERFORMANCE_METRICS_COUNTER_UNIT_GENERIC_META = 0,
+    XR_PERFORMANCE_METRICS_COUNTER_UNIT_PERCENTAGE_META = 1,
+    XR_PERFORMANCE_METRICS_COUNTER_UNIT_MILLISECONDS_META = 2,
+    XR_PERFORMANCE_METRICS_COUNTER_UNIT_BYTES_META = 3,
+    XR_PERFORMANCE_METRICS_COUNTER_UNIT_HERTZ_META = 4,
+    XR_PERFORMANCE_METRICS_COUNTER_UNIT_META_MAX_ENUM = 0x7fffffff,
+} XrPerformanceMetricsCounterUnitMETA;
+
+typedef enum XrPersistenceLocationBD
+{
+    XR_PERSISTENCE_LOCATION_LOCAL_BD = 0,
+    XR_PERSISTENCE_LOCATION_BD_MAX_ENUM = 0x7fffffff,
+} XrPersistenceLocationBD;
+
+typedef enum XrPlaneDetectionStateEXT
+{
+    XR_PLANE_DETECTION_STATE_NONE_EXT = 0,
+    XR_PLANE_DETECTION_STATE_PENDING_EXT = 1,
+    XR_PLANE_DETECTION_STATE_DONE_EXT = 2,
+    XR_PLANE_DETECTION_STATE_ERROR_EXT = 3,
+    XR_PLANE_DETECTION_STATE_FATAL_EXT = 4,
+    XR_PLANE_DETECTION_STATE_EXT_MAX_ENUM = 0x7fffffff,
+} XrPlaneDetectionStateEXT;
+
+typedef enum XrPlaneDetectorFlagBitsEXT
+{
+    XR_PLANE_DETECTOR_ENABLE_CONTOUR_BIT_EXT = 0x00000001,
+    XR_PLANE_DETECTOR_FLAG_BITS_EXT_MAX_ENUM = 0x7fffffff,
+} XrPlaneDetectorFlagBitsEXT;
+
+typedef enum XrPlaneDetectorOrientationEXT
+{
+    XR_PLANE_DETECTOR_ORIENTATION_HORIZONTAL_UPWARD_EXT = 0,
+    XR_PLANE_DETECTOR_ORIENTATION_HORIZONTAL_DOWNWARD_EXT = 1,
+    XR_PLANE_DETECTOR_ORIENTATION_VERTICAL_EXT = 2,
+    XR_PLANE_DETECTOR_ORIENTATION_ARBITRARY_EXT = 3,
+    XR_PLANE_DETECTOR_ORIENTATION_EXT_MAX_ENUM = 0x7fffffff,
+} XrPlaneDetectorOrientationEXT;
+
+typedef enum XrPlaneDetectorSemanticTypeEXT
+{
+    XR_PLANE_DETECTOR_SEMANTIC_TYPE_UNDEFINED_EXT = 0,
+    XR_PLANE_DETECTOR_SEMANTIC_TYPE_CEILING_EXT = 1,
+    XR_PLANE_DETECTOR_SEMANTIC_TYPE_FLOOR_EXT = 2,
+    XR_PLANE_DETECTOR_SEMANTIC_TYPE_WALL_EXT = 3,
+    XR_PLANE_DETECTOR_SEMANTIC_TYPE_PLATFORM_EXT = 4,
+    XR_PLANE_DETECTOR_SEMANTIC_TYPE_EXT_MAX_ENUM = 0x7fffffff,
+} XrPlaneDetectorSemanticTypeEXT;
+
+typedef enum XrPlaneLabelANDROID
+{
+    XR_PLANE_LABEL_UNKNOWN_ANDROID = 0,
+    XR_PLANE_LABEL_WALL_ANDROID = 1,
+    XR_PLANE_LABEL_FLOOR_ANDROID = 2,
+    XR_PLANE_LABEL_CEILING_ANDROID = 3,
+    XR_PLANE_LABEL_TABLE_ANDROID = 4,
+    XR_PLANE_LABEL_ANDROID_MAX_ENUM = 0x7fffffff,
+} XrPlaneLabelANDROID;
+
+typedef enum XrPlaneOrientationBD
+{
+    XR_PLANE_ORIENTATION_HORIZONTAL_UPWARD_BD = 0,
+    XR_PLANE_ORIENTATION_HORIZONTAL_DOWNWARD_BD = 1,
+    XR_PLANE_ORIENTATION_VERTICAL_BD = 2,
+    XR_PLANE_ORIENTATION_ARBITRARY_BD = 3,
+    XR_PLANE_ORIENTATION_BD_MAX_ENUM = 0x7fffffff,
+} XrPlaneOrientationBD;
+
+typedef enum XrPlaneTypeANDROID
+{
+    XR_PLANE_TYPE_HORIZONTAL_DOWNWARD_FACING_ANDROID = 0,
+    XR_PLANE_TYPE_HORIZONTAL_UPWARD_FACING_ANDROID = 1,
+    XR_PLANE_TYPE_VERTICAL_ANDROID = 2,
+    XR_PLANE_TYPE_ARBITRARY_ANDROID = 3,
+    XR_PLANE_TYPE_ANDROID_MAX_ENUM = 0x7fffffff,
+} XrPlaneTypeANDROID;
+
+typedef enum XrReferenceSpaceType
+{
+    XR_REFERENCE_SPACE_TYPE_VIEW = 1,
+    XR_REFERENCE_SPACE_TYPE_LOCAL = 2,
+    XR_REFERENCE_SPACE_TYPE_STAGE = 3,
+    XR_REFERENCE_SPACE_TYPE_UNBOUNDED_MSFT = 1000038000,
+    XR_REFERENCE_SPACE_TYPE_COMBINED_EYE_VARJO = 1000121000,
+    XR_REFERENCE_SPACE_TYPE_LOCALIZATION_MAP_ML = 1000139000,
+    XR_REFERENCE_SPACE_TYPE_LOCAL_FLOOR = 1000426000,
+    XR_REFERENCE_SPACE_TYPE_LOCAL_FLOOR_EXT = XR_REFERENCE_SPACE_TYPE_LOCAL_FLOOR,
+    XR_REFERENCE_SPACE_TYPE_MAX_ENUM = 0x7fffffff,
+} XrReferenceSpaceType;
+
+typedef enum XrRenderModelFlagBitsFB
+{
+    XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_1_BIT_FB = 0x00000001,
+    XR_RENDER_MODEL_SUPPORTS_GLTF_2_0_SUBSET_2_BIT_FB = 0x00000002,
+    XR_RENDER_MODEL_FLAG_BITS_FB_MAX_ENUM = 0x7fffffff,
+} XrRenderModelFlagBitsFB;
+
+typedef enum XrReprojectionModeMSFT
+{
+    XR_REPROJECTION_MODE_DEPTH_MSFT = 1,
+    XR_REPROJECTION_MODE_PLANAR_FROM_DEPTH_MSFT = 2,
+    XR_REPROJECTION_MODE_PLANAR_MANUAL_MSFT = 3,
+    XR_REPROJECTION_MODE_ORIENTATION_ONLY_MSFT = 4,
+    XR_REPROJECTION_MODE_MSFT_MAX_ENUM = 0x7fffffff,
+} XrReprojectionModeMSFT;
+
+typedef enum XrResult
+{
+    XR_ERROR_SPATIAL_PERSISTENCE_SCOPE_INCOMPATIBLE_EXT = -1000781001,
+    XR_ERROR_SPATIAL_PERSISTENCE_SCOPE_UNSUPPORTED_EXT = -1000763001,
+    XR_ERROR_SPATIAL_COMPONENT_NOT_ENABLED_EXT = -1000740006,
+    XR_ERROR_SPATIAL_CAPABILITY_CONFIGURATION_INVALID_EXT = -1000740005,
+    XR_ERROR_SPATIAL_COMPONENT_UNSUPPORTED_FOR_CAPABILITY_EXT = -1000740004,
+    XR_ERROR_SPATIAL_BUFFER_ID_INVALID_EXT = -1000740003,
+    XR_ERROR_SPATIAL_ENTITY_ID_INVALID_EXT = -1000740002,
+    XR_ERROR_SPATIAL_CAPABILITY_UNSUPPORTED_EXT = -1000740001,
+    XR_ERROR_EXTENSION_DEPENDENCY_NOT_ENABLED = -1000710001,
+    XR_ERROR_PERMISSION_INSUFFICIENT = -1000710000,
+    XR_ERROR_SPACE_GROUP_NOT_FOUND_META = -1000572002,
+    XR_ERROR_COLOCATION_DISCOVERY_NO_DISCOVERY_METHOD_META = -1000571002,
+    XR_ERROR_COLOCATION_DISCOVERY_NETWORK_FAILED_META = -1000571001,
+    XR_ERROR_WORLD_MESH_DETECTOR_SPACE_NOT_LOCATABLE_ML = -1000474001,
+    XR_ERROR_WORLD_MESH_DETECTOR_PERMISSION_DENIED_ML = -1000474000,
+    XR_ERROR_SYSTEM_NOTIFICATION_INCOMPATIBLE_SKU_ML = -1000473001,
+    XR_ERROR_SYSTEM_NOTIFICATION_PERMISSION_DENIED_ML = -1000473000,
+    XR_ERROR_FUTURE_INVALID_EXT = -1000469002,
+    XR_ERROR_FUTURE_PENDING_EXT = -1000469001,
+    XR_ERROR_PERSISTED_DATA_NOT_READY_ANDROID = -1000457003,
+    XR_ERROR_ANCHOR_NOT_TRACKING_ANDROID = -1000457002,
+    XR_ERROR_ANCHOR_ALREADY_PERSISTED_ANDROID = -1000457001,
+    XR_ERROR_ANCHOR_ID_NOT_FOUND_ANDROID = -1000457000,
+    XR_ERROR_TRACKABLE_TYPE_NOT_SUPPORTED_ANDROID = -1000455001,
+    XR_ERROR_MISMATCHING_TRACKABLE_TYPE_ANDROID = -1000455000,
+    XR_ERROR_PLANE_DETECTION_PERMISSION_DENIED_EXT = -1000429001,
+    XR_ERROR_SPACE_NOT_LOCATABLE_EXT = -1000429000,
+    XR_ERROR_SCENE_CAPTURE_FAILURE_BD = -1000392000,
+    XR_ERROR_SPATIAL_ANCHOR_SHARING_MAP_INSUFFICIENT_BD = -1000391004,
+    XR_ERROR_SPATIAL_ANCHOR_SHARING_LOCALIZATION_FAIL_BD = -1000391003,
+    XR_ERROR_SPATIAL_ANCHOR_SHARING_NETWORK_FAILURE_BD = -1000391002,
+    XR_ERROR_SPATIAL_ANCHOR_SHARING_AUTHENTICATION_FAILURE_BD = -1000391001,
+    XR_ERROR_SPATIAL_ANCHOR_SHARING_NETWORK_TIMEOUT_BD = -1000391000,
+    XR_ERROR_SPATIAL_ANCHOR_NOT_FOUND_BD = -1000390000,
+    XR_ERROR_ANCHOR_NOT_SUPPORTED_FOR_ENTITY_BD = -1000389002,
+    XR_ERROR_SPATIAL_SENSING_SERVICE_UNAVAILABLE_BD = -1000389001,
+    XR_ERROR_SPATIAL_ENTITY_ID_INVALID_BD = -1000389000,
+    XR_ERROR_NOT_AN_ANCHOR_HTC = -1000319000,
+    XR_ERROR_HINT_ALREADY_SET_QCOM = -1000306000,
+    XR_ERROR_NOT_INTERACTION_RENDER_MODEL_EXT = -1000301000,
+    XR_ERROR_RENDER_MODEL_GLTF_EXTENSION_REQUIRED_EXT = -1000300002,
+    XR_ERROR_RENDER_MODEL_ASSET_UNAVAILABLE_EXT = -1000300001,
+    XR_ERROR_RENDER_MODEL_ID_INVALID_EXT = -1000300000,
+    XR_ERROR_PASSTHROUGH_COLOR_LUT_BUFFER_SIZE_MISMATCH_META = -1000266000,
+    XR_ERROR_SPACE_TOO_BRIGHT_META = -1000259006,
+    XR_ERROR_SPACE_TOO_DARK_META = -1000259005,
+    XR_ERROR_SPACE_RATE_LIMITED_META = -1000259004,
+    XR_ERROR_SPACE_PERMISSION_INSUFFICIENT_META = -1000259003,
+    XR_ERROR_SPACE_INSUFFICIENT_VIEW_META = -1000259002,
+    XR_ERROR_SPACE_STORAGE_AT_CAPACITY_META = -1000259001,
+    XR_ERROR_SPACE_INSUFFICIENT_RESOURCES_META = -1000259000,
+    XR_ERROR_SPACE_CLOUD_STORAGE_DISABLED_FB = -1000169004,
+    XR_ERROR_SPACE_NETWORK_REQUEST_FAILED_FB = -1000169003,
+    XR_ERROR_SPACE_NETWORK_TIMEOUT_FB = -1000169002,
+    XR_ERROR_SPACE_LOCALIZATION_FAILED_FB = -1000169001,
+    XR_ERROR_SPACE_MAPPING_INSUFFICIENT_FB = -1000169000,
+    XR_ERROR_SPATIAL_ANCHOR_NAME_INVALID_MSFT = -1000142002,
+    XR_ERROR_SPATIAL_ANCHOR_NAME_NOT_FOUND_MSFT = -1000142001,
+    XR_ERROR_SPATIAL_ANCHORS_ANCHOR_NOT_FOUND_ML = -1000141000,
+    XR_ERROR_SPATIAL_ANCHORS_SPACE_NOT_LOCATABLE_ML = -1000140003,
+    XR_ERROR_SPATIAL_ANCHORS_OUT_OF_MAP_BOUNDS_ML = -1000140002,
+    XR_ERROR_SPATIAL_ANCHORS_NOT_LOCALIZED_ML = -1000140001,
+    XR_ERROR_SPATIAL_ANCHORS_PERMISSION_DENIED_ML = -1000140000,
+    XR_ERROR_LOCALIZATION_MAP_CANNOT_EXPORT_CLOUD_MAP_ML = -1000139006,
+    XR_ERROR_LOCALIZATION_MAP_ALREADY_EXISTS_ML = -1000139005,
+    XR_ERROR_LOCALIZATION_MAP_PERMISSION_DENIED_ML = -1000139004,
+    XR_ERROR_LOCALIZATION_MAP_IMPORT_EXPORT_PERMISSION_DENIED_ML = -1000139003,
+    XR_ERROR_LOCALIZATION_MAP_FAIL_ML = -1000139002,
+    XR_ERROR_LOCALIZATION_MAP_UNAVAILABLE_ML = -1000139001,
+    XR_ERROR_LOCALIZATION_MAP_INCOMPATIBLE_ML = -1000139000,
+    XR_ERROR_MARKER_INVALID_ML = -1000138004,
+    XR_ERROR_MARKER_DETECTOR_INVALID_CREATE_INFO_ML = -1000138003,
+    XR_ERROR_MARKER_DETECTOR_INVALID_DATA_QUERY_ML = -1000138002,
+    XR_ERROR_MARKER_DETECTOR_LOCATE_FAILED_ML = -1000138001,
+    XR_ERROR_MARKER_DETECTOR_PERMISSION_DENIED_ML = -1000138000,
+    XR_ERROR_MARKER_ID_INVALID_VARJO = -1000124001,
+    XR_ERROR_MARKER_NOT_TRACKED_VARJO = -1000124000,
+    XR_ERROR_RENDER_MODEL_KEY_INVALID_FB = -1000119000,
+    XR_ERROR_UNKNOWN_PASSTHROUGH_FB = -1000118050,
+    XR_ERROR_INSUFFICIENT_RESOURCES_PASSTHROUGH_FB = -1000118004,
+    XR_ERROR_NOT_PERMITTED_PASSTHROUGH_FB = -1000118003,
+    XR_ERROR_FEATURE_REQUIRED_PASSTHROUGH_FB = -1000118002,
+    XR_ERROR_FEATURE_ALREADY_CREATED_PASSTHROUGH_FB = -1000118001,
+    XR_ERROR_UNEXPECTED_STATE_PASSTHROUGH_FB = -1000118000,
+    XR_ERROR_SPACE_COMPONENT_STATUS_ALREADY_SET_FB = -1000113003,
+    XR_ERROR_SPACE_COMPONENT_STATUS_PENDING_FB = -1000113002,
+    XR_ERROR_SPACE_COMPONENT_NOT_ENABLED_FB = -1000113001,
+    XR_ERROR_SPACE_COMPONENT_NOT_SUPPORTED_FB = -1000113000,
+    XR_ERROR_COLOR_SPACE_UNSUPPORTED_FB = -1000108000,
+    XR_ERROR_DISPLAY_REFRESH_RATE_UNSUPPORTED_FB = -1000101000,
+    XR_ERROR_SCENE_COMPUTE_CONSISTENCY_MISMATCH_MSFT = -1000097005,
+    XR_ERROR_SCENE_COMPUTE_FEATURE_INCOMPATIBLE_MSFT = -1000097004,
+    XR_ERROR_SCENE_MESH_BUFFER_ID_INVALID_MSFT = -1000097003,
+    XR_ERROR_SCENE_COMPONENT_TYPE_MISMATCH_MSFT = -1000097002,
+    XR_ERROR_SCENE_COMPONENT_ID_INVALID_MSFT = -1000097001,
+    XR_ERROR_COMPUTE_NEW_SCENE_NOT_COMPLETED_MSFT = -1000097000,
+    XR_ERROR_REPROJECTION_MODE_UNSUPPORTED_MSFT = -1000066000,
+    XR_ERROR_CONTROLLER_MODEL_KEY_INVALID_MSFT = -1000055000,
+    XR_ERROR_SECONDARY_VIEW_CONFIGURATION_TYPE_NOT_ENABLED_MSFT = -1000053000,
+    XR_ERROR_CREATE_SPATIAL_ANCHOR_FAILED_MSFT = -1000039001,
+    XR_ERROR_RUNTIME_UNAVAILABLE = -51,
+    XR_ERROR_GRAPHICS_REQUIREMENTS_CALL_MISSING = -50,
+    XR_ERROR_LOCALIZED_NAME_INVALID = -49,
+    XR_ERROR_LOCALIZED_NAME_DUPLICATED = -48,
+    XR_ERROR_ACTIONSETS_ALREADY_ATTACHED = -47,
+    XR_ERROR_ACTIONSET_NOT_ATTACHED = -46,
+    XR_ERROR_NAME_INVALID = -45,
+    XR_ERROR_NAME_DUPLICATED = -44,
+    XR_ERROR_ENVIRONMENT_BLEND_MODE_UNSUPPORTED = -42,
+    XR_ERROR_VIEW_CONFIGURATION_TYPE_UNSUPPORTED = -41,
+    XR_ERROR_INDEX_OUT_OF_RANGE = -40,
+    XR_ERROR_POSE_INVALID = -39,
+    XR_ERROR_GRAPHICS_DEVICE_INVALID = -38,
+    XR_ERROR_CALL_ORDER_INVALID = -37,
+    XR_ERROR_API_LAYER_NOT_PRESENT = -36,
+    XR_ERROR_FORM_FACTOR_UNAVAILABLE = -35,
+    XR_ERROR_FORM_FACTOR_UNSUPPORTED = -34,
+    XR_ERROR_FILE_CONTENTS_INVALID = -33,
+    XR_ERROR_FILE_ACCESS_ERROR = -32,
+    XR_ERROR_REFERENCE_SPACE_UNSUPPORTED = -31,
+    XR_ERROR_TIME_INVALID = -30,
+    XR_ERROR_SESSION_NOT_STOPPING = -29,
+    XR_ERROR_SESSION_NOT_READY = -28,
+    XR_ERROR_ACTION_TYPE_MISMATCH = -27,
+    XR_ERROR_SWAPCHAIN_FORMAT_UNSUPPORTED = -26,
+    XR_ERROR_SWAPCHAIN_RECT_INVALID = -25,
+    XR_ERROR_LAYER_LIMIT_EXCEEDED = -24,
+    XR_ERROR_LAYER_INVALID = -23,
+    XR_ERROR_PATH_UNSUPPORTED = -22,
+    XR_ERROR_PATH_FORMAT_INVALID = -21,
+    XR_ERROR_PATH_COUNT_EXCEEDED = -20,
+    XR_ERROR_PATH_INVALID = -19,
+    XR_ERROR_SYSTEM_INVALID = -18,
+    XR_ERROR_SESSION_LOST = -17,
+    XR_ERROR_SESSION_NOT_RUNNING = -16,
+    XR_ERROR_SESSION_RUNNING = -14,
+    XR_ERROR_INSTANCE_LOST = -13,
+    XR_ERROR_HANDLE_INVALID = -12,
+    XR_ERROR_SIZE_INSUFFICIENT = -11,
+    XR_ERROR_LIMIT_REACHED = -10,
+    XR_ERROR_EXTENSION_NOT_PRESENT = -9,
+    XR_ERROR_FEATURE_UNSUPPORTED = -8,
+    XR_ERROR_FUNCTION_UNSUPPORTED = -7,
+    XR_ERROR_INITIALIZATION_FAILED = -6,
+    XR_ERROR_API_VERSION_UNSUPPORTED = -4,
+    XR_ERROR_OUT_OF_MEMORY = -3,
+    XR_ERROR_RUNTIME_FAILURE = -2,
+    XR_ERROR_VALIDATION_FAILURE = -1,
+    XR_SUCCESS = 0,
+    XR_TIMEOUT_EXPIRED = 1,
+    XR_SESSION_LOSS_PENDING = 3,
+    XR_EVENT_UNAVAILABLE = 4,
+    XR_SPACE_BOUNDS_UNAVAILABLE = 7,
+    XR_SESSION_NOT_FOCUSED = 8,
+    XR_FRAME_DISCARDED = 9,
+    XR_RENDER_MODEL_UNAVAILABLE_FB = 1000119020,
+    XR_SCENE_MARKER_DATA_NOT_STRING_MSFT = 1000147000,
+    XR_ENVIRONMENT_DEPTH_NOT_AVAILABLE_META = 1000291000,
+    XR_ERROR_FACIAL_EXPRESSION_PERMISSION_DENIED_ML = 1000482000,
+    XR_COLOCATION_DISCOVERY_ALREADY_ADVERTISING_META = 1000571003,
+    XR_COLOCATION_DISCOVERY_ALREADY_DISCOVERING_META = 1000571004,
+    XR_ERROR_EXTENSION_DEPENDENCY_NOT_ENABLED_KHR = XR_ERROR_EXTENSION_DEPENDENCY_NOT_ENABLED,
+    XR_ERROR_PERMISSION_INSUFFICIENT_KHR = XR_ERROR_PERMISSION_INSUFFICIENT,
+    XR_RESULT_MAX_ENUM = 0x7fffffff,
+} XrResult;
+
+typedef enum XrSceneComponentTypeMSFT
+{
+    XR_SCENE_COMPONENT_TYPE_INVALID_MSFT = -1,
+    XR_SCENE_COMPONENT_TYPE_OBJECT_MSFT = 1,
+    XR_SCENE_COMPONENT_TYPE_PLANE_MSFT = 2,
+    XR_SCENE_COMPONENT_TYPE_VISUAL_MESH_MSFT = 3,
+    XR_SCENE_COMPONENT_TYPE_COLLIDER_MESH_MSFT = 4,
+    XR_SCENE_COMPONENT_TYPE_SERIALIZED_SCENE_FRAGMENT_MSFT = 1000098000,
+    XR_SCENE_COMPONENT_TYPE_MARKER_MSFT = 1000147000,
+    XR_SCENE_COMPONENT_TYPE_MSFT_MAX_ENUM = 0x7fffffff,
+} XrSceneComponentTypeMSFT;
+
+typedef enum XrSceneComputeConsistencyMSFT
+{
+    XR_SCENE_COMPUTE_CONSISTENCY_SNAPSHOT_COMPLETE_MSFT = 1,
+    XR_SCENE_COMPUTE_CONSISTENCY_SNAPSHOT_INCOMPLETE_FAST_MSFT = 2,
+    XR_SCENE_COMPUTE_CONSISTENCY_OCCLUSION_OPTIMIZED_MSFT = 3,
+    XR_SCENE_COMPUTE_CONSISTENCY_MSFT_MAX_ENUM = 0x7fffffff,
+} XrSceneComputeConsistencyMSFT;
+
+typedef enum XrSceneComputeFeatureMSFT
+{
+    XR_SCENE_COMPUTE_FEATURE_PLANE_MSFT = 1,
+    XR_SCENE_COMPUTE_FEATURE_PLANE_MESH_MSFT = 2,
+    XR_SCENE_COMPUTE_FEATURE_VISUAL_MESH_MSFT = 3,
+    XR_SCENE_COMPUTE_FEATURE_COLLIDER_MESH_MSFT = 4,
+    XR_SCENE_COMPUTE_FEATURE_SERIALIZE_SCENE_MSFT = 1000098000,
+    XR_SCENE_COMPUTE_FEATURE_MARKER_MSFT = 1000147000,
+    XR_SCENE_COMPUTE_FEATURE_MSFT_MAX_ENUM = 0x7fffffff,
+} XrSceneComputeFeatureMSFT;
+
+typedef enum XrSceneComputeStateMSFT
+{
+    XR_SCENE_COMPUTE_STATE_NONE_MSFT = 0,
+    XR_SCENE_COMPUTE_STATE_UPDATING_MSFT = 1,
+    XR_SCENE_COMPUTE_STATE_COMPLETED_MSFT = 2,
+    XR_SCENE_COMPUTE_STATE_COMPLETED_WITH_ERROR_MSFT = 3,
+    XR_SCENE_COMPUTE_STATE_MSFT_MAX_ENUM = 0x7fffffff,
+} XrSceneComputeStateMSFT;
+
+typedef enum XrSceneMarkerQRCodeSymbolTypeMSFT
+{
+    XR_SCENE_MARKER_QR_CODE_SYMBOL_TYPE_QR_CODE_MSFT = 1,
+    XR_SCENE_MARKER_QR_CODE_SYMBOL_TYPE_MICRO_QR_CODE_MSFT = 2,
+    XR_SCENE_MARKER_QRCODE_SYMBOL_TYPE_MSFT_MAX_ENUM = 0x7fffffff,
+} XrSceneMarkerQRCodeSymbolTypeMSFT;
+
+typedef enum XrSceneMarkerTypeMSFT
+{
+    XR_SCENE_MARKER_TYPE_QR_CODE_MSFT = 1,
+    XR_SCENE_MARKER_TYPE_MSFT_MAX_ENUM = 0x7fffffff,
+} XrSceneMarkerTypeMSFT;
+
+typedef enum XrSceneObjectTypeMSFT
+{
+    XR_SCENE_OBJECT_TYPE_UNCATEGORIZED_MSFT = -1,
+    XR_SCENE_OBJECT_TYPE_BACKGROUND_MSFT = 1,
+    XR_SCENE_OBJECT_TYPE_WALL_MSFT = 2,
+    XR_SCENE_OBJECT_TYPE_FLOOR_MSFT = 3,
+    XR_SCENE_OBJECT_TYPE_CEILING_MSFT = 4,
+    XR_SCENE_OBJECT_TYPE_PLATFORM_MSFT = 5,
+    XR_SCENE_OBJECT_TYPE_INFERRED_MSFT = 6,
+    XR_SCENE_OBJECT_TYPE_MSFT_MAX_ENUM = 0x7fffffff,
+} XrSceneObjectTypeMSFT;
+
+typedef enum XrScenePlaneAlignmentTypeMSFT
+{
+    XR_SCENE_PLANE_ALIGNMENT_TYPE_NON_ORTHOGONAL_MSFT = 0,
+    XR_SCENE_PLANE_ALIGNMENT_TYPE_HORIZONTAL_MSFT = 1,
+    XR_SCENE_PLANE_ALIGNMENT_TYPE_VERTICAL_MSFT = 2,
+    XR_SCENE_PLANE_ALIGNMENT_TYPE_MSFT_MAX_ENUM = 0x7fffffff,
+} XrScenePlaneAlignmentTypeMSFT;
+
+typedef enum XrSemanticLabelBD
+{
+    XR_SEMANTIC_LABEL_UNKNOWN_BD = 0,
+    XR_SEMANTIC_LABEL_FLOOR_BD = 1,
+    XR_SEMANTIC_LABEL_CEILING_BD = 2,
+    XR_SEMANTIC_LABEL_WALL_BD = 3,
+    XR_SEMANTIC_LABEL_DOOR_BD = 4,
+    XR_SEMANTIC_LABEL_WINDOW_BD = 5,
+    XR_SEMANTIC_LABEL_OPENING_BD = 6,
+    XR_SEMANTIC_LABEL_TABLE_BD = 7,
+    XR_SEMANTIC_LABEL_SOFA_BD = 8,
+    XR_SEMANTIC_LABEL_CHAIR_BD = 9,
+    XR_SEMANTIC_LABEL_HUMAN_BD = 10,
+    XR_SEMANTIC_LABEL_BEAM_BD = 11,
+    XR_SEMANTIC_LABEL_COLUMN_BD = 12,
+    XR_SEMANTIC_LABEL_CURTAIN_BD = 13,
+    XR_SEMANTIC_LABEL_CABINET_BD = 14,
+    XR_SEMANTIC_LABEL_BED_BD = 15,
+    XR_SEMANTIC_LABEL_PLANT_BD = 16,
+    XR_SEMANTIC_LABEL_SCREEN_BD = 17,
+    XR_SEMANTIC_LABEL_VIRTUAL_WALL_BD = 18,
+    XR_SEMANTIC_LABEL_REFRIGERATOR_BD = 19,
+    XR_SEMANTIC_LABEL_WASHING_MACHINE_BD = 20,
+    XR_SEMANTIC_LABEL_AIR_CONDITIONER_BD = 21,
+    XR_SEMANTIC_LABEL_LAMP_BD = 22,
+    XR_SEMANTIC_LABEL_WALL_ART_BD = 23,
+    XR_SEMANTIC_LABEL_STAIRWAY_BD = 24,
+    XR_SEMANTIC_LABEL_BD_MAX_ENUM = 0x7fffffff,
+} XrSemanticLabelBD;
+
+typedef enum XrSemanticLabelsSupportFlagBitsFB
+{
+    XR_SEMANTIC_LABELS_SUPPORT_MULTIPLE_SEMANTIC_LABELS_BIT_FB = 0x00000001,
+    XR_SEMANTIC_LABELS_SUPPORT_ACCEPT_DESK_TO_TABLE_MIGRATION_BIT_FB = 0x00000002,
+    XR_SEMANTIC_LABELS_SUPPORT_ACCEPT_INVISIBLE_WALL_FACE_BIT_FB = 0x00000004,
+    XR_SEMANTIC_LABELS_SUPPORT_FLAG_BITS_FB_MAX_ENUM = 0x7fffffff,
+} XrSemanticLabelsSupportFlagBitsFB;
+
+typedef enum XrSenseDataProviderStateBD
+{
+    XR_SENSE_DATA_PROVIDER_STATE_INITIALIZED_BD = 0,
+    XR_SENSE_DATA_PROVIDER_STATE_RUNNING_BD = 1,
+    XR_SENSE_DATA_PROVIDER_STATE_STOPPED_BD = 2,
+    XR_SENSE_DATA_PROVIDER_STATE_BD_MAX_ENUM = 0x7fffffff,
+} XrSenseDataProviderStateBD;
+
+typedef enum XrSenseDataProviderTypeBD
+{
+    XR_SENSE_DATA_PROVIDER_TYPE_ANCHOR_BD = 1000390000,
+    XR_SENSE_DATA_PROVIDER_TYPE_SCENE_BD = 1000392000,
+    XR_SENSE_DATA_PROVIDER_TYPE_MESH_BD = 1000393000,
+    XR_SENSE_DATA_PROVIDER_TYPE_PLANE_BD = 1000396000,
+    XR_SENSE_DATA_PROVIDER_TYPE_BD_MAX_ENUM = 0x7fffffff,
+} XrSenseDataProviderTypeBD;
+
+typedef enum XrSessionCreateFlagBits
+{
+    XR_SESSION_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
+} XrSessionCreateFlagBits;
+
+typedef enum XrSessionState
+{
+    XR_SESSION_STATE_UNKNOWN = 0,
+    XR_SESSION_STATE_IDLE = 1,
+    XR_SESSION_STATE_READY = 2,
+    XR_SESSION_STATE_SYNCHRONIZED = 3,
+    XR_SESSION_STATE_VISIBLE = 4,
+    XR_SESSION_STATE_FOCUSED = 5,
+    XR_SESSION_STATE_STOPPING = 6,
+    XR_SESSION_STATE_LOSS_PENDING = 7,
+    XR_SESSION_STATE_EXITING = 8,
+    XR_SESSION_STATE_MAX_ENUM = 0x7fffffff,
+} XrSessionState;
+
+typedef enum XrSpaceComponentTypeFB
+{
+    XR_SPACE_COMPONENT_TYPE_LOCATABLE_FB = 0,
+    XR_SPACE_COMPONENT_TYPE_STORABLE_FB = 1,
+    XR_SPACE_COMPONENT_TYPE_SHARABLE_FB = 2,
+    XR_SPACE_COMPONENT_TYPE_BOUNDED_2D_FB = 3,
+    XR_SPACE_COMPONENT_TYPE_BOUNDED_3D_FB = 4,
+    XR_SPACE_COMPONENT_TYPE_SEMANTIC_LABELS_FB = 5,
+    XR_SPACE_COMPONENT_TYPE_ROOM_LAYOUT_FB = 6,
+    XR_SPACE_COMPONENT_TYPE_SPACE_CONTAINER_FB = 7,
+    XR_SPACE_COMPONENT_TYPE_TRIANGLE_MESH_META = 1000269000,
+    XR_SPACE_COMPONENT_TYPE_FB_MAX_ENUM = 0x7fffffff,
+} XrSpaceComponentTypeFB;
+
+typedef enum XrSpaceLocationFlagBits
+{
+    XR_SPACE_LOCATION_ORIENTATION_VALID_BIT = 0x00000001,
+    XR_SPACE_LOCATION_POSITION_VALID_BIT = 0x00000002,
+    XR_SPACE_LOCATION_ORIENTATION_TRACKED_BIT = 0x00000004,
+    XR_SPACE_LOCATION_POSITION_TRACKED_BIT = 0x00000008,
+    XR_SPACE_LOCATION_FLAG_BITS_MAX_ENUM = 0x7fffffff,
+} XrSpaceLocationFlagBits;
+
+typedef enum XrSpacePersistenceModeFB
+{
+    XR_SPACE_PERSISTENCE_MODE_INVALID_FB = 0,
+    XR_SPACE_PERSISTENCE_MODE_INDEFINITE_FB = 1,
+    XR_SPACE_PERSISTENCE_MODE_FB_MAX_ENUM = 0x7fffffff,
+} XrSpacePersistenceModeFB;
+
+typedef enum XrSpaceQueryActionFB
+{
+    XR_SPACE_QUERY_ACTION_LOAD_FB = 0,
+    XR_SPACE_QUERY_ACTION_FB_MAX_ENUM = 0x7fffffff,
+} XrSpaceQueryActionFB;
+
+typedef enum XrSpaceStorageLocationFB
+{
+    XR_SPACE_STORAGE_LOCATION_INVALID_FB = 0,
+    XR_SPACE_STORAGE_LOCATION_LOCAL_FB = 1,
+    XR_SPACE_STORAGE_LOCATION_CLOUD_FB = 2,
+    XR_SPACE_STORAGE_LOCATION_FB_MAX_ENUM = 0x7fffffff,
+} XrSpaceStorageLocationFB;
+
+typedef enum XrSpaceVelocityFlagBits
+{
+    XR_SPACE_VELOCITY_LINEAR_VALID_BIT = 0x00000001,
+    XR_SPACE_VELOCITY_ANGULAR_VALID_BIT = 0x00000002,
+    XR_SPACE_VELOCITY_FLAG_BITS_MAX_ENUM = 0x7fffffff,
+} XrSpaceVelocityFlagBits;
+
+typedef enum XrSpatialAnchorConfidenceML
+{
+    XR_SPATIAL_ANCHOR_CONFIDENCE_LOW_ML = 0,
+    XR_SPATIAL_ANCHOR_CONFIDENCE_MEDIUM_ML = 1,
+    XR_SPATIAL_ANCHOR_CONFIDENCE_HIGH_ML = 2,
+    XR_SPATIAL_ANCHOR_CONFIDENCE_ML_MAX_ENUM = 0x7fffffff,
+} XrSpatialAnchorConfidenceML;
+
+typedef enum XrSpatialBufferTypeEXT
+{
+    XR_SPATIAL_BUFFER_TYPE_UNKNOWN_EXT = 0,
+    XR_SPATIAL_BUFFER_TYPE_STRING_EXT = 1,
+    XR_SPATIAL_BUFFER_TYPE_UINT8_EXT = 2,
+    XR_SPATIAL_BUFFER_TYPE_UINT16_EXT = 3,
+    XR_SPATIAL_BUFFER_TYPE_UINT32_EXT = 4,
+    XR_SPATIAL_BUFFER_TYPE_FLOAT_EXT = 5,
+    XR_SPATIAL_BUFFER_TYPE_VECTOR2F_EXT = 6,
+    XR_SPATIAL_BUFFER_TYPE_VECTOR3F_EXT = 7,
+    XR_SPATIAL_BUFFER_TYPE_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialBufferTypeEXT;
+
+typedef enum XrSpatialCapabilityEXT
+{
+    XR_SPATIAL_CAPABILITY_PLANE_TRACKING_EXT = 1000741000,
+    XR_SPATIAL_CAPABILITY_MARKER_TRACKING_QR_CODE_EXT = 1000743000,
+    XR_SPATIAL_CAPABILITY_MARKER_TRACKING_MICRO_QR_CODE_EXT = 1000743001,
+    XR_SPATIAL_CAPABILITY_MARKER_TRACKING_ARUCO_MARKER_EXT = 1000743002,
+    XR_SPATIAL_CAPABILITY_MARKER_TRACKING_APRIL_TAG_EXT = 1000743003,
+    XR_SPATIAL_CAPABILITY_ANCHOR_EXT = 1000762000,
+    XR_SPATIAL_CAPABILITY_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialCapabilityEXT;
+
+typedef enum XrSpatialCapabilityFeatureEXT
+{
+    XR_SPATIAL_CAPABILITY_FEATURE_MARKER_TRACKING_FIXED_SIZE_MARKERS_EXT = 1000743000,
+    XR_SPATIAL_CAPABILITY_FEATURE_MARKER_TRACKING_STATIC_MARKERS_EXT = 1000743001,
+    XR_SPATIAL_CAPABILITY_FEATURE_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialCapabilityFeatureEXT;
+
+typedef enum XrSpatialComponentTypeEXT
+{
+    XR_SPATIAL_COMPONENT_TYPE_BOUNDED_2D_EXT = 1,
+    XR_SPATIAL_COMPONENT_TYPE_BOUNDED_3D_EXT = 2,
+    XR_SPATIAL_COMPONENT_TYPE_PARENT_EXT = 3,
+    XR_SPATIAL_COMPONENT_TYPE_MESH_3D_EXT = 4,
+    XR_SPATIAL_COMPONENT_TYPE_PLANE_ALIGNMENT_EXT = 1000741000,
+    XR_SPATIAL_COMPONENT_TYPE_MESH_2D_EXT = 1000741001,
+    XR_SPATIAL_COMPONENT_TYPE_POLYGON_2D_EXT = 1000741002,
+    XR_SPATIAL_COMPONENT_TYPE_PLANE_SEMANTIC_LABEL_EXT = 1000741003,
+    XR_SPATIAL_COMPONENT_TYPE_MARKER_EXT = 1000743000,
+    XR_SPATIAL_COMPONENT_TYPE_ANCHOR_EXT = 1000762000,
+    XR_SPATIAL_COMPONENT_TYPE_PERSISTENCE_EXT = 1000763000,
+    XR_SPATIAL_COMPONENT_TYPE_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialComponentTypeEXT;
+
+typedef enum XrSpatialEntityComponentTypeBD
+{
+    XR_SPATIAL_ENTITY_COMPONENT_TYPE_LOCATION_BD = 0,
+    XR_SPATIAL_ENTITY_COMPONENT_TYPE_SEMANTIC_BD = 1,
+    XR_SPATIAL_ENTITY_COMPONENT_TYPE_BOUNDING_BOX_2D_BD = 2,
+    XR_SPATIAL_ENTITY_COMPONENT_TYPE_POLYGON_BD = 3,
+    XR_SPATIAL_ENTITY_COMPONENT_TYPE_BOUNDING_BOX_3D_BD = 4,
+    XR_SPATIAL_ENTITY_COMPONENT_TYPE_TRIANGLE_MESH_BD = 5,
+    XR_SPATIAL_ENTITY_COMPONENT_TYPE_PLANE_ORIENTATION_BD = 1000396000,
+    XR_SPATIAL_ENTITY_COMPONENT_TYPE_BD_MAX_ENUM = 0x7fffffff,
+} XrSpatialEntityComponentTypeBD;
+
+typedef enum XrSpatialEntityTrackingStateEXT
+{
+    XR_SPATIAL_ENTITY_TRACKING_STATE_STOPPED_EXT = 1,
+    XR_SPATIAL_ENTITY_TRACKING_STATE_PAUSED_EXT = 2,
+    XR_SPATIAL_ENTITY_TRACKING_STATE_TRACKING_EXT = 3,
+    XR_SPATIAL_ENTITY_TRACKING_STATE_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialEntityTrackingStateEXT;
+
+typedef enum XrSpatialGraphNodeTypeMSFT
+{
+    XR_SPATIAL_GRAPH_NODE_TYPE_STATIC_MSFT = 1,
+    XR_SPATIAL_GRAPH_NODE_TYPE_DYNAMIC_MSFT = 2,
+    XR_SPATIAL_GRAPH_NODE_TYPE_MSFT_MAX_ENUM = 0x7fffffff,
+} XrSpatialGraphNodeTypeMSFT;
+
+typedef enum XrSpatialMarkerAprilTagDictEXT
+{
+    XR_SPATIAL_MARKER_APRIL_TAG_DICT_16H5_EXT = 1,
+    XR_SPATIAL_MARKER_APRIL_TAG_DICT_25H9_EXT = 2,
+    XR_SPATIAL_MARKER_APRIL_TAG_DICT_36H10_EXT = 3,
+    XR_SPATIAL_MARKER_APRIL_TAG_DICT_36H11_EXT = 4,
+    XR_SPATIAL_MARKER_APRIL_TAG_DICT_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialMarkerAprilTagDictEXT;
+
+typedef enum XrSpatialMarkerArucoDictEXT
+{
+    XR_SPATIAL_MARKER_ARUCO_DICT_4X4_50_EXT = 1,
+    XR_SPATIAL_MARKER_ARUCO_DICT_4X4_100_EXT = 2,
+    XR_SPATIAL_MARKER_ARUCO_DICT_4X4_250_EXT = 3,
+    XR_SPATIAL_MARKER_ARUCO_DICT_4X4_1000_EXT = 4,
+    XR_SPATIAL_MARKER_ARUCO_DICT_5X5_50_EXT = 5,
+    XR_SPATIAL_MARKER_ARUCO_DICT_5X5_100_EXT = 6,
+    XR_SPATIAL_MARKER_ARUCO_DICT_5X5_250_EXT = 7,
+    XR_SPATIAL_MARKER_ARUCO_DICT_5X5_1000_EXT = 8,
+    XR_SPATIAL_MARKER_ARUCO_DICT_6X6_50_EXT = 9,
+    XR_SPATIAL_MARKER_ARUCO_DICT_6X6_100_EXT = 10,
+    XR_SPATIAL_MARKER_ARUCO_DICT_6X6_250_EXT = 11,
+    XR_SPATIAL_MARKER_ARUCO_DICT_6X6_1000_EXT = 12,
+    XR_SPATIAL_MARKER_ARUCO_DICT_7X7_50_EXT = 13,
+    XR_SPATIAL_MARKER_ARUCO_DICT_7X7_100_EXT = 14,
+    XR_SPATIAL_MARKER_ARUCO_DICT_7X7_250_EXT = 15,
+    XR_SPATIAL_MARKER_ARUCO_DICT_7X7_1000_EXT = 16,
+    XR_SPATIAL_MARKER_ARUCO_DICT_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialMarkerArucoDictEXT;
+
+typedef enum XrSpatialMeshConfigFlagBitsBD
+{
+    XR_SPATIAL_MESH_CONFIG_SEMANTIC_BIT_BD = 0x00000001,
+    XR_SPATIAL_MESH_CONFIG_ALIGN_SEMANTIC_WITH_VERTEX_BIT_BD = 0x00000002,
+    XR_SPATIAL_MESH_CONFIG_FLAG_BITS_BD_MAX_ENUM = 0x7fffffff,
+} XrSpatialMeshConfigFlagBitsBD;
+
+typedef enum XrSpatialMeshLodBD
+{
+    XR_SPATIAL_MESH_LOD_COARSE_BD = 0,
+    XR_SPATIAL_MESH_LOD_MEDIUM_BD = 1,
+    XR_SPATIAL_MESH_LOD_FINE_BD = 2,
+    XR_SPATIAL_MESH_LOD_BD_MAX_ENUM = 0x7fffffff,
+} XrSpatialMeshLodBD;
+
+typedef enum XrSpatialPersistenceContextResultEXT
+{
+    XR_SPATIAL_PERSISTENCE_CONTEXT_RESULT_PERSIST_UUID_NOT_FOUND_EXT = -1000781002,
+    XR_SPATIAL_PERSISTENCE_CONTEXT_RESULT_ENTITY_NOT_TRACKING_EXT = -1000781001,
+    XR_SPATIAL_PERSISTENCE_CONTEXT_RESULT_SUCCESS_EXT = 0,
+    XR_SPATIAL_PERSISTENCE_CONTEXT_RESULT_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialPersistenceContextResultEXT;
+
+typedef enum XrSpatialPersistenceScopeEXT
+{
+    XR_SPATIAL_PERSISTENCE_SCOPE_SYSTEM_MANAGED_EXT = 1,
+    XR_SPATIAL_PERSISTENCE_SCOPE_LOCAL_ANCHORS_EXT = 1000781000,
+    XR_SPATIAL_PERSISTENCE_SCOPE_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialPersistenceScopeEXT;
+
+typedef enum XrSpatialPersistenceStateEXT
+{
+    XR_SPATIAL_PERSISTENCE_STATE_LOADED_EXT = 1,
+    XR_SPATIAL_PERSISTENCE_STATE_NOT_FOUND_EXT = 2,
+    XR_SPATIAL_PERSISTENCE_STATE_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialPersistenceStateEXT;
+
+typedef enum XrSpatialPlaneAlignmentEXT
+{
+    XR_SPATIAL_PLANE_ALIGNMENT_HORIZONTAL_UPWARD_EXT = 0,
+    XR_SPATIAL_PLANE_ALIGNMENT_HORIZONTAL_DOWNWARD_EXT = 1,
+    XR_SPATIAL_PLANE_ALIGNMENT_VERTICAL_EXT = 2,
+    XR_SPATIAL_PLANE_ALIGNMENT_ARBITRARY_EXT = 3,
+    XR_SPATIAL_PLANE_ALIGNMENT_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialPlaneAlignmentEXT;
+
+typedef enum XrSpatialPlaneSemanticLabelEXT
+{
+    XR_SPATIAL_PLANE_SEMANTIC_LABEL_UNCATEGORIZED_EXT = 1,
+    XR_SPATIAL_PLANE_SEMANTIC_LABEL_FLOOR_EXT = 2,
+    XR_SPATIAL_PLANE_SEMANTIC_LABEL_WALL_EXT = 3,
+    XR_SPATIAL_PLANE_SEMANTIC_LABEL_CEILING_EXT = 4,
+    XR_SPATIAL_PLANE_SEMANTIC_LABEL_TABLE_EXT = 5,
+    XR_SPATIAL_PLANE_SEMANTIC_LABEL_EXT_MAX_ENUM = 0x7fffffff,
+} XrSpatialPlaneSemanticLabelEXT;
+
+typedef enum XrStructureType
+{
+    XR_TYPE_UNKNOWN = 0,
+    XR_TYPE_API_LAYER_PROPERTIES = 1,
+    XR_TYPE_EXTENSION_PROPERTIES = 2,
+    XR_TYPE_INSTANCE_CREATE_INFO = 3,
+    XR_TYPE_SYSTEM_GET_INFO = 4,
+    XR_TYPE_SYSTEM_PROPERTIES = 5,
+    XR_TYPE_VIEW_LOCATE_INFO = 6,
+    XR_TYPE_VIEW = 7,
+    XR_TYPE_SESSION_CREATE_INFO = 8,
+    XR_TYPE_SWAPCHAIN_CREATE_INFO = 9,
+    XR_TYPE_SESSION_BEGIN_INFO = 10,
+    XR_TYPE_VIEW_STATE = 11,
+    XR_TYPE_FRAME_END_INFO = 12,
+    XR_TYPE_HAPTIC_VIBRATION = 13,
+    XR_TYPE_EVENT_DATA_BUFFER = 16,
+    XR_TYPE_EVENT_DATA_INSTANCE_LOSS_PENDING = 17,
+    XR_TYPE_EVENT_DATA_SESSION_STATE_CHANGED = 18,
+    XR_TYPE_ACTION_STATE_BOOLEAN = 23,
+    XR_TYPE_ACTION_STATE_FLOAT = 24,
+    XR_TYPE_ACTION_STATE_VECTOR2F = 25,
+    XR_TYPE_ACTION_STATE_POSE = 27,
+    XR_TYPE_ACTION_SET_CREATE_INFO = 28,
+    XR_TYPE_ACTION_CREATE_INFO = 29,
+    XR_TYPE_INSTANCE_PROPERTIES = 32,
+    XR_TYPE_FRAME_WAIT_INFO = 33,
+    XR_TYPE_COMPOSITION_LAYER_PROJECTION = 35,
+    XR_TYPE_COMPOSITION_LAYER_QUAD = 36,
+    XR_TYPE_REFERENCE_SPACE_CREATE_INFO = 37,
+    XR_TYPE_ACTION_SPACE_CREATE_INFO = 38,
+    XR_TYPE_EVENT_DATA_REFERENCE_SPACE_CHANGE_PENDING = 40,
+    XR_TYPE_VIEW_CONFIGURATION_VIEW = 41,
+    XR_TYPE_SPACE_LOCATION = 42,
+    XR_TYPE_SPACE_VELOCITY = 43,
+    XR_TYPE_FRAME_STATE = 44,
+    XR_TYPE_VIEW_CONFIGURATION_PROPERTIES = 45,
+    XR_TYPE_FRAME_BEGIN_INFO = 46,
+    XR_TYPE_COMPOSITION_LAYER_PROJECTION_VIEW = 48,
+    XR_TYPE_EVENT_DATA_EVENTS_LOST = 49,
+    XR_TYPE_INTERACTION_PROFILE_SUGGESTED_BINDING = 51,
+    XR_TYPE_EVENT_DATA_INTERACTION_PROFILE_CHANGED = 52,
+    XR_TYPE_INTERACTION_PROFILE_STATE = 53,
+    XR_TYPE_SWAPCHAIN_IMAGE_ACQUIRE_INFO = 55,
+    XR_TYPE_SWAPCHAIN_IMAGE_WAIT_INFO = 56,
+    XR_TYPE_SWAPCHAIN_IMAGE_RELEASE_INFO = 57,
+    XR_TYPE_ACTION_STATE_GET_INFO = 58,
+    XR_TYPE_HAPTIC_ACTION_INFO = 59,
+    XR_TYPE_SESSION_ACTION_SETS_ATTACH_INFO = 60,
+    XR_TYPE_ACTIONS_SYNC_INFO = 61,
+    XR_TYPE_BOUND_SOURCES_FOR_ACTION_ENUMERATE_INFO = 62,
+    XR_TYPE_INPUT_SOURCE_LOCALIZED_NAME_GET_INFO = 63,
+    XR_TYPE_COMPOSITION_LAYER_CUBE_KHR = 1000006000,
+    XR_TYPE_COMPOSITION_LAYER_DEPTH_INFO_KHR = 1000010000,
+    XR_TYPE_VULKAN_SWAPCHAIN_FORMAT_LIST_CREATE_INFO_KHR = 1000014000,
+    XR_TYPE_EVENT_DATA_PERF_SETTINGS_EXT = 1000015000,
+    XR_TYPE_COMPOSITION_LAYER_CYLINDER_KHR = 1000017000,
+    XR_TYPE_COMPOSITION_LAYER_EQUIRECT_KHR = 1000018000,
+    XR_TYPE_GRAPHICS_BINDING_OPENGL_WIN32_KHR = 1000023000,
+    XR_TYPE_GRAPHICS_BINDING_OPENGL_XLIB_KHR = 1000023001,
+    XR_TYPE_GRAPHICS_BINDING_OPENGL_XCB_KHR = 1000023002,
+    XR_TYPE_GRAPHICS_BINDING_OPENGL_WAYLAND_KHR = 1000023003,
+    XR_TYPE_SWAPCHAIN_IMAGE_OPENGL_KHR = 1000023004,
+    XR_TYPE_GRAPHICS_REQUIREMENTS_OPENGL_KHR = 1000023005,
+    XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR = 1000025000,
+    XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR = 1000025001,
+    XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR = 1000025002,
+    XR_TYPE_GRAPHICS_BINDING_D3D11_KHR = 1000027000,
+    XR_TYPE_SWAPCHAIN_IMAGE_D3D11_KHR = 1000027001,
+    XR_TYPE_GRAPHICS_REQUIREMENTS_D3D11_KHR = 1000027002,
+    XR_TYPE_GRAPHICS_BINDING_D3D12_KHR = 1000028000,
+    XR_TYPE_SWAPCHAIN_IMAGE_D3D12_KHR = 1000028001,
+    XR_TYPE_GRAPHICS_REQUIREMENTS_D3D12_KHR = 1000028002,
+    XR_TYPE_SYSTEM_EYE_GAZE_INTERACTION_PROPERTIES_EXT = 1000030000,
+    XR_TYPE_EYE_GAZE_SAMPLE_TIME_EXT = 1000030001,
+    XR_TYPE_VISIBILITY_MASK_KHR = 1000031000,
+    XR_TYPE_EVENT_DATA_VISIBILITY_MASK_CHANGED_KHR = 1000031001,
+    XR_TYPE_SESSION_CREATE_INFO_OVERLAY_EXTX = 1000033000,
+    XR_TYPE_EVENT_DATA_MAIN_SESSION_VISIBILITY_CHANGED_EXTX = 1000033003,
+    XR_TYPE_COMPOSITION_LAYER_COLOR_SCALE_BIAS_KHR = 1000034000,
+    XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_MSFT = 1000039000,
+    XR_TYPE_SPATIAL_ANCHOR_SPACE_CREATE_INFO_MSFT = 1000039001,
+    XR_TYPE_COMPOSITION_LAYER_IMAGE_LAYOUT_FB = 1000040000,
+    XR_TYPE_COMPOSITION_LAYER_ALPHA_BLEND_FB = 1000041001,
+    XR_TYPE_VIEW_CONFIGURATION_DEPTH_RANGE_EXT = 1000046000,
+    XR_TYPE_SPATIAL_GRAPH_NODE_SPACE_CREATE_INFO_MSFT = 1000049000,
+    XR_TYPE_SPATIAL_GRAPH_STATIC_NODE_BINDING_CREATE_INFO_MSFT = 1000049001,
+    XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_GET_INFO_MSFT = 1000049002,
+    XR_TYPE_SPATIAL_GRAPH_NODE_BINDING_PROPERTIES_MSFT = 1000049003,
+    XR_TYPE_SYSTEM_HAND_TRACKING_PROPERTIES_EXT = 1000051000,
+    XR_TYPE_HAND_TRACKER_CREATE_INFO_EXT = 1000051001,
+    XR_TYPE_HAND_JOINTS_LOCATE_INFO_EXT = 1000051002,
+    XR_TYPE_HAND_JOINT_LOCATIONS_EXT = 1000051003,
+    XR_TYPE_HAND_JOINT_VELOCITIES_EXT = 1000051004,
+    XR_TYPE_SYSTEM_HAND_TRACKING_MESH_PROPERTIES_MSFT = 1000052000,
+    XR_TYPE_HAND_MESH_SPACE_CREATE_INFO_MSFT = 1000052001,
+    XR_TYPE_HAND_MESH_UPDATE_INFO_MSFT = 1000052002,
+    XR_TYPE_HAND_MESH_MSFT = 1000052003,
+    XR_TYPE_HAND_POSE_TYPE_INFO_MSFT = 1000052004,
+    XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SESSION_BEGIN_INFO_MSFT = 1000053000,
+    XR_TYPE_SECONDARY_VIEW_CONFIGURATION_STATE_MSFT = 1000053001,
+    XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_STATE_MSFT = 1000053002,
+    XR_TYPE_SECONDARY_VIEW_CONFIGURATION_FRAME_END_INFO_MSFT = 1000053003,
+    XR_TYPE_SECONDARY_VIEW_CONFIGURATION_LAYER_INFO_MSFT = 1000053004,
+    XR_TYPE_SECONDARY_VIEW_CONFIGURATION_SWAPCHAIN_CREATE_INFO_MSFT = 1000053005,
+    XR_TYPE_CONTROLLER_MODEL_KEY_STATE_MSFT = 1000055000,
+    XR_TYPE_CONTROLLER_MODEL_NODE_PROPERTIES_MSFT = 1000055001,
+    XR_TYPE_CONTROLLER_MODEL_PROPERTIES_MSFT = 1000055002,
+    XR_TYPE_CONTROLLER_MODEL_NODE_STATE_MSFT = 1000055003,
+    XR_TYPE_CONTROLLER_MODEL_STATE_MSFT = 1000055004,
+    XR_TYPE_VIEW_CONFIGURATION_VIEW_FOV_EPIC = 1000059000,
+    XR_TYPE_HOLOGRAPHIC_WINDOW_ATTACHMENT_MSFT = 1000063000,
+    XR_TYPE_COMPOSITION_LAYER_REPROJECTION_INFO_MSFT = 1000066000,
+    XR_TYPE_COMPOSITION_LAYER_REPROJECTION_PLANE_OVERRIDE_MSFT = 1000066001,
+    XR_TYPE_COMPOSITION_LAYER_SECURE_CONTENT_FB = 1000072000,
+    XR_TYPE_BODY_TRACKER_CREATE_INFO_FB = 1000076001,
+    XR_TYPE_BODY_JOINTS_LOCATE_INFO_FB = 1000076002,
+    XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_FB = 1000076004,
+    XR_TYPE_BODY_JOINT_LOCATIONS_FB = 1000076005,
+    XR_TYPE_BODY_SKELETON_FB = 1000076006,
+    XR_TYPE_INTERACTION_PROFILE_DPAD_BINDING_EXT = 1000078000,
+    XR_TYPE_INTERACTION_PROFILE_ANALOG_THRESHOLD_VALVE = 1000079000,
+    XR_TYPE_HAND_JOINTS_MOTION_RANGE_INFO_EXT = 1000080000,
+    XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR = 1000090000,
+    XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR = 1000090001,
+    XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR = 1000090003,
+    XR_TYPE_COMPOSITION_LAYER_EQUIRECT2_KHR = 1000091000,
+    XR_TYPE_SCENE_OBSERVER_CREATE_INFO_MSFT = 1000097000,
+    XR_TYPE_SCENE_CREATE_INFO_MSFT = 1000097001,
+    XR_TYPE_NEW_SCENE_COMPUTE_INFO_MSFT = 1000097002,
+    XR_TYPE_VISUAL_MESH_COMPUTE_LOD_INFO_MSFT = 1000097003,
+    XR_TYPE_SCENE_COMPONENTS_MSFT = 1000097004,
+    XR_TYPE_SCENE_COMPONENTS_GET_INFO_MSFT = 1000097005,
+    XR_TYPE_SCENE_COMPONENT_LOCATIONS_MSFT = 1000097006,
+    XR_TYPE_SCENE_COMPONENTS_LOCATE_INFO_MSFT = 1000097007,
+    XR_TYPE_SCENE_OBJECTS_MSFT = 1000097008,
+    XR_TYPE_SCENE_COMPONENT_PARENT_FILTER_INFO_MSFT = 1000097009,
+    XR_TYPE_SCENE_OBJECT_TYPES_FILTER_INFO_MSFT = 1000097010,
+    XR_TYPE_SCENE_PLANES_MSFT = 1000097011,
+    XR_TYPE_SCENE_PLANE_ALIGNMENT_FILTER_INFO_MSFT = 1000097012,
+    XR_TYPE_SCENE_MESHES_MSFT = 1000097013,
+    XR_TYPE_SCENE_MESH_BUFFERS_GET_INFO_MSFT = 1000097014,
+    XR_TYPE_SCENE_MESH_BUFFERS_MSFT = 1000097015,
+    XR_TYPE_SCENE_MESH_VERTEX_BUFFER_MSFT = 1000097016,
+    XR_TYPE_SCENE_MESH_INDICES_UINT32_MSFT = 1000097017,
+    XR_TYPE_SCENE_MESH_INDICES_UINT16_MSFT = 1000097018,
+    XR_TYPE_SERIALIZED_SCENE_FRAGMENT_DATA_GET_INFO_MSFT = 1000098000,
+    XR_TYPE_SCENE_DESERIALIZE_INFO_MSFT = 1000098001,
+    XR_TYPE_EVENT_DATA_DISPLAY_REFRESH_RATE_CHANGED_FB = 1000101000,
+    XR_TYPE_VIVE_TRACKER_PATHS_HTCX = 1000103000,
+    XR_TYPE_EVENT_DATA_VIVE_TRACKER_CONNECTED_HTCX = 1000103001,
+    XR_TYPE_SYSTEM_FACIAL_TRACKING_PROPERTIES_HTC = 1000104000,
+    XR_TYPE_FACIAL_TRACKER_CREATE_INFO_HTC = 1000104001,
+    XR_TYPE_FACIAL_EXPRESSIONS_HTC = 1000104002,
+    XR_TYPE_SYSTEM_COLOR_SPACE_PROPERTIES_FB = 1000108000,
+    XR_TYPE_HAND_TRACKING_MESH_FB = 1000110001,
+    XR_TYPE_HAND_TRACKING_SCALE_FB = 1000110003,
+    XR_TYPE_HAND_TRACKING_AIM_STATE_FB = 1000111001,
+    XR_TYPE_HAND_TRACKING_CAPSULES_STATE_FB = 1000112000,
+    XR_TYPE_SPACE_COMPONENT_STATUS_FB = 1000113001,
+    XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_FB = 1000113003,
+    XR_TYPE_SYSTEM_SPATIAL_ENTITY_PROPERTIES_FB = 1000113004,
+    XR_TYPE_EVENT_DATA_SPATIAL_ANCHOR_CREATE_COMPLETE_FB = 1000113005,
+    XR_TYPE_EVENT_DATA_SPACE_SET_STATUS_COMPLETE_FB = 1000113006,
+    XR_TYPE_SPACE_COMPONENT_STATUS_SET_INFO_FB = 1000113007,
+    XR_TYPE_FOVEATION_PROFILE_CREATE_INFO_FB = 1000114000,
+    XR_TYPE_SWAPCHAIN_CREATE_INFO_FOVEATION_FB = 1000114001,
+    XR_TYPE_SWAPCHAIN_STATE_FOVEATION_FB = 1000114002,
+    XR_TYPE_FOVEATION_LEVEL_PROFILE_CREATE_INFO_FB = 1000115000,
+    XR_TYPE_SYSTEM_KEYBOARD_TRACKING_PROPERTIES_FB = 1000116002,
+    XR_TYPE_KEYBOARD_TRACKING_QUERY_FB = 1000116004,
+    XR_TYPE_KEYBOARD_SPACE_CREATE_INFO_FB = 1000116009,
+    XR_TYPE_TRIANGLE_MESH_CREATE_INFO_FB = 1000117001,
+    XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES_FB = 1000118000,
+    XR_TYPE_PASSTHROUGH_CREATE_INFO_FB = 1000118001,
+    XR_TYPE_PASSTHROUGH_LAYER_CREATE_INFO_FB = 1000118002,
+    XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_FB = 1000118003,
+    XR_TYPE_GEOMETRY_INSTANCE_CREATE_INFO_FB = 1000118004,
+    XR_TYPE_GEOMETRY_INSTANCE_TRANSFORM_FB = 1000118005,
+    XR_TYPE_SYSTEM_PASSTHROUGH_PROPERTIES2_FB = 1000118006,
+    XR_TYPE_PASSTHROUGH_STYLE_FB = 1000118020,
+    XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_RGBA_FB = 1000118021,
+    XR_TYPE_PASSTHROUGH_COLOR_MAP_MONO_TO_MONO_FB = 1000118022,
+    XR_TYPE_PASSTHROUGH_BRIGHTNESS_CONTRAST_SATURATION_FB = 1000118023,
+    XR_TYPE_EVENT_DATA_PASSTHROUGH_STATE_CHANGED_FB = 1000118030,
+    XR_TYPE_RENDER_MODEL_PATH_INFO_FB = 1000119000,
+    XR_TYPE_RENDER_MODEL_PROPERTIES_FB = 1000119001,
+    XR_TYPE_RENDER_MODEL_BUFFER_FB = 1000119002,
+    XR_TYPE_RENDER_MODEL_LOAD_INFO_FB = 1000119003,
+    XR_TYPE_SYSTEM_RENDER_MODEL_PROPERTIES_FB = 1000119004,
+    XR_TYPE_RENDER_MODEL_CAPABILITIES_REQUEST_FB = 1000119005,
+    XR_TYPE_BINDING_MODIFICATIONS_KHR = 1000120000,
+    XR_TYPE_VIEW_LOCATE_FOVEATED_RENDERING_VARJO = 1000121000,
+    XR_TYPE_FOVEATED_VIEW_CONFIGURATION_VIEW_VARJO = 1000121001,
+    XR_TYPE_SYSTEM_FOVEATED_RENDERING_PROPERTIES_VARJO = 1000121002,
+    XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_VARJO = 1000122000,
+    XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_VARJO = 1000124000,
+    XR_TYPE_EVENT_DATA_MARKER_TRACKING_UPDATE_VARJO = 1000124001,
+    XR_TYPE_MARKER_SPACE_CREATE_INFO_VARJO = 1000124002,
+    XR_TYPE_FRAME_END_INFO_ML = 1000135000,
+    XR_TYPE_GLOBAL_DIMMER_FRAME_END_INFO_ML = 1000136000,
+    XR_TYPE_SYSTEM_MARKER_UNDERSTANDING_PROPERTIES_ML = 1000138000,
+    XR_TYPE_MARKER_DETECTOR_CREATE_INFO_ML = 1000138001,
+    XR_TYPE_MARKER_DETECTOR_ARUCO_INFO_ML = 1000138002,
+    XR_TYPE_MARKER_DETECTOR_SIZE_INFO_ML = 1000138003,
+    XR_TYPE_MARKER_DETECTOR_APRIL_TAG_INFO_ML = 1000138004,
+    XR_TYPE_MARKER_DETECTOR_CUSTOM_PROFILE_INFO_ML = 1000138005,
+    XR_TYPE_MARKER_DETECTOR_SNAPSHOT_INFO_ML = 1000138006,
+    XR_TYPE_MARKER_DETECTOR_STATE_ML = 1000138007,
+    XR_TYPE_MARKER_SPACE_CREATE_INFO_ML = 1000138008,
+    XR_TYPE_LOCALIZATION_MAP_ML = 1000139000,
+    XR_TYPE_EVENT_DATA_LOCALIZATION_CHANGED_ML = 1000139001,
+    XR_TYPE_MAP_LOCALIZATION_REQUEST_INFO_ML = 1000139002,
+    XR_TYPE_LOCALIZATION_MAP_IMPORT_INFO_ML = 1000139003,
+    XR_TYPE_LOCALIZATION_ENABLE_EVENTS_INFO_ML = 1000139004,
+    XR_TYPE_SPATIAL_ANCHORS_CREATE_INFO_FROM_POSE_ML = 1000140000,
+    XR_TYPE_CREATE_SPATIAL_ANCHORS_COMPLETION_ML = 1000140001,
+    XR_TYPE_SPATIAL_ANCHOR_STATE_ML = 1000140002,
+    XR_TYPE_SPATIAL_ANCHORS_CREATE_STORAGE_INFO_ML = 1000141000,
+    XR_TYPE_SPATIAL_ANCHORS_QUERY_INFO_RADIUS_ML = 1000141001,
+    XR_TYPE_SPATIAL_ANCHORS_QUERY_COMPLETION_ML = 1000141002,
+    XR_TYPE_SPATIAL_ANCHORS_CREATE_INFO_FROM_UUIDS_ML = 1000141003,
+    XR_TYPE_SPATIAL_ANCHORS_PUBLISH_INFO_ML = 1000141004,
+    XR_TYPE_SPATIAL_ANCHORS_PUBLISH_COMPLETION_ML = 1000141005,
+    XR_TYPE_SPATIAL_ANCHORS_DELETE_INFO_ML = 1000141006,
+    XR_TYPE_SPATIAL_ANCHORS_DELETE_COMPLETION_ML = 1000141007,
+    XR_TYPE_SPATIAL_ANCHORS_UPDATE_EXPIRATION_INFO_ML = 1000141008,
+    XR_TYPE_SPATIAL_ANCHORS_UPDATE_EXPIRATION_COMPLETION_ML = 1000141009,
+    XR_TYPE_SPATIAL_ANCHORS_PUBLISH_COMPLETION_DETAILS_ML = 1000141010,
+    XR_TYPE_SPATIAL_ANCHORS_DELETE_COMPLETION_DETAILS_ML = 1000141011,
+    XR_TYPE_SPATIAL_ANCHORS_UPDATE_EXPIRATION_COMPLETION_DETAILS_ML = 1000141012,
+    XR_TYPE_SPATIAL_ANCHOR_PERSISTENCE_INFO_MSFT = 1000142000,
+    XR_TYPE_SPATIAL_ANCHOR_FROM_PERSISTED_ANCHOR_CREATE_INFO_MSFT = 1000142001,
+    XR_TYPE_SCENE_MARKERS_MSFT = 1000147000,
+    XR_TYPE_SCENE_MARKER_TYPE_FILTER_MSFT = 1000147001,
+    XR_TYPE_SCENE_MARKER_QR_CODES_MSFT = 1000147002,
+    XR_TYPE_SPACE_QUERY_INFO_FB = 1000156001,
+    XR_TYPE_SPACE_QUERY_RESULTS_FB = 1000156002,
+    XR_TYPE_SPACE_STORAGE_LOCATION_FILTER_INFO_FB = 1000156003,
+    XR_TYPE_SPACE_COMPONENT_FILTER_INFO_FB = 1000156052,
+    XR_TYPE_SPACE_UUID_FILTER_INFO_FB = 1000156054,
+    XR_TYPE_EVENT_DATA_SPACE_QUERY_RESULTS_AVAILABLE_FB = 1000156103,
+    XR_TYPE_EVENT_DATA_SPACE_QUERY_COMPLETE_FB = 1000156104,
+    XR_TYPE_SPACE_SAVE_INFO_FB = 1000158000,
+    XR_TYPE_SPACE_ERASE_INFO_FB = 1000158001,
+    XR_TYPE_EVENT_DATA_SPACE_SAVE_COMPLETE_FB = 1000158106,
+    XR_TYPE_EVENT_DATA_SPACE_ERASE_COMPLETE_FB = 1000158107,
+    XR_TYPE_SWAPCHAIN_IMAGE_FOVEATION_VULKAN_FB = 1000160000,
+    XR_TYPE_SWAPCHAIN_STATE_SAMPLER_VULKAN_FB = 1000163000,
+    XR_TYPE_SPACE_SHARE_INFO_FB = 1000169001,
+    XR_TYPE_EVENT_DATA_SPACE_SHARE_COMPLETE_FB = 1000169002,
+    XR_TYPE_COMPOSITION_LAYER_SPACE_WARP_INFO_FB = 1000171000,
+    XR_TYPE_SYSTEM_SPACE_WARP_PROPERTIES_FB = 1000171001,
+    XR_TYPE_HAPTIC_AMPLITUDE_ENVELOPE_VIBRATION_FB = 1000173001,
+    XR_TYPE_SEMANTIC_LABELS_FB = 1000175000,
+    XR_TYPE_ROOM_LAYOUT_FB = 1000175001,
+    XR_TYPE_BOUNDARY_2D_FB = 1000175002,
+    XR_TYPE_SEMANTIC_LABELS_SUPPORT_INFO_FB = 1000175010,
+    XR_TYPE_DIGITAL_LENS_CONTROL_ALMALENCE = 1000196000,
+    XR_TYPE_EVENT_DATA_SCENE_CAPTURE_COMPLETE_FB = 1000198001,
+    XR_TYPE_SCENE_CAPTURE_REQUEST_INFO_FB = 1000198050,
+    XR_TYPE_SPACE_CONTAINER_FB = 1000199000,
+    XR_TYPE_FOVEATION_EYE_TRACKED_PROFILE_CREATE_INFO_META = 1000200000,
+    XR_TYPE_FOVEATION_EYE_TRACKED_STATE_META = 1000200001,
+    XR_TYPE_SYSTEM_FOVEATION_EYE_TRACKED_PROPERTIES_META = 1000200002,
+    XR_TYPE_FACE_EXPRESSION_INFO_FB = 1000201002,
+    XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES_FB = 1000201004,
+    XR_TYPE_FACE_TRACKER_CREATE_INFO_FB = 1000201005,
+    XR_TYPE_FACE_EXPRESSION_WEIGHTS_FB = 1000201006,
+    XR_TYPE_EYE_TRACKER_CREATE_INFO_FB = 1000202001,
+    XR_TYPE_EYE_GAZES_INFO_FB = 1000202002,
+    XR_TYPE_EYE_GAZES_FB = 1000202003,
+    XR_TYPE_SYSTEM_EYE_TRACKING_PROPERTIES_FB = 1000202004,
+    XR_TYPE_PASSTHROUGH_KEYBOARD_HANDS_INTENSITY_FB = 1000203002,
+    XR_TYPE_COMPOSITION_LAYER_SETTINGS_FB = 1000204000,
+    XR_TYPE_HAPTIC_PCM_VIBRATION_FB = 1000209001,
+    XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB = 1000209002,
+    XR_TYPE_FRAME_SYNTHESIS_INFO_EXT = 1000211000,
+    XR_TYPE_FRAME_SYNTHESIS_CONFIG_VIEW_EXT = 1000211001,
+    XR_TYPE_COMPOSITION_LAYER_DEPTH_TEST_FB = 1000212000,
+    XR_TYPE_LOCAL_DIMMING_FRAME_END_INFO_META = 1000216000,
+    XR_TYPE_PASSTHROUGH_PREFERENCES_META = 1000217000,
+    XR_TYPE_SYSTEM_VIRTUAL_KEYBOARD_PROPERTIES_META = 1000219001,
+    XR_TYPE_VIRTUAL_KEYBOARD_CREATE_INFO_META = 1000219002,
+    XR_TYPE_VIRTUAL_KEYBOARD_SPACE_CREATE_INFO_META = 1000219003,
+    XR_TYPE_VIRTUAL_KEYBOARD_LOCATION_INFO_META = 1000219004,
+    XR_TYPE_VIRTUAL_KEYBOARD_MODEL_VISIBILITY_SET_INFO_META = 1000219005,
+    XR_TYPE_VIRTUAL_KEYBOARD_ANIMATION_STATE_META = 1000219006,
+    XR_TYPE_VIRTUAL_KEYBOARD_MODEL_ANIMATION_STATES_META = 1000219007,
+    XR_TYPE_VIRTUAL_KEYBOARD_TEXTURE_DATA_META = 1000219009,
+    XR_TYPE_VIRTUAL_KEYBOARD_INPUT_INFO_META = 1000219010,
+    XR_TYPE_VIRTUAL_KEYBOARD_TEXT_CONTEXT_CHANGE_INFO_META = 1000219011,
+    XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_COMMIT_TEXT_META = 1000219014,
+    XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_BACKSPACE_META = 1000219015,
+    XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_ENTER_META = 1000219016,
+    XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_SHOWN_META = 1000219017,
+    XR_TYPE_EVENT_DATA_VIRTUAL_KEYBOARD_HIDDEN_META = 1000219018,
+    XR_TYPE_EXTERNAL_CAMERA_OCULUS = 1000226000,
+    XR_TYPE_VULKAN_SWAPCHAIN_CREATE_INFO_META = 1000227000,
+    XR_TYPE_PERFORMANCE_METRICS_STATE_META = 1000232001,
+    XR_TYPE_PERFORMANCE_METRICS_COUNTER_META = 1000232002,
+    XR_TYPE_SPACE_LIST_SAVE_INFO_FB = 1000238000,
+    XR_TYPE_EVENT_DATA_SPACE_LIST_SAVE_COMPLETE_FB = 1000238001,
+    XR_TYPE_SPACE_USER_CREATE_INFO_FB = 1000241001,
+    XR_TYPE_SYSTEM_HEADSET_ID_PROPERTIES_META = 1000245000,
+    XR_TYPE_SYSTEM_SPACE_DISCOVERY_PROPERTIES_META = 1000247000,
+    XR_TYPE_SPACE_DISCOVERY_INFO_META = 1000247001,
+    XR_TYPE_SPACE_FILTER_UUID_META = 1000247003,
+    XR_TYPE_SPACE_FILTER_COMPONENT_META = 1000247004,
+    XR_TYPE_SPACE_DISCOVERY_RESULT_META = 1000247005,
+    XR_TYPE_SPACE_DISCOVERY_RESULTS_META = 1000247006,
+    XR_TYPE_EVENT_DATA_SPACE_DISCOVERY_RESULTS_AVAILABLE_META = 1000247007,
+    XR_TYPE_EVENT_DATA_SPACE_DISCOVERY_COMPLETE_META = 1000247008,
+    XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_META = 1000254000,
+    XR_TYPE_RECOMMENDED_LAYER_RESOLUTION_GET_INFO_META = 1000254001,
+    XR_TYPE_SYSTEM_SPACE_PERSISTENCE_PROPERTIES_META = 1000259000,
+    XR_TYPE_SPACES_SAVE_INFO_META = 1000259001,
+    XR_TYPE_EVENT_DATA_SPACES_SAVE_RESULT_META = 1000259002,
+    XR_TYPE_SPACES_ERASE_INFO_META = 1000259003,
+    XR_TYPE_EVENT_DATA_SPACES_ERASE_RESULT_META = 1000259004,
+    XR_TYPE_SYSTEM_PASSTHROUGH_COLOR_LUT_PROPERTIES_META = 1000266000,
+    XR_TYPE_PASSTHROUGH_COLOR_LUT_CREATE_INFO_META = 1000266001,
+    XR_TYPE_PASSTHROUGH_COLOR_LUT_UPDATE_INFO_META = 1000266002,
+    XR_TYPE_PASSTHROUGH_COLOR_MAP_LUT_META = 1000266100,
+    XR_TYPE_PASSTHROUGH_COLOR_MAP_INTERPOLATED_LUT_META = 1000266101,
+    XR_TYPE_SPACE_TRIANGLE_MESH_GET_INFO_META = 1000269001,
+    XR_TYPE_SPACE_TRIANGLE_MESH_META = 1000269002,
+    XR_TYPE_SYSTEM_PROPERTIES_BODY_TRACKING_FULL_BODY_META = 1000274000,
+    XR_TYPE_EVENT_DATA_PASSTHROUGH_LAYER_RESUMED_META = 1000282000,
+    XR_TYPE_BODY_TRACKING_CALIBRATION_INFO_META = 1000283002,
+    XR_TYPE_BODY_TRACKING_CALIBRATION_STATUS_META = 1000283003,
+    XR_TYPE_SYSTEM_PROPERTIES_BODY_TRACKING_CALIBRATION_META = 1000283004,
+    XR_TYPE_SYSTEM_FACE_TRACKING_PROPERTIES2_FB = 1000287013,
+    XR_TYPE_FACE_TRACKER_CREATE_INFO2_FB = 1000287014,
+    XR_TYPE_FACE_EXPRESSION_INFO2_FB = 1000287015,
+    XR_TYPE_FACE_EXPRESSION_WEIGHTS2_FB = 1000287016,
+    XR_TYPE_SYSTEM_SPATIAL_ENTITY_SHARING_PROPERTIES_META = 1000290000,
+    XR_TYPE_SHARE_SPACES_INFO_META = 1000290001,
+    XR_TYPE_EVENT_DATA_SHARE_SPACES_COMPLETE_META = 1000290002,
+    XR_TYPE_ENVIRONMENT_DEPTH_PROVIDER_CREATE_INFO_META = 1000291000,
+    XR_TYPE_ENVIRONMENT_DEPTH_SWAPCHAIN_CREATE_INFO_META = 1000291001,
+    XR_TYPE_ENVIRONMENT_DEPTH_SWAPCHAIN_STATE_META = 1000291002,
+    XR_TYPE_ENVIRONMENT_DEPTH_IMAGE_ACQUIRE_INFO_META = 1000291003,
+    XR_TYPE_ENVIRONMENT_DEPTH_IMAGE_VIEW_META = 1000291004,
+    XR_TYPE_ENVIRONMENT_DEPTH_IMAGE_META = 1000291005,
+    XR_TYPE_ENVIRONMENT_DEPTH_HAND_REMOVAL_SET_INFO_META = 1000291006,
+    XR_TYPE_SYSTEM_ENVIRONMENT_DEPTH_PROPERTIES_META = 1000291007,
+    XR_TYPE_RENDER_MODEL_CREATE_INFO_EXT = 1000300000,
+    XR_TYPE_RENDER_MODEL_PROPERTIES_GET_INFO_EXT = 1000300001,
+    XR_TYPE_RENDER_MODEL_PROPERTIES_EXT = 1000300002,
+    XR_TYPE_RENDER_MODEL_SPACE_CREATE_INFO_EXT = 1000300003,
+    XR_TYPE_RENDER_MODEL_STATE_GET_INFO_EXT = 1000300004,
+    XR_TYPE_RENDER_MODEL_STATE_EXT = 1000300005,
+    XR_TYPE_RENDER_MODEL_ASSET_CREATE_INFO_EXT = 1000300006,
+    XR_TYPE_RENDER_MODEL_ASSET_DATA_GET_INFO_EXT = 1000300007,
+    XR_TYPE_RENDER_MODEL_ASSET_DATA_EXT = 1000300008,
+    XR_TYPE_RENDER_MODEL_ASSET_PROPERTIES_GET_INFO_EXT = 1000300009,
+    XR_TYPE_RENDER_MODEL_ASSET_PROPERTIES_EXT = 1000300010,
+    XR_TYPE_INTERACTION_RENDER_MODEL_IDS_ENUMERATE_INFO_EXT = 1000301000,
+    XR_TYPE_INTERACTION_RENDER_MODEL_SUBACTION_PATH_INFO_EXT = 1000301001,
+    XR_TYPE_EVENT_DATA_INTERACTION_RENDER_MODELS_CHANGED_EXT = 1000301002,
+    XR_TYPE_INTERACTION_RENDER_MODEL_TOP_LEVEL_USER_PATH_GET_INFO_EXT = 1000301003,
+    XR_TYPE_PASSTHROUGH_CREATE_INFO_HTC = 1000317001,
+    XR_TYPE_PASSTHROUGH_COLOR_HTC = 1000317002,
+    XR_TYPE_PASSTHROUGH_MESH_TRANSFORM_INFO_HTC = 1000317003,
+    XR_TYPE_COMPOSITION_LAYER_PASSTHROUGH_HTC = 1000317004,
+    XR_TYPE_SYSTEM_ANCHOR_PROPERTIES_HTC = 1000319000,
+    XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_HTC = 1000319001,
+    XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_HTC = 1000320000,
+    XR_TYPE_BODY_TRACKER_CREATE_INFO_HTC = 1000320001,
+    XR_TYPE_BODY_JOINTS_LOCATE_INFO_HTC = 1000320002,
+    XR_TYPE_BODY_JOINT_LOCATIONS_HTC = 1000320003,
+    XR_TYPE_BODY_SKELETON_HTC = 1000320004,
+    XR_TYPE_ACTIVE_ACTION_SET_PRIORITIES_EXT = 1000373000,
+    XR_TYPE_SYSTEM_FORCE_FEEDBACK_CURL_PROPERTIES_MNDX = 1000375000,
+    XR_TYPE_FORCE_FEEDBACK_CURL_APPLY_LOCATIONS_MNDX = 1000375001,
+    XR_TYPE_BODY_TRACKER_CREATE_INFO_BD = 1000385001,
+    XR_TYPE_BODY_JOINTS_LOCATE_INFO_BD = 1000385002,
+    XR_TYPE_BODY_JOINT_LOCATIONS_BD = 1000385003,
+    XR_TYPE_SYSTEM_BODY_TRACKING_PROPERTIES_BD = 1000385004,
+    XR_TYPE_SYSTEM_SPATIAL_SENSING_PROPERTIES_BD = 1000389000,
+    XR_TYPE_SPATIAL_ENTITY_COMPONENT_GET_INFO_BD = 1000389001,
+    XR_TYPE_SPATIAL_ENTITY_LOCATION_GET_INFO_BD = 1000389002,
+    XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_LOCATION_BD = 1000389003,
+    XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_SEMANTIC_BD = 1000389004,
+    XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_BOUNDING_BOX_2D_BD = 1000389005,
+    XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_POLYGON_BD = 1000389006,
+    XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_BOUNDING_BOX_3D_BD = 1000389007,
+    XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_TRIANGLE_MESH_BD = 1000389008,
+    XR_TYPE_SENSE_DATA_PROVIDER_CREATE_INFO_BD = 1000389009,
+    XR_TYPE_SENSE_DATA_PROVIDER_START_INFO_BD = 1000389010,
+    XR_TYPE_EVENT_DATA_SENSE_DATA_PROVIDER_STATE_CHANGED_BD = 1000389011,
+    XR_TYPE_EVENT_DATA_SENSE_DATA_UPDATED_BD = 1000389012,
+    XR_TYPE_SENSE_DATA_QUERY_INFO_BD = 1000389013,
+    XR_TYPE_SENSE_DATA_QUERY_COMPLETION_BD = 1000389014,
+    XR_TYPE_SENSE_DATA_FILTER_UUID_BD = 1000389015,
+    XR_TYPE_SENSE_DATA_FILTER_SEMANTIC_BD = 1000389016,
+    XR_TYPE_QUERIED_SENSE_DATA_GET_INFO_BD = 1000389017,
+    XR_TYPE_QUERIED_SENSE_DATA_BD = 1000389018,
+    XR_TYPE_SPATIAL_ENTITY_STATE_BD = 1000389019,
+    XR_TYPE_SPATIAL_ENTITY_ANCHOR_CREATE_INFO_BD = 1000389020,
+    XR_TYPE_ANCHOR_SPACE_CREATE_INFO_BD = 1000389021,
+    XR_TYPE_SYSTEM_SPATIAL_ANCHOR_PROPERTIES_BD = 1000390000,
+    XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_BD = 1000390001,
+    XR_TYPE_SPATIAL_ANCHOR_CREATE_COMPLETION_BD = 1000390002,
+    XR_TYPE_SPATIAL_ANCHOR_PERSIST_INFO_BD = 1000390003,
+    XR_TYPE_SPATIAL_ANCHOR_UNPERSIST_INFO_BD = 1000390004,
+    XR_TYPE_SYSTEM_SPATIAL_ANCHOR_SHARING_PROPERTIES_BD = 1000391000,
+    XR_TYPE_SPATIAL_ANCHOR_SHARE_INFO_BD = 1000391001,
+    XR_TYPE_SHARED_SPATIAL_ANCHOR_DOWNLOAD_INFO_BD = 1000391002,
+    XR_TYPE_SYSTEM_SPATIAL_SCENE_PROPERTIES_BD = 1000392000,
+    XR_TYPE_SCENE_CAPTURE_INFO_BD = 1000392001,
+    XR_TYPE_SYSTEM_SPATIAL_MESH_PROPERTIES_BD = 1000393000,
+    XR_TYPE_SENSE_DATA_PROVIDER_CREATE_INFO_SPATIAL_MESH_BD = 1000393001,
+    XR_TYPE_FUTURE_POLL_RESULT_PROGRESS_BD = 1000394001,
+    XR_TYPE_SYSTEM_SPATIAL_PLANE_PROPERTIES_BD = 1000396000,
+    XR_TYPE_SPATIAL_ENTITY_COMPONENT_DATA_PLANE_ORIENTATION_BD = 1000396001,
+    XR_TYPE_SENSE_DATA_FILTER_PLANE_ORIENTATION_BD = 1000396002,
+    XR_TYPE_HAND_TRACKING_DATA_SOURCE_INFO_EXT = 1000428000,
+    XR_TYPE_HAND_TRACKING_DATA_SOURCE_STATE_EXT = 1000428001,
+    XR_TYPE_PLANE_DETECTOR_CREATE_INFO_EXT = 1000429001,
+    XR_TYPE_PLANE_DETECTOR_BEGIN_INFO_EXT = 1000429002,
+    XR_TYPE_PLANE_DETECTOR_GET_INFO_EXT = 1000429003,
+    XR_TYPE_PLANE_DETECTOR_LOCATIONS_EXT = 1000429004,
+    XR_TYPE_PLANE_DETECTOR_LOCATION_EXT = 1000429005,
+    XR_TYPE_PLANE_DETECTOR_POLYGON_BUFFER_EXT = 1000429006,
+    XR_TYPE_SYSTEM_PLANE_DETECTION_PROPERTIES_EXT = 1000429007,
+    XR_TYPE_TRACKABLE_GET_INFO_ANDROID = 1000455000,
+    XR_TYPE_ANCHOR_SPACE_CREATE_INFO_ANDROID = 1000455001,
+    XR_TYPE_TRACKABLE_PLANE_ANDROID = 1000455003,
+    XR_TYPE_TRACKABLE_TRACKER_CREATE_INFO_ANDROID = 1000455004,
+    XR_TYPE_SYSTEM_TRACKABLES_PROPERTIES_ANDROID = 1000455005,
+    XR_TYPE_PERSISTED_ANCHOR_SPACE_CREATE_INFO_ANDROID = 1000457001,
+    XR_TYPE_PERSISTED_ANCHOR_SPACE_INFO_ANDROID = 1000457002,
+    XR_TYPE_DEVICE_ANCHOR_PERSISTENCE_CREATE_INFO_ANDROID = 1000457003,
+    XR_TYPE_SYSTEM_DEVICE_ANCHOR_PERSISTENCE_PROPERTIES_ANDROID = 1000457004,
+    XR_TYPE_PASSTHROUGH_CAMERA_STATE_GET_INFO_ANDROID = 1000460000,
+    XR_TYPE_SYSTEM_PASSTHROUGH_CAMERA_STATE_PROPERTIES_ANDROID = 1000460001,
+    XR_TYPE_RAYCAST_INFO_ANDROID = 1000463000,
+    XR_TYPE_RAYCAST_HIT_RESULTS_ANDROID = 1000463001,
+    XR_TYPE_TRACKABLE_OBJECT_ANDROID = 1000466000,
+    XR_TYPE_TRACKABLE_OBJECT_CONFIGURATION_ANDROID = 1000466001,
+    XR_TYPE_FUTURE_CANCEL_INFO_EXT = 1000469000,
+    XR_TYPE_FUTURE_POLL_INFO_EXT = 1000469001,
+    XR_TYPE_FUTURE_COMPLETION_EXT = 1000469002,
+    XR_TYPE_FUTURE_POLL_RESULT_EXT = 1000469003,
+    XR_TYPE_EVENT_DATA_USER_PRESENCE_CHANGED_EXT = 1000470000,
+    XR_TYPE_SYSTEM_USER_PRESENCE_PROPERTIES_EXT = 1000470001,
+    XR_TYPE_SPACES_LOCATE_INFO = 1000471000,
+    XR_TYPE_SPACE_LOCATIONS = 1000471001,
+    XR_TYPE_SPACE_VELOCITIES = 1000471002,
+    XR_TYPE_EVENT_DATA_HEADSET_FIT_CHANGED_ML = 1000472000,
+    XR_TYPE_EVENT_DATA_EYE_CALIBRATION_CHANGED_ML = 1000472001,
+    XR_TYPE_USER_CALIBRATION_ENABLE_EVENTS_INFO_ML = 1000472002,
+    XR_TYPE_SYSTEM_NOTIFICATIONS_SET_INFO_ML = 1000473000,
+    XR_TYPE_WORLD_MESH_DETECTOR_CREATE_INFO_ML = 1000474001,
+    XR_TYPE_WORLD_MESH_STATE_REQUEST_INFO_ML = 1000474002,
+    XR_TYPE_WORLD_MESH_BLOCK_STATE_ML = 1000474003,
+    XR_TYPE_WORLD_MESH_STATE_REQUEST_COMPLETION_ML = 1000474004,
+    XR_TYPE_WORLD_MESH_BUFFER_RECOMMENDED_SIZE_INFO_ML = 1000474005,
+    XR_TYPE_WORLD_MESH_BUFFER_SIZE_ML = 1000474006,
+    XR_TYPE_WORLD_MESH_BUFFER_ML = 1000474007,
+    XR_TYPE_WORLD_MESH_BLOCK_REQUEST_ML = 1000474008,
+    XR_TYPE_WORLD_MESH_GET_INFO_ML = 1000474009,
+    XR_TYPE_WORLD_MESH_BLOCK_ML = 1000474010,
+    XR_TYPE_WORLD_MESH_REQUEST_COMPLETION_ML = 1000474011,
+    XR_TYPE_WORLD_MESH_REQUEST_COMPLETION_INFO_ML = 1000474012,
+    XR_TYPE_SYSTEM_FACIAL_EXPRESSION_PROPERTIES_ML = 1000482004,
+    XR_TYPE_FACIAL_EXPRESSION_CLIENT_CREATE_INFO_ML = 1000482005,
+    XR_TYPE_FACIAL_EXPRESSION_BLEND_SHAPE_GET_INFO_ML = 1000482006,
+    XR_TYPE_FACIAL_EXPRESSION_BLEND_SHAPE_PROPERTIES_ML = 1000482007,
+    XR_TYPE_SYSTEM_SIMULTANEOUS_HANDS_AND_CONTROLLERS_PROPERTIES_META = 1000532001,
+    XR_TYPE_SIMULTANEOUS_HANDS_AND_CONTROLLERS_TRACKING_RESUME_INFO_META = 1000532002,
+    XR_TYPE_SIMULTANEOUS_HANDS_AND_CONTROLLERS_TRACKING_PAUSE_INFO_META = 1000532003,
+    XR_TYPE_COLOCATION_DISCOVERY_START_INFO_META = 1000571010,
+    XR_TYPE_COLOCATION_DISCOVERY_STOP_INFO_META = 1000571011,
+    XR_TYPE_COLOCATION_ADVERTISEMENT_START_INFO_META = 1000571012,
+    XR_TYPE_COLOCATION_ADVERTISEMENT_STOP_INFO_META = 1000571013,
+    XR_TYPE_EVENT_DATA_START_COLOCATION_ADVERTISEMENT_COMPLETE_META = 1000571020,
+    XR_TYPE_EVENT_DATA_STOP_COLOCATION_ADVERTISEMENT_COMPLETE_META = 1000571021,
+    XR_TYPE_EVENT_DATA_COLOCATION_ADVERTISEMENT_COMPLETE_META = 1000571022,
+    XR_TYPE_EVENT_DATA_START_COLOCATION_DISCOVERY_COMPLETE_META = 1000571023,
+    XR_TYPE_EVENT_DATA_COLOCATION_DISCOVERY_RESULT_META = 1000571024,
+    XR_TYPE_EVENT_DATA_COLOCATION_DISCOVERY_COMPLETE_META = 1000571025,
+    XR_TYPE_EVENT_DATA_STOP_COLOCATION_DISCOVERY_COMPLETE_META = 1000571026,
+    XR_TYPE_SYSTEM_COLOCATION_DISCOVERY_PROPERTIES_META = 1000571030,
+    XR_TYPE_SHARE_SPACES_RECIPIENT_GROUPS_META = 1000572000,
+    XR_TYPE_SPACE_GROUP_UUID_FILTER_INFO_META = 1000572001,
+    XR_TYPE_SYSTEM_SPATIAL_ENTITY_GROUP_SHARING_PROPERTIES_META = 1000572100,
+    XR_TYPE_SYSTEM_MARKER_TRACKING_PROPERTIES_ANDROID = 1000707000,
+    XR_TYPE_TRACKABLE_MARKER_CONFIGURATION_ANDROID = 1000707001,
+    XR_TYPE_TRACKABLE_MARKER_ANDROID = 1000707002,
+    XR_TYPE_SPATIAL_CAPABILITY_COMPONENT_TYPES_EXT = 1000740000,
+    XR_TYPE_SPATIAL_CONTEXT_CREATE_INFO_EXT = 1000740001,
+    XR_TYPE_CREATE_SPATIAL_CONTEXT_COMPLETION_EXT = 1000740002,
+    XR_TYPE_SPATIAL_DISCOVERY_SNAPSHOT_CREATE_INFO_EXT = 1000740003,
+    XR_TYPE_CREATE_SPATIAL_DISCOVERY_SNAPSHOT_COMPLETION_INFO_EXT = 1000740004,
+    XR_TYPE_CREATE_SPATIAL_DISCOVERY_SNAPSHOT_COMPLETION_EXT = 1000740005,
+    XR_TYPE_SPATIAL_COMPONENT_DATA_QUERY_CONDITION_EXT = 1000740006,
+    XR_TYPE_SPATIAL_COMPONENT_DATA_QUERY_RESULT_EXT = 1000740007,
+    XR_TYPE_SPATIAL_BUFFER_GET_INFO_EXT = 1000740008,
+    XR_TYPE_SPATIAL_COMPONENT_BOUNDED_2D_LIST_EXT = 1000740009,
+    XR_TYPE_SPATIAL_COMPONENT_BOUNDED_3D_LIST_EXT = 1000740010,
+    XR_TYPE_SPATIAL_COMPONENT_PARENT_LIST_EXT = 1000740011,
+    XR_TYPE_SPATIAL_COMPONENT_MESH_3D_LIST_EXT = 1000740012,
+    XR_TYPE_SPATIAL_ENTITY_FROM_ID_CREATE_INFO_EXT = 1000740013,
+    XR_TYPE_SPATIAL_UPDATE_SNAPSHOT_CREATE_INFO_EXT = 1000740014,
+    XR_TYPE_EVENT_DATA_SPATIAL_DISCOVERY_RECOMMENDED_EXT = 1000740015,
+    XR_TYPE_SPATIAL_FILTER_TRACKING_STATE_EXT = 1000740016,
+    XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_PLANE_TRACKING_EXT = 1000741000,
+    XR_TYPE_SPATIAL_COMPONENT_PLANE_ALIGNMENT_LIST_EXT = 1000741001,
+    XR_TYPE_SPATIAL_COMPONENT_MESH_2D_LIST_EXT = 1000741002,
+    XR_TYPE_SPATIAL_COMPONENT_POLYGON_2D_LIST_EXT = 1000741003,
+    XR_TYPE_SPATIAL_COMPONENT_PLANE_SEMANTIC_LABEL_LIST_EXT = 1000741004,
+    XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_QR_CODE_EXT = 1000743000,
+    XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_MICRO_QR_CODE_EXT = 1000743001,
+    XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_ARUCO_MARKER_EXT = 1000743002,
+    XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_APRIL_TAG_EXT = 1000743003,
+    XR_TYPE_SPATIAL_MARKER_SIZE_EXT = 1000743004,
+    XR_TYPE_SPATIAL_MARKER_STATIC_OPTIMIZATION_EXT = 1000743005,
+    XR_TYPE_SPATIAL_COMPONENT_MARKER_LIST_EXT = 1000743006,
+    XR_TYPE_SPATIAL_CAPABILITY_CONFIGURATION_ANCHOR_EXT = 1000762000,
+    XR_TYPE_SPATIAL_COMPONENT_ANCHOR_LIST_EXT = 1000762001,
+    XR_TYPE_SPATIAL_ANCHOR_CREATE_INFO_EXT = 1000762002,
+    XR_TYPE_SPATIAL_PERSISTENCE_CONTEXT_CREATE_INFO_EXT = 1000763000,
+    XR_TYPE_CREATE_SPATIAL_PERSISTENCE_CONTEXT_COMPLETION_EXT = 1000763001,
+    XR_TYPE_SPATIAL_CONTEXT_PERSISTENCE_CONFIG_EXT = 1000763002,
+    XR_TYPE_SPATIAL_DISCOVERY_PERSISTENCE_UUID_FILTER_EXT = 1000763003,
+    XR_TYPE_SPATIAL_COMPONENT_PERSISTENCE_LIST_EXT = 1000763004,
+    XR_TYPE_SPATIAL_ENTITY_PERSIST_INFO_EXT = 1000781000,
+    XR_TYPE_PERSIST_SPATIAL_ENTITY_COMPLETION_EXT = 1000781001,
+    XR_TYPE_SPATIAL_ENTITY_UNPERSIST_INFO_EXT = 1000781002,
+    XR_TYPE_UNPERSIST_SPATIAL_ENTITY_COMPLETION_EXT = 1000781003,
+    XR_TYPE_LOADER_INIT_INFO_PROPERTIES_EXT = 1000838000,
+    XR_TYPE_GRAPHICS_BINDING_VULKAN2_KHR = XR_TYPE_GRAPHICS_BINDING_VULKAN_KHR,
+    XR_TYPE_SWAPCHAIN_IMAGE_VULKAN2_KHR = XR_TYPE_SWAPCHAIN_IMAGE_VULKAN_KHR,
+    XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN2_KHR = XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN_KHR,
+    XR_TYPE_DEVICE_PCM_SAMPLE_RATE_GET_INFO_FB = XR_TYPE_DEVICE_PCM_SAMPLE_RATE_STATE_FB,
+    XR_TYPE_SPACES_LOCATE_INFO_KHR = XR_TYPE_SPACES_LOCATE_INFO,
+    XR_TYPE_SPACE_LOCATIONS_KHR = XR_TYPE_SPACE_LOCATIONS,
+    XR_TYPE_SPACE_VELOCITIES_KHR = XR_TYPE_SPACE_VELOCITIES,
+    XR_STRUCTURE_TYPE_MAX_ENUM = 0x7fffffff,
+} XrStructureType;
+
+typedef enum XrSwapchainCreateFlagBits
+{
+    XR_SWAPCHAIN_CREATE_PROTECTED_CONTENT_BIT = 0x00000001,
+    XR_SWAPCHAIN_CREATE_STATIC_IMAGE_BIT = 0x00000002,
+    XR_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
+} XrSwapchainCreateFlagBits;
+
+typedef enum XrSwapchainUsageFlagBits
+{
+    XR_SWAPCHAIN_USAGE_COLOR_ATTACHMENT_BIT = 0x00000001,
+    XR_SWAPCHAIN_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0x00000002,
+    XR_SWAPCHAIN_USAGE_UNORDERED_ACCESS_BIT = 0x00000004,
+    XR_SWAPCHAIN_USAGE_TRANSFER_SRC_BIT = 0x00000008,
+    XR_SWAPCHAIN_USAGE_TRANSFER_DST_BIT = 0x00000010,
+    XR_SWAPCHAIN_USAGE_SAMPLED_BIT = 0x00000020,
+    XR_SWAPCHAIN_USAGE_MUTABLE_FORMAT_BIT = 0x00000040,
+    XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_MND = 0x00000080,
+    XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_KHR = XR_SWAPCHAIN_USAGE_INPUT_ATTACHMENT_BIT_MND,
+    XR_SWAPCHAIN_USAGE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
+} XrSwapchainUsageFlagBits;
+
+typedef enum XrTrackableMarkerDictionaryANDROID
+{
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_4X4_50_ANDROID = 0,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_4X4_100_ANDROID = 1,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_4X4_250_ANDROID = 2,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_4X4_1000_ANDROID = 3,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_5X5_50_ANDROID = 4,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_5X5_100_ANDROID = 5,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_5X5_250_ANDROID = 6,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_5X5_1000_ANDROID = 7,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_6X6_50_ANDROID = 8,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_6X6_100_ANDROID = 9,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_6X6_250_ANDROID = 10,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_6X6_1000_ANDROID = 11,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_7X7_50_ANDROID = 12,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_7X7_100_ANDROID = 13,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_7X7_250_ANDROID = 14,
+    XR_TRACKABLE_MARKER_DICTIONARY_ARUCO_7X7_1000_ANDROID = 15,
+    XR_TRACKABLE_MARKER_DICTIONARY_APRILTAG_16H5_ANDROID = 16,
+    XR_TRACKABLE_MARKER_DICTIONARY_APRILTAG_25H9_ANDROID = 17,
+    XR_TRACKABLE_MARKER_DICTIONARY_APRILTAG_36H10_ANDROID = 18,
+    XR_TRACKABLE_MARKER_DICTIONARY_APRILTAG_36H11_ANDROID = 19,
+    XR_TRACKABLE_MARKER_DICTIONARY_ANDROID_MAX_ENUM = 0x7fffffff,
+} XrTrackableMarkerDictionaryANDROID;
+
+typedef enum XrTrackableMarkerTrackingModeANDROID
+{
+    XR_TRACKABLE_MARKER_TRACKING_MODE_DYNAMIC_ANDROID = 0,
+    XR_TRACKABLE_MARKER_TRACKING_MODE_STATIC_ANDROID = 1,
+    XR_TRACKABLE_MARKER_TRACKING_MODE_ANDROID_MAX_ENUM = 0x7fffffff,
+} XrTrackableMarkerTrackingModeANDROID;
+
+typedef enum XrTrackableTypeANDROID
+{
+    XR_TRACKABLE_TYPE_NOT_VALID_ANDROID = 0,
+    XR_TRACKABLE_TYPE_PLANE_ANDROID = 1,
+    XR_TRACKABLE_TYPE_DEPTH_ANDROID = 1000463000,
+    XR_TRACKABLE_TYPE_OBJECT_ANDROID = 1000466000,
+    XR_TRACKABLE_TYPE_MARKER_ANDROID = 1000707000,
+    XR_TRACKABLE_TYPE_ANDROID_MAX_ENUM = 0x7fffffff,
+} XrTrackableTypeANDROID;
+
+typedef enum XrTrackingOptimizationSettingsDomainQCOM
+{
+    XR_TRACKING_OPTIMIZATION_SETTINGS_DOMAIN_ALL_QCOM = 1,
+    XR_TRACKING_OPTIMIZATION_SETTINGS_DOMAIN_QCOM_MAX_ENUM = 0x7fffffff,
+} XrTrackingOptimizationSettingsDomainQCOM;
+
+typedef enum XrTrackingOptimizationSettingsHintQCOM
+{
+    XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_NONE_QCOM = 0,
+    XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_LONG_RANGE_PRIORIZATION_QCOM = 1,
+    XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_CLOSE_RANGE_PRIORIZATION_QCOM = 2,
+    XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_LOW_POWER_PRIORIZATION_QCOM = 3,
+    XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_HIGH_POWER_PRIORIZATION_QCOM = 4,
+    XR_TRACKING_OPTIMIZATION_SETTINGS_HINT_QCOM_MAX_ENUM = 0x7fffffff,
+} XrTrackingOptimizationSettingsHintQCOM;
+
+typedef enum XrTrackingStateANDROID
+{
+    XR_TRACKING_STATE_PAUSED_ANDROID = 0,
+    XR_TRACKING_STATE_STOPPED_ANDROID = 1,
+    XR_TRACKING_STATE_TRACKING_ANDROID = 2,
+    XR_TRACKING_STATE_ANDROID_MAX_ENUM = 0x7fffffff,
+} XrTrackingStateANDROID;
+
+typedef enum XrTriangleMeshFlagBitsFB
+{
+    XR_TRIANGLE_MESH_MUTABLE_BIT_FB = 0x00000001,
+    XR_TRIANGLE_MESH_FLAG_BITS_FB_MAX_ENUM = 0x7fffffff,
+} XrTriangleMeshFlagBitsFB;
+
+typedef enum XrViewConfigurationType
+{
+    XR_VIEW_CONFIGURATION_TYPE_PRIMARY_MONO = 1,
+    XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO = 2,
+    XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO_WITH_FOVEATED_INSET = 1000037000,
+    XR_VIEW_CONFIGURATION_TYPE_SECONDARY_MONO_FIRST_PERSON_OBSERVER_MSFT = 1000054000,
+    XR_VIEW_CONFIGURATION_TYPE_PRIMARY_QUAD_VARJO = XR_VIEW_CONFIGURATION_TYPE_PRIMARY_STEREO_WITH_FOVEATED_INSET,
+    XR_VIEW_CONFIGURATION_TYPE_MAX_ENUM = 0x7fffffff,
+} XrViewConfigurationType;
+
+typedef enum XrViewStateFlagBits
+{
+    XR_VIEW_STATE_ORIENTATION_VALID_BIT = 0x00000001,
+    XR_VIEW_STATE_POSITION_VALID_BIT = 0x00000002,
+    XR_VIEW_STATE_ORIENTATION_TRACKED_BIT = 0x00000004,
+    XR_VIEW_STATE_POSITION_TRACKED_BIT = 0x00000008,
+    XR_VIEW_STATE_FLAG_BITS_MAX_ENUM = 0x7fffffff,
+} XrViewStateFlagBits;
+
+typedef enum XrVirtualKeyboardInputSourceMETA
+{
+    XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_RAY_LEFT_META = 1,
+    XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_RAY_RIGHT_META = 2,
+    XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_RAY_LEFT_META = 3,
+    XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_RAY_RIGHT_META = 4,
+    XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_DIRECT_LEFT_META = 5,
+    XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_CONTROLLER_DIRECT_RIGHT_META = 6,
+    XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_DIRECT_INDEX_TIP_LEFT_META = 7,
+    XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_HAND_DIRECT_INDEX_TIP_RIGHT_META = 8,
+    XR_VIRTUAL_KEYBOARD_INPUT_SOURCE_META_MAX_ENUM = 0x7fffffff,
+} XrVirtualKeyboardInputSourceMETA;
+
+typedef enum XrVirtualKeyboardInputStateFlagBitsMETA
+{
+    XR_VIRTUAL_KEYBOARD_INPUT_STATE_PRESSED_BIT_META = 0x00000001,
+    XR_VIRTUAL_KEYBOARD_INPUT_STATE_FLAG_BITS_META_MAX_ENUM = 0x7fffffff,
+} XrVirtualKeyboardInputStateFlagBitsMETA;
+
+typedef enum XrVirtualKeyboardLocationTypeMETA
+{
+    XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_CUSTOM_META = 0,
+    XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_FAR_META = 1,
+    XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_DIRECT_META = 2,
+    XR_VIRTUAL_KEYBOARD_LOCATION_TYPE_META_MAX_ENUM = 0x7fffffff,
+} XrVirtualKeyboardLocationTypeMETA;
+
+typedef enum XrVisibilityMaskTypeKHR
+{
+    XR_VISIBILITY_MASK_TYPE_HIDDEN_TRIANGLE_MESH_KHR = 1,
+    XR_VISIBILITY_MASK_TYPE_VISIBLE_TRIANGLE_MESH_KHR = 2,
+    XR_VISIBILITY_MASK_TYPE_LINE_LOOP_KHR = 3,
+    XR_VISIBILITY_MASK_TYPE_KHR_MAX_ENUM = 0x7fffffff,
+} XrVisibilityMaskTypeKHR;
+
+typedef enum XrVulkanDeviceCreateFlagBitsKHR
+{
+    XR_VULKAN_DEVICE_CREATE_FLAG_BITS_KHR_MAX_ENUM = 0x7fffffff,
+} XrVulkanDeviceCreateFlagBitsKHR;
+
+typedef enum XrVulkanInstanceCreateFlagBitsKHR
+{
+    XR_VULKAN_INSTANCE_CREATE_FLAG_BITS_KHR_MAX_ENUM = 0x7fffffff,
+} XrVulkanInstanceCreateFlagBitsKHR;
+
+typedef enum XrWindingOrderFB
+{
+    XR_WINDING_ORDER_UNKNOWN_FB = 0,
+    XR_WINDING_ORDER_CW_FB = 1,
+    XR_WINDING_ORDER_CCW_FB = 2,
+    XR_WINDING_ORDER_FB_MAX_ENUM = 0x7fffffff,
+} XrWindingOrderFB;
+
+typedef enum XrWorldMeshBlockResultML
+{
+    XR_WORLD_MESH_BLOCK_RESULT_SUCCESS_ML = 0,
+    XR_WORLD_MESH_BLOCK_RESULT_FAILED_ML = 1,
+    XR_WORLD_MESH_BLOCK_RESULT_PENDING_ML = 2,
+    XR_WORLD_MESH_BLOCK_RESULT_PARTIAL_UPDATE_ML = 3,
+    XR_WORLD_MESH_BLOCK_RESULT_ML_MAX_ENUM = 0x7fffffff,
+} XrWorldMeshBlockResultML;
+
+typedef enum XrWorldMeshBlockStatusML
+{
+    XR_WORLD_MESH_BLOCK_STATUS_NEW_ML = 0,
+    XR_WORLD_MESH_BLOCK_STATUS_UPDATED_ML = 1,
+    XR_WORLD_MESH_BLOCK_STATUS_DELETED_ML = 2,
+    XR_WORLD_MESH_BLOCK_STATUS_UNCHANGED_ML = 3,
+    XR_WORLD_MESH_BLOCK_STATUS_ML_MAX_ENUM = 0x7fffffff,
+} XrWorldMeshBlockStatusML;
+
+typedef enum XrWorldMeshDetectorFlagBitsML
+{
+    XR_WORLD_MESH_DETECTOR_POINT_CLOUD_BIT_ML = 0x00000001,
+    XR_WORLD_MESH_DETECTOR_COMPUTE_NORMALS_BIT_ML = 0x00000002,
+    XR_WORLD_MESH_DETECTOR_COMPUTE_CONFIDENCE_BIT_ML = 0x00000004,
+    XR_WORLD_MESH_DETECTOR_PLANARIZE_BIT_ML = 0x00000008,
+    XR_WORLD_MESH_DETECTOR_REMOVE_MESH_SKIRT_BIT_ML = 0x00000010,
+    XR_WORLD_MESH_DETECTOR_INDEX_ORDER_CW_BIT_ML = 0x00000020,
+    XR_WORLD_MESH_DETECTOR_FLAG_BITS_ML_MAX_ENUM = 0x7fffffff,
+} XrWorldMeshDetectorFlagBitsML;
+
+typedef enum XrWorldMeshDetectorLodML
+{
+    XR_WORLD_MESH_DETECTOR_LOD_MINIMUM_ML = 0,
+    XR_WORLD_MESH_DETECTOR_LOD_MEDIUM_ML = 1,
+    XR_WORLD_MESH_DETECTOR_LOD_MAXIMUM_ML = 2,
+    XR_WORLD_MESH_DETECTOR_LOD_ML_MAX_ENUM = 0x7fffffff,
+} XrWorldMeshDetectorLodML;
+
+typedef void (XRAPI_PTR * PFN_xrVoidFunction)(
+void);
+typedef XrResult (XRAPI_PTR * PFN_xrGetInstanceProcAddr)(
+XrInstance instance, const char* name, PFN_xrVoidFunction* function);
+typedef struct XrInstanceCreateInfo XrInstanceCreateInfo;
+
+typedef struct XrApiLayerCreateInfo XrApiLayerCreateInfo;
+typedef XrResult (XRAPI_PTR * PFN_xrCreateApiLayerInstance)(
+
+            const XrInstanceCreateInfo* info,
+            const XrApiLayerCreateInfo* apiLayerInfo,
+            XrInstance* instance);
+
+typedef struct XrActionCreateInfo
+{
+    XrStructureType type;
+    const void *next;
+    char actionName[XR_MAX_ACTION_NAME_SIZE];
+    XrActionType actionType;
+    uint32_t countSubactionPaths;
+    const XrPath *subactionPaths;
+    char localizedActionName[XR_MAX_LOCALIZED_ACTION_NAME_SIZE];
+} XrActionCreateInfo;
+
+typedef struct XrActionSetCreateInfo
+{
+    XrStructureType type;
+    const void *next;
+    char actionSetName[XR_MAX_ACTION_SET_NAME_SIZE];
+    char localizedActionSetName[XR_MAX_LOCALIZED_ACTION_SET_NAME_SIZE];
+    uint32_t priority;
+} XrActionSetCreateInfo;
+
+typedef struct XrActionStateBoolean
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 currentState;
+    XrBool32 changedSinceLastSync;
+    XrTime lastChangeTime;
+    XrBool32 isActive;
+} XrActionStateBoolean;
+
+typedef struct XrActionStateFloat
+{
+    XrStructureType type;
+    void *next;
+    float currentState;
+    XrBool32 changedSinceLastSync;
+    XrTime lastChangeTime;
+    XrBool32 isActive;
+} XrActionStateFloat;
+
+typedef struct XrActionStateGetInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrAction action;
+    XrPath subactionPath;
+} XrActionStateGetInfo;
+
+typedef struct XrActionStatePose
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 isActive;
+} XrActionStatePose;
+
+typedef struct XrActionSuggestedBinding
+{
+    XrAction action;
+    XrPath binding;
+} XrActionSuggestedBinding;
+
+typedef struct XrActiveActionSet
+{
+    XrActionSet actionSet;
+    XrPath subactionPath;
+} XrActiveActionSet;
+
+typedef struct XrActiveActionSetPriorityEXT
+{
+    XrActionSet actionSet;
+    uint32_t priorityOverride;
+} XrActiveActionSetPriorityEXT;
+
+typedef struct XrApiLayerNextInfo
+{
+    XrLoaderInterfaceStructs structType;
+    uint32_t structVersion;
+    size_t structSize;
+    char layerName[XR_MAX_API_LAYER_NAME_SIZE];
+    PFN_xrGetInstanceProcAddr nextGetInstanceProcAddr;
+    PFN_xrCreateApiLayerInstance nextCreateApiLayerInstance;
+    struct XrApiLayerNextInfo *next;
+} XrApiLayerNextInfo;
+
+typedef struct XrApiLayerProperties
+{
+    XrStructureType type;
+    void *next;
+    char layerName[XR_MAX_API_LAYER_NAME_SIZE];
+    XrVersion specVersion;
+    uint32_t layerVersion;
+    char description[XR_MAX_API_LAYER_DESCRIPTION_SIZE];
+} XrApiLayerProperties;
+
+typedef struct XrApplicationInfo
+{
+    char applicationName[XR_MAX_APPLICATION_NAME_SIZE];
+    uint32_t applicationVersion;
+    char engineName[XR_MAX_ENGINE_NAME_SIZE];
+    uint32_t engineVersion;
+    XrVersion apiVersion;
+} XrApplicationInfo;
+
+typedef struct XrBaseInStructure
+{
+    XrStructureType type;
+    const struct XrBaseInStructure *next;
+} XrBaseInStructure;
+
+typedef struct XrBaseOutStructure
+{
+    XrStructureType type;
+    struct XrBaseOutStructure *next;
+} XrBaseOutStructure;
+
+typedef struct XrBindingModificationBaseHeaderKHR
+{
+    XrStructureType type;
+    const void *next;
+} XrBindingModificationBaseHeaderKHR;
+
+typedef struct XrBindingModificationsKHR
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t bindingModificationCount;
+    const XrBindingModificationBaseHeaderKHR * const*bindingModifications;
+} XrBindingModificationsKHR;
+
+typedef struct XrBodyJointsLocateInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+} XrBodyJointsLocateInfoBD;
+
+typedef struct XrBodyJointsLocateInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+} XrBodyJointsLocateInfoFB;
+
+typedef struct XrBodyJointsLocateInfoHTC
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+} XrBodyJointsLocateInfoHTC;
+
+typedef struct XrBodyTrackerCreateInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrBodyJointSetBD jointSet;
+} XrBodyTrackerCreateInfoBD;
+
+typedef struct XrBodyTrackerCreateInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrBodyJointSetFB bodyJointSet;
+} XrBodyTrackerCreateInfoFB;
+
+typedef struct XrBodyTrackerCreateInfoHTC
+{
+    XrStructureType type;
+    const void *next;
+    XrBodyJointSetHTC bodyJointSet;
+} XrBodyTrackerCreateInfoHTC;
+
+typedef struct XrBodyTrackingCalibrationInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    float bodyHeight;
+} XrBodyTrackingCalibrationInfoMETA;
+
+typedef struct XrBodyTrackingCalibrationStatusMETA
+{
+    XrStructureType type;
+    void *next;
+    XrBodyTrackingCalibrationStateMETA status;
+} XrBodyTrackingCalibrationStatusMETA;
+
+typedef struct XrBoundSourcesForActionEnumerateInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrAction action;
+} XrBoundSourcesForActionEnumerateInfo;
+
+typedef struct XrColocationAdvertisementStartInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t bufferSize;
+    uint8_t *buffer;
+} XrColocationAdvertisementStartInfoMETA;
+
+typedef struct XrColocationAdvertisementStopInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+} XrColocationAdvertisementStopInfoMETA;
+
+typedef struct XrColocationDiscoveryStartInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+} XrColocationDiscoveryStartInfoMETA;
+
+typedef struct XrColocationDiscoveryStopInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+} XrColocationDiscoveryStopInfoMETA;
+
+typedef struct XrColor3f
+{
+    float r;
+    float g;
+    float b;
+} XrColor3f;
+typedef XrColor3f XrColor3fKHR;
+
+typedef struct XrColor4f
+{
+    float r;
+    float g;
+    float b;
+    float a;
+} XrColor4f;
+
+typedef struct XrCompositionLayerAlphaBlendFB
+{
+    XrStructureType type;
+    void *next;
+    XrBlendFactorFB srcFactorColor;
+    XrBlendFactorFB dstFactorColor;
+    XrBlendFactorFB srcFactorAlpha;
+    XrBlendFactorFB dstFactorAlpha;
+} XrCompositionLayerAlphaBlendFB;
+
+typedef struct XrCompositionLayerBaseHeader
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerFlags WINE_XR_ALIGN(8) layerFlags;
+    XrSpace space;
+} XrCompositionLayerBaseHeader;
+
+typedef struct XrCompositionLayerColorScaleBiasKHR
+{
+    XrStructureType type;
+    const void *next;
+    XrColor4f colorScale;
+    XrColor4f colorBias;
+} XrCompositionLayerColorScaleBiasKHR;
+
+typedef struct XrCompositionLayerDepthTestFB
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 depthMask;
+    XrCompareOpFB compareOp;
+} XrCompositionLayerDepthTestFB;
+
+typedef struct XrCompositionLayerDepthTestVARJO
+{
+    XrStructureType type;
+    const void *next;
+    float depthTestRangeNearZ;
+    float depthTestRangeFarZ;
+} XrCompositionLayerDepthTestVARJO;
+
+typedef struct XrCompositionLayerImageLayoutFB
+{
+    XrStructureType type;
+    void *next;
+    XrCompositionLayerImageLayoutFlagsFB WINE_XR_ALIGN(8) flags;
+} XrCompositionLayerImageLayoutFB;
+
+typedef struct XrCompositionLayerPassthroughFB
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerFlags WINE_XR_ALIGN(8) flags;
+    XrSpace space;
+    XrPassthroughLayerFB layerHandle;
+} XrCompositionLayerPassthroughFB;
+
+typedef struct XrCompositionLayerReprojectionInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrReprojectionModeMSFT reprojectionMode;
+} XrCompositionLayerReprojectionInfoMSFT;
+
+typedef struct XrCompositionLayerSecureContentFB
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerSecureContentFlagsFB WINE_XR_ALIGN(8) flags;
+} XrCompositionLayerSecureContentFB;
+
+typedef struct XrCompositionLayerSettingsFB
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerSettingsFlagsFB WINE_XR_ALIGN(8) layerFlags;
+} XrCompositionLayerSettingsFB;
+
+typedef struct XrControllerModelKeyStateMSFT
+{
+    XrStructureType type;
+    void *next;
+    XrControllerModelKeyMSFT modelKey;
+} XrControllerModelKeyStateMSFT;
+
+typedef struct XrControllerModelNodePropertiesMSFT
+{
+    XrStructureType type;
+    void *next;
+    char parentNodeName[XR_MAX_CONTROLLER_MODEL_NODE_NAME_SIZE_MSFT];
+    char nodeName[XR_MAX_CONTROLLER_MODEL_NODE_NAME_SIZE_MSFT];
+} XrControllerModelNodePropertiesMSFT;
+
+typedef struct XrControllerModelPropertiesMSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t nodeCapacityInput;
+    uint32_t nodeCountOutput;
+    XrControllerModelNodePropertiesMSFT *nodeProperties;
+} XrControllerModelPropertiesMSFT;
+
+typedef struct XrCreateSpatialAnchorsCompletionML
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    uint32_t spaceCount;
+    XrSpace *spaces;
+} XrCreateSpatialAnchorsCompletionML;
+
+typedef struct XrCreateSpatialContextCompletionEXT
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    XrSpatialContextEXT spatialContext;
+} XrCreateSpatialContextCompletionEXT;
+
+typedef struct XrCreateSpatialDiscoverySnapshotCompletionEXT
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    XrSpatialSnapshotEXT snapshot;
+} XrCreateSpatialDiscoverySnapshotCompletionEXT;
+
+typedef struct XrCreateSpatialDiscoverySnapshotCompletionInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+    XrFutureEXT future;
+} XrCreateSpatialDiscoverySnapshotCompletionInfoEXT;
+
+typedef struct XrCreateSpatialPersistenceContextCompletionEXT
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    XrSpatialPersistenceContextResultEXT createResult;
+    XrSpatialPersistenceContextEXT persistenceContext;
+} XrCreateSpatialPersistenceContextCompletionEXT;
+
+typedef struct XrDeserializeSceneFragmentMSFT
+{
+    uint32_t bufferSize;
+    const uint8_t *buffer;
+} XrDeserializeSceneFragmentMSFT;
+
+typedef struct XrDeviceAnchorPersistenceCreateInfoANDROID
+{
+    XrStructureType type;
+    const void *next;
+} XrDeviceAnchorPersistenceCreateInfoANDROID;
+
+
+typedef struct XrDevicePcmSampleRateStateFB
+{
+    XrStructureType type;
+    void *next;
+    float sampleRate;
+} XrDevicePcmSampleRateStateFB;
+typedef XrDevicePcmSampleRateStateFB XrDevicePcmSampleRateGetInfoFB;
+
+typedef struct XrDigitalLensControlALMALENCE
+{
+    XrStructureType type;
+    const void *next;
+    XrDigitalLensControlFlagsALMALENCE WINE_XR_ALIGN(8) flags;
+} XrDigitalLensControlALMALENCE;
+
+typedef struct XrEnvironmentDepthHandRemovalSetInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 enabled;
+} XrEnvironmentDepthHandRemovalSetInfoMETA;
+
+typedef struct XrEnvironmentDepthImageAcquireInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace space;
+    XrTime displayTime;
+} XrEnvironmentDepthImageAcquireInfoMETA;
+
+typedef struct XrEnvironmentDepthProviderCreateInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrEnvironmentDepthProviderCreateFlagsMETA WINE_XR_ALIGN(8) createFlags;
+} XrEnvironmentDepthProviderCreateInfoMETA;
+
+typedef struct XrEnvironmentDepthSwapchainCreateInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrEnvironmentDepthSwapchainCreateFlagsMETA WINE_XR_ALIGN(8) createFlags;
+} XrEnvironmentDepthSwapchainCreateInfoMETA;
+
+typedef struct XrEnvironmentDepthSwapchainStateMETA
+{
+    XrStructureType type;
+    void *next;
+    uint32_t width;
+    uint32_t height;
+} XrEnvironmentDepthSwapchainStateMETA;
+
+typedef struct XrEventDataBaseHeader
+{
+    XrStructureType type;
+    const void *next;
+} XrEventDataBaseHeader;
+
+typedef struct XrEventDataBuffer
+{
+    XrStructureType type;
+    const void *next;
+    uint8_t varying[4000];
+} XrEventDataBuffer;
+
+typedef struct XrEventDataColocationAdvertisementCompleteMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB advertisementRequestId;
+    XrResult result;
+} XrEventDataColocationAdvertisementCompleteMETA;
+
+typedef struct XrEventDataColocationDiscoveryCompleteMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB discoveryRequestId;
+    XrResult result;
+} XrEventDataColocationDiscoveryCompleteMETA;
+
+typedef struct XrEventDataDisplayRefreshRateChangedFB
+{
+    XrStructureType type;
+    const void *next;
+    float fromDisplayRefreshRate;
+    float toDisplayRefreshRate;
+} XrEventDataDisplayRefreshRateChangedFB;
+
+typedef struct XrEventDataEventsLost
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t lostEventCount;
+} XrEventDataEventsLost;
+
+typedef struct XrEventDataEyeCalibrationChangedML
+{
+    XrStructureType type;
+    const void *next;
+    XrEyeCalibrationStatusML status;
+} XrEventDataEyeCalibrationChangedML;
+
+typedef struct XrEventDataHeadsetFitChangedML
+{
+    XrStructureType type;
+    const void *next;
+    XrHeadsetFitStatusML status;
+    XrTime time;
+} XrEventDataHeadsetFitChangedML;
+
+typedef struct XrEventDataInstanceLossPending
+{
+    XrStructureType type;
+    const void *next;
+    XrTime lossTime;
+} XrEventDataInstanceLossPending;
+
+typedef struct XrEventDataInteractionProfileChanged
+{
+    XrStructureType type;
+    const void *next;
+    XrSession session;
+} XrEventDataInteractionProfileChanged;
+
+typedef struct XrEventDataInteractionRenderModelsChangedEXT
+{
+    XrStructureType type;
+    const void *next;
+} XrEventDataInteractionRenderModelsChangedEXT;
+
+typedef struct XrEventDataMainSessionVisibilityChangedEXTX
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 visible;
+    XrOverlayMainSessionFlagsEXTX WINE_XR_ALIGN(8) flags;
+} XrEventDataMainSessionVisibilityChangedEXTX;
+
+typedef struct XrEventDataMarkerTrackingUpdateVARJO
+{
+    XrStructureType type;
+    const void *next;
+    uint64_t WINE_XR_ALIGN(8) markerId;
+    XrBool32 isActive;
+    XrBool32 isPredicted;
+    XrTime time;
+} XrEventDataMarkerTrackingUpdateVARJO;
+
+typedef struct XrEventDataPassthroughLayerResumedMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughLayerFB layer;
+} XrEventDataPassthroughLayerResumedMETA;
+
+typedef struct XrEventDataPassthroughStateChangedFB
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughStateChangedFlagsFB WINE_XR_ALIGN(8) flags;
+} XrEventDataPassthroughStateChangedFB;
+
+typedef struct XrEventDataPerfSettingsEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrPerfSettingsDomainEXT domain;
+    XrPerfSettingsSubDomainEXT subDomain;
+    XrPerfSettingsNotificationLevelEXT fromLevel;
+    XrPerfSettingsNotificationLevelEXT toLevel;
+} XrEventDataPerfSettingsEXT;
+
+typedef struct XrEventDataSceneCaptureCompleteFB
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+} XrEventDataSceneCaptureCompleteFB;
+
+typedef struct XrEventDataSenseDataProviderStateChangedBD
+{
+    XrStructureType type;
+    const void *next;
+    XrSenseDataProviderBD provider;
+    XrSenseDataProviderStateBD newState;
+} XrEventDataSenseDataProviderStateChangedBD;
+
+typedef struct XrEventDataSenseDataUpdatedBD
+{
+    XrStructureType type;
+    const void *next;
+    XrSenseDataProviderBD provider;
+} XrEventDataSenseDataUpdatedBD;
+
+typedef struct XrEventDataSessionStateChanged
+{
+    XrStructureType type;
+    const void *next;
+    XrSession session;
+    XrSessionState state;
+    XrTime time;
+} XrEventDataSessionStateChanged;
+
+typedef struct XrEventDataShareSpacesCompleteMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+} XrEventDataShareSpacesCompleteMETA;
+
+typedef struct XrEventDataSpaceDiscoveryCompleteMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+} XrEventDataSpaceDiscoveryCompleteMETA;
+
+typedef struct XrEventDataSpaceDiscoveryResultsAvailableMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+} XrEventDataSpaceDiscoveryResultsAvailableMETA;
+
+typedef struct XrEventDataSpaceListSaveCompleteFB
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+} XrEventDataSpaceListSaveCompleteFB;
+
+typedef struct XrEventDataSpaceQueryCompleteFB
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+} XrEventDataSpaceQueryCompleteFB;
+
+typedef struct XrEventDataSpaceQueryResultsAvailableFB
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+} XrEventDataSpaceQueryResultsAvailableFB;
+
+typedef struct XrEventDataSpaceShareCompleteFB
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+} XrEventDataSpaceShareCompleteFB;
+
+typedef struct XrEventDataSpacesEraseResultMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+} XrEventDataSpacesEraseResultMETA;
+
+typedef struct XrEventDataSpacesSaveResultMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+} XrEventDataSpacesSaveResultMETA;
+
+typedef struct XrEventDataSpatialDiscoveryRecommendedEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialContextEXT spatialContext;
+} XrEventDataSpatialDiscoveryRecommendedEXT;
+
+typedef struct XrEventDataStartColocationDiscoveryCompleteMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB discoveryRequestId;
+    XrResult result;
+} XrEventDataStartColocationDiscoveryCompleteMETA;
+
+typedef struct XrEventDataStopColocationAdvertisementCompleteMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+} XrEventDataStopColocationAdvertisementCompleteMETA;
+
+typedef struct XrEventDataStopColocationDiscoveryCompleteMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+} XrEventDataStopColocationDiscoveryCompleteMETA;
+
+typedef struct XrEventDataUserPresenceChangedEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSession session;
+    XrBool32 isUserPresent;
+} XrEventDataUserPresenceChangedEXT;
+
+typedef struct XrEventDataVirtualKeyboardBackspaceMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrVirtualKeyboardMETA keyboard;
+} XrEventDataVirtualKeyboardBackspaceMETA;
+
+typedef struct XrEventDataVirtualKeyboardCommitTextMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrVirtualKeyboardMETA keyboard;
+    char text[XR_MAX_VIRTUAL_KEYBOARD_COMMIT_TEXT_SIZE_META];
+} XrEventDataVirtualKeyboardCommitTextMETA;
+
+typedef struct XrEventDataVirtualKeyboardEnterMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrVirtualKeyboardMETA keyboard;
+} XrEventDataVirtualKeyboardEnterMETA;
+
+typedef struct XrEventDataVirtualKeyboardHiddenMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrVirtualKeyboardMETA keyboard;
+} XrEventDataVirtualKeyboardHiddenMETA;
+
+typedef struct XrEventDataVirtualKeyboardShownMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrVirtualKeyboardMETA keyboard;
+} XrEventDataVirtualKeyboardShownMETA;
+
+typedef struct XrEventDataVisibilityMaskChangedKHR
+{
+    XrStructureType type;
+    const void *next;
+    XrSession session;
+    XrViewConfigurationType viewConfigurationType;
+    uint32_t viewIndex;
+} XrEventDataVisibilityMaskChangedKHR;
+
+typedef struct XrExtensionProperties
+{
+    XrStructureType type;
+    void *next;
+    char extensionName[XR_MAX_EXTENSION_NAME_SIZE];
+    uint32_t extensionVersion;
+} XrExtensionProperties;
+
+typedef struct XrExtent2Df
+{
+    float width;
+    float height;
+} XrExtent2Df;
+
+typedef struct XrExtent2Di
+{
+    int32_t width;
+    int32_t height;
+} XrExtent2Di;
+
+typedef struct XrExtent3Df
+{
+    float width;
+    float height;
+    float depth;
+} XrExtent3Df;
+typedef XrExtent3Df XrExtent3DfEXT;
+typedef XrExtent3Df XrExtent3DfFB;
+typedef XrExtent3Df XrExtent3DfKHR;
+
+
+
+typedef struct XrEyeGazeSampleTimeEXT
+{
+    XrStructureType type;
+    void *next;
+    XrTime time;
+} XrEyeGazeSampleTimeEXT;
+
+typedef struct XrEyeGazesInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+} XrEyeGazesInfoFB;
+
+typedef struct XrEyeTrackerCreateInfoFB
+{
+    XrStructureType type;
+    const void *next;
+} XrEyeTrackerCreateInfoFB;
+
+typedef struct XrFaceExpressionInfo2FB
+{
+    XrStructureType type;
+    const void *next;
+    XrTime time;
+} XrFaceExpressionInfo2FB;
+
+typedef struct XrFaceExpressionInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrTime time;
+} XrFaceExpressionInfoFB;
+
+typedef struct XrFaceExpressionStatusFB
+{
+    XrBool32 isValid;
+    XrBool32 isEyeFollowingBlendshapesValid;
+} XrFaceExpressionStatusFB;
+
+typedef struct XrFaceExpressionWeights2FB
+{
+    XrStructureType type;
+    void *next;
+    uint32_t weightCount;
+    float *weights;
+    uint32_t confidenceCount;
+    float *confidences;
+    XrBool32 isValid;
+    XrBool32 isEyeFollowingBlendshapesValid;
+    XrFaceTrackingDataSource2FB dataSource;
+    XrTime time;
+} XrFaceExpressionWeights2FB;
+
+typedef struct XrFaceExpressionWeightsFB
+{
+    XrStructureType type;
+    void *next;
+    uint32_t weightCount;
+    float *weights;
+    uint32_t confidenceCount;
+    float *confidences;
+    XrFaceExpressionStatusFB status;
+    XrTime time;
+} XrFaceExpressionWeightsFB;
+
+typedef struct XrFaceTrackerCreateInfo2FB
+{
+    XrStructureType type;
+    const void *next;
+    XrFaceExpressionSet2FB faceExpressionSet;
+    uint32_t requestedDataSourceCount;
+    XrFaceTrackingDataSource2FB *requestedDataSources;
+} XrFaceTrackerCreateInfo2FB;
+
+typedef struct XrFaceTrackerCreateInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrFaceExpressionSetFB faceExpressionSet;
+} XrFaceTrackerCreateInfoFB;
+
+typedef struct XrFacialExpressionBlendShapeGetInfoML
+{
+    XrStructureType type;
+    const void *next;
+} XrFacialExpressionBlendShapeGetInfoML;
+
+typedef struct XrFacialExpressionBlendShapePropertiesML
+{
+    XrStructureType type;
+    void *next;
+    XrFacialBlendShapeML requestedFacialBlendShape;
+    float weight;
+    XrFacialExpressionBlendShapePropertiesFlagsML WINE_XR_ALIGN(8) flags;
+    XrTime time;
+} XrFacialExpressionBlendShapePropertiesML;
+
+typedef struct XrFacialExpressionClientCreateInfoML
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t requestedCount;
+    const XrFacialBlendShapeML *requestedFacialBlendShapes;
+} XrFacialExpressionClientCreateInfoML;
+
+typedef struct XrFacialExpressionsHTC
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 isActive;
+    XrTime sampleTime;
+    uint32_t expressionCount;
+    float *expressionWeightings;
+} XrFacialExpressionsHTC;
+
+typedef struct XrFacialTrackerCreateInfoHTC
+{
+    XrStructureType type;
+    const void *next;
+    XrFacialTrackingTypeHTC facialTrackingType;
+} XrFacialTrackerCreateInfoHTC;
+
+typedef struct XrForceFeedbackCurlApplyLocationMNDX
+{
+    XrForceFeedbackCurlLocationMNDX location;
+    float value;
+} XrForceFeedbackCurlApplyLocationMNDX;
+
+typedef struct XrForceFeedbackCurlApplyLocationsMNDX
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t locationCount;
+    XrForceFeedbackCurlApplyLocationMNDX *locations;
+} XrForceFeedbackCurlApplyLocationsMNDX;
+
+typedef struct XrFoveatedViewConfigurationViewVARJO
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 foveatedRenderingActive;
+} XrFoveatedViewConfigurationViewVARJO;
+
+typedef struct XrFoveationEyeTrackedProfileCreateInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrFoveationEyeTrackedProfileCreateFlagsMETA WINE_XR_ALIGN(8) flags;
+} XrFoveationEyeTrackedProfileCreateInfoMETA;
+
+typedef struct XrFoveationLevelProfileCreateInfoFB
+{
+    XrStructureType type;
+    void *next;
+    XrFoveationLevelFB level;
+    float verticalOffset;
+    XrFoveationDynamicFB dynamic;
+} XrFoveationLevelProfileCreateInfoFB;
+
+typedef struct XrFoveationProfileCreateInfoFB
+{
+    XrStructureType type;
+    void *next;
+} XrFoveationProfileCreateInfoFB;
+
+typedef struct XrFovf
+{
+    float angleLeft;
+    float angleRight;
+    float angleUp;
+    float angleDown;
+} XrFovf;
+
+typedef struct XrFrameBeginInfo
+{
+    XrStructureType type;
+    const void *next;
+} XrFrameBeginInfo;
+
+typedef struct XrFrameEndInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrTime displayTime;
+    XrEnvironmentBlendMode environmentBlendMode;
+    uint32_t layerCount;
+    const XrCompositionLayerBaseHeader * const*layers;
+} XrFrameEndInfo;
+
+typedef struct XrFrameEndInfoML
+{
+    XrStructureType type;
+    const void *next;
+    float focusDistance;
+    XrFrameEndInfoFlagsML WINE_XR_ALIGN(8) flags;
+} XrFrameEndInfoML;
+
+typedef struct XrFrameState
+{
+    XrStructureType type;
+    void *next;
+    XrTime predictedDisplayTime;
+    XrDuration predictedDisplayPeriod;
+    XrBool32 shouldRender;
+} XrFrameState;
+
+typedef struct XrFrameSynthesisConfigViewEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t recommendedMotionVectorImageRectWidth;
+    uint32_t recommendedMotionVectorImageRectHeight;
+} XrFrameSynthesisConfigViewEXT;
+
+typedef struct XrFrameWaitInfo
+{
+    XrStructureType type;
+    const void *next;
+} XrFrameWaitInfo;
+
+typedef struct XrFutureCancelInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrFutureEXT future;
+} XrFutureCancelInfoEXT;
+
+typedef struct XrFutureCompletionBaseHeaderEXT
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+} XrFutureCompletionBaseHeaderEXT;
+
+typedef struct XrFutureCompletionEXT
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+} XrFutureCompletionEXT;
+
+typedef struct XrFuturePollInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrFutureEXT future;
+} XrFuturePollInfoEXT;
+
+typedef struct XrFuturePollResultEXT
+{
+    XrStructureType type;
+    void *next;
+    XrFutureStateEXT state;
+} XrFuturePollResultEXT;
+
+typedef struct XrFuturePollResultProgressBD
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 isSupported;
+    uint32_t progressPercentage;
+} XrFuturePollResultProgressBD;
+
+typedef struct XrGlobalDimmerFrameEndInfoML
+{
+    XrStructureType type;
+    const void *next;
+    float dimmerValue;
+    XrGlobalDimmerFrameEndInfoFlagsML WINE_XR_ALIGN(8) flags;
+} XrGlobalDimmerFrameEndInfoML;
+
+typedef struct XrGraphicsBindingD3D11KHR
+{
+    XrStructureType type;
+    const void *next;
+    ID3D11Device *device;
+} XrGraphicsBindingD3D11KHR;
+
+typedef struct XrGraphicsBindingD3D12KHR
+{
+    XrStructureType type;
+    const void *next;
+    ID3D12Device *device;
+    ID3D12CommandQueue *queue;
+} XrGraphicsBindingD3D12KHR;
+
+typedef struct XrGraphicsBindingOpenGLWin32KHR
+{
+    XrStructureType type;
+    const void *next;
+    HDC hDC;
+    HGLRC hGLRC;
+} XrGraphicsBindingOpenGLWin32KHR;
+
+typedef struct XrGraphicsBindingVulkanKHR
+{
+    XrStructureType type;
+    const void *next;
+    VkInstance instance;
+    VkPhysicalDevice physicalDevice;
+    VkDevice device;
+    uint32_t queueFamilyIndex;
+    uint32_t queueIndex;
+} XrGraphicsBindingVulkanKHR;
+typedef XrGraphicsBindingVulkanKHR XrGraphicsBindingVulkan2KHR;
+
+typedef struct XrGraphicsRequirementsD3D11KHR
+{
+    XrStructureType type;
+    void *next;
+    LUID adapterLuid;
+    D3D_FEATURE_LEVEL minFeatureLevel;
+} XrGraphicsRequirementsD3D11KHR;
+
+typedef struct XrGraphicsRequirementsD3D12KHR
+{
+    XrStructureType type;
+    void *next;
+    LUID adapterLuid;
+    D3D_FEATURE_LEVEL minFeatureLevel;
+} XrGraphicsRequirementsD3D12KHR;
+
+typedef struct XrGraphicsRequirementsOpenGLKHR
+{
+    XrStructureType type;
+    void *next;
+    XrVersion minApiVersionSupported;
+    XrVersion maxApiVersionSupported;
+} XrGraphicsRequirementsOpenGLKHR;
+
+typedef struct XrGraphicsRequirementsVulkanKHR
+{
+    XrStructureType type;
+    void *next;
+    XrVersion minApiVersionSupported;
+    XrVersion maxApiVersionSupported;
+} XrGraphicsRequirementsVulkanKHR;
+typedef XrGraphicsRequirementsVulkanKHR XrGraphicsRequirementsVulkan2KHR;
+
+typedef struct XrHandJointsLocateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+} XrHandJointsLocateInfoEXT;
+
+typedef struct XrHandJointsMotionRangeInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrHandJointsMotionRangeEXT handJointsMotionRange;
+} XrHandJointsMotionRangeInfoEXT;
+
+typedef struct XrHandMeshIndexBufferMSFT
+{
+    uint32_t indexBufferKey;
+    uint32_t indexCapacityInput;
+    uint32_t indexCountOutput;
+    uint32_t *indices;
+} XrHandMeshIndexBufferMSFT;
+
+typedef struct XrHandMeshUpdateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrTime time;
+    XrHandPoseTypeMSFT handPoseType;
+} XrHandMeshUpdateInfoMSFT;
+
+typedef struct XrHandPoseTypeInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrHandPoseTypeMSFT handPoseType;
+} XrHandPoseTypeInfoMSFT;
+
+typedef struct XrHandTrackerCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrHandEXT hand;
+    XrHandJointSetEXT handJointSet;
+} XrHandTrackerCreateInfoEXT;
+
+typedef struct XrHandTrackingDataSourceInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t requestedDataSourceCount;
+    XrHandTrackingDataSourceEXT *requestedDataSources;
+} XrHandTrackingDataSourceInfoEXT;
+
+typedef struct XrHandTrackingDataSourceStateEXT
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 isActive;
+    XrHandTrackingDataSourceEXT dataSource;
+} XrHandTrackingDataSourceStateEXT;
+
+typedef struct XrHandTrackingScaleFB
+{
+    XrStructureType type;
+    void *next;
+    float sensorOutput;
+    float currentOutput;
+    XrBool32 overrideHandScale;
+    float overrideValueInput;
+} XrHandTrackingScaleFB;
+
+typedef struct XrHapticActionInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrAction action;
+    XrPath subactionPath;
+} XrHapticActionInfo;
+
+typedef struct XrHapticAmplitudeEnvelopeVibrationFB
+{
+    XrStructureType type;
+    const void *next;
+    XrDuration duration;
+    uint32_t amplitudeCount;
+    const float *amplitudes;
+} XrHapticAmplitudeEnvelopeVibrationFB;
+
+typedef struct XrHapticBaseHeader
+{
+    XrStructureType type;
+    const void *next;
+} XrHapticBaseHeader;
+
+typedef struct XrHapticPcmVibrationFB
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t bufferSize;
+    const float *buffer;
+    float sampleRate;
+    XrBool32 append;
+    uint32_t *samplesConsumed;
+} XrHapticPcmVibrationFB;
+
+typedef struct XrHapticVibration
+{
+    XrStructureType type;
+    const void *next;
+    XrDuration duration;
+    float frequency;
+    float amplitude;
+} XrHapticVibration;
+
+typedef struct XrHolographicWindowAttachmentMSFT
+{
+    XrStructureType type;
+    const void *next;
+    IUnknown *holographicSpace;
+    IUnknown *coreWindow;
+} XrHolographicWindowAttachmentMSFT;
+
+typedef struct XrInputSourceLocalizedNameGetInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrPath sourcePath;
+    XrInputSourceLocalizedNameFlags WINE_XR_ALIGN(8) whichComponents;
+} XrInputSourceLocalizedNameGetInfo;
+
+typedef struct XrInstanceCreateInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrInstanceCreateFlags WINE_XR_ALIGN(8) createFlags;
+    XrApplicationInfo applicationInfo;
+    uint32_t enabledApiLayerCount;
+    const char * const*enabledApiLayerNames;
+    uint32_t enabledExtensionCount;
+    const char * const*enabledExtensionNames;
+} XrInstanceCreateInfo;
+
+typedef struct XrInstanceProperties
+{
+    XrStructureType type;
+    void *next;
+    XrVersion runtimeVersion;
+    char runtimeName[XR_MAX_RUNTIME_NAME_SIZE];
+} XrInstanceProperties;
+
+typedef struct XrInteractionProfileAnalogThresholdVALVE
+{
+    XrStructureType type;
+    const void *next;
+    XrAction action;
+    XrPath binding;
+    float onThreshold;
+    float offThreshold;
+    const XrHapticBaseHeader *onHaptic;
+    const XrHapticBaseHeader *offHaptic;
+} XrInteractionProfileAnalogThresholdVALVE;
+
+typedef struct XrInteractionProfileDpadBindingEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrPath binding;
+    XrActionSet actionSet;
+    float forceThreshold;
+    float forceThresholdReleased;
+    float centerRegion;
+    float wedgeAngle;
+    XrBool32 isSticky;
+    const XrHapticBaseHeader *onHaptic;
+    const XrHapticBaseHeader *offHaptic;
+} XrInteractionProfileDpadBindingEXT;
+
+typedef struct XrInteractionProfileState
+{
+    XrStructureType type;
+    void *next;
+    XrPath interactionProfile;
+} XrInteractionProfileState;
+
+typedef struct XrInteractionProfileSuggestedBinding
+{
+    XrStructureType type;
+    const void *next;
+    XrPath interactionProfile;
+    uint32_t countSuggestedBindings;
+    const XrActionSuggestedBinding *suggestedBindings;
+} XrInteractionProfileSuggestedBinding;
+
+typedef struct XrInteractionRenderModelIdsEnumerateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+} XrInteractionRenderModelIdsEnumerateInfoEXT;
+
+typedef struct XrInteractionRenderModelSubactionPathInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+} XrInteractionRenderModelSubactionPathInfoEXT;
+
+typedef struct XrInteractionRenderModelTopLevelUserPathGetInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t topLevelUserPathCount;
+    const XrPath *topLevelUserPaths;
+} XrInteractionRenderModelTopLevelUserPathGetInfoEXT;
+
+typedef struct XrKeyboardSpaceCreateInfoFB
+{
+    XrStructureType type;
+    void *next;
+    uint64_t WINE_XR_ALIGN(8) trackedKeyboardId;
+} XrKeyboardSpaceCreateInfoFB;
+
+typedef struct XrKeyboardTrackingQueryFB
+{
+    XrStructureType type;
+    void *next;
+    XrKeyboardTrackingQueryFlagsFB WINE_XR_ALIGN(8) flags;
+} XrKeyboardTrackingQueryFB;
+
+typedef struct XrLoaderInitPropertyValueEXT
+{
+    const char *name;
+    const char *value;
+} XrLoaderInitPropertyValueEXT;
+
+typedef struct XrLocalDimmingFrameEndInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrLocalDimmingModeMETA localDimmingMode;
+} XrLocalDimmingFrameEndInfoMETA;
+
+typedef struct XrLocalizationEnableEventsInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 enabled;
+} XrLocalizationEnableEventsInfoML;
+
+typedef struct XrLocalizationMapImportInfoML
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t size;
+    char *data;
+} XrLocalizationMapImportInfoML;
+
+typedef struct XrLocalizationMapQueryInfoBaseHeaderML
+{
+    XrStructureType type;
+    const void *next;
+} XrLocalizationMapQueryInfoBaseHeaderML;
+
+typedef struct XrMarkerDetectorAprilTagInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrMarkerAprilTagDictML aprilTagDict;
+} XrMarkerDetectorAprilTagInfoML;
+
+typedef struct XrMarkerDetectorArucoInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrMarkerArucoDictML arucoDict;
+} XrMarkerDetectorArucoInfoML;
+
+typedef struct XrMarkerDetectorCreateInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrMarkerDetectorProfileML profile;
+    XrMarkerTypeML markerType;
+} XrMarkerDetectorCreateInfoML;
+
+typedef struct XrMarkerDetectorCustomProfileInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrMarkerDetectorFpsML fpsHint;
+    XrMarkerDetectorResolutionML resolutionHint;
+    XrMarkerDetectorCameraML cameraHint;
+    XrMarkerDetectorCornerRefineMethodML cornerRefineMethod;
+    XrBool32 useEdgeRefinement;
+    XrMarkerDetectorFullAnalysisIntervalML fullAnalysisIntervalHint;
+} XrMarkerDetectorCustomProfileInfoML;
+
+typedef struct XrMarkerDetectorSizeInfoML
+{
+    XrStructureType type;
+    const void *next;
+    float markerLength;
+} XrMarkerDetectorSizeInfoML;
+
+typedef struct XrMarkerDetectorSnapshotInfoML
+{
+    XrStructureType type;
+    const void *next;
+} XrMarkerDetectorSnapshotInfoML;
+
+typedef struct XrMarkerDetectorStateML
+{
+    XrStructureType type;
+    void *next;
+    XrMarkerDetectorStatusML state;
+} XrMarkerDetectorStateML;
+
+typedef struct XrNegotiateApiLayerRequest
+{
+    XrLoaderInterfaceStructs structType;
+    uint32_t structVersion;
+    size_t structSize;
+    uint32_t layerInterfaceVersion;
+    XrVersion layerApiVersion;
+    PFN_xrGetInstanceProcAddr getInstanceProcAddr;
+    PFN_xrCreateApiLayerInstance createApiLayerInstance;
+} XrNegotiateApiLayerRequest;
+
+typedef struct XrNegotiateLoaderInfo
+{
+    XrLoaderInterfaceStructs structType;
+    uint32_t structVersion;
+    size_t structSize;
+    uint32_t minInterfaceVersion;
+    uint32_t maxInterfaceVersion;
+    XrVersion minApiVersion;
+    XrVersion maxApiVersion;
+} XrNegotiateLoaderInfo;
+
+typedef struct XrNegotiateRuntimeRequest
+{
+    XrLoaderInterfaceStructs structType;
+    uint32_t structVersion;
+    size_t structSize;
+    uint32_t runtimeInterfaceVersion;
+    XrVersion runtimeApiVersion;
+    PFN_xrGetInstanceProcAddr getInstanceProcAddr;
+} XrNegotiateRuntimeRequest;
+
+typedef struct XrOffset2Df
+{
+    float x;
+    float y;
+} XrOffset2Df;
+
+typedef struct XrOffset2Di
+{
+    int32_t x;
+    int32_t y;
+} XrOffset2Di;
+
+typedef struct XrOffset3DfFB
+{
+    float x;
+    float y;
+    float z;
+} XrOffset3DfFB;
+
+typedef struct XrPassthroughBrightnessContrastSaturationFB
+{
+    XrStructureType type;
+    const void *next;
+    float brightness;
+    float contrast;
+    float saturation;
+} XrPassthroughBrightnessContrastSaturationFB;
+
+typedef struct XrPassthroughCameraStateGetInfoANDROID
+{
+    XrStructureType type;
+    const void *next;
+} XrPassthroughCameraStateGetInfoANDROID;
+
+typedef struct XrPassthroughColorHTC
+{
+    XrStructureType type;
+    const void *next;
+    float alpha;
+} XrPassthroughColorHTC;
+
+typedef struct XrPassthroughColorLutDataMETA
+{
+    uint32_t bufferSize;
+    const uint8_t *buffer;
+} XrPassthroughColorLutDataMETA;
+
+typedef struct XrPassthroughColorLutUpdateInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughColorLutDataMETA data;
+} XrPassthroughColorLutUpdateInfoMETA;
+
+typedef struct XrPassthroughColorMapInterpolatedLutMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughColorLutMETA sourceColorLut;
+    XrPassthroughColorLutMETA targetColorLut;
+    float weight;
+} XrPassthroughColorMapInterpolatedLutMETA;
+
+typedef struct XrPassthroughColorMapLutMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughColorLutMETA colorLut;
+    float weight;
+} XrPassthroughColorMapLutMETA;
+
+typedef struct XrPassthroughColorMapMonoToMonoFB
+{
+    XrStructureType type;
+    const void *next;
+    uint8_t textureColorMap[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB];
+} XrPassthroughColorMapMonoToMonoFB;
+
+typedef struct XrPassthroughColorMapMonoToRgbaFB
+{
+    XrStructureType type;
+    const void *next;
+    XrColor4f textureColorMap[XR_PASSTHROUGH_COLOR_MAP_MONO_SIZE_FB];
+} XrPassthroughColorMapMonoToRgbaFB;
+
+typedef struct XrPassthroughCreateInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughFlagsFB WINE_XR_ALIGN(8) flags;
+} XrPassthroughCreateInfoFB;
+
+typedef struct XrPassthroughCreateInfoHTC
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughFormHTC form;
+} XrPassthroughCreateInfoHTC;
+
+typedef struct XrPassthroughKeyboardHandsIntensityFB
+{
+    XrStructureType type;
+    const void *next;
+    float leftHandIntensity;
+    float rightHandIntensity;
+} XrPassthroughKeyboardHandsIntensityFB;
+
+typedef struct XrPassthroughLayerCreateInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughFB passthrough;
+    XrPassthroughFlagsFB WINE_XR_ALIGN(8) flags;
+    XrPassthroughLayerPurposeFB purpose;
+} XrPassthroughLayerCreateInfoFB;
+
+typedef struct XrPassthroughPreferencesMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughPreferenceFlagsMETA WINE_XR_ALIGN(8) flags;
+} XrPassthroughPreferencesMETA;
+
+typedef struct XrPassthroughStyleFB
+{
+    XrStructureType type;
+    const void *next;
+    float textureOpacityFactor;
+    XrColor4f edgeColor;
+} XrPassthroughStyleFB;
+
+typedef struct XrPerformanceMetricsCounterMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrPerformanceMetricsCounterFlagsMETA WINE_XR_ALIGN(8) counterFlags;
+    XrPerformanceMetricsCounterUnitMETA counterUnit;
+    uint32_t uintValue;
+    float floatValue;
+} XrPerformanceMetricsCounterMETA;
+
+typedef struct XrPerformanceMetricsStateMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 enabled;
+} XrPerformanceMetricsStateMETA;
+
+typedef struct XrPersistedAnchorSpaceInfoANDROID
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace anchor;
+} XrPersistedAnchorSpaceInfoANDROID;
+
+typedef struct XrPlaneDetectorCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrPlaneDetectorFlagsEXT WINE_XR_ALIGN(8) flags;
+} XrPlaneDetectorCreateInfoEXT;
+
+typedef struct XrPlaneDetectorGetInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+} XrPlaneDetectorGetInfoEXT;
+
+typedef struct XrQuaternionf
+{
+    float x;
+    float y;
+    float z;
+    float w;
+} XrQuaternionf;
+
+typedef struct XrQueriedSenseDataGetInfoBD
+{
+    XrStructureType type;
+    const void *next;
+} XrQueriedSenseDataGetInfoBD;
+
+typedef struct XrRecommendedLayerResolutionGetInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    const XrCompositionLayerBaseHeader *layer;
+    XrTime predictedDisplayTime;
+} XrRecommendedLayerResolutionGetInfoMETA;
+
+typedef struct XrRecommendedLayerResolutionMETA
+{
+    XrStructureType type;
+    void *next;
+    XrExtent2Di recommendedImageDimensions;
+    XrBool32 isValid;
+} XrRecommendedLayerResolutionMETA;
+
+typedef struct XrRect2Df
+{
+    XrOffset2Df offset;
+    XrExtent2Df extent;
+} XrRect2Df;
+
+typedef struct XrRect2Di
+{
+    XrOffset2Di offset;
+    XrExtent2Di extent;
+} XrRect2Di;
+
+typedef struct XrRect3DfFB
+{
+    XrOffset3DfFB offset;
+    XrExtent3DfFB extent;
+} XrRect3DfFB;
+
+typedef struct XrRenderModelAssetDataEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t bufferCapacityInput;
+    uint32_t bufferCountOutput;
+    uint8_t *buffer;
+} XrRenderModelAssetDataEXT;
+
+typedef struct XrRenderModelAssetDataGetInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+} XrRenderModelAssetDataGetInfoEXT;
+
+typedef struct XrRenderModelAssetNodePropertiesEXT
+{
+    char uniqueName[XR_MAX_RENDER_MODEL_ASSET_NODE_NAME_SIZE_EXT];
+} XrRenderModelAssetNodePropertiesEXT;
+
+typedef struct XrRenderModelAssetPropertiesEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t nodePropertyCount;
+    XrRenderModelAssetNodePropertiesEXT *nodeProperties;
+} XrRenderModelAssetPropertiesEXT;
+
+typedef struct XrRenderModelAssetPropertiesGetInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+} XrRenderModelAssetPropertiesGetInfoEXT;
+
+typedef struct XrRenderModelBufferFB
+{
+    XrStructureType type;
+    void *next;
+    uint32_t bufferCapacityInput;
+    uint32_t bufferCountOutput;
+    uint8_t *buffer;
+} XrRenderModelBufferFB;
+
+typedef struct XrRenderModelCapabilitiesRequestFB
+{
+    XrStructureType type;
+    void *next;
+    XrRenderModelFlagsFB WINE_XR_ALIGN(8) flags;
+} XrRenderModelCapabilitiesRequestFB;
+
+typedef struct XrRenderModelCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrRenderModelIdEXT renderModelId;
+    uint32_t gltfExtensionCount;
+    const char * const*gltfExtensions;
+} XrRenderModelCreateInfoEXT;
+
+typedef struct XrRenderModelLoadInfoFB
+{
+    XrStructureType type;
+    void *next;
+    XrRenderModelKeyFB modelKey;
+} XrRenderModelLoadInfoFB;
+
+typedef struct XrRenderModelPathInfoFB
+{
+    XrStructureType type;
+    void *next;
+    XrPath path;
+} XrRenderModelPathInfoFB;
+
+typedef struct XrRenderModelPropertiesFB
+{
+    XrStructureType type;
+    void *next;
+    uint32_t vendorId;
+    char modelName[XR_MAX_RENDER_MODEL_NAME_SIZE_FB];
+    XrRenderModelKeyFB modelKey;
+    uint32_t modelVersion;
+    XrRenderModelFlagsFB WINE_XR_ALIGN(8) flags;
+} XrRenderModelPropertiesFB;
+
+typedef struct XrRenderModelPropertiesGetInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+} XrRenderModelPropertiesGetInfoEXT;
+
+typedef struct XrRenderModelSpaceCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrRenderModelEXT renderModel;
+} XrRenderModelSpaceCreateInfoEXT;
+
+typedef struct XrRenderModelStateGetInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrTime displayTime;
+} XrRenderModelStateGetInfoEXT;
+
+typedef struct XrSceneCaptureInfoBD
+{
+    XrStructureType type;
+    const void *next;
+} XrSceneCaptureInfoBD;
+
+typedef struct XrSceneCaptureRequestInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t requestByteCount;
+    const char *request;
+} XrSceneCaptureRequestInfoFB;
+
+typedef struct XrSceneComponentsGetInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrSceneComponentTypeMSFT componentType;
+} XrSceneComponentsGetInfoMSFT;
+
+typedef struct XrSceneCreateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+} XrSceneCreateInfoMSFT;
+
+typedef struct XrSceneDeserializeInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t fragmentCount;
+    const XrDeserializeSceneFragmentMSFT *fragments;
+} XrSceneDeserializeInfoMSFT;
+
+typedef struct XrSceneMarkerMSFT
+{
+    XrSceneMarkerTypeMSFT markerType;
+    XrTime lastSeenTime;
+    XrOffset2Df center;
+    XrExtent2Df size;
+} XrSceneMarkerMSFT;
+
+typedef struct XrSceneMarkerQRCodeMSFT
+{
+    XrSceneMarkerQRCodeSymbolTypeMSFT symbolType;
+    uint8_t version;
+} XrSceneMarkerQRCodeMSFT;
+
+typedef struct XrSceneMarkerQRCodesMSFT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t qrCodeCapacityInput;
+    XrSceneMarkerQRCodeMSFT *qrCodes;
+} XrSceneMarkerQRCodesMSFT;
+
+typedef struct XrSceneMarkerTypeFilterMSFT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t markerTypeCount;
+    XrSceneMarkerTypeMSFT *markerTypes;
+} XrSceneMarkerTypeFilterMSFT;
+
+typedef struct XrSceneMarkersMSFT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t sceneMarkerCapacityInput;
+    XrSceneMarkerMSFT *sceneMarkers;
+} XrSceneMarkersMSFT;
+
+typedef struct XrSceneMeshBuffersGetInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    uint64_t WINE_XR_ALIGN(8) meshBufferId;
+} XrSceneMeshBuffersGetInfoMSFT;
+
+typedef struct XrSceneMeshBuffersMSFT
+{
+    XrStructureType type;
+    void *next;
+} XrSceneMeshBuffersMSFT;
+
+typedef struct XrSceneMeshIndicesUint16MSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t indexCapacityInput;
+    uint32_t indexCountOutput;
+    uint16_t *indices;
+} XrSceneMeshIndicesUint16MSFT;
+
+typedef struct XrSceneMeshIndicesUint32MSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t indexCapacityInput;
+    uint32_t indexCountOutput;
+    uint32_t *indices;
+} XrSceneMeshIndicesUint32MSFT;
+
+typedef struct XrSceneMeshMSFT
+{
+    uint64_t WINE_XR_ALIGN(8) meshBufferId;
+    XrBool32 supportsIndicesUint16;
+} XrSceneMeshMSFT;
+
+typedef struct XrSceneMeshesMSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t sceneMeshCount;
+    XrSceneMeshMSFT *sceneMeshes;
+} XrSceneMeshesMSFT;
+
+typedef struct XrSceneObjectMSFT
+{
+    XrSceneObjectTypeMSFT objectType;
+} XrSceneObjectMSFT;
+
+typedef struct XrSceneObjectTypesFilterInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t objectTypeCount;
+    const XrSceneObjectTypeMSFT *objectTypes;
+} XrSceneObjectTypesFilterInfoMSFT;
+
+typedef struct XrSceneObjectsMSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t sceneObjectCount;
+    XrSceneObjectMSFT *sceneObjects;
+} XrSceneObjectsMSFT;
+
+typedef struct XrSceneObserverCreateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+} XrSceneObserverCreateInfoMSFT;
+
+typedef struct XrScenePlaneAlignmentFilterInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t alignmentCount;
+    const XrScenePlaneAlignmentTypeMSFT *alignments;
+} XrScenePlaneAlignmentFilterInfoMSFT;
+
+typedef struct XrScenePlaneMSFT
+{
+    XrScenePlaneAlignmentTypeMSFT alignment;
+    XrExtent2Df size;
+    uint64_t WINE_XR_ALIGN(8) meshBufferId;
+    XrBool32 supportsIndicesUint16;
+} XrScenePlaneMSFT;
+
+typedef struct XrScenePlanesMSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t scenePlaneCount;
+    XrScenePlaneMSFT *scenePlanes;
+} XrScenePlanesMSFT;
+
+typedef struct XrSecondaryViewConfigurationLayerInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrViewConfigurationType viewConfigurationType;
+    XrEnvironmentBlendMode environmentBlendMode;
+    uint32_t layerCount;
+    const XrCompositionLayerBaseHeader * const*layers;
+} XrSecondaryViewConfigurationLayerInfoMSFT;
+
+typedef struct XrSecondaryViewConfigurationSessionBeginInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t viewConfigurationCount;
+    const XrViewConfigurationType *enabledViewConfigurationTypes;
+} XrSecondaryViewConfigurationSessionBeginInfoMSFT;
+
+typedef struct XrSecondaryViewConfigurationStateMSFT
+{
+    XrStructureType type;
+    void *next;
+    XrViewConfigurationType viewConfigurationType;
+    XrBool32 active;
+} XrSecondaryViewConfigurationStateMSFT;
+
+typedef struct XrSecondaryViewConfigurationSwapchainCreateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrViewConfigurationType viewConfigurationType;
+} XrSecondaryViewConfigurationSwapchainCreateInfoMSFT;
+
+typedef struct XrSemanticLabelsFB
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t bufferCapacityInput;
+    uint32_t bufferCountOutput;
+    char *buffer;
+} XrSemanticLabelsFB;
+
+typedef struct XrSemanticLabelsSupportInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSemanticLabelsSupportFlagsFB WINE_XR_ALIGN(8) flags;
+    const char *recognizedLabels;
+} XrSemanticLabelsSupportInfoFB;
+
+typedef struct XrSenseDataFilterPlaneOrientationBD
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t orientationCount;
+    XrPlaneOrientationBD *orientations;
+} XrSenseDataFilterPlaneOrientationBD;
+
+typedef struct XrSenseDataFilterSemanticBD
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t labelCount;
+    const XrSemanticLabelBD *labels;
+} XrSenseDataFilterSemanticBD;
+
+typedef struct XrSenseDataProviderCreateInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrSenseDataProviderTypeBD providerType;
+} XrSenseDataProviderCreateInfoBD;
+
+typedef struct XrSenseDataProviderCreateInfoSpatialMeshBD
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialMeshConfigFlagsBD WINE_XR_ALIGN(8) configFlags;
+    XrSpatialMeshLodBD lod;
+} XrSenseDataProviderCreateInfoSpatialMeshBD;
+
+typedef struct XrSenseDataProviderStartInfoBD
+{
+    XrStructureType type;
+    const void *next;
+} XrSenseDataProviderStartInfoBD;
+
+typedef struct XrSenseDataQueryCompletionBD
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    XrSenseDataSnapshotBD snapshot;
+} XrSenseDataQueryCompletionBD;
+
+typedef struct XrSenseDataQueryInfoBD
+{
+    XrStructureType type;
+    const void *next;
+} XrSenseDataQueryInfoBD;
+
+typedef struct XrSessionActionSetsAttachInfo
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t countActionSets;
+    const XrActionSet *actionSets;
+} XrSessionActionSetsAttachInfo;
+
+typedef struct XrSessionBeginInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrViewConfigurationType primaryViewConfigurationType;
+} XrSessionBeginInfo;
+
+typedef struct XrSessionCreateInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrSessionCreateFlags WINE_XR_ALIGN(8) createFlags;
+    XrSystemId systemId;
+} XrSessionCreateInfo;
+
+typedef struct XrSessionCreateInfoOverlayEXTX
+{
+    XrStructureType type;
+    const void *next;
+    XrOverlaySessionCreateFlagsEXTX WINE_XR_ALIGN(8) createFlags;
+    uint32_t sessionLayersPlacement;
+} XrSessionCreateInfoOverlayEXTX;
+
+typedef struct XrShareSpacesRecipientBaseHeaderMETA
+{
+    XrStructureType type;
+    const void *next;
+} XrShareSpacesRecipientBaseHeaderMETA;
+
+typedef struct XrSimultaneousHandsAndControllersTrackingPauseInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+} XrSimultaneousHandsAndControllersTrackingPauseInfoMETA;
+
+typedef struct XrSimultaneousHandsAndControllersTrackingResumeInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+} XrSimultaneousHandsAndControllersTrackingResumeInfoMETA;
+
+typedef struct XrSpaceComponentFilterInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpaceComponentTypeFB componentType;
+} XrSpaceComponentFilterInfoFB;
+
+typedef struct XrSpaceComponentStatusFB
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 enabled;
+    XrBool32 changePending;
+} XrSpaceComponentStatusFB;
+
+typedef struct XrSpaceComponentStatusSetInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpaceComponentTypeFB componentType;
+    XrBool32 enabled;
+    XrDuration timeout;
+} XrSpaceComponentStatusSetInfoFB;
+
+typedef struct XrSpaceEraseInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace space;
+    XrSpaceStorageLocationFB location;
+} XrSpaceEraseInfoFB;
+
+typedef struct XrSpaceFilterBaseHeaderMETA
+{
+    XrStructureType type;
+    const void *next;
+} XrSpaceFilterBaseHeaderMETA;
+
+typedef struct XrSpaceFilterComponentMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrSpaceComponentTypeFB componentType;
+} XrSpaceFilterComponentMETA;
+
+typedef struct XrSpaceFilterInfoBaseHeaderFB
+{
+    XrStructureType type;
+    const void *next;
+} XrSpaceFilterInfoBaseHeaderFB;
+
+typedef struct XrSpaceListSaveInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t spaceCount;
+    XrSpace *spaces;
+    XrSpaceStorageLocationFB location;
+} XrSpaceListSaveInfoFB;
+
+typedef struct XrSpaceQueryInfoBaseHeaderFB
+{
+    XrStructureType type;
+    const void *next;
+} XrSpaceQueryInfoBaseHeaderFB;
+
+typedef struct XrSpaceQueryInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpaceQueryActionFB queryAction;
+    uint32_t maxResultCount;
+    XrDuration timeout;
+    const XrSpaceFilterInfoBaseHeaderFB *filter;
+    const XrSpaceFilterInfoBaseHeaderFB *excludeFilter;
+} XrSpaceQueryInfoFB;
+
+typedef struct XrSpaceSaveInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace space;
+    XrSpaceStorageLocationFB location;
+    XrSpacePersistenceModeFB persistenceMode;
+} XrSpaceSaveInfoFB;
+
+typedef struct XrSpaceShareInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t spaceCount;
+    XrSpace *spaces;
+    uint32_t userCount;
+    XrSpaceUserFB *users;
+} XrSpaceShareInfoFB;
+
+typedef struct XrSpaceStorageLocationFilterInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpaceStorageLocationFB location;
+} XrSpaceStorageLocationFilterInfoFB;
+
+typedef struct XrSpaceTriangleMeshGetInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+} XrSpaceTriangleMeshGetInfoMETA;
+
+typedef struct XrSpaceUserCreateInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpaceUserIdFB userId;
+} XrSpaceUserCreateInfoFB;
+
+typedef struct XrSpacesLocateInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+    uint32_t spaceCount;
+    const XrSpace *spaces;
+} XrSpacesLocateInfo;
+typedef XrSpacesLocateInfo XrSpacesLocateInfoKHR;
+
+typedef struct XrSpacesSaveInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t spaceCount;
+    XrSpace *spaces;
+} XrSpacesSaveInfoMETA;
+
+typedef struct XrSpatialAnchorNameHTC
+{
+    char name[XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_HTC];
+} XrSpatialAnchorNameHTC;
+
+typedef struct XrSpatialAnchorPersistInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrPersistenceLocationBD location;
+    XrAnchorBD anchor;
+} XrSpatialAnchorPersistInfoBD;
+
+typedef struct XrSpatialAnchorPersistenceNameMSFT
+{
+    char name[XR_MAX_SPATIAL_ANCHOR_NAME_SIZE_MSFT];
+} XrSpatialAnchorPersistenceNameMSFT;
+
+typedef struct XrSpatialAnchorShareInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrAnchorBD anchor;
+} XrSpatialAnchorShareInfoBD;
+
+typedef struct XrSpatialAnchorStateML
+{
+    XrStructureType type;
+    void *next;
+    XrSpatialAnchorConfidenceML confidence;
+} XrSpatialAnchorStateML;
+
+typedef struct XrSpatialAnchorUnpersistInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrPersistenceLocationBD location;
+    XrAnchorBD anchor;
+} XrSpatialAnchorUnpersistInfoBD;
+
+typedef struct XrSpatialAnchorsCreateInfoBaseHeaderML
+{
+    XrStructureType type;
+    const void *next;
+} XrSpatialAnchorsCreateInfoBaseHeaderML;
+
+typedef struct XrSpatialAnchorsCreateStorageInfoML
+{
+    XrStructureType type;
+    const void *next;
+} XrSpatialAnchorsCreateStorageInfoML;
+
+typedef struct XrSpatialAnchorsDeleteCompletionML
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+} XrSpatialAnchorsDeleteCompletionML;
+
+typedef struct XrSpatialAnchorsPublishInfoML
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t anchorCount;
+    const XrSpace *anchors;
+    uint64_t WINE_XR_ALIGN(8) expiration;
+} XrSpatialAnchorsPublishInfoML;
+
+typedef struct XrSpatialAnchorsQueryInfoBaseHeaderML
+{
+    XrStructureType type;
+    const void *next;
+} XrSpatialAnchorsQueryInfoBaseHeaderML;
+
+typedef struct XrSpatialAnchorsUpdateExpirationCompletionML
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+} XrSpatialAnchorsUpdateExpirationCompletionML;
+
+typedef struct XrSpatialBufferEXT
+{
+    XrSpatialBufferIdEXT bufferId;
+    XrSpatialBufferTypeEXT bufferType;
+} XrSpatialBufferEXT;
+
+typedef struct XrSpatialBufferGetInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialBufferIdEXT bufferId;
+} XrSpatialBufferGetInfoEXT;
+
+typedef struct XrSpatialCapabilityComponentTypesEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t componentTypeCapacityInput;
+    uint32_t componentTypeCountOutput;
+    XrSpatialComponentTypeEXT *componentTypes;
+} XrSpatialCapabilityComponentTypesEXT;
+
+typedef struct XrSpatialCapabilityConfigurationAnchorEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialCapabilityEXT capability;
+    uint32_t enabledComponentCount;
+    const XrSpatialComponentTypeEXT *enabledComponents;
+} XrSpatialCapabilityConfigurationAnchorEXT;
+
+typedef struct XrSpatialCapabilityConfigurationAprilTagEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialCapabilityEXT capability;
+    uint32_t enabledComponentCount;
+    const XrSpatialComponentTypeEXT *enabledComponents;
+    XrSpatialMarkerAprilTagDictEXT aprilDict;
+} XrSpatialCapabilityConfigurationAprilTagEXT;
+
+typedef struct XrSpatialCapabilityConfigurationArucoMarkerEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialCapabilityEXT capability;
+    uint32_t enabledComponentCount;
+    const XrSpatialComponentTypeEXT *enabledComponents;
+    XrSpatialMarkerArucoDictEXT arUcoDict;
+} XrSpatialCapabilityConfigurationArucoMarkerEXT;
+
+typedef struct XrSpatialCapabilityConfigurationBaseHeaderEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialCapabilityEXT capability;
+    uint32_t enabledComponentCount;
+    const XrSpatialComponentTypeEXT *enabledComponents;
+} XrSpatialCapabilityConfigurationBaseHeaderEXT;
+
+typedef struct XrSpatialCapabilityConfigurationMicroQrCodeEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialCapabilityEXT capability;
+    uint32_t enabledComponentCount;
+    const XrSpatialComponentTypeEXT *enabledComponents;
+} XrSpatialCapabilityConfigurationMicroQrCodeEXT;
+
+typedef struct XrSpatialCapabilityConfigurationPlaneTrackingEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialCapabilityEXT capability;
+    uint32_t enabledComponentCount;
+    const XrSpatialComponentTypeEXT *enabledComponents;
+} XrSpatialCapabilityConfigurationPlaneTrackingEXT;
+
+typedef struct XrSpatialCapabilityConfigurationQrCodeEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialCapabilityEXT capability;
+    uint32_t enabledComponentCount;
+    const XrSpatialComponentTypeEXT *enabledComponents;
+} XrSpatialCapabilityConfigurationQrCodeEXT;
+
+typedef struct XrSpatialComponentDataQueryConditionEXT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t componentTypeCount;
+    const XrSpatialComponentTypeEXT *componentTypes;
+} XrSpatialComponentDataQueryConditionEXT;
+
+typedef struct XrSpatialComponentDataQueryResultEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t entityIdCapacityInput;
+    uint32_t entityIdCountOutput;
+    XrSpatialEntityIdEXT *entityIds;
+    uint32_t entityStateCapacityInput;
+    uint32_t entityStateCountOutput;
+    XrSpatialEntityTrackingStateEXT *entityStates;
+} XrSpatialComponentDataQueryResultEXT;
+
+typedef struct XrSpatialComponentParentListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t parentCount;
+    XrSpatialEntityIdEXT *parents;
+} XrSpatialComponentParentListEXT;
+
+typedef struct XrSpatialComponentPlaneAlignmentListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t planeAlignmentCount;
+    XrSpatialPlaneAlignmentEXT *planeAlignments;
+} XrSpatialComponentPlaneAlignmentListEXT;
+
+typedef struct XrSpatialComponentPlaneSemanticLabelListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t semanticLabelCount;
+    XrSpatialPlaneSemanticLabelEXT *semanticLabels;
+} XrSpatialComponentPlaneSemanticLabelListEXT;
+
+typedef struct XrSpatialContextCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t capabilityConfigCount;
+    const XrSpatialCapabilityConfigurationBaseHeaderEXT * const*capabilityConfigs;
+} XrSpatialContextCreateInfoEXT;
+
+typedef struct XrSpatialContextPersistenceConfigEXT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t persistenceContextCount;
+    const XrSpatialPersistenceContextEXT *persistenceContexts;
+} XrSpatialContextPersistenceConfigEXT;
+
+typedef struct XrSpatialDiscoverySnapshotCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t componentTypeCount;
+    const XrSpatialComponentTypeEXT *componentTypes;
+} XrSpatialDiscoverySnapshotCreateInfoEXT;
+
+typedef struct XrSpatialEntityAnchorCreateInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrSenseDataSnapshotBD snapshot;
+    XrSpatialEntityIdBD entityId;
+} XrSpatialEntityAnchorCreateInfoBD;
+
+typedef struct XrSpatialEntityComponentDataBaseHeaderBD
+{
+    XrStructureType type;
+    void *next;
+} XrSpatialEntityComponentDataBaseHeaderBD;
+
+typedef struct XrSpatialEntityComponentDataBoundingBox2DBD
+{
+    XrStructureType type;
+    void *next;
+    XrRect2Df boundingBox2D;
+} XrSpatialEntityComponentDataBoundingBox2DBD;
+
+typedef struct XrSpatialEntityComponentDataPlaneOrientationBD
+{
+    XrStructureType type;
+    void *next;
+    XrPlaneOrientationBD orientation;
+} XrSpatialEntityComponentDataPlaneOrientationBD;
+
+typedef struct XrSpatialEntityComponentDataSemanticBD
+{
+    XrStructureType type;
+    void *next;
+    uint32_t labelCapacityInput;
+    uint32_t labelCountOutput;
+    XrSemanticLabelBD *labels;
+} XrSpatialEntityComponentDataSemanticBD;
+
+typedef struct XrSpatialEntityComponentGetInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialEntityIdBD entityId;
+    XrSpatialEntityComponentTypeBD componentType;
+} XrSpatialEntityComponentGetInfoBD;
+
+typedef struct XrSpatialEntityFromIdCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialEntityIdEXT entityId;
+} XrSpatialEntityFromIdCreateInfoEXT;
+
+typedef struct XrSpatialEntityLocationGetInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+} XrSpatialEntityLocationGetInfoBD;
+
+typedef struct XrSpatialEntityPersistInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialContextEXT spatialContext;
+    XrSpatialEntityIdEXT spatialEntityId;
+} XrSpatialEntityPersistInfoEXT;
+
+typedef struct XrSpatialFilterTrackingStateEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialEntityTrackingStateEXT trackingState;
+} XrSpatialFilterTrackingStateEXT;
+
+typedef struct XrSpatialGraphNodeBindingPropertiesGetInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+} XrSpatialGraphNodeBindingPropertiesGetInfoMSFT;
+
+typedef struct XrSpatialMarkerDataEXT
+{
+    XrSpatialCapabilityEXT capability;
+    uint32_t markerId;
+    XrSpatialBufferEXT data;
+} XrSpatialMarkerDataEXT;
+
+typedef struct XrSpatialMarkerSizeEXT
+{
+    XrStructureType type;
+    const void *next;
+    float markerSideLength;
+} XrSpatialMarkerSizeEXT;
+
+typedef struct XrSpatialMarkerStaticOptimizationEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 optimizeForStaticMarker;
+} XrSpatialMarkerStaticOptimizationEXT;
+
+typedef struct XrSpatialPersistenceContextCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialPersistenceScopeEXT scope;
+} XrSpatialPersistenceContextCreateInfoEXT;
+
+typedef struct XrSpatialUpdateSnapshotCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t entityCount;
+    const XrSpatialEntityEXT *entities;
+    uint32_t componentTypeCount;
+    const XrSpatialComponentTypeEXT *componentTypes;
+    XrSpace baseSpace;
+    XrTime time;
+} XrSpatialUpdateSnapshotCreateInfoEXT;
+
+typedef struct XrSwapchainCreateInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrSwapchainCreateFlags WINE_XR_ALIGN(8) createFlags;
+    XrSwapchainUsageFlags WINE_XR_ALIGN(8) usageFlags;
+    int64_t format;
+    uint32_t sampleCount;
+    uint32_t width;
+    uint32_t height;
+    uint32_t faceCount;
+    uint32_t arraySize;
+    uint32_t mipCount;
+} XrSwapchainCreateInfo;
+
+typedef struct XrSwapchainCreateInfoFoveationFB
+{
+    XrStructureType type;
+    void *next;
+    XrSwapchainCreateFoveationFlagsFB WINE_XR_ALIGN(8) flags;
+} XrSwapchainCreateInfoFoveationFB;
+
+typedef struct XrSwapchainImageAcquireInfo
+{
+    XrStructureType type;
+    const void *next;
+} XrSwapchainImageAcquireInfo;
+
+typedef struct XrSwapchainImageBaseHeader
+{
+    XrStructureType type;
+    void *next;
+} XrSwapchainImageBaseHeader;
+
+typedef struct XrSwapchainImageD3D11KHR
+{
+    XrStructureType type;
+    void *next;
+    ID3D11Texture2D *texture;
+} XrSwapchainImageD3D11KHR;
+
+typedef struct XrSwapchainImageD3D12KHR
+{
+    XrStructureType type;
+    void *next;
+    ID3D12Resource *texture;
+} XrSwapchainImageD3D12KHR;
+
+typedef struct XrSwapchainImageFoveationVulkanFB
+{
+    XrStructureType type;
+    void *next;
+    VkImage image;
+    uint32_t width;
+    uint32_t height;
+} XrSwapchainImageFoveationVulkanFB;
+
+typedef struct XrSwapchainImageOpenGLKHR
+{
+    XrStructureType type;
+    void *next;
+    uint32_t image;
+} XrSwapchainImageOpenGLKHR;
+
+typedef struct XrSwapchainImageReleaseInfo
+{
+    XrStructureType type;
+    const void *next;
+} XrSwapchainImageReleaseInfo;
+
+typedef struct XrSwapchainImageVulkanKHR
+{
+    XrStructureType type;
+    void *next;
+    VkImage image;
+} XrSwapchainImageVulkanKHR;
+typedef XrSwapchainImageVulkanKHR XrSwapchainImageVulkan2KHR;
+
+typedef struct XrSwapchainImageWaitInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrDuration timeout;
+} XrSwapchainImageWaitInfo;
+
+typedef struct XrSwapchainStateBaseHeaderFB
+{
+    XrStructureType type;
+    void *next;
+} XrSwapchainStateBaseHeaderFB;
+
+typedef struct XrSwapchainStateFoveationFB
+{
+    XrStructureType type;
+    void *next;
+    XrSwapchainStateFoveationFlagsFB WINE_XR_ALIGN(8) flags;
+    XrFoveationProfileFB profile;
+} XrSwapchainStateFoveationFB;
+
+typedef struct XrSwapchainStateSamplerVulkanFB
+{
+    XrStructureType type;
+    void *next;
+    VkFilter minFilter;
+    VkFilter magFilter;
+    VkSamplerMipmapMode mipmapMode;
+    VkSamplerAddressMode wrapModeS;
+    VkSamplerAddressMode wrapModeT;
+    VkComponentSwizzle swizzleRed;
+    VkComponentSwizzle swizzleGreen;
+    VkComponentSwizzle swizzleBlue;
+    VkComponentSwizzle swizzleAlpha;
+    float maxAnisotropy;
+    XrColor4f borderColor;
+} XrSwapchainStateSamplerVulkanFB;
+
+typedef struct XrSwapchainSubImage
+{
+    XrSwapchain swapchain;
+    XrRect2Di imageRect;
+    uint32_t imageArrayIndex;
+} XrSwapchainSubImage;
+
+typedef struct XrSystemAnchorPropertiesHTC
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsAnchor;
+} XrSystemAnchorPropertiesHTC;
+
+typedef struct XrSystemBodyTrackingPropertiesBD
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsBodyTracking;
+} XrSystemBodyTrackingPropertiesBD;
+
+typedef struct XrSystemBodyTrackingPropertiesFB
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsBodyTracking;
+} XrSystemBodyTrackingPropertiesFB;
+
+typedef struct XrSystemBodyTrackingPropertiesHTC
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsBodyTracking;
+} XrSystemBodyTrackingPropertiesHTC;
+
+typedef struct XrSystemColocationDiscoveryPropertiesMETA
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsColocationDiscovery;
+} XrSystemColocationDiscoveryPropertiesMETA;
+
+typedef struct XrSystemColorSpacePropertiesFB
+{
+    XrStructureType type;
+    void *next;
+    XrColorSpaceFB colorSpace;
+} XrSystemColorSpacePropertiesFB;
+
+typedef struct XrSystemDeviceAnchorPersistencePropertiesANDROID
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsAnchorPersistence;
+} XrSystemDeviceAnchorPersistencePropertiesANDROID;
+
+typedef struct XrSystemEnvironmentDepthPropertiesMETA
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsEnvironmentDepth;
+    XrBool32 supportsHandRemoval;
+} XrSystemEnvironmentDepthPropertiesMETA;
+
+typedef struct XrSystemEyeGazeInteractionPropertiesEXT
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsEyeGazeInteraction;
+} XrSystemEyeGazeInteractionPropertiesEXT;
+
+typedef struct XrSystemEyeTrackingPropertiesFB
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsEyeTracking;
+} XrSystemEyeTrackingPropertiesFB;
+
+typedef struct XrSystemFaceTrackingProperties2FB
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsVisualFaceTracking;
+    XrBool32 supportsAudioFaceTracking;
+} XrSystemFaceTrackingProperties2FB;
+
+typedef struct XrSystemFaceTrackingPropertiesFB
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsFaceTracking;
+} XrSystemFaceTrackingPropertiesFB;
+
+typedef struct XrSystemFacialExpressionPropertiesML
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsFacialExpression;
+} XrSystemFacialExpressionPropertiesML;
+
+typedef struct XrSystemFacialTrackingPropertiesHTC
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportEyeFacialTracking;
+    XrBool32 supportLipFacialTracking;
+} XrSystemFacialTrackingPropertiesHTC;
+
+typedef struct XrSystemForceFeedbackCurlPropertiesMNDX
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsForceFeedbackCurl;
+} XrSystemForceFeedbackCurlPropertiesMNDX;
+
+typedef struct XrSystemFoveatedRenderingPropertiesVARJO
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsFoveatedRendering;
+} XrSystemFoveatedRenderingPropertiesVARJO;
+
+typedef struct XrSystemFoveationEyeTrackedPropertiesMETA
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsFoveationEyeTracked;
+} XrSystemFoveationEyeTrackedPropertiesMETA;
+
+typedef struct XrSystemGetInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrFormFactor formFactor;
+} XrSystemGetInfo;
+
+typedef struct XrSystemGraphicsProperties
+{
+    uint32_t maxSwapchainImageHeight;
+    uint32_t maxSwapchainImageWidth;
+    uint32_t maxLayerCount;
+} XrSystemGraphicsProperties;
+
+typedef struct XrSystemHandTrackingMeshPropertiesMSFT
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsHandTrackingMesh;
+    uint32_t maxHandMeshIndexCount;
+    uint32_t maxHandMeshVertexCount;
+} XrSystemHandTrackingMeshPropertiesMSFT;
+
+typedef struct XrSystemHandTrackingPropertiesEXT
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsHandTracking;
+} XrSystemHandTrackingPropertiesEXT;
+
+typedef struct XrSystemKeyboardTrackingPropertiesFB
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsKeyboardTracking;
+} XrSystemKeyboardTrackingPropertiesFB;
+
+typedef struct XrSystemMarkerTrackingPropertiesANDROID
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsMarkerTracking;
+    XrBool32 supportsMarkerSizeEstimation;
+    uint16_t maxMarkerCount;
+} XrSystemMarkerTrackingPropertiesANDROID;
+
+typedef struct XrSystemMarkerTrackingPropertiesVARJO
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsMarkerTracking;
+} XrSystemMarkerTrackingPropertiesVARJO;
+
+typedef struct XrSystemMarkerUnderstandingPropertiesML
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsMarkerUnderstanding;
+} XrSystemMarkerUnderstandingPropertiesML;
+
+typedef struct XrSystemNotificationsSetInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 suppressNotifications;
+} XrSystemNotificationsSetInfoML;
+
+typedef struct XrSystemPassthroughCameraStatePropertiesANDROID
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsPassthroughCameraState;
+} XrSystemPassthroughCameraStatePropertiesANDROID;
+
+typedef struct XrSystemPassthroughColorLutPropertiesMETA
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t maxColorLutResolution;
+} XrSystemPassthroughColorLutPropertiesMETA;
+
+typedef struct XrSystemPassthroughProperties2FB
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughCapabilityFlagsFB WINE_XR_ALIGN(8) capabilities;
+} XrSystemPassthroughProperties2FB;
+
+typedef struct XrSystemPassthroughPropertiesFB
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 supportsPassthrough;
+} XrSystemPassthroughPropertiesFB;
+
+typedef struct XrSystemPlaneDetectionPropertiesEXT
+{
+    XrStructureType type;
+    void *next;
+    XrPlaneDetectionCapabilityFlagsEXT WINE_XR_ALIGN(8) supportedFeatures;
+} XrSystemPlaneDetectionPropertiesEXT;
+
+typedef struct XrSystemPropertiesBodyTrackingCalibrationMETA
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsHeightOverride;
+} XrSystemPropertiesBodyTrackingCalibrationMETA;
+
+typedef struct XrSystemPropertiesBodyTrackingFullBodyMETA
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsFullBodyTracking;
+} XrSystemPropertiesBodyTrackingFullBodyMETA;
+
+typedef struct XrSystemRenderModelPropertiesFB
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsRenderModelLoading;
+} XrSystemRenderModelPropertiesFB;
+
+typedef struct XrSystemSimultaneousHandsAndControllersPropertiesMETA
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsSimultaneousHandsAndControllers;
+} XrSystemSimultaneousHandsAndControllersPropertiesMETA;
+
+typedef struct XrSystemSpaceDiscoveryPropertiesMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 supportsSpaceDiscovery;
+} XrSystemSpaceDiscoveryPropertiesMETA;
+
+typedef struct XrSystemSpacePersistencePropertiesMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 supportsSpacePersistence;
+} XrSystemSpacePersistencePropertiesMETA;
+
+typedef struct XrSystemSpaceWarpPropertiesFB
+{
+    XrStructureType type;
+    void *next;
+    uint32_t recommendedMotionVectorImageRectWidth;
+    uint32_t recommendedMotionVectorImageRectHeight;
+} XrSystemSpaceWarpPropertiesFB;
+
+typedef struct XrSystemSpatialAnchorPropertiesBD
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsSpatialAnchor;
+} XrSystemSpatialAnchorPropertiesBD;
+
+typedef struct XrSystemSpatialAnchorSharingPropertiesBD
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsSpatialAnchorSharing;
+} XrSystemSpatialAnchorSharingPropertiesBD;
+
+typedef struct XrSystemSpatialEntityGroupSharingPropertiesMETA
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsSpatialEntityGroupSharing;
+} XrSystemSpatialEntityGroupSharingPropertiesMETA;
+
+typedef struct XrSystemSpatialEntityPropertiesFB
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 supportsSpatialEntity;
+} XrSystemSpatialEntityPropertiesFB;
+
+typedef struct XrSystemSpatialEntitySharingPropertiesMETA
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsSpatialEntitySharing;
+} XrSystemSpatialEntitySharingPropertiesMETA;
+
+typedef struct XrSystemSpatialMeshPropertiesBD
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsSpatialMesh;
+} XrSystemSpatialMeshPropertiesBD;
+
+typedef struct XrSystemSpatialPlanePropertiesBD
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsSpatialPlane;
+} XrSystemSpatialPlanePropertiesBD;
+
+typedef struct XrSystemSpatialScenePropertiesBD
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsSpatialScene;
+} XrSystemSpatialScenePropertiesBD;
+
+typedef struct XrSystemSpatialSensingPropertiesBD
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsSpatialSensing;
+} XrSystemSpatialSensingPropertiesBD;
+
+typedef struct XrSystemTrackablesPropertiesANDROID
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 supportsAnchor;
+    uint32_t maxAnchors;
+} XrSystemTrackablesPropertiesANDROID;
+
+typedef struct XrSystemTrackingProperties
+{
+    XrBool32 orientationTracking;
+    XrBool32 positionTracking;
+} XrSystemTrackingProperties;
+
+typedef struct XrSystemUserPresencePropertiesEXT
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsUserPresence;
+} XrSystemUserPresencePropertiesEXT;
+
+typedef struct XrSystemVirtualKeyboardPropertiesMETA
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 supportsVirtualKeyboard;
+} XrSystemVirtualKeyboardPropertiesMETA;
+
+typedef struct XrTrackableGetInfoANDROID
+{
+    XrStructureType type;
+    const void *next;
+    XrTrackableANDROID trackable;
+    XrSpace baseSpace;
+    XrTime time;
+} XrTrackableGetInfoANDROID;
+
+typedef struct XrTrackableMarkerDatabaseEntryANDROID
+{
+    int32_t id;
+    float edgeSize;
+} XrTrackableMarkerDatabaseEntryANDROID;
+
+typedef struct XrTrackableObjectConfigurationANDROID
+{
+    XrStructureType type;
+    void *next;
+    uint32_t labelCount;
+    const XrObjectLabelANDROID *activeLabels;
+} XrTrackableObjectConfigurationANDROID;
+
+typedef struct XrTrackableTrackerCreateInfoANDROID
+{
+    XrStructureType type;
+    const void *next;
+    XrTrackableTypeANDROID trackableType;
+} XrTrackableTrackerCreateInfoANDROID;
+
+typedef struct XrUnpersistSpatialEntityCompletionEXT
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    XrSpatialPersistenceContextResultEXT unpersistResult;
+} XrUnpersistSpatialEntityCompletionEXT;
+
+typedef struct XrUserCalibrationEnableEventsInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 enabled;
+} XrUserCalibrationEnableEventsInfoML;
+
+typedef struct XrUuid
+{
+    uint8_t data[XR_UUID_SIZE];
+} XrUuid;
+typedef XrUuid XrUuidEXT;
+
+
+typedef struct XrUuidMSFT
+{
+    uint8_t bytes[16];
+} XrUuidMSFT;
+
+typedef struct XrVector2f
+{
+    float x;
+    float y;
+} XrVector2f;
+
+typedef struct XrVector3f
+{
+    float x;
+    float y;
+    float z;
+} XrVector3f;
+
+typedef struct XrVector4f
+{
+    float x;
+    float y;
+    float z;
+    float w;
+} XrVector4f;
+
+typedef struct XrVector4sFB
+{
+    int16_t x;
+    int16_t y;
+    int16_t z;
+    int16_t w;
+} XrVector4sFB;
+
+typedef struct XrViewConfigurationDepthRangeEXT
+{
+    XrStructureType type;
+    void *next;
+    float recommendedNearZ;
+    float minNearZ;
+    float recommendedFarZ;
+    float maxFarZ;
+} XrViewConfigurationDepthRangeEXT;
+
+typedef struct XrViewConfigurationProperties
+{
+    XrStructureType type;
+    void *next;
+    XrViewConfigurationType viewConfigurationType;
+    XrBool32 fovMutable;
+} XrViewConfigurationProperties;
+
+typedef struct XrViewConfigurationView
+{
+    XrStructureType type;
+    void *next;
+    uint32_t recommendedImageRectWidth;
+    uint32_t maxImageRectWidth;
+    uint32_t recommendedImageRectHeight;
+    uint32_t maxImageRectHeight;
+    uint32_t recommendedSwapchainSampleCount;
+    uint32_t maxSwapchainSampleCount;
+} XrViewConfigurationView;
+
+typedef struct XrViewConfigurationViewFovEPIC
+{
+    XrStructureType type;
+    const void *next;
+    XrFovf recommendedFov;
+    XrFovf maxMutableFov;
+} XrViewConfigurationViewFovEPIC;
+
+typedef struct XrViewLocateFoveatedRenderingVARJO
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 foveatedRenderingActive;
+} XrViewLocateFoveatedRenderingVARJO;
+
+typedef struct XrViewLocateInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrViewConfigurationType viewConfigurationType;
+    XrTime displayTime;
+    XrSpace space;
+} XrViewLocateInfo;
+
+typedef struct XrViewState
+{
+    XrStructureType type;
+    void *next;
+    XrViewStateFlags WINE_XR_ALIGN(8) viewStateFlags;
+} XrViewState;
+
+typedef struct XrVirtualKeyboardAnimationStateMETA
+{
+    XrStructureType type;
+    void *next;
+    int32_t animationIndex;
+    float fraction;
+} XrVirtualKeyboardAnimationStateMETA;
+
+typedef struct XrVirtualKeyboardCreateInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+} XrVirtualKeyboardCreateInfoMETA;
+
+typedef struct XrVirtualKeyboardModelAnimationStatesMETA
+{
+    XrStructureType type;
+    void *next;
+    uint32_t stateCapacityInput;
+    uint32_t stateCountOutput;
+    XrVirtualKeyboardAnimationStateMETA *states;
+} XrVirtualKeyboardModelAnimationStatesMETA;
+
+typedef struct XrVirtualKeyboardModelVisibilitySetInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrBool32 visible;
+} XrVirtualKeyboardModelVisibilitySetInfoMETA;
+
+typedef struct XrVirtualKeyboardTextContextChangeInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    const char *textContext;
+} XrVirtualKeyboardTextContextChangeInfoMETA;
+
+typedef struct XrVirtualKeyboardTextureDataMETA
+{
+    XrStructureType type;
+    void *next;
+    uint32_t textureWidth;
+    uint32_t textureHeight;
+    uint32_t bufferCapacityInput;
+    uint32_t bufferCountOutput;
+    uint8_t *buffer;
+} XrVirtualKeyboardTextureDataMETA;
+
+typedef struct XrVisibilityMaskKHR
+{
+    XrStructureType type;
+    void *next;
+    uint32_t vertexCapacityInput;
+    uint32_t vertexCountOutput;
+    XrVector2f *vertices;
+    uint32_t indexCapacityInput;
+    uint32_t indexCountOutput;
+    uint32_t *indices;
+} XrVisibilityMaskKHR;
+
+typedef struct XrVisualMeshComputeLodInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrMeshComputeLodMSFT lod;
+} XrVisualMeshComputeLodInfoMSFT;
+
+typedef struct XrViveTrackerPathsHTCX
+{
+    XrStructureType type;
+    void *next;
+    XrPath persistentPath;
+    XrPath rolePath;
+} XrViveTrackerPathsHTCX;
+
+typedef struct XrVulkanDeviceCreateInfoKHR
+{
+    XrStructureType type;
+    const void *next;
+    XrSystemId systemId;
+    XrVulkanDeviceCreateFlagsKHR WINE_XR_ALIGN(8) createFlags;
+    PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;
+    VkPhysicalDevice vulkanPhysicalDevice;
+    const VkDeviceCreateInfo *vulkanCreateInfo;
+    const VkAllocationCallbacks *vulkanAllocator;
+} XrVulkanDeviceCreateInfoKHR;
+
+typedef struct XrVulkanGraphicsDeviceGetInfoKHR
+{
+    XrStructureType type;
+    const void *next;
+    XrSystemId systemId;
+    VkInstance vulkanInstance;
+} XrVulkanGraphicsDeviceGetInfoKHR;
+
+typedef struct XrVulkanInstanceCreateInfoKHR
+{
+    XrStructureType type;
+    const void *next;
+    XrSystemId systemId;
+    XrVulkanInstanceCreateFlagsKHR WINE_XR_ALIGN(8) createFlags;
+    PFN_vkGetInstanceProcAddr pfnGetInstanceProcAddr;
+    const VkInstanceCreateInfo *vulkanCreateInfo;
+    const VkAllocationCallbacks *vulkanAllocator;
+} XrVulkanInstanceCreateInfoKHR;
+
+typedef struct XrVulkanSwapchainCreateInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    VkImageCreateFlags additionalCreateFlags;
+    VkImageUsageFlags additionalUsageFlags;
+} XrVulkanSwapchainCreateInfoMETA;
+
+typedef struct XrVulkanSwapchainFormatListCreateInfoKHR
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t viewFormatCount;
+    const VkFormat *viewFormats;
+} XrVulkanSwapchainFormatListCreateInfoKHR;
+
+typedef struct XrWorldMeshBlockML
+{
+    XrStructureType type;
+    void *next;
+    XrUuidEXT uuid;
+    XrWorldMeshBlockResultML blockResult;
+    XrWorldMeshDetectorLodML lod;
+    XrWorldMeshDetectorFlagsML WINE_XR_ALIGN(8) flags;
+    uint32_t indexCount;
+    uint16_t *indexBuffer;
+    uint32_t vertexCount;
+    XrVector3f *vertexBuffer;
+    uint32_t normalCount;
+    XrVector3f *normalBuffer;
+    uint32_t confidenceCount;
+    float *confidenceBuffer;
+} XrWorldMeshBlockML;
+
+typedef struct XrWorldMeshBlockRequestML
+{
+    XrStructureType type;
+    void *next;
+    XrUuidEXT uuid;
+    XrWorldMeshDetectorLodML lod;
+} XrWorldMeshBlockRequestML;
+
+typedef struct XrWorldMeshBufferML
+{
+    XrStructureType type;
+    void *next;
+    uint32_t bufferSize;
+    void *buffer;
+} XrWorldMeshBufferML;
+
+typedef struct XrWorldMeshBufferRecommendedSizeInfoML
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t maxBlockCount;
+} XrWorldMeshBufferRecommendedSizeInfoML;
+
+typedef struct XrWorldMeshBufferSizeML
+{
+    XrStructureType type;
+    void *next;
+    uint32_t size;
+} XrWorldMeshBufferSizeML;
+
+typedef struct XrWorldMeshDetectorCreateInfoML
+{
+    XrStructureType type;
+    const void *next;
+} XrWorldMeshDetectorCreateInfoML;
+
+typedef struct XrWorldMeshGetInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrWorldMeshDetectorFlagsML WINE_XR_ALIGN(8) flags;
+    float fillHoleLength;
+    float disconnectedComponentArea;
+    uint32_t blockCount;
+    XrWorldMeshBlockRequestML *blocks;
+} XrWorldMeshGetInfoML;
+
+typedef struct XrWorldMeshRequestCompletionInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace meshSpace;
+    XrTime meshSpaceLocateTime;
+} XrWorldMeshRequestCompletionInfoML;
+
+typedef struct XrWorldMeshRequestCompletionML
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    uint32_t blockCount;
+    XrWorldMeshBlockML *blocks;
+} XrWorldMeshRequestCompletionML;
+
+typedef struct XrActionStateVector2f
+{
+    XrStructureType type;
+    void *next;
+    XrVector2f currentState;
+    XrBool32 changedSinceLastSync;
+    XrTime lastChangeTime;
+    XrBool32 isActive;
+} XrActionStateVector2f;
+
+typedef struct XrActionsSyncInfo
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t countActiveActionSets;
+    const XrActiveActionSet *activeActionSets;
+} XrActionsSyncInfo;
+
+typedef struct XrActiveActionSetPrioritiesEXT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t actionSetPriorityCount;
+    const XrActiveActionSetPriorityEXT *actionSetPriorities;
+} XrActiveActionSetPrioritiesEXT;
+
+typedef struct XrApiLayerCreateInfo
+{
+    XrLoaderInterfaceStructs structType;
+    uint32_t structVersion;
+    size_t structSize;
+    void *loaderInstance;
+    char settings_file_location[XR_API_LAYER_MAX_SETTINGS_PATH_SIZE];
+    XrApiLayerNextInfo *nextInfo;
+} XrApiLayerCreateInfo;
+
+typedef struct XrBoundary2DFB
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t vertexCapacityInput;
+    uint32_t vertexCountOutput;
+    XrVector2f *vertices;
+} XrBoundary2DFB;
+
+typedef struct XrCompositionLayerCubeKHR
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerFlags WINE_XR_ALIGN(8) layerFlags;
+    XrSpace space;
+    XrEyeVisibility eyeVisibility;
+    XrSwapchain swapchain;
+    uint32_t imageArrayIndex;
+    XrQuaternionf orientation;
+} XrCompositionLayerCubeKHR;
+
+typedef struct XrCompositionLayerDepthInfoKHR
+{
+    XrStructureType type;
+    const void *next;
+    XrSwapchainSubImage subImage;
+    float minDepth;
+    float maxDepth;
+    float nearZ;
+    float farZ;
+} XrCompositionLayerDepthInfoKHR;
+
+typedef struct XrCompositionLayerPassthroughHTC
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerFlags WINE_XR_ALIGN(8) layerFlags;
+    XrSpace space;
+    XrPassthroughHTC passthrough;
+    XrPassthroughColorHTC color;
+} XrCompositionLayerPassthroughHTC;
+
+typedef struct XrCompositionLayerReprojectionPlaneOverrideMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrVector3f position;
+    XrVector3f normal;
+    XrVector3f velocity;
+} XrCompositionLayerReprojectionPlaneOverrideMSFT;
+
+typedef struct XrEventDataColocationDiscoveryResultMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB discoveryRequestId;
+    XrUuid advertisementUuid;
+    uint32_t bufferSize;
+    uint8_t buffer[XR_MAX_COLOCATION_DISCOVERY_BUFFER_SIZE_META];
+} XrEventDataColocationDiscoveryResultMETA;
+
+typedef struct XrEventDataSpaceEraseCompleteFB
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+    XrSpace space;
+    XrUuidEXT uuid;
+    XrSpaceStorageLocationFB location;
+} XrEventDataSpaceEraseCompleteFB;
+
+typedef struct XrEventDataSpaceSaveCompleteFB
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+    XrSpace space;
+    XrUuidEXT uuid;
+    XrSpaceStorageLocationFB location;
+} XrEventDataSpaceSaveCompleteFB;
+
+typedef struct XrEventDataSpaceSetStatusCompleteFB
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+    XrSpace space;
+    XrUuidEXT uuid;
+    XrSpaceComponentTypeFB componentType;
+    XrBool32 enabled;
+} XrEventDataSpaceSetStatusCompleteFB;
+
+typedef struct XrEventDataSpatialAnchorCreateCompleteFB
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB requestId;
+    XrResult result;
+    XrSpace space;
+    XrUuidEXT uuid;
+} XrEventDataSpatialAnchorCreateCompleteFB;
+
+typedef struct XrEventDataStartColocationAdvertisementCompleteMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrAsyncRequestIdFB advertisementRequestId;
+    XrResult result;
+    XrUuid advertisementUuid;
+} XrEventDataStartColocationAdvertisementCompleteMETA;
+
+typedef struct XrEventDataViveTrackerConnectedHTCX
+{
+    XrStructureType type;
+    const void *next;
+    XrViveTrackerPathsHTCX *paths;
+} XrEventDataViveTrackerConnectedHTCX;
+
+typedef struct XrExternalCameraIntrinsicsOCULUS
+{
+    XrTime lastChangeTime;
+    XrFovf fov;
+    float virtualNearPlaneDistance;
+    float virtualFarPlaneDistance;
+    XrExtent2Di imageSensorPixelResolution;
+} XrExternalCameraIntrinsicsOCULUS;
+
+typedef struct XrFoveationEyeTrackedStateMETA
+{
+    XrStructureType type;
+    void *next;
+    XrVector2f foveationCenter[XR_FOVEATION_CENTER_SIZE_META];
+    XrFoveationEyeTrackedStateFlagsMETA WINE_XR_ALIGN(8) flags;
+} XrFoveationEyeTrackedStateMETA;
+
+typedef struct XrHandCapsuleFB
+{
+    XrVector3f points[XR_HAND_TRACKING_CAPSULE_POINT_COUNT_FB];
+    float radius;
+    XrHandJointEXT joint;
+} XrHandCapsuleFB;
+
+typedef struct XrHandJointVelocityEXT
+{
+    XrSpaceVelocityFlags WINE_XR_ALIGN(8) velocityFlags;
+    XrVector3f linearVelocity;
+    XrVector3f angularVelocity;
+} XrHandJointVelocityEXT;
+
+typedef struct XrHandMeshVertexMSFT
+{
+    XrVector3f position;
+    XrVector3f normal;
+} XrHandMeshVertexMSFT;
+
+typedef struct XrHandTrackingCapsulesStateFB
+{
+    XrStructureType type;
+    void *next;
+    XrHandCapsuleFB capsules[XR_HAND_TRACKING_CAPSULE_COUNT_FB];
+} XrHandTrackingCapsulesStateFB;
+
+typedef struct XrKeyboardTrackingDescriptionFB
+{
+    uint64_t WINE_XR_ALIGN(8) trackedKeyboardId;
+    XrVector3f size;
+    XrKeyboardTrackingFlagsFB WINE_XR_ALIGN(8) flags;
+    char name[XR_MAX_KEYBOARD_TRACKING_NAME_SIZE_FB];
+} XrKeyboardTrackingDescriptionFB;
+
+typedef struct XrLoaderInitInfoPropertiesEXT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t propertyValueCount;
+    const XrLoaderInitPropertyValueEXT *propertyValues;
+} XrLoaderInitInfoPropertiesEXT;
+
+typedef struct XrLocalizationMapML
+{
+    XrStructureType type;
+    void *next;
+    char name[XR_MAX_LOCALIZATION_MAP_NAME_LENGTH_ML];
+    XrUuidEXT mapUuid;
+    XrLocalizationMapTypeML mapType;
+} XrLocalizationMapML;
+
+typedef struct XrMapLocalizationRequestInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrUuidEXT mapUuid;
+} XrMapLocalizationRequestInfoML;
+
+typedef struct XrPassthroughColorLutCreateInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughColorLutChannelsMETA channels;
+    uint32_t resolution;
+    XrPassthroughColorLutDataMETA data;
+} XrPassthroughColorLutCreateInfoMETA;
+
+typedef struct XrPersistSpatialEntityCompletionEXT
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    XrSpatialPersistenceContextResultEXT persistResult;
+    XrUuid persistUuid;
+} XrPersistSpatialEntityCompletionEXT;
+
+typedef struct XrPersistedAnchorSpaceCreateInfoANDROID
+{
+    XrStructureType type;
+    const void *next;
+    XrUuidEXT anchorId;
+} XrPersistedAnchorSpaceCreateInfoANDROID;
+
+typedef struct XrPlaneDetectorPolygonBufferEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t vertexCapacityInput;
+    uint32_t vertexCountOutput;
+    XrVector2f *vertices;
+} XrPlaneDetectorPolygonBufferEXT;
+
+typedef struct XrPosef
+{
+    XrQuaternionf orientation;
+    XrVector3f position;
+} XrPosef;
+
+typedef struct XrRaycastHitResultANDROID
+{
+    XrTrackableTypeANDROID type;
+    XrTrackableANDROID trackable;
+    XrPosef pose;
+} XrRaycastHitResultANDROID;
+
+typedef struct XrRaycastHitResultsANDROID
+{
+    XrStructureType type;
+    void *next;
+    uint32_t resultsCapacityInput;
+    uint32_t resultsCountOutput;
+    XrRaycastHitResultANDROID *results;
+} XrRaycastHitResultsANDROID;
+
+typedef struct XrRaycastInfoANDROID
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t maxResults;
+    uint32_t trackerCount;
+    const XrTrackableTrackerANDROID *trackers;
+    XrVector3f origin;
+    XrVector3f trajectory;
+    XrSpace space;
+    XrTime time;
+} XrRaycastInfoANDROID;
+
+typedef struct XrReferenceSpaceCreateInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrReferenceSpaceType referenceSpaceType;
+    XrPosef poseInReferenceSpace;
+} XrReferenceSpaceCreateInfo;
+
+typedef struct XrRenderModelAssetCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrUuidEXT cacheId;
+} XrRenderModelAssetCreateInfoEXT;
+
+typedef struct XrRenderModelNodeStateEXT
+{
+    XrPosef nodePose;
+    XrBool32 isVisible;
+} XrRenderModelNodeStateEXT;
+
+typedef struct XrRenderModelPropertiesEXT
+{
+    XrStructureType type;
+    void *next;
+    XrUuidEXT cacheId;
+    uint32_t animatableNodeCount;
+} XrRenderModelPropertiesEXT;
+
+typedef struct XrRenderModelStateEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t nodeStateCount;
+    XrRenderModelNodeStateEXT *nodeStates;
+} XrRenderModelStateEXT;
+
+typedef struct XrRoomLayoutFB
+{
+    XrStructureType type;
+    const void *next;
+    XrUuidEXT floorUuid;
+    XrUuidEXT ceilingUuid;
+    uint32_t wallUuidCapacityInput;
+    uint32_t wallUuidCountOutput;
+    XrUuidEXT *wallUuids;
+} XrRoomLayoutFB;
+
+typedef struct XrSceneComponentLocationMSFT
+{
+    XrSpaceLocationFlags WINE_XR_ALIGN(8) flags;
+    XrPosef pose;
+} XrSceneComponentLocationMSFT;
+
+typedef struct XrSceneComponentLocationsMSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t locationCount;
+    XrSceneComponentLocationMSFT *locations;
+} XrSceneComponentLocationsMSFT;
+
+typedef struct XrSceneComponentMSFT
+{
+    XrSceneComponentTypeMSFT componentType;
+    XrUuidMSFT id;
+    XrUuidMSFT parentId;
+    XrTime updateTime;
+} XrSceneComponentMSFT;
+
+typedef struct XrSceneComponentParentFilterInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrUuidMSFT parentId;
+} XrSceneComponentParentFilterInfoMSFT;
+
+typedef struct XrSceneComponentsLocateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+    uint32_t componentIdCount;
+    const XrUuidMSFT *componentIds;
+} XrSceneComponentsLocateInfoMSFT;
+
+typedef struct XrSceneComponentsMSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t componentCapacityInput;
+    uint32_t componentCountOutput;
+    XrSceneComponentMSFT *components;
+} XrSceneComponentsMSFT;
+
+typedef struct XrSceneFrustumBoundMSFT
+{
+    XrPosef pose;
+    XrFovf fov;
+    float farDistance;
+} XrSceneFrustumBoundMSFT;
+
+typedef struct XrSceneMeshVertexBufferMSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t vertexCapacityInput;
+    uint32_t vertexCountOutput;
+    XrVector3f *vertices;
+} XrSceneMeshVertexBufferMSFT;
+
+typedef struct XrSceneOrientedBoxBoundMSFT
+{
+    XrPosef pose;
+    XrVector3f extents;
+} XrSceneOrientedBoxBoundMSFT;
+
+typedef struct XrSceneSphereBoundMSFT
+{
+    XrVector3f center;
+    float radius;
+} XrSceneSphereBoundMSFT;
+
+typedef struct XrSecondaryViewConfigurationFrameEndInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t viewConfigurationCount;
+    const XrSecondaryViewConfigurationLayerInfoMSFT *viewConfigurationLayersInfo;
+} XrSecondaryViewConfigurationFrameEndInfoMSFT;
+
+typedef struct XrSecondaryViewConfigurationFrameStateMSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t viewConfigurationCount;
+    XrSecondaryViewConfigurationStateMSFT *viewConfigurationStates;
+} XrSecondaryViewConfigurationFrameStateMSFT;
+
+typedef struct XrSenseDataFilterUuidBD
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t uuidCount;
+    const XrUuidEXT *uuids;
+} XrSenseDataFilterUuidBD;
+
+typedef struct XrSerializedSceneFragmentDataGetInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrUuidMSFT sceneFragmentId;
+} XrSerializedSceneFragmentDataGetInfoMSFT;
+
+typedef struct XrShareSpacesInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t spaceCount;
+    XrSpace *spaces;
+    const XrShareSpacesRecipientBaseHeaderMETA *recipientInfo;
+} XrShareSpacesInfoMETA;
+
+typedef struct XrShareSpacesRecipientGroupsMETA
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t groupCount;
+    XrUuid *groups;
+} XrShareSpacesRecipientGroupsMETA;
+
+typedef struct XrSharedSpatialAnchorDownloadInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrUuidEXT uuid;
+} XrSharedSpatialAnchorDownloadInfoBD;
+
+typedef struct XrSpaceContainerFB
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t uuidCapacityInput;
+    uint32_t uuidCountOutput;
+    XrUuidEXT *uuids;
+} XrSpaceContainerFB;
+
+typedef struct XrSpaceDiscoveryInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t filterCount;
+    const XrSpaceFilterBaseHeaderMETA * const *filters;
+} XrSpaceDiscoveryInfoMETA;
+
+typedef struct XrSpaceDiscoveryResultMETA
+{
+    XrSpace space;
+    XrUuidEXT uuid;
+} XrSpaceDiscoveryResultMETA;
+
+typedef struct XrSpaceDiscoveryResultsMETA
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t resultCapacityInput;
+    uint32_t resultCountOutput;
+    XrSpaceDiscoveryResultMETA *results;
+} XrSpaceDiscoveryResultsMETA;
+
+typedef struct XrSpaceFilterUuidMETA
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t uuidCount;
+    const XrUuidEXT *uuids;
+} XrSpaceFilterUuidMETA;
+
+typedef struct XrSpaceGroupUuidFilterInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrUuid groupUuid;
+} XrSpaceGroupUuidFilterInfoMETA;
+
+typedef struct XrSpaceLocation
+{
+    XrStructureType type;
+    void *next;
+    XrSpaceLocationFlags WINE_XR_ALIGN(8) locationFlags;
+    XrPosef pose;
+} XrSpaceLocation;
+
+typedef struct XrSpaceLocationData
+{
+    XrSpaceLocationFlags WINE_XR_ALIGN(8) locationFlags;
+    XrPosef pose;
+} XrSpaceLocationData;
+typedef XrSpaceLocationData XrSpaceLocationDataKHR;
+
+typedef struct XrSpaceLocations
+{
+    XrStructureType type;
+    void *next;
+    uint32_t locationCount;
+    XrSpaceLocationData *locations;
+} XrSpaceLocations;
+typedef XrSpaceLocations XrSpaceLocationsKHR;
+
+typedef struct XrSpaceQueryResultFB
+{
+    XrSpace space;
+    XrUuidEXT uuid;
+} XrSpaceQueryResultFB;
+
+typedef struct XrSpaceQueryResultsFB
+{
+    XrStructureType type;
+    void *next;
+    uint32_t resultCapacityInput;
+    uint32_t resultCountOutput;
+    XrSpaceQueryResultFB *results;
+} XrSpaceQueryResultsFB;
+
+typedef struct XrSpaceTriangleMeshMETA
+{
+    XrStructureType type;
+    void *next;
+    uint32_t vertexCapacityInput;
+    uint32_t vertexCountOutput;
+    XrVector3f *vertices;
+    uint32_t indexCapacityInput;
+    uint32_t indexCountOutput;
+    uint32_t *indices;
+} XrSpaceTriangleMeshMETA;
+
+typedef struct XrSpaceUuidFilterInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t uuidCount;
+    XrUuidEXT *uuids;
+} XrSpaceUuidFilterInfoFB;
+
+typedef struct XrSpaceVelocity
+{
+    XrStructureType type;
+    void *next;
+    XrSpaceVelocityFlags WINE_XR_ALIGN(8) velocityFlags;
+    XrVector3f linearVelocity;
+    XrVector3f angularVelocity;
+} XrSpaceVelocity;
+
+typedef struct XrSpaceVelocityData
+{
+    XrSpaceVelocityFlags WINE_XR_ALIGN(8) velocityFlags;
+    XrVector3f linearVelocity;
+    XrVector3f angularVelocity;
+} XrSpaceVelocityData;
+typedef XrSpaceVelocityData XrSpaceVelocityDataKHR;
+
+typedef struct XrSpacesEraseInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t spaceCount;
+    XrSpace *spaces;
+    uint32_t uuidCount;
+    XrUuidEXT *uuids;
+} XrSpacesEraseInfoMETA;
+
+typedef struct XrSpatialAnchorCompletionResultML
+{
+    XrUuidEXT uuid;
+    XrResult result;
+} XrSpatialAnchorCompletionResultML;
+
+typedef struct XrSpatialAnchorCreateCompletionBD
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    XrUuidEXT uuid;
+    XrAnchorBD anchor;
+} XrSpatialAnchorCreateCompletionBD;
+
+typedef struct XrSpatialAnchorCreateInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace space;
+    XrPosef pose;
+    XrTime time;
+} XrSpatialAnchorCreateInfoBD;
+
+typedef struct XrSpatialAnchorCreateInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+    XrPosef pose;
+} XrSpatialAnchorCreateInfoEXT;
+
+typedef struct XrSpatialAnchorCreateInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace space;
+    XrPosef poseInSpace;
+    XrTime time;
+} XrSpatialAnchorCreateInfoFB;
+
+typedef struct XrSpatialAnchorCreateInfoHTC
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace space;
+    XrPosef poseInSpace;
+    XrSpatialAnchorNameHTC name;
+} XrSpatialAnchorCreateInfoHTC;
+
+typedef struct XrSpatialAnchorCreateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace space;
+    XrPosef pose;
+    XrTime time;
+} XrSpatialAnchorCreateInfoMSFT;
+
+typedef struct XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore;
+    XrSpatialAnchorPersistenceNameMSFT spatialAnchorPersistenceName;
+} XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT;
+
+typedef struct XrSpatialAnchorPersistenceInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialAnchorPersistenceNameMSFT spatialAnchorPersistenceName;
+    XrSpatialAnchorMSFT spatialAnchor;
+} XrSpatialAnchorPersistenceInfoMSFT;
+
+typedef struct XrSpatialAnchorSpaceCreateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialAnchorMSFT anchor;
+    XrPosef poseInAnchorSpace;
+} XrSpatialAnchorSpaceCreateInfoMSFT;
+
+typedef struct XrSpatialAnchorsCreateInfoFromPoseML
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrPosef poseInBaseSpace;
+    XrTime time;
+} XrSpatialAnchorsCreateInfoFromPoseML;
+
+typedef struct XrSpatialAnchorsCreateInfoFromUuidsML
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialAnchorsStorageML storage;
+    uint32_t uuidCount;
+    const XrUuidEXT *uuids;
+} XrSpatialAnchorsCreateInfoFromUuidsML;
+
+typedef struct XrSpatialAnchorsDeleteCompletionDetailsML
+{
+    XrStructureType type;
+    void *next;
+    uint32_t resultCount;
+    XrSpatialAnchorCompletionResultML *results;
+} XrSpatialAnchorsDeleteCompletionDetailsML;
+
+typedef struct XrSpatialAnchorsDeleteInfoML
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t uuidCount;
+    const XrUuidEXT *uuids;
+} XrSpatialAnchorsDeleteInfoML;
+
+typedef struct XrSpatialAnchorsPublishCompletionDetailsML
+{
+    XrStructureType type;
+    void *next;
+    uint32_t resultCount;
+    XrSpatialAnchorCompletionResultML *results;
+} XrSpatialAnchorsPublishCompletionDetailsML;
+
+typedef struct XrSpatialAnchorsPublishCompletionML
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    uint32_t uuidCount;
+    XrUuidEXT *uuids;
+} XrSpatialAnchorsPublishCompletionML;
+
+typedef struct XrSpatialAnchorsQueryCompletionML
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    uint32_t uuidCapacityInput;
+    uint32_t uuidCountOutput;
+    XrUuidEXT *uuids;
+} XrSpatialAnchorsQueryCompletionML;
+
+typedef struct XrSpatialAnchorsQueryInfoRadiusML
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrVector3f center;
+    XrTime time;
+    float radius;
+} XrSpatialAnchorsQueryInfoRadiusML;
+
+typedef struct XrSpatialAnchorsUpdateExpirationCompletionDetailsML
+{
+    XrStructureType type;
+    void *next;
+    uint32_t resultCount;
+    XrSpatialAnchorCompletionResultML *results;
+} XrSpatialAnchorsUpdateExpirationCompletionDetailsML;
+
+typedef struct XrSpatialAnchorsUpdateExpirationInfoML
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t uuidCount;
+    const XrUuidEXT *uuids;
+    uint64_t WINE_XR_ALIGN(8) expiration;
+} XrSpatialAnchorsUpdateExpirationInfoML;
+
+typedef struct XrSpatialBounded2DDataEXT
+{
+    XrPosef center;
+    XrExtent2Df extents;
+} XrSpatialBounded2DDataEXT;
+
+typedef struct XrSpatialComponentAnchorListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t locationCount;
+    XrPosef *locations;
+} XrSpatialComponentAnchorListEXT;
+
+typedef struct XrSpatialComponentBounded2DListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t boundCount;
+    XrSpatialBounded2DDataEXT *bounds;
+} XrSpatialComponentBounded2DListEXT;
+
+typedef struct XrSpatialComponentMarkerListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t markerCount;
+    XrSpatialMarkerDataEXT *markers;
+} XrSpatialComponentMarkerListEXT;
+
+typedef struct XrSpatialDiscoveryPersistenceUuidFilterEXT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t persistedUuidCount;
+    const XrUuid *persistedUuids;
+} XrSpatialDiscoveryPersistenceUuidFilterEXT;
+
+typedef struct XrSpatialEntityComponentDataLocationBD
+{
+    XrStructureType type;
+    void *next;
+    XrSpaceLocation WINE_XR_ALIGN(8) location;
+} XrSpatialEntityComponentDataLocationBD;
+
+typedef struct XrSpatialEntityComponentDataPolygonBD
+{
+    XrStructureType type;
+    void *next;
+    uint32_t vertexCapacityInput;
+    uint32_t vertexCountOutput;
+    XrVector2f *vertices;
+} XrSpatialEntityComponentDataPolygonBD;
+
+typedef struct XrSpatialEntityComponentDataTriangleMeshBD
+{
+    XrStructureType type;
+    void *next;
+    uint32_t vertexCapacityInput;
+    uint32_t vertexCountOutput;
+    XrVector3f *vertices;
+    uint32_t indexCapacityInput;
+    uint32_t indexCountOutput;
+    uint16_t *indices;
+} XrSpatialEntityComponentDataTriangleMeshBD;
+
+typedef struct XrSpatialEntityStateBD
+{
+    XrStructureType type;
+    void *next;
+    XrSpatialEntityIdBD entityId;
+    XrTime lastUpdateTime;
+    XrUuidEXT uuid;
+} XrSpatialEntityStateBD;
+
+typedef struct XrSpatialEntityUnpersistInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrUuid persistUuid;
+} XrSpatialEntityUnpersistInfoEXT;
+
+typedef struct XrSpatialGraphNodeBindingPropertiesMSFT
+{
+    XrStructureType type;
+    void *next;
+    uint8_t nodeId[XR_GUID_SIZE_MSFT];
+    XrPosef poseInNodeSpace;
+} XrSpatialGraphNodeBindingPropertiesMSFT;
+
+typedef struct XrSpatialGraphNodeSpaceCreateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpatialGraphNodeTypeMSFT nodeType;
+    uint8_t nodeId[XR_GUID_SIZE_MSFT];
+    XrPosef pose;
+} XrSpatialGraphNodeSpaceCreateInfoMSFT;
+
+typedef struct XrSpatialGraphStaticNodeBindingCreateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace space;
+    XrPosef poseInSpace;
+    XrTime time;
+} XrSpatialGraphStaticNodeBindingCreateInfoMSFT;
+
+typedef struct XrSpatialMeshDataEXT
+{
+    XrPosef origin;
+    XrSpatialBufferEXT vertexBuffer;
+    XrSpatialBufferEXT indexBuffer;
+} XrSpatialMeshDataEXT;
+
+typedef struct XrSpatialPersistenceDataEXT
+{
+    XrUuid persistUuid;
+    XrSpatialPersistenceStateEXT persistState;
+} XrSpatialPersistenceDataEXT;
+
+typedef struct XrSpatialPolygon2DDataEXT
+{
+    XrPosef origin;
+    XrSpatialBufferEXT vertexBuffer;
+} XrSpatialPolygon2DDataEXT;
+
+typedef struct XrSpheref
+{
+    XrPosef center;
+    float radius;
+} XrSpheref;
+typedef XrSpheref XrSpherefKHR;
+
+typedef struct XrSystemHeadsetIdPropertiesMETA
+{
+    XrStructureType type;
+    void *next;
+    XrUuidEXT id;
+} XrSystemHeadsetIdPropertiesMETA;
+
+typedef struct XrSystemProperties
+{
+    XrStructureType type;
+    void *next;
+    XrSystemId systemId;
+    uint32_t vendorId;
+    char systemName[XR_MAX_SYSTEM_NAME_SIZE];
+    XrSystemGraphicsProperties graphicsProperties;
+    XrSystemTrackingProperties trackingProperties;
+} XrSystemProperties;
+
+typedef struct XrTrackableMarkerANDROID
+{
+    XrStructureType type;
+    void *next;
+    XrTrackingStateANDROID trackingState;
+    XrTime lastUpdatedTime;
+    XrTrackableMarkerDictionaryANDROID dictionary;
+    int32_t markerId;
+    XrPosef centerPose;
+    XrExtent2Df extents;
+} XrTrackableMarkerANDROID;
+
+typedef struct XrTrackableMarkerDatabaseANDROID
+{
+    XrTrackableMarkerDictionaryANDROID dictionary;
+    uint32_t entryCount;
+    const XrTrackableMarkerDatabaseEntryANDROID *entries;
+} XrTrackableMarkerDatabaseANDROID;
+
+typedef struct XrTrackableObjectANDROID
+{
+    XrStructureType type;
+    void *next;
+    XrTrackingStateANDROID trackingState;
+    XrPosef centerPose;
+    XrExtent3DfEXT extents;
+    XrObjectLabelANDROID objectLabel;
+    XrTime lastUpdatedTime;
+} XrTrackableObjectANDROID;
+
+typedef struct XrTrackablePlaneANDROID
+{
+    XrStructureType type;
+    void *next;
+    XrTrackingStateANDROID trackingState;
+    XrPosef centerPose;
+    XrExtent2Df extents;
+    XrPlaneTypeANDROID planeType;
+    XrPlaneLabelANDROID planeLabel;
+    XrTrackableANDROID subsumedByPlane;
+    XrTime lastUpdatedTime;
+    uint32_t vertexCapacityInput;
+    uint32_t *vertexCountOutput;
+    XrVector2f *vertices;
+} XrTrackablePlaneANDROID;
+
+typedef struct XrTriangleMeshCreateInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrTriangleMeshFlagsFB WINE_XR_ALIGN(8) flags;
+    XrWindingOrderFB windingOrder;
+    uint32_t vertexCount;
+    const XrVector3f *vertexBuffer;
+    uint32_t triangleCount;
+    const uint32_t *indexBuffer;
+} XrTriangleMeshCreateInfoFB;
+
+typedef struct XrView
+{
+    XrStructureType type;
+    void *next;
+    XrPosef pose;
+    XrFovf fov;
+} XrView;
+
+typedef struct XrVirtualKeyboardInputInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrVirtualKeyboardInputSourceMETA inputSource;
+    XrSpace inputSpace;
+    XrPosef inputPoseInSpace;
+    XrVirtualKeyboardInputStateFlagsMETA WINE_XR_ALIGN(8) inputState;
+} XrVirtualKeyboardInputInfoMETA;
+
+typedef struct XrVirtualKeyboardLocationInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrVirtualKeyboardLocationTypeMETA locationType;
+    XrSpace space;
+    XrPosef poseInSpace;
+    float scale;
+} XrVirtualKeyboardLocationInfoMETA;
+
+typedef struct XrVirtualKeyboardSpaceCreateInfoMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrVirtualKeyboardLocationTypeMETA locationType;
+    XrSpace space;
+    XrPosef poseInSpace;
+} XrVirtualKeyboardSpaceCreateInfoMETA;
+
+typedef struct XrWorldMeshBlockStateML
+{
+    XrStructureType type;
+    void *next;
+    XrUuidEXT uuid;
+    XrPosef meshBoundingBoxCenter;
+    XrExtent3DfEXT meshBoundingBoxExtents;
+    XrTime lastUpdateTime;
+    XrWorldMeshBlockStatusML status;
+} XrWorldMeshBlockStateML;
+
+typedef struct XrWorldMeshStateRequestCompletionML
+{
+    XrStructureType type;
+    void *next;
+    XrResult futureResult;
+    XrTime timestamp;
+    uint32_t meshBlockStateCapacityInput;
+    uint32_t meshBlockStateCountOutput;
+    XrWorldMeshBlockStateML *meshBlockStates;
+} XrWorldMeshStateRequestCompletionML;
+
+typedef struct XrWorldMeshStateRequestInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+    XrPosef boundingBoxCenter;
+    XrExtent3DfEXT boundingBoxExtents;
+} XrWorldMeshStateRequestInfoML;
+
+typedef struct XrActionSpaceCreateInfo
+{
+    XrStructureType type;
+    const void *next;
+    XrAction action;
+    XrPath subactionPath;
+    XrPosef poseInActionSpace;
+} XrActionSpaceCreateInfo;
+
+typedef struct XrAnchorSpaceCreateInfoANDROID
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace space;
+    XrTime time;
+    XrPosef pose;
+    XrTrackableANDROID trackable;
+} XrAnchorSpaceCreateInfoANDROID;
+
+typedef struct XrAnchorSpaceCreateInfoBD
+{
+    XrStructureType type;
+    const void *next;
+    XrAnchorBD anchor;
+    XrPosef poseInAnchorSpace;
+} XrAnchorSpaceCreateInfoBD;
+
+typedef struct XrBodyJointLocationBD
+{
+    XrSpaceLocationFlags WINE_XR_ALIGN(8) locationFlags;
+    XrPosef pose;
+} XrBodyJointLocationBD;
+
+typedef struct XrBodyJointLocationFB
+{
+    XrSpaceLocationFlags WINE_XR_ALIGN(8) locationFlags;
+    XrPosef pose;
+} XrBodyJointLocationFB;
+
+typedef struct XrBodyJointLocationHTC
+{
+    XrSpaceLocationFlags WINE_XR_ALIGN(8) locationFlags;
+    XrPosef pose;
+} XrBodyJointLocationHTC;
+
+typedef struct XrBodyJointLocationsBD
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 allJointPosesTracked;
+    uint32_t jointLocationCount;
+    XrBodyJointLocationBD *jointLocations;
+} XrBodyJointLocationsBD;
+
+typedef struct XrBodyJointLocationsFB
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 isActive;
+    float confidence;
+    uint32_t jointCount;
+    XrBodyJointLocationFB *jointLocations;
+    uint32_t skeletonChangedCount;
+    XrTime time;
+} XrBodyJointLocationsFB;
+
+typedef struct XrBodyJointLocationsHTC
+{
+    XrStructureType type;
+    void *next;
+    XrSpaceLocationFlags WINE_XR_ALIGN(8) combinedLocationFlags;
+    XrBodyJointConfidenceHTC confidenceLevel;
+    uint32_t jointLocationCount;
+    XrBodyJointLocationHTC *jointLocations;
+    uint32_t skeletonGenerationId;
+} XrBodyJointLocationsHTC;
+
+typedef struct XrBodySkeletonJointFB
+{
+    int32_t joint;
+    int32_t parentJoint;
+    XrPosef pose;
+} XrBodySkeletonJointFB;
+
+typedef struct XrBodySkeletonJointHTC
+{
+    XrPosef pose;
+} XrBodySkeletonJointHTC;
+
+typedef struct XrBoxf
+{
+    XrPosef center;
+    XrExtent3Df extents;
+} XrBoxf;
+typedef XrBoxf XrBoxfKHR;
+
+typedef struct XrCompositionLayerCylinderKHR
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerFlags WINE_XR_ALIGN(8) layerFlags;
+    XrSpace space;
+    XrEyeVisibility eyeVisibility;
+    XrSwapchainSubImage subImage;
+    XrPosef pose;
+    float radius;
+    float centralAngle;
+    float aspectRatio;
+} XrCompositionLayerCylinderKHR;
+
+typedef struct XrCompositionLayerEquirect2KHR
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerFlags WINE_XR_ALIGN(8) layerFlags;
+    XrSpace space;
+    XrEyeVisibility eyeVisibility;
+    XrSwapchainSubImage subImage;
+    XrPosef pose;
+    float radius;
+    float centralHorizontalAngle;
+    float upperVerticalAngle;
+    float lowerVerticalAngle;
+} XrCompositionLayerEquirect2KHR;
+
+typedef struct XrCompositionLayerEquirectKHR
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerFlags WINE_XR_ALIGN(8) layerFlags;
+    XrSpace space;
+    XrEyeVisibility eyeVisibility;
+    XrSwapchainSubImage subImage;
+    XrPosef pose;
+    float radius;
+    XrVector2f scale;
+    XrVector2f bias;
+} XrCompositionLayerEquirectKHR;
+
+typedef struct XrCompositionLayerProjectionView
+{
+    XrStructureType type;
+    const void *next;
+    XrPosef pose;
+    XrFovf fov;
+    XrSwapchainSubImage subImage;
+} XrCompositionLayerProjectionView;
+
+typedef struct XrCompositionLayerQuad
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerFlags WINE_XR_ALIGN(8) layerFlags;
+    XrSpace space;
+    XrEyeVisibility eyeVisibility;
+    XrSwapchainSubImage subImage;
+    XrPosef pose;
+    XrExtent2Df size;
+} XrCompositionLayerQuad;
+
+typedef struct XrCompositionLayerSpaceWarpInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerSpaceWarpInfoFlagsFB WINE_XR_ALIGN(8) layerFlags;
+    XrSwapchainSubImage motionVectorSubImage;
+    XrPosef appSpaceDeltaPose;
+    XrSwapchainSubImage depthSubImage;
+    float minDepth;
+    float maxDepth;
+    float nearZ;
+    float farZ;
+} XrCompositionLayerSpaceWarpInfoFB;
+
+typedef struct XrControllerModelNodeStateMSFT
+{
+    XrStructureType type;
+    void *next;
+    XrPosef nodePose;
+} XrControllerModelNodeStateMSFT;
+
+typedef struct XrControllerModelStateMSFT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t nodeCapacityInput;
+    uint32_t nodeCountOutput;
+    XrControllerModelNodeStateMSFT *nodeStates;
+} XrControllerModelStateMSFT;
+
+typedef struct XrEnvironmentDepthImageViewMETA
+{
+    XrStructureType type;
+    const void *next;
+    XrFovf fov;
+    XrPosef pose;
+} XrEnvironmentDepthImageViewMETA;
+
+typedef struct XrEventDataLocalizationChangedML
+{
+    XrStructureType type;
+    const void *next;
+    XrSession session;
+    XrLocalizationMapStateML state;
+    XrLocalizationMapML map;
+    XrLocalizationMapConfidenceML confidence;
+    XrLocalizationMapErrorFlagsML WINE_XR_ALIGN(8) errorFlags;
+} XrEventDataLocalizationChangedML;
+
+typedef struct XrEventDataReferenceSpaceChangePending
+{
+    XrStructureType type;
+    const void *next;
+    XrSession session;
+    XrReferenceSpaceType referenceSpaceType;
+    XrTime changeTime;
+    XrBool32 poseValid;
+    XrPosef poseInPreviousSpace;
+} XrEventDataReferenceSpaceChangePending;
+
+typedef struct XrExternalCameraExtrinsicsOCULUS
+{
+    XrTime lastChangeTime;
+    XrExternalCameraStatusFlagsOCULUS WINE_XR_ALIGN(8) cameraStatusFlags;
+    XrExternalCameraAttachedToDeviceOCULUS attachedToDevice;
+    XrPosef relativePose;
+} XrExternalCameraExtrinsicsOCULUS;
+
+typedef struct XrExternalCameraOCULUS
+{
+    XrStructureType type;
+    const void *next;
+    char name[XR_MAX_EXTERNAL_CAMERA_NAME_SIZE_OCULUS];
+    XrExternalCameraIntrinsicsOCULUS intrinsics;
+    XrExternalCameraExtrinsicsOCULUS WINE_XR_ALIGN(8) extrinsics;
+} XrExternalCameraOCULUS;
+
+typedef struct XrEyeGazeFB
+{
+    XrBool32 isValid;
+    XrPosef gazePose;
+    float gazeConfidence;
+} XrEyeGazeFB;
+
+typedef struct XrEyeGazesFB
+{
+    XrStructureType type;
+    void *next;
+    XrEyeGazeFB gaze[XR_EYE_POSITION_COUNT_FB];
+    XrTime time;
+} XrEyeGazesFB;
+
+typedef struct XrFrameSynthesisInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrFrameSynthesisInfoFlagsEXT WINE_XR_ALIGN(8) layerFlags;
+    XrSwapchainSubImage motionVectorSubImage;
+    XrVector4f motionVectorScale;
+    XrVector4f motionVectorOffset;
+    XrPosef appSpaceDeltaPose;
+    XrSwapchainSubImage depthSubImage;
+    float minDepth;
+    float maxDepth;
+    float nearZ;
+    float farZ;
+} XrFrameSynthesisInfoEXT;
+
+typedef struct XrFrustumf
+{
+    XrPosef pose;
+    XrFovf fov;
+    float nearZ;
+    float farZ;
+} XrFrustumf;
+typedef XrFrustumf XrFrustumfKHR;
+
+typedef struct XrGeometryInstanceCreateInfoFB
+{
+    XrStructureType type;
+    const void *next;
+    XrPassthroughLayerFB layer;
+    XrTriangleMeshFB mesh;
+    XrSpace baseSpace;
+    XrPosef pose;
+    XrVector3f scale;
+} XrGeometryInstanceCreateInfoFB;
+
+typedef struct XrGeometryInstanceTransformFB
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+    XrPosef pose;
+    XrVector3f scale;
+} XrGeometryInstanceTransformFB;
+
+typedef struct XrHandJointLocationEXT
+{
+    XrSpaceLocationFlags WINE_XR_ALIGN(8) locationFlags;
+    XrPosef pose;
+    float radius;
+} XrHandJointLocationEXT;
+
+typedef struct XrHandJointLocationsEXT
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 isActive;
+    uint32_t jointCount;
+    XrHandJointLocationEXT *jointLocations;
+} XrHandJointLocationsEXT;
+
+typedef struct XrHandJointVelocitiesEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t jointCount;
+    XrHandJointVelocityEXT *jointVelocities;
+} XrHandJointVelocitiesEXT;
+
+typedef struct XrHandMeshSpaceCreateInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    XrHandPoseTypeMSFT handPoseType;
+    XrPosef poseInHandMeshSpace;
+} XrHandMeshSpaceCreateInfoMSFT;
+
+typedef struct XrHandMeshVertexBufferMSFT
+{
+    XrTime vertexUpdateTime;
+    uint32_t vertexCapacityInput;
+    uint32_t vertexCountOutput;
+    XrHandMeshVertexMSFT *vertices;
+} XrHandMeshVertexBufferMSFT;
+
+typedef struct XrHandTrackingAimStateFB
+{
+    XrStructureType type;
+    void *next;
+    XrHandTrackingAimFlagsFB WINE_XR_ALIGN(8) status;
+    XrPosef aimPose;
+    float pinchStrengthIndex;
+    float pinchStrengthMiddle;
+    float pinchStrengthRing;
+    float pinchStrengthLittle;
+} XrHandTrackingAimStateFB;
+
+typedef struct XrHandTrackingMeshFB
+{
+    XrStructureType type;
+    void *next;
+    uint32_t jointCapacityInput;
+    uint32_t jointCountOutput;
+    XrPosef *jointBindPoses;
+    float *jointRadii;
+    XrHandJointEXT *jointParents;
+    uint32_t vertexCapacityInput;
+    uint32_t vertexCountOutput;
+    XrVector3f *vertexPositions;
+    XrVector3f *vertexNormals;
+    XrVector2f *vertexUVs;
+    XrVector4sFB *vertexBlendIndices;
+    XrVector4f *vertexBlendWeights;
+    uint32_t indexCapacityInput;
+    uint32_t indexCountOutput;
+    int16_t *indices;
+} XrHandTrackingMeshFB;
+
+typedef struct XrMarkerSpaceCreateInfoML
+{
+    XrStructureType type;
+    const void *next;
+    XrMarkerDetectorML markerDetector;
+    XrMarkerML marker;
+    XrPosef poseInMarkerSpace;
+} XrMarkerSpaceCreateInfoML;
+
+typedef struct XrMarkerSpaceCreateInfoVARJO
+{
+    XrStructureType type;
+    const void *next;
+    uint64_t WINE_XR_ALIGN(8) markerId;
+    XrPosef poseInMarkerSpace;
+} XrMarkerSpaceCreateInfoVARJO;
+
+typedef struct XrPassthroughMeshTransformInfoHTC
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t vertexCount;
+    const XrVector3f *vertices;
+    uint32_t indexCount;
+    const uint32_t *indices;
+    XrSpace baseSpace;
+    XrTime time;
+    XrPosef pose;
+    XrVector3f scale;
+} XrPassthroughMeshTransformInfoHTC;
+
+typedef struct XrPlaneDetectorBeginInfoEXT
+{
+    XrStructureType type;
+    const void *next;
+    XrSpace baseSpace;
+    XrTime time;
+    uint32_t orientationCount;
+    const XrPlaneDetectorOrientationEXT *orientations;
+    uint32_t semanticTypeCount;
+    const XrPlaneDetectorSemanticTypeEXT *semanticTypes;
+    uint32_t maxPlanes;
+    float minArea;
+    XrPosef boundingBoxPose;
+    XrExtent3DfEXT boundingBoxExtent;
+} XrPlaneDetectorBeginInfoEXT;
+
+typedef struct XrPlaneDetectorLocationEXT
+{
+    XrStructureType type;
+    void *next;
+    uint64_t WINE_XR_ALIGN(8) planeId;
+    XrSpaceLocationFlags WINE_XR_ALIGN(8) locationFlags;
+    XrPosef pose;
+    XrExtent2Df extents;
+    XrPlaneDetectorOrientationEXT orientation;
+    XrPlaneDetectorSemanticTypeEXT semanticType;
+    uint32_t polygonBufferCount;
+} XrPlaneDetectorLocationEXT;
+
+typedef struct XrPlaneDetectorLocationsEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t planeLocationCapacityInput;
+    uint32_t planeLocationCountOutput;
+    XrPlaneDetectorLocationEXT *planeLocations;
+} XrPlaneDetectorLocationsEXT;
+
+typedef struct XrQueriedSenseDataBD
+{
+    XrStructureType type;
+    void *next;
+    uint32_t stateCapacityInput;
+    uint32_t stateCountOutput;
+    XrSpatialEntityStateBD *states;
+} XrQueriedSenseDataBD;
+
+typedef struct XrSceneBoundsMSFT
+{
+    XrSpace space;
+    XrTime time;
+    uint32_t sphereCount;
+    const XrSceneSphereBoundMSFT *spheres;
+    uint32_t boxCount;
+    const XrSceneOrientedBoxBoundMSFT *boxes;
+    uint32_t frustumCount;
+    const XrSceneFrustumBoundMSFT *frustums;
+} XrSceneBoundsMSFT;
+
+typedef struct XrSpaceVelocities
+{
+    XrStructureType type;
+    void *next;
+    uint32_t velocityCount;
+    XrSpaceVelocityData *velocities;
+} XrSpaceVelocities;
+typedef XrSpaceVelocities XrSpaceVelocitiesKHR;
+
+typedef struct XrSpatialComponentBounded3DListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t boundCount;
+    XrBoxf *bounds;
+} XrSpatialComponentBounded3DListEXT;
+
+typedef struct XrSpatialComponentMesh2DListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t meshCount;
+    XrSpatialMeshDataEXT *meshes;
+} XrSpatialComponentMesh2DListEXT;
+
+typedef struct XrSpatialComponentMesh3DListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t meshCount;
+    XrSpatialMeshDataEXT *meshes;
+} XrSpatialComponentMesh3DListEXT;
+
+typedef struct XrSpatialComponentPersistenceListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t persistDataCount;
+    XrSpatialPersistenceDataEXT *persistData;
+} XrSpatialComponentPersistenceListEXT;
+
+typedef struct XrSpatialComponentPolygon2DListEXT
+{
+    XrStructureType type;
+    void *next;
+    uint32_t polygonCount;
+    XrSpatialPolygon2DDataEXT *polygons;
+} XrSpatialComponentPolygon2DListEXT;
+
+typedef struct XrSpatialEntityComponentDataBoundingBox3DBD
+{
+    XrStructureType type;
+    void *next;
+    XrBoxf boundingBox3D;
+} XrSpatialEntityComponentDataBoundingBox3DBD;
+
+typedef struct XrTrackableMarkerConfigurationANDROID
+{
+    XrStructureType type;
+    void *next;
+    XrTrackableMarkerTrackingModeANDROID trackingMode;
+    uint32_t databaseCount;
+    const XrTrackableMarkerDatabaseANDROID *databases;
+} XrTrackableMarkerConfigurationANDROID;
+
+typedef struct XrBodySkeletonFB
+{
+    XrStructureType type;
+    void *next;
+    uint32_t jointCount;
+    XrBodySkeletonJointFB *joints;
+} XrBodySkeletonFB;
+
+typedef struct XrBodySkeletonHTC
+{
+    XrStructureType type;
+    void *next;
+    uint32_t jointCount;
+    XrBodySkeletonJointHTC *joints;
+} XrBodySkeletonHTC;
+
+typedef struct XrCompositionLayerProjection
+{
+    XrStructureType type;
+    const void *next;
+    XrCompositionLayerFlags WINE_XR_ALIGN(8) layerFlags;
+    XrSpace space;
+    uint32_t viewCount;
+    const XrCompositionLayerProjectionView *views;
+} XrCompositionLayerProjection;
+
+typedef struct XrEnvironmentDepthImageMETA
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t swapchainIndex;
+    float nearZ;
+    float farZ;
+    XrEnvironmentDepthImageViewMETA views[2];
+} XrEnvironmentDepthImageMETA;
+
+typedef struct XrHandMeshMSFT
+{
+    XrStructureType type;
+    void *next;
+    XrBool32 isActive;
+    XrBool32 indexBufferChanged;
+    XrBool32 vertexBufferChanged;
+    XrHandMeshIndexBufferMSFT indexBuffer;
+    XrHandMeshVertexBufferMSFT vertexBuffer;
+} XrHandMeshMSFT;
+
+typedef struct XrNewSceneComputeInfoMSFT
+{
+    XrStructureType type;
+    const void *next;
+    uint32_t requestedFeatureCount;
+    const XrSceneComputeFeatureMSFT *requestedFeatures;
+    XrSceneComputeConsistencyMSFT consistency;
+    XrSceneBoundsMSFT bounds;
+} XrNewSceneComputeInfoMSFT;
+
+typedef XrResult (XRAPI_PTR *PFN_xrAcquireEnvironmentDepthImageMETA)(XrEnvironmentDepthProviderMETA, const XrEnvironmentDepthImageAcquireInfoMETA *, XrEnvironmentDepthImageMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrAcquireSwapchainImage)(XrSwapchain, const XrSwapchainImageAcquireInfo *, uint32_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrAllocateWorldMeshBufferML)(XrWorldMeshDetectorML, const XrWorldMeshBufferSizeML *, XrWorldMeshBufferML *);
+typedef XrResult (XRAPI_PTR *PFN_xrApplyForceFeedbackCurlMNDX)(XrHandTrackerEXT, const XrForceFeedbackCurlApplyLocationsMNDX *);
+typedef XrResult (XRAPI_PTR *PFN_xrApplyHapticFeedback)(XrSession, const XrHapticActionInfo *, const XrHapticBaseHeader *);
+typedef XrResult (XRAPI_PTR *PFN_xrAttachSessionActionSets)(XrSession, const XrSessionActionSetsAttachInfo *);
+typedef XrResult (XRAPI_PTR *PFN_xrBeginFrame)(XrSession, const XrFrameBeginInfo *);
+typedef XrResult (XRAPI_PTR *PFN_xrBeginPlaneDetectionEXT)(XrPlaneDetectorEXT, const XrPlaneDetectorBeginInfoEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrBeginSession)(XrSession, const XrSessionBeginInfo *);
+typedef XrResult (XRAPI_PTR *PFN_xrCancelFutureEXT)(XrInstance, const XrFutureCancelInfoEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCaptureSceneAsyncBD)(XrSenseDataProviderBD, const XrSceneCaptureInfoBD *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCaptureSceneCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrFutureCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrChangeVirtualKeyboardTextContextMETA)(XrVirtualKeyboardMETA, const XrVirtualKeyboardTextContextChangeInfoMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrClearSpatialAnchorStoreMSFT)(XrSpatialAnchorStoreConnectionMSFT);
+typedef XrResult (XRAPI_PTR *PFN_xrComputeNewSceneMSFT)(XrSceneObserverMSFT, const XrNewSceneComputeInfoMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrConvertTimeToWin32PerformanceCounterKHR)(XrInstance, XrTime, LARGE_INTEGER *);
+typedef XrResult (XRAPI_PTR *PFN_xrConvertWin32PerformanceCounterToTimeKHR)(XrInstance, const LARGE_INTEGER *, XrTime *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateAction)(XrActionSet, const XrActionCreateInfo *, XrAction *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateActionSet)(XrInstance, const XrActionSetCreateInfo *, XrActionSet *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateActionSpace)(XrSession, const XrActionSpaceCreateInfo *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateAnchorSpaceANDROID)(XrSession, const XrAnchorSpaceCreateInfoANDROID *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateAnchorSpaceBD)(XrSession, const XrAnchorSpaceCreateInfoBD *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateApiLayerInstance)(const XrInstanceCreateInfo *, const XrApiLayerCreateInfo *, XrInstance *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateBodyTrackerBD)(XrSession, const XrBodyTrackerCreateInfoBD *, XrBodyTrackerBD *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateBodyTrackerFB)(XrSession, const XrBodyTrackerCreateInfoFB *, XrBodyTrackerFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateBodyTrackerHTC)(XrSession, const XrBodyTrackerCreateInfoHTC *, XrBodyTrackerHTC *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateDeviceAnchorPersistenceANDROID)(XrSession, const XrDeviceAnchorPersistenceCreateInfoANDROID *, XrDeviceAnchorPersistenceANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateEnvironmentDepthProviderMETA)(XrSession, const XrEnvironmentDepthProviderCreateInfoMETA *, XrEnvironmentDepthProviderMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateEnvironmentDepthSwapchainMETA)(XrEnvironmentDepthProviderMETA, const XrEnvironmentDepthSwapchainCreateInfoMETA *, XrEnvironmentDepthSwapchainMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateExportedLocalizationMapML)(XrSession, const XrUuidEXT *, XrExportedLocalizationMapML *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateEyeTrackerFB)(XrSession, const XrEyeTrackerCreateInfoFB *, XrEyeTrackerFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateFaceTracker2FB)(XrSession, const XrFaceTrackerCreateInfo2FB *, XrFaceTracker2FB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateFaceTrackerFB)(XrSession, const XrFaceTrackerCreateInfoFB *, XrFaceTrackerFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateFacialExpressionClientML)(XrSession, const XrFacialExpressionClientCreateInfoML *, XrFacialExpressionClientML *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateFacialTrackerHTC)(XrSession, const XrFacialTrackerCreateInfoHTC *, XrFacialTrackerHTC *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateFoveationProfileFB)(XrSession, const XrFoveationProfileCreateInfoFB *, XrFoveationProfileFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateGeometryInstanceFB)(XrSession, const XrGeometryInstanceCreateInfoFB *, XrGeometryInstanceFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateHandMeshSpaceMSFT)(XrHandTrackerEXT, const XrHandMeshSpaceCreateInfoMSFT *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateHandTrackerEXT)(XrSession, const XrHandTrackerCreateInfoEXT *, XrHandTrackerEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateInstance)(const XrInstanceCreateInfo *, XrInstance *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateKeyboardSpaceFB)(XrSession, const XrKeyboardSpaceCreateInfoFB *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateMarkerDetectorML)(XrSession, const XrMarkerDetectorCreateInfoML *, XrMarkerDetectorML *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateMarkerSpaceML)(XrSession, const XrMarkerSpaceCreateInfoML *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateMarkerSpaceVARJO)(XrSession, const XrMarkerSpaceCreateInfoVARJO *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreatePassthroughColorLutMETA)(XrPassthroughFB, const XrPassthroughColorLutCreateInfoMETA *, XrPassthroughColorLutMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreatePassthroughFB)(XrSession, const XrPassthroughCreateInfoFB *, XrPassthroughFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreatePassthroughHTC)(XrSession, const XrPassthroughCreateInfoHTC *, XrPassthroughHTC *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreatePassthroughLayerFB)(XrSession, const XrPassthroughLayerCreateInfoFB *, XrPassthroughLayerFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreatePersistedAnchorSpaceANDROID)(XrDeviceAnchorPersistenceANDROID, const XrPersistedAnchorSpaceCreateInfoANDROID *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreatePlaneDetectorEXT)(XrSession, const XrPlaneDetectorCreateInfoEXT *, XrPlaneDetectorEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateReferenceSpace)(XrSession, const XrReferenceSpaceCreateInfo *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateRenderModelAssetEXT)(XrSession, const XrRenderModelAssetCreateInfoEXT *, XrRenderModelAssetEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateRenderModelEXT)(XrSession, const XrRenderModelCreateInfoEXT *, XrRenderModelEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateRenderModelSpaceEXT)(XrSession, const XrRenderModelSpaceCreateInfoEXT *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSceneMSFT)(XrSceneObserverMSFT, const XrSceneCreateInfoMSFT *, XrSceneMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSceneObserverMSFT)(XrSession, const XrSceneObserverCreateInfoMSFT *, XrSceneObserverMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSenseDataProviderBD)(XrSession, const XrSenseDataProviderCreateInfoBD *, XrSenseDataProviderBD *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSession)(XrInstance, const XrSessionCreateInfo *, XrSession *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpaceUserFB)(XrSession, const XrSpaceUserCreateInfoFB *, XrSpaceUserFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorAsyncBD)(XrSenseDataProviderBD, const XrSpatialAnchorCreateInfoBD *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrSpatialAnchorCreateCompletionBD *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorEXT)(XrSpatialContextEXT, const XrSpatialAnchorCreateInfoEXT *, XrSpatialEntityIdEXT *, XrSpatialEntityEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorFB)(XrSession, const XrSpatialAnchorCreateInfoFB *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorFromPersistedNameMSFT)(XrSession, const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT *, XrSpatialAnchorMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorHTC)(XrSession, const XrSpatialAnchorCreateInfoHTC *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorMSFT)(XrSession, const XrSpatialAnchorCreateInfoMSFT *, XrSpatialAnchorMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorSpaceMSFT)(XrSession, const XrSpatialAnchorSpaceCreateInfoMSFT *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorStoreConnectionMSFT)(XrSession, XrSpatialAnchorStoreConnectionMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorsAsyncML)(XrSession, const XrSpatialAnchorsCreateInfoBaseHeaderML *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorsCompleteML)(XrSession, XrFutureEXT, XrCreateSpatialAnchorsCompletionML *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialAnchorsStorageML)(XrSession, const XrSpatialAnchorsCreateStorageInfoML *, XrSpatialAnchorsStorageML *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialContextAsyncEXT)(XrSession, const XrSpatialContextCreateInfoEXT *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialContextCompleteEXT)(XrSession, XrFutureEXT, XrCreateSpatialContextCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialDiscoverySnapshotAsyncEXT)(XrSpatialContextEXT, const XrSpatialDiscoverySnapshotCreateInfoEXT *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialDiscoverySnapshotCompleteEXT)(XrSpatialContextEXT, const XrCreateSpatialDiscoverySnapshotCompletionInfoEXT *, XrCreateSpatialDiscoverySnapshotCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialEntityAnchorBD)(XrSenseDataProviderBD, const XrSpatialEntityAnchorCreateInfoBD *, XrAnchorBD *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialEntityFromIdEXT)(XrSpatialContextEXT, const XrSpatialEntityFromIdCreateInfoEXT *, XrSpatialEntityEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialGraphNodeSpaceMSFT)(XrSession, const XrSpatialGraphNodeSpaceCreateInfoMSFT *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialPersistenceContextAsyncEXT)(XrSession, const XrSpatialPersistenceContextCreateInfoEXT *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialPersistenceContextCompleteEXT)(XrSession, XrFutureEXT, XrCreateSpatialPersistenceContextCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSpatialUpdateSnapshotEXT)(XrSpatialContextEXT, const XrSpatialUpdateSnapshotCreateInfoEXT *, XrSpatialSnapshotEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateSwapchain)(XrSession, const XrSwapchainCreateInfo *, XrSwapchain *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateTrackableTrackerANDROID)(XrSession, const XrTrackableTrackerCreateInfoANDROID *, XrTrackableTrackerANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateTriangleMeshFB)(XrSession, const XrTriangleMeshCreateInfoFB *, XrTriangleMeshFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateVirtualKeyboardMETA)(XrSession, const XrVirtualKeyboardCreateInfoMETA *, XrVirtualKeyboardMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateVirtualKeyboardSpaceMETA)(XrSession, XrVirtualKeyboardMETA, const XrVirtualKeyboardSpaceCreateInfoMETA *, XrSpace *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateVulkanDeviceKHR)(XrInstance, const XrVulkanDeviceCreateInfoKHR *, VkDevice *, VkResult *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateVulkanInstanceKHR)(XrInstance, const XrVulkanInstanceCreateInfoKHR *, VkInstance *, VkResult *);
+typedef XrResult (XRAPI_PTR *PFN_xrCreateWorldMeshDetectorML)(XrSession, const XrWorldMeshDetectorCreateInfoML *, XrWorldMeshDetectorML *);
+typedef XrResult (XRAPI_PTR *PFN_xrDeleteSpatialAnchorsAsyncML)(XrSpatialAnchorsStorageML, const XrSpatialAnchorsDeleteInfoML *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrDeleteSpatialAnchorsCompleteML)(XrSpatialAnchorsStorageML, XrFutureEXT, XrSpatialAnchorsDeleteCompletionML *);
+typedef XrResult (XRAPI_PTR *PFN_xrDeserializeSceneMSFT)(XrSceneObserverMSFT, const XrSceneDeserializeInfoMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyAction)(XrAction);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyActionSet)(XrActionSet);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyAnchorBD)(XrAnchorBD);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyBodyTrackerBD)(XrBodyTrackerBD);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyBodyTrackerFB)(XrBodyTrackerFB);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyBodyTrackerHTC)(XrBodyTrackerHTC);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyDeviceAnchorPersistenceANDROID)(XrDeviceAnchorPersistenceANDROID);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyEnvironmentDepthProviderMETA)(XrEnvironmentDepthProviderMETA);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyEnvironmentDepthSwapchainMETA)(XrEnvironmentDepthSwapchainMETA);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyExportedLocalizationMapML)(XrExportedLocalizationMapML);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyEyeTrackerFB)(XrEyeTrackerFB);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyFaceTracker2FB)(XrFaceTracker2FB);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyFaceTrackerFB)(XrFaceTrackerFB);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyFacialExpressionClientML)(XrFacialExpressionClientML);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyFacialTrackerHTC)(XrFacialTrackerHTC);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyFoveationProfileFB)(XrFoveationProfileFB);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyGeometryInstanceFB)(XrGeometryInstanceFB);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyHandTrackerEXT)(XrHandTrackerEXT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyInstance)(XrInstance);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyMarkerDetectorML)(XrMarkerDetectorML);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyPassthroughColorLutMETA)(XrPassthroughColorLutMETA);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyPassthroughFB)(XrPassthroughFB);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyPassthroughHTC)(XrPassthroughHTC);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyPassthroughLayerFB)(XrPassthroughLayerFB);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyPlaneDetectorEXT)(XrPlaneDetectorEXT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyRenderModelAssetEXT)(XrRenderModelAssetEXT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyRenderModelEXT)(XrRenderModelEXT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySceneMSFT)(XrSceneMSFT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySceneObserverMSFT)(XrSceneObserverMSFT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySenseDataProviderBD)(XrSenseDataProviderBD);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySenseDataSnapshotBD)(XrSenseDataSnapshotBD);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySession)(XrSession);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySpace)(XrSpace);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySpaceUserFB)(XrSpaceUserFB);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySpatialAnchorMSFT)(XrSpatialAnchorMSFT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySpatialAnchorStoreConnectionMSFT)(XrSpatialAnchorStoreConnectionMSFT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySpatialAnchorsStorageML)(XrSpatialAnchorsStorageML);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySpatialContextEXT)(XrSpatialContextEXT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySpatialEntityEXT)(XrSpatialEntityEXT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySpatialGraphNodeBindingMSFT)(XrSpatialGraphNodeBindingMSFT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySpatialPersistenceContextEXT)(XrSpatialPersistenceContextEXT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySpatialSnapshotEXT)(XrSpatialSnapshotEXT);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroySwapchain)(XrSwapchain);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyTrackableTrackerANDROID)(XrTrackableTrackerANDROID);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyTriangleMeshFB)(XrTriangleMeshFB);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyVirtualKeyboardMETA)(XrVirtualKeyboardMETA);
+typedef XrResult (XRAPI_PTR *PFN_xrDestroyWorldMeshDetectorML)(XrWorldMeshDetectorML);
+typedef XrResult (XRAPI_PTR *PFN_xrDiscoverSpacesMETA)(XrSession, const XrSpaceDiscoveryInfoMETA *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrDownloadSharedSpatialAnchorAsyncBD)(XrSenseDataProviderBD, const XrSharedSpatialAnchorDownloadInfoBD *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrDownloadSharedSpatialAnchorCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrFutureCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnableLocalizationEventsML)(XrSession, const XrLocalizationEnableEventsInfoML *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnableUserCalibrationEventsML)(XrInstance, const XrUserCalibrationEnableEventsInfoML *);
+typedef XrResult (XRAPI_PTR *PFN_xrEndFrame)(XrSession, const XrFrameEndInfo *);
+typedef XrResult (XRAPI_PTR *PFN_xrEndSession)(XrSession);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateApiLayerProperties)(uint32_t, uint32_t *, XrApiLayerProperties *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateBoundSourcesForAction)(XrSession, const XrBoundSourcesForActionEnumerateInfo *, uint32_t, uint32_t *, XrPath *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateColorSpacesFB)(XrSession, uint32_t, uint32_t *, XrColorSpaceFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateDisplayRefreshRatesFB)(XrSession, uint32_t, uint32_t *, float *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateEnvironmentBlendModes)(XrInstance, XrSystemId, XrViewConfigurationType, uint32_t, uint32_t *, XrEnvironmentBlendMode *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateEnvironmentDepthSwapchainImagesMETA)(XrEnvironmentDepthSwapchainMETA, uint32_t, uint32_t *, XrSwapchainImageBaseHeader *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateExternalCamerasOCULUS)(XrSession, uint32_t, uint32_t *, XrExternalCameraOCULUS *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateInstanceExtensionProperties)(const char *, uint32_t, uint32_t *, XrExtensionProperties *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateInteractionRenderModelIdsEXT)(XrSession, const XrInteractionRenderModelIdsEnumerateInfoEXT *, uint32_t, uint32_t *, XrRenderModelIdEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumeratePerformanceMetricsCounterPathsMETA)(XrInstance, uint32_t, uint32_t *, XrPath *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumeratePersistedAnchorsANDROID)(XrDeviceAnchorPersistenceANDROID, uint32_t, uint32_t *, XrUuidEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumeratePersistedSpatialAnchorNamesMSFT)(XrSpatialAnchorStoreConnectionMSFT, uint32_t, uint32_t *, XrSpatialAnchorPersistenceNameMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateRaycastSupportedTrackableTypesANDROID)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrTrackableTypeANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateReferenceSpaces)(XrSession, uint32_t, uint32_t *, XrReferenceSpaceType *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateRenderModelPathsFB)(XrSession, uint32_t, uint32_t *, XrRenderModelPathInfoFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateRenderModelSubactionPathsEXT)(XrRenderModelEXT, const XrInteractionRenderModelSubactionPathInfoEXT *, uint32_t, uint32_t *, XrPath *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateReprojectionModesMSFT)(XrInstance, XrSystemId, XrViewConfigurationType, uint32_t, uint32_t *, XrReprojectionModeMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSceneComputeFeaturesMSFT)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrSceneComputeFeatureMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSpaceSupportedComponentsFB)(XrSpace, uint32_t, uint32_t *, XrSpaceComponentTypeFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSpatialCapabilitiesEXT)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrSpatialCapabilityEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSpatialCapabilityComponentTypesEXT)(XrInstance, XrSystemId, XrSpatialCapabilityEXT, XrSpatialCapabilityComponentTypesEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSpatialCapabilityFeaturesEXT)(XrInstance, XrSystemId, XrSpatialCapabilityEXT, uint32_t, uint32_t *, XrSpatialCapabilityFeatureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSpatialEntityComponentTypesBD)(XrSenseDataSnapshotBD, XrSpatialEntityIdBD, uint32_t, uint32_t *, XrSpatialEntityComponentTypeBD *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSpatialPersistenceScopesEXT)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrSpatialPersistenceScopeEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSupportedAnchorTrackableTypesANDROID)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrTrackableTypeANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSupportedPersistenceAnchorTypesANDROID)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrTrackableTypeANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSupportedTrackableTypesANDROID)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrTrackableTypeANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSwapchainFormats)(XrSession, uint32_t, uint32_t *, int64_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateSwapchainImages)(XrSwapchain, uint32_t, uint32_t *, XrSwapchainImageBaseHeader *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateViewConfigurationViews)(XrInstance, XrSystemId, XrViewConfigurationType, uint32_t, uint32_t *, XrViewConfigurationView *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateViewConfigurations)(XrInstance, XrSystemId, uint32_t, uint32_t *, XrViewConfigurationType *);
+typedef XrResult (XRAPI_PTR *PFN_xrEnumerateViveTrackerPathsHTCX)(XrInstance, uint32_t, uint32_t *, XrViveTrackerPathsHTCX *);
+typedef XrResult (XRAPI_PTR *PFN_xrEraseSpaceFB)(XrSession, const XrSpaceEraseInfoFB *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrEraseSpacesMETA)(XrSession, const XrSpacesEraseInfoMETA *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrFreeWorldMeshBufferML)(XrWorldMeshDetectorML, const XrWorldMeshBufferML *);
+typedef XrResult (XRAPI_PTR *PFN_xrGeometryInstanceSetTransformFB)(XrGeometryInstanceFB, const XrGeometryInstanceTransformFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetActionStateBoolean)(XrSession, const XrActionStateGetInfo *, XrActionStateBoolean *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetActionStateFloat)(XrSession, const XrActionStateGetInfo *, XrActionStateFloat *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetActionStatePose)(XrSession, const XrActionStateGetInfo *, XrActionStatePose *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetActionStateVector2f)(XrSession, const XrActionStateGetInfo *, XrActionStateVector2f *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetAllTrackablesANDROID)(XrTrackableTrackerANDROID, uint32_t, uint32_t *, XrTrackableANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetAnchorPersistStateANDROID)(XrDeviceAnchorPersistenceANDROID, const XrUuidEXT *, XrAnchorPersistStateANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetAnchorUuidBD)(XrAnchorBD, XrUuidEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetAudioInputDeviceGuidOculus)(XrInstance, wchar_t[]);
+typedef XrResult (XRAPI_PTR *PFN_xrGetAudioOutputDeviceGuidOculus)(XrInstance, wchar_t[]);
+typedef XrResult (XRAPI_PTR *PFN_xrGetBodySkeletonFB)(XrBodyTrackerFB, XrBodySkeletonFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetBodySkeletonHTC)(XrBodyTrackerHTC, XrSpace, uint32_t, XrBodySkeletonHTC *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetControllerModelKeyMSFT)(XrSession, XrPath, XrControllerModelKeyStateMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetControllerModelPropertiesMSFT)(XrSession, XrControllerModelKeyMSFT, XrControllerModelPropertiesMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetControllerModelStateMSFT)(XrSession, XrControllerModelKeyMSFT, XrControllerModelStateMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetCurrentInteractionProfile)(XrSession, XrPath, XrInteractionProfileState *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetD3D11GraphicsRequirementsKHR)(XrInstance, XrSystemId, XrGraphicsRequirementsD3D11KHR *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetD3D12GraphicsRequirementsKHR)(XrInstance, XrSystemId, XrGraphicsRequirementsD3D12KHR *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetDeviceSampleRateFB)(XrSession, const XrHapticActionInfo *, XrDevicePcmSampleRateGetInfoFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetDisplayRefreshRateFB)(XrSession, float *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetEnvironmentDepthSwapchainStateMETA)(XrEnvironmentDepthSwapchainMETA, XrEnvironmentDepthSwapchainStateMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetExportedLocalizationMapDataML)(XrExportedLocalizationMapML, uint32_t, uint32_t *, char *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetEyeGazesFB)(XrEyeTrackerFB, const XrEyeGazesInfoFB *, XrEyeGazesFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetFaceExpressionWeights2FB)(XrFaceTracker2FB, const XrFaceExpressionInfo2FB *, XrFaceExpressionWeights2FB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetFaceExpressionWeightsFB)(XrFaceTrackerFB, const XrFaceExpressionInfoFB *, XrFaceExpressionWeightsFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetFacialExpressionBlendShapePropertiesML)(XrFacialExpressionClientML, const XrFacialExpressionBlendShapeGetInfoML *, uint32_t, XrFacialExpressionBlendShapePropertiesML *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetFacialExpressionsHTC)(XrFacialTrackerHTC, XrFacialExpressionsHTC *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetFoveationEyeTrackedStateMETA)(XrSession, XrFoveationEyeTrackedStateMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetHandMeshFB)(XrHandTrackerEXT, XrHandTrackingMeshFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetInputSourceLocalizedName)(XrSession, const XrInputSourceLocalizedNameGetInfo *, uint32_t, uint32_t *, char *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetInstanceProcAddr)(XrInstance, const char *, PFN_xrVoidFunction *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetInstanceProperties)(XrInstance, XrInstanceProperties *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetMarkerDetectorStateML)(XrMarkerDetectorML, XrMarkerDetectorStateML *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetMarkerLengthML)(XrMarkerDetectorML, XrMarkerML, float *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetMarkerNumberML)(XrMarkerDetectorML, XrMarkerML, uint64_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetMarkerReprojectionErrorML)(XrMarkerDetectorML, XrMarkerML, float *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetMarkerSizeVARJO)(XrSession, uint64_t, XrExtent2Df *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetMarkerStringML)(XrMarkerDetectorML, XrMarkerML, uint32_t, uint32_t *, char *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetMarkersML)(XrMarkerDetectorML, uint32_t, uint32_t *, XrMarkerML *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetOpenGLGraphicsRequirementsKHR)(XrInstance, XrSystemId, XrGraphicsRequirementsOpenGLKHR *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetPassthroughCameraStateANDROID)(XrSession, const XrPassthroughCameraStateGetInfoANDROID *, XrPassthroughCameraStateANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetPassthroughPreferencesMETA)(XrSession, XrPassthroughPreferencesMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetPerformanceMetricsStateMETA)(XrSession, XrPerformanceMetricsStateMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetPlaneDetectionStateEXT)(XrPlaneDetectorEXT, XrPlaneDetectionStateEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetPlaneDetectionsEXT)(XrPlaneDetectorEXT, const XrPlaneDetectorGetInfoEXT *, XrPlaneDetectorLocationsEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetPlanePolygonBufferEXT)(XrPlaneDetectorEXT, uint64_t, uint32_t, XrPlaneDetectorPolygonBufferEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetQueriedSenseDataBD)(XrSenseDataSnapshotBD, XrQueriedSenseDataGetInfoBD *, XrQueriedSenseDataBD *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetRecommendedLayerResolutionMETA)(XrSession, const XrRecommendedLayerResolutionGetInfoMETA *, XrRecommendedLayerResolutionMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetReferenceSpaceBoundsRect)(XrSession, XrReferenceSpaceType, XrExtent2Df *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetRenderModelAssetDataEXT)(XrRenderModelAssetEXT, const XrRenderModelAssetDataGetInfoEXT *, XrRenderModelAssetDataEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetRenderModelAssetPropertiesEXT)(XrRenderModelAssetEXT, const XrRenderModelAssetPropertiesGetInfoEXT *, XrRenderModelAssetPropertiesEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetRenderModelPoseTopLevelUserPathEXT)(XrRenderModelEXT, const XrInteractionRenderModelTopLevelUserPathGetInfoEXT *, XrPath *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetRenderModelPropertiesEXT)(XrRenderModelEXT, const XrRenderModelPropertiesGetInfoEXT *, XrRenderModelPropertiesEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetRenderModelPropertiesFB)(XrSession, XrPath, XrRenderModelPropertiesFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetRenderModelStateEXT)(XrRenderModelEXT, const XrRenderModelStateGetInfoEXT *, XrRenderModelStateEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSceneComponentsMSFT)(XrSceneMSFT, const XrSceneComponentsGetInfoMSFT *, XrSceneComponentsMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSceneComputeStateMSFT)(XrSceneObserverMSFT, XrSceneComputeStateMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSceneMarkerDecodedStringMSFT)(XrSceneMSFT, const XrUuidMSFT *, uint32_t, uint32_t *, char *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSceneMarkerRawDataMSFT)(XrSceneMSFT, const XrUuidMSFT *, uint32_t, uint32_t *, uint8_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSceneMeshBuffersMSFT)(XrSceneMSFT, const XrSceneMeshBuffersGetInfoMSFT *, XrSceneMeshBuffersMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSenseDataProviderStateBD)(XrSenseDataProviderBD, XrSenseDataProviderStateBD *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSerializedSceneFragmentDataMSFT)(XrSceneMSFT, const XrSerializedSceneFragmentDataGetInfoMSFT *, uint32_t, uint32_t *, uint8_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpaceBoundary2DFB)(XrSession, XrSpace, XrBoundary2DFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpaceBoundingBox2DFB)(XrSession, XrSpace, XrRect2Df *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpaceBoundingBox3DFB)(XrSession, XrSpace, XrRect3DfFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpaceComponentStatusFB)(XrSpace, XrSpaceComponentTypeFB, XrSpaceComponentStatusFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpaceContainerFB)(XrSession, XrSpace, XrSpaceContainerFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpaceRoomLayoutFB)(XrSession, XrSpace, XrRoomLayoutFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpaceSemanticLabelsFB)(XrSession, XrSpace, XrSemanticLabelsFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpaceTriangleMeshMETA)(XrSpace, const XrSpaceTriangleMeshGetInfoMETA *, XrSpaceTriangleMeshMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpaceUserIdFB)(XrSpaceUserFB, XrSpaceUserIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpaceUuidFB)(XrSpace, XrUuidEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialAnchorNameHTC)(XrSpace, XrSpatialAnchorNameHTC *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialAnchorStateML)(XrSpace, XrSpatialAnchorStateML *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialBufferFloatEXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, float *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialBufferStringEXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, char *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialBufferUint16EXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, uint16_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialBufferUint32EXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, uint32_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialBufferUint8EXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, uint8_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialBufferVector2fEXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, XrVector2f *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialBufferVector3fEXT)(XrSpatialSnapshotEXT, const XrSpatialBufferGetInfoEXT *, uint32_t, uint32_t *, XrVector3f *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialEntityComponentDataBD)(XrSenseDataSnapshotBD, const XrSpatialEntityComponentGetInfoBD *, XrSpatialEntityComponentDataBaseHeaderBD *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialEntityUuidBD)(XrSenseDataSnapshotBD, XrSpatialEntityIdBD, XrUuidEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSpatialGraphNodeBindingPropertiesMSFT)(XrSpatialGraphNodeBindingMSFT, const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT *, XrSpatialGraphNodeBindingPropertiesMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSwapchainStateFB)(XrSwapchain, XrSwapchainStateBaseHeaderFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSystem)(XrInstance, const XrSystemGetInfo *, XrSystemId *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetSystemProperties)(XrInstance, XrSystemId, XrSystemProperties *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetTrackableMarkerANDROID)(XrTrackableTrackerANDROID, const XrTrackableGetInfoANDROID *, XrTrackableMarkerANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetTrackableObjectANDROID)(XrTrackableTrackerANDROID, const XrTrackableGetInfoANDROID *, XrTrackableObjectANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetTrackablePlaneANDROID)(XrTrackableTrackerANDROID, const XrTrackableGetInfoANDROID *, XrTrackablePlaneANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetViewConfigurationProperties)(XrInstance, XrSystemId, XrViewConfigurationType, XrViewConfigurationProperties *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVirtualKeyboardDirtyTexturesMETA)(XrVirtualKeyboardMETA, uint32_t, uint32_t *, uint64_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVirtualKeyboardModelAnimationStatesMETA)(XrVirtualKeyboardMETA, XrVirtualKeyboardModelAnimationStatesMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVirtualKeyboardScaleMETA)(XrVirtualKeyboardMETA, float *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVirtualKeyboardTextureDataMETA)(XrVirtualKeyboardMETA, uint64_t, XrVirtualKeyboardTextureDataMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVisibilityMaskKHR)(XrSession, XrViewConfigurationType, uint32_t, XrVisibilityMaskTypeKHR, XrVisibilityMaskKHR *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVulkanDeviceExtensionsKHR)(XrInstance, XrSystemId, uint32_t, uint32_t *, char *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVulkanGraphicsDevice2KHR)(XrInstance, const XrVulkanGraphicsDeviceGetInfoKHR *, VkPhysicalDevice *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVulkanGraphicsDeviceKHR)(XrInstance, XrSystemId, VkInstance, VkPhysicalDevice *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVulkanGraphicsRequirements2KHR)(XrInstance, XrSystemId, XrGraphicsRequirementsVulkanKHR *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVulkanGraphicsRequirementsKHR)(XrInstance, XrSystemId, XrGraphicsRequirementsVulkanKHR *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetVulkanInstanceExtensionsKHR)(XrInstance, XrSystemId, uint32_t, uint32_t *, char *);
+typedef XrResult (XRAPI_PTR *PFN_xrGetWorldMeshBufferRecommendSizeML)(XrWorldMeshDetectorML, const XrWorldMeshBufferRecommendedSizeInfoML *, XrWorldMeshBufferSizeML *);
+typedef XrResult (XRAPI_PTR *PFN_xrImportLocalizationMapML)(XrSession, const XrLocalizationMapImportInfoML *, XrUuidEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrLoadControllerModelMSFT)(XrSession, XrControllerModelKeyMSFT, uint32_t, uint32_t *, uint8_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrLoadRenderModelFB)(XrSession, const XrRenderModelLoadInfoFB *, XrRenderModelBufferFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrLocateBodyJointsBD)(XrBodyTrackerBD, const XrBodyJointsLocateInfoBD *, XrBodyJointLocationsBD *);
+typedef XrResult (XRAPI_PTR *PFN_xrLocateBodyJointsFB)(XrBodyTrackerFB, const XrBodyJointsLocateInfoFB *, XrBodyJointLocationsFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrLocateBodyJointsHTC)(XrBodyTrackerHTC, const XrBodyJointsLocateInfoHTC *, XrBodyJointLocationsHTC *);
+typedef XrResult (XRAPI_PTR *PFN_xrLocateHandJointsEXT)(XrHandTrackerEXT, const XrHandJointsLocateInfoEXT *, XrHandJointLocationsEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrLocateSceneComponentsMSFT)(XrSceneMSFT, const XrSceneComponentsLocateInfoMSFT *, XrSceneComponentLocationsMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrLocateSpace)(XrSpace, XrSpace, XrTime, XrSpaceLocation *);
+typedef XrResult (XRAPI_PTR *PFN_xrLocateSpaces)(XrSession, const XrSpacesLocateInfo *, XrSpaceLocations *);
+typedef XrResult (XRAPI_PTR *PFN_xrLocateSpacesKHR)(XrSession, const XrSpacesLocateInfo *, XrSpaceLocations *);
+typedef XrResult (XRAPI_PTR *PFN_xrLocateViews)(XrSession, const XrViewLocateInfo *, XrViewState *, uint32_t, uint32_t *, XrView *);
+typedef XrResult (XRAPI_PTR *PFN_xrNegotiateLoaderApiLayerInterface)(const XrNegotiateLoaderInfo *, const char *, XrNegotiateApiLayerRequest *);
+typedef XrResult (XRAPI_PTR *PFN_xrNegotiateLoaderRuntimeInterface)(const XrNegotiateLoaderInfo *, XrNegotiateRuntimeRequest *);
+typedef XrResult (XRAPI_PTR *PFN_xrPassthroughLayerPauseFB)(XrPassthroughLayerFB);
+typedef XrResult (XRAPI_PTR *PFN_xrPassthroughLayerResumeFB)(XrPassthroughLayerFB);
+typedef XrResult (XRAPI_PTR *PFN_xrPassthroughLayerSetKeyboardHandsIntensityFB)(XrPassthroughLayerFB, const XrPassthroughKeyboardHandsIntensityFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrPassthroughLayerSetStyleFB)(XrPassthroughLayerFB, const XrPassthroughStyleFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrPassthroughPauseFB)(XrPassthroughFB);
+typedef XrResult (XRAPI_PTR *PFN_xrPassthroughStartFB)(XrPassthroughFB);
+typedef XrResult (XRAPI_PTR *PFN_xrPathToString)(XrInstance, XrPath, uint32_t, uint32_t *, char *);
+typedef XrResult (XRAPI_PTR *PFN_xrPauseSimultaneousHandsAndControllersTrackingMETA)(XrSession, const XrSimultaneousHandsAndControllersTrackingPauseInfoMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrPerfSettingsSetPerformanceLevelEXT)(XrSession, XrPerfSettingsDomainEXT, XrPerfSettingsLevelEXT);
+typedef XrResult (XRAPI_PTR *PFN_xrPersistAnchorANDROID)(XrDeviceAnchorPersistenceANDROID, const XrPersistedAnchorSpaceInfoANDROID *, XrUuidEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrPersistSpatialAnchorAsyncBD)(XrSenseDataProviderBD, const XrSpatialAnchorPersistInfoBD *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrPersistSpatialAnchorCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrFutureCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrPersistSpatialAnchorMSFT)(XrSpatialAnchorStoreConnectionMSFT, const XrSpatialAnchorPersistenceInfoMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrPersistSpatialEntityAsyncEXT)(XrSpatialPersistenceContextEXT, const XrSpatialEntityPersistInfoEXT *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrPersistSpatialEntityCompleteEXT)(XrSpatialPersistenceContextEXT, XrFutureEXT, XrPersistSpatialEntityCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrPollEvent)(XrInstance, XrEventDataBuffer *);
+typedef XrResult (XRAPI_PTR *PFN_xrPollFutureEXT)(XrInstance, const XrFuturePollInfoEXT *, XrFuturePollResultEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrPublishSpatialAnchorsAsyncML)(XrSpatialAnchorsStorageML, const XrSpatialAnchorsPublishInfoML *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrPublishSpatialAnchorsCompleteML)(XrSpatialAnchorsStorageML, XrFutureEXT, XrSpatialAnchorsPublishCompletionML *);
+typedef XrResult (XRAPI_PTR *PFN_xrQueryLocalizationMapsML)(XrSession, const XrLocalizationMapQueryInfoBaseHeaderML *, uint32_t, uint32_t *, XrLocalizationMapML *);
+typedef XrResult (XRAPI_PTR *PFN_xrQueryPerformanceMetricsCounterMETA)(XrSession, XrPath, XrPerformanceMetricsCounterMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrQuerySenseDataAsyncBD)(XrSenseDataProviderBD, const XrSenseDataQueryInfoBD *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrQuerySenseDataCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrSenseDataQueryCompletionBD *);
+typedef XrResult (XRAPI_PTR *PFN_xrQuerySpacesFB)(XrSession, const XrSpaceQueryInfoBaseHeaderFB *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrQuerySpatialAnchorsAsyncML)(XrSpatialAnchorsStorageML, const XrSpatialAnchorsQueryInfoBaseHeaderML *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrQuerySpatialAnchorsCompleteML)(XrSpatialAnchorsStorageML, XrFutureEXT, XrSpatialAnchorsQueryCompletionML *);
+typedef XrResult (XRAPI_PTR *PFN_xrQuerySpatialComponentDataEXT)(XrSpatialSnapshotEXT, const XrSpatialComponentDataQueryConditionEXT *, XrSpatialComponentDataQueryResultEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrQuerySystemTrackedKeyboardFB)(XrSession, const XrKeyboardTrackingQueryFB *, XrKeyboardTrackingDescriptionFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrRaycastANDROID)(XrSession, const XrRaycastInfoANDROID *, XrRaycastHitResultsANDROID *);
+typedef XrResult (XRAPI_PTR *PFN_xrReleaseSwapchainImage)(XrSwapchain, const XrSwapchainImageReleaseInfo *);
+typedef XrResult (XRAPI_PTR *PFN_xrRequestDisplayRefreshRateFB)(XrSession, float);
+typedef XrResult (XRAPI_PTR *PFN_xrRequestExitSession)(XrSession);
+typedef XrResult (XRAPI_PTR *PFN_xrRequestMapLocalizationML)(XrSession, const XrMapLocalizationRequestInfoML *);
+typedef XrResult (XRAPI_PTR *PFN_xrRequestSceneCaptureFB)(XrSession, const XrSceneCaptureRequestInfoFB *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrRequestWorldMeshAsyncML)(XrWorldMeshDetectorML, const XrWorldMeshGetInfoML *, XrWorldMeshBufferML *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrRequestWorldMeshCompleteML)(XrWorldMeshDetectorML, const XrWorldMeshRequestCompletionInfoML *, XrFutureEXT, XrWorldMeshRequestCompletionML *);
+typedef XrResult (XRAPI_PTR *PFN_xrRequestWorldMeshStateAsyncML)(XrWorldMeshDetectorML, const XrWorldMeshStateRequestInfoML *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrRequestWorldMeshStateCompleteML)(XrWorldMeshDetectorML, XrFutureEXT, XrWorldMeshStateRequestCompletionML *);
+typedef XrResult (XRAPI_PTR *PFN_xrResetBodyTrackingCalibrationMETA)(XrBodyTrackerFB);
+typedef XrResult (XRAPI_PTR *PFN_xrResultToString)(XrInstance, XrResult, char[]);
+typedef XrResult (XRAPI_PTR *PFN_xrResumeSimultaneousHandsAndControllersTrackingMETA)(XrSession, const XrSimultaneousHandsAndControllersTrackingResumeInfoMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrRetrieveSpaceDiscoveryResultsMETA)(XrSession, XrAsyncRequestIdFB, XrSpaceDiscoveryResultsMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrRetrieveSpaceQueryResultsFB)(XrSession, XrAsyncRequestIdFB, XrSpaceQueryResultsFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrSaveSpaceFB)(XrSession, const XrSpaceSaveInfoFB *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrSaveSpaceListFB)(XrSession, const XrSpaceListSaveInfoFB *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrSaveSpacesMETA)(XrSession, const XrSpacesSaveInfoMETA *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrSendVirtualKeyboardInputMETA)(XrVirtualKeyboardMETA, const XrVirtualKeyboardInputInfoMETA *, XrPosef *);
+typedef XrResult (XRAPI_PTR *PFN_xrSetColorSpaceFB)(XrSession, const XrColorSpaceFB);
+typedef XrResult (XRAPI_PTR *PFN_xrSetDigitalLensControlALMALENCE)(XrSession, const XrDigitalLensControlALMALENCE *);
+typedef XrResult (XRAPI_PTR *PFN_xrSetEnvironmentDepthEstimationVARJO)(XrSession, XrBool32);
+typedef XrResult (XRAPI_PTR *PFN_xrSetEnvironmentDepthHandRemovalMETA)(XrEnvironmentDepthProviderMETA, const XrEnvironmentDepthHandRemovalSetInfoMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrSetInputDeviceActiveEXT)(XrSession, XrPath, XrPath, XrBool32);
+typedef XrResult (XRAPI_PTR *PFN_xrSetInputDeviceLocationEXT)(XrSession, XrPath, XrPath, XrSpace, XrPosef);
+typedef XrResult (XRAPI_PTR *PFN_xrSetInputDeviceStateBoolEXT)(XrSession, XrPath, XrPath, XrBool32);
+typedef XrResult (XRAPI_PTR *PFN_xrSetInputDeviceStateFloatEXT)(XrSession, XrPath, XrPath, float);
+typedef XrResult (XRAPI_PTR *PFN_xrSetInputDeviceStateVector2fEXT)(XrSession, XrPath, XrPath, XrVector2f);
+typedef XrResult (XRAPI_PTR *PFN_xrSetMarkerTrackingPredictionVARJO)(XrSession, uint64_t, XrBool32);
+typedef XrResult (XRAPI_PTR *PFN_xrSetMarkerTrackingTimeoutVARJO)(XrSession, uint64_t, XrDuration);
+typedef XrResult (XRAPI_PTR *PFN_xrSetMarkerTrackingVARJO)(XrSession, XrBool32);
+typedef XrResult (XRAPI_PTR *PFN_xrSetPerformanceMetricsStateMETA)(XrSession, const XrPerformanceMetricsStateMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrSetSpaceComponentStatusFB)(XrSpace, const XrSpaceComponentStatusSetInfoFB *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrSetSystemNotificationsML)(XrInstance, const XrSystemNotificationsSetInfoML *);
+typedef XrResult (XRAPI_PTR *PFN_xrSetTrackingOptimizationSettingsHintQCOM)(XrSession, XrTrackingOptimizationSettingsDomainQCOM, XrTrackingOptimizationSettingsHintQCOM);
+typedef XrResult (XRAPI_PTR *PFN_xrSetViewOffsetVARJO)(XrSession, float);
+typedef XrResult (XRAPI_PTR *PFN_xrSetVirtualKeyboardModelVisibilityMETA)(XrVirtualKeyboardMETA, const XrVirtualKeyboardModelVisibilitySetInfoMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrShareSpacesFB)(XrSession, const XrSpaceShareInfoFB *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrShareSpacesMETA)(XrSession, const XrShareSpacesInfoMETA *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrShareSpatialAnchorAsyncBD)(XrSenseDataProviderBD, const XrSpatialAnchorShareInfoBD *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrShareSpatialAnchorCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrFutureCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrSnapshotMarkerDetectorML)(XrMarkerDetectorML, XrMarkerDetectorSnapshotInfoML *);
+typedef XrResult (XRAPI_PTR *PFN_xrStartColocationAdvertisementMETA)(XrSession, const XrColocationAdvertisementStartInfoMETA *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrStartColocationDiscoveryMETA)(XrSession, const XrColocationDiscoveryStartInfoMETA *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrStartEnvironmentDepthProviderMETA)(XrEnvironmentDepthProviderMETA);
+typedef XrResult (XRAPI_PTR *PFN_xrStartSenseDataProviderAsyncBD)(XrSenseDataProviderBD, const XrSenseDataProviderStartInfoBD *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrStartSenseDataProviderCompleteBD)(XrSession, XrFutureEXT, XrFutureCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrStopColocationAdvertisementMETA)(XrSession, const XrColocationAdvertisementStopInfoMETA *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrStopColocationDiscoveryMETA)(XrSession, const XrColocationDiscoveryStopInfoMETA *, XrAsyncRequestIdFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrStopEnvironmentDepthProviderMETA)(XrEnvironmentDepthProviderMETA);
+typedef XrResult (XRAPI_PTR *PFN_xrStopHapticFeedback)(XrSession, const XrHapticActionInfo *);
+typedef XrResult (XRAPI_PTR *PFN_xrStopSenseDataProviderBD)(XrSenseDataProviderBD);
+typedef XrResult (XRAPI_PTR *PFN_xrStringToPath)(XrInstance, const char *, XrPath *);
+typedef XrResult (XRAPI_PTR *PFN_xrStructureTypeToString)(XrInstance, XrStructureType, char[]);
+typedef XrResult (XRAPI_PTR *PFN_xrStructureTypeToString2KHR)(XrInstance, XrStructureType, char[]);
+typedef XrResult (XRAPI_PTR *PFN_xrSuggestBodyTrackingCalibrationOverrideMETA)(XrBodyTrackerFB, const XrBodyTrackingCalibrationInfoMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrSuggestInteractionProfileBindings)(XrInstance, const XrInteractionProfileSuggestedBinding *);
+typedef XrResult (XRAPI_PTR *PFN_xrSuggestVirtualKeyboardLocationMETA)(XrVirtualKeyboardMETA, const XrVirtualKeyboardLocationInfoMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrSyncActions)(XrSession, const XrActionsSyncInfo *);
+typedef XrResult (XRAPI_PTR *PFN_xrThermalGetTemperatureTrendEXT)(XrSession, XrPerfSettingsDomainEXT, XrPerfSettingsNotificationLevelEXT *, float *, float *);
+typedef XrResult (XRAPI_PTR *PFN_xrTriangleMeshBeginUpdateFB)(XrTriangleMeshFB);
+typedef XrResult (XRAPI_PTR *PFN_xrTriangleMeshBeginVertexBufferUpdateFB)(XrTriangleMeshFB, uint32_t *);
+typedef XrResult (XRAPI_PTR *PFN_xrTriangleMeshEndUpdateFB)(XrTriangleMeshFB, uint32_t, uint32_t);
+typedef XrResult (XRAPI_PTR *PFN_xrTriangleMeshEndVertexBufferUpdateFB)(XrTriangleMeshFB);
+typedef XrResult (XRAPI_PTR *PFN_xrTriangleMeshGetIndexBufferFB)(XrTriangleMeshFB, uint32_t **);
+typedef XrResult (XRAPI_PTR *PFN_xrTriangleMeshGetVertexBufferFB)(XrTriangleMeshFB, XrVector3f **);
+typedef XrResult (XRAPI_PTR *PFN_xrTryCreateSpatialGraphStaticNodeBindingMSFT)(XrSession, const XrSpatialGraphStaticNodeBindingCreateInfoMSFT *, XrSpatialGraphNodeBindingMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrUnpersistAnchorANDROID)(XrDeviceAnchorPersistenceANDROID, const XrUuidEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrUnpersistSpatialAnchorAsyncBD)(XrSenseDataProviderBD, const XrSpatialAnchorUnpersistInfoBD *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrUnpersistSpatialAnchorCompleteBD)(XrSenseDataProviderBD, XrFutureEXT, XrFutureCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrUnpersistSpatialAnchorMSFT)(XrSpatialAnchorStoreConnectionMSFT, const XrSpatialAnchorPersistenceNameMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrUnpersistSpatialEntityAsyncEXT)(XrSpatialPersistenceContextEXT, const XrSpatialEntityUnpersistInfoEXT *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrUnpersistSpatialEntityCompleteEXT)(XrSpatialPersistenceContextEXT, XrFutureEXT, XrUnpersistSpatialEntityCompletionEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrUpdateHandMeshMSFT)(XrHandTrackerEXT, const XrHandMeshUpdateInfoMSFT *, XrHandMeshMSFT *);
+typedef XrResult (XRAPI_PTR *PFN_xrUpdatePassthroughColorLutMETA)(XrPassthroughColorLutMETA, const XrPassthroughColorLutUpdateInfoMETA *);
+typedef XrResult (XRAPI_PTR *PFN_xrUpdateSpatialAnchorsExpirationAsyncML)(XrSpatialAnchorsStorageML, const XrSpatialAnchorsUpdateExpirationInfoML *, XrFutureEXT *);
+typedef XrResult (XRAPI_PTR *PFN_xrUpdateSpatialAnchorsExpirationCompleteML)(XrSpatialAnchorsStorageML, XrFutureEXT, XrSpatialAnchorsUpdateExpirationCompletionML *);
+typedef XrResult (XRAPI_PTR *PFN_xrUpdateSwapchainFB)(XrSwapchain, const XrSwapchainStateBaseHeaderFB *);
+typedef XrResult (XRAPI_PTR *PFN_xrWaitFrame)(XrSession, const XrFrameWaitInfo *, XrFrameState *);
+typedef XrResult (XRAPI_PTR *PFN_xrWaitSwapchainImage)(XrSwapchain, const XrSwapchainImageWaitInfo *);
+
+#ifndef XR_NO_PROTOTYPES
+XrResult XRAPI_CALL xrAcquireEnvironmentDepthImageMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider, const XrEnvironmentDepthImageAcquireInfoMETA *acquireInfo, XrEnvironmentDepthImageMETA *environmentDepthImage);
+XrResult XRAPI_CALL xrAcquireSwapchainImage(XrSwapchain swapchain, const XrSwapchainImageAcquireInfo *acquireInfo, uint32_t *index);
+XrResult XRAPI_CALL xrAllocateWorldMeshBufferML(XrWorldMeshDetectorML detector, const XrWorldMeshBufferSizeML *size, XrWorldMeshBufferML *buffer);
+XrResult XRAPI_CALL xrApplyForceFeedbackCurlMNDX(XrHandTrackerEXT handTracker, const XrForceFeedbackCurlApplyLocationsMNDX *locations);
+XrResult XRAPI_CALL xrApplyHapticFeedback(XrSession session, const XrHapticActionInfo *hapticActionInfo, const XrHapticBaseHeader *hapticFeedback);
+XrResult XRAPI_CALL xrAttachSessionActionSets(XrSession session, const XrSessionActionSetsAttachInfo *attachInfo);
+XrResult XRAPI_CALL xrBeginFrame(XrSession session, const XrFrameBeginInfo *frameBeginInfo);
+XrResult XRAPI_CALL xrBeginPlaneDetectionEXT(XrPlaneDetectorEXT planeDetector, const XrPlaneDetectorBeginInfoEXT *beginInfo);
+XrResult XRAPI_CALL xrBeginSession(XrSession session, const XrSessionBeginInfo *beginInfo);
+XrResult XRAPI_CALL xrCancelFutureEXT(XrInstance instance, const XrFutureCancelInfoEXT *cancelInfo);
+XrResult XRAPI_CALL xrCaptureSceneAsyncBD(XrSenseDataProviderBD provider, const XrSceneCaptureInfoBD *info, XrFutureEXT *future);
+XrResult XRAPI_CALL xrCaptureSceneCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrFutureCompletionEXT *completion);
+XrResult XRAPI_CALL xrChangeVirtualKeyboardTextContextMETA(XrVirtualKeyboardMETA keyboard, const XrVirtualKeyboardTextContextChangeInfoMETA *changeInfo);
+XrResult XRAPI_CALL xrClearSpatialAnchorStoreMSFT(XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore);
+XrResult XRAPI_CALL xrComputeNewSceneMSFT(XrSceneObserverMSFT sceneObserver, const XrNewSceneComputeInfoMSFT *computeInfo);
+XrResult XRAPI_CALL xrConvertTimeToWin32PerformanceCounterKHR(XrInstance instance, XrTime time, LARGE_INTEGER *performanceCounter);
+XrResult XRAPI_CALL xrConvertWin32PerformanceCounterToTimeKHR(XrInstance instance, const LARGE_INTEGER *performanceCounter, XrTime *time);
+XrResult XRAPI_CALL xrCreateAction(XrActionSet actionSet, const XrActionCreateInfo *createInfo, XrAction *action);
+XrResult XRAPI_CALL xrCreateActionSet(XrInstance instance, const XrActionSetCreateInfo *createInfo, XrActionSet *actionSet);
+XrResult XRAPI_CALL xrCreateActionSpace(XrSession session, const XrActionSpaceCreateInfo *createInfo, XrSpace *space);
+XrResult XRAPI_CALL xrCreateAnchorSpaceANDROID(XrSession session, const XrAnchorSpaceCreateInfoANDROID *createInfo, XrSpace *anchorOutput);
+XrResult XRAPI_CALL xrCreateAnchorSpaceBD(XrSession session, const XrAnchorSpaceCreateInfoBD *createInfo, XrSpace *space);
+XrResult XRAPI_CALL xrCreateApiLayerInstance(const XrInstanceCreateInfo *info, const XrApiLayerCreateInfo *layerInfo, XrInstance *instance);
+XrResult XRAPI_CALL xrCreateBodyTrackerBD(XrSession session, const XrBodyTrackerCreateInfoBD *createInfo, XrBodyTrackerBD *bodyTracker);
+XrResult XRAPI_CALL xrCreateBodyTrackerFB(XrSession session, const XrBodyTrackerCreateInfoFB *createInfo, XrBodyTrackerFB *bodyTracker);
+XrResult XRAPI_CALL xrCreateBodyTrackerHTC(XrSession session, const XrBodyTrackerCreateInfoHTC *createInfo, XrBodyTrackerHTC *bodyTracker);
+XrResult XRAPI_CALL xrCreateDeviceAnchorPersistenceANDROID(XrSession session, const XrDeviceAnchorPersistenceCreateInfoANDROID *createInfo, XrDeviceAnchorPersistenceANDROID *outHandle);
+XrResult XRAPI_CALL xrCreateEnvironmentDepthProviderMETA(XrSession session, const XrEnvironmentDepthProviderCreateInfoMETA *createInfo, XrEnvironmentDepthProviderMETA *environmentDepthProvider);
+XrResult XRAPI_CALL xrCreateEnvironmentDepthSwapchainMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider, const XrEnvironmentDepthSwapchainCreateInfoMETA *createInfo, XrEnvironmentDepthSwapchainMETA *swapchain);
+XrResult XRAPI_CALL xrCreateExportedLocalizationMapML(XrSession session, const XrUuidEXT *mapUuid, XrExportedLocalizationMapML *map);
+XrResult XRAPI_CALL xrCreateEyeTrackerFB(XrSession session, const XrEyeTrackerCreateInfoFB *createInfo, XrEyeTrackerFB *eyeTracker);
+XrResult XRAPI_CALL xrCreateFaceTracker2FB(XrSession session, const XrFaceTrackerCreateInfo2FB *createInfo, XrFaceTracker2FB *faceTracker);
+XrResult XRAPI_CALL xrCreateFaceTrackerFB(XrSession session, const XrFaceTrackerCreateInfoFB *createInfo, XrFaceTrackerFB *faceTracker);
+XrResult XRAPI_CALL xrCreateFacialExpressionClientML(XrSession session, const XrFacialExpressionClientCreateInfoML *createInfo, XrFacialExpressionClientML *facialExpressionClient);
+XrResult XRAPI_CALL xrCreateFacialTrackerHTC(XrSession session, const XrFacialTrackerCreateInfoHTC *createInfo, XrFacialTrackerHTC *facialTracker);
+XrResult XRAPI_CALL xrCreateFoveationProfileFB(XrSession session, const XrFoveationProfileCreateInfoFB *createInfo, XrFoveationProfileFB *profile);
+XrResult XRAPI_CALL xrCreateGeometryInstanceFB(XrSession session, const XrGeometryInstanceCreateInfoFB *createInfo, XrGeometryInstanceFB *outGeometryInstance);
+XrResult XRAPI_CALL xrCreateHandMeshSpaceMSFT(XrHandTrackerEXT handTracker, const XrHandMeshSpaceCreateInfoMSFT *createInfo, XrSpace *space);
+XrResult XRAPI_CALL xrCreateHandTrackerEXT(XrSession session, const XrHandTrackerCreateInfoEXT *createInfo, XrHandTrackerEXT *handTracker);
+XrResult XRAPI_CALL xrCreateInstance(const XrInstanceCreateInfo *createInfo, XrInstance *instance);
+XrResult XRAPI_CALL xrCreateKeyboardSpaceFB(XrSession session, const XrKeyboardSpaceCreateInfoFB *createInfo, XrSpace *keyboardSpace);
+XrResult XRAPI_CALL xrCreateMarkerDetectorML(XrSession session, const XrMarkerDetectorCreateInfoML *createInfo, XrMarkerDetectorML *markerDetector);
+XrResult XRAPI_CALL xrCreateMarkerSpaceML(XrSession session, const XrMarkerSpaceCreateInfoML *createInfo, XrSpace *space);
+XrResult XRAPI_CALL xrCreateMarkerSpaceVARJO(XrSession session, const XrMarkerSpaceCreateInfoVARJO *createInfo, XrSpace *space);
+XrResult XRAPI_CALL xrCreatePassthroughColorLutMETA(XrPassthroughFB passthrough, const XrPassthroughColorLutCreateInfoMETA *createInfo, XrPassthroughColorLutMETA *colorLut);
+XrResult XRAPI_CALL xrCreatePassthroughFB(XrSession session, const XrPassthroughCreateInfoFB *createInfo, XrPassthroughFB *outPassthrough);
+XrResult XRAPI_CALL xrCreatePassthroughHTC(XrSession session, const XrPassthroughCreateInfoHTC *createInfo, XrPassthroughHTC *passthrough);
+XrResult XRAPI_CALL xrCreatePassthroughLayerFB(XrSession session, const XrPassthroughLayerCreateInfoFB *createInfo, XrPassthroughLayerFB *outLayer);
+XrResult XRAPI_CALL xrCreatePersistedAnchorSpaceANDROID(XrDeviceAnchorPersistenceANDROID handle, const XrPersistedAnchorSpaceCreateInfoANDROID *createInfo, XrSpace *anchorOutput);
+XrResult XRAPI_CALL xrCreatePlaneDetectorEXT(XrSession session, const XrPlaneDetectorCreateInfoEXT *createInfo, XrPlaneDetectorEXT *planeDetector);
+XrResult XRAPI_CALL xrCreateReferenceSpace(XrSession session, const XrReferenceSpaceCreateInfo *createInfo, XrSpace *space);
+XrResult XRAPI_CALL xrCreateRenderModelAssetEXT(XrSession session, const XrRenderModelAssetCreateInfoEXT *createInfo, XrRenderModelAssetEXT *asset);
+XrResult XRAPI_CALL xrCreateRenderModelEXT(XrSession session, const XrRenderModelCreateInfoEXT *createInfo, XrRenderModelEXT *renderModel);
+XrResult XRAPI_CALL xrCreateRenderModelSpaceEXT(XrSession session, const XrRenderModelSpaceCreateInfoEXT *createInfo, XrSpace *space);
+XrResult XRAPI_CALL xrCreateSceneMSFT(XrSceneObserverMSFT sceneObserver, const XrSceneCreateInfoMSFT *createInfo, XrSceneMSFT *scene);
+XrResult XRAPI_CALL xrCreateSceneObserverMSFT(XrSession session, const XrSceneObserverCreateInfoMSFT *createInfo, XrSceneObserverMSFT *sceneObserver);
+XrResult XRAPI_CALL xrCreateSenseDataProviderBD(XrSession session, const XrSenseDataProviderCreateInfoBD *createInfo, XrSenseDataProviderBD *provider);
+XrResult XRAPI_CALL xrCreateSession(XrInstance instance, const XrSessionCreateInfo *createInfo, XrSession *session);
+XrResult XRAPI_CALL xrCreateSpaceUserFB(XrSession session, const XrSpaceUserCreateInfoFB *info, XrSpaceUserFB *user);
+XrResult XRAPI_CALL xrCreateSpatialAnchorAsyncBD(XrSenseDataProviderBD provider, const XrSpatialAnchorCreateInfoBD *info, XrFutureEXT *future);
+XrResult XRAPI_CALL xrCreateSpatialAnchorCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrSpatialAnchorCreateCompletionBD *completion);
+XrResult XRAPI_CALL xrCreateSpatialAnchorEXT(XrSpatialContextEXT spatialContext, const XrSpatialAnchorCreateInfoEXT *createInfo, XrSpatialEntityIdEXT *anchorEntityId, XrSpatialEntityEXT *anchorEntity);
+XrResult XRAPI_CALL xrCreateSpatialAnchorFB(XrSession session, const XrSpatialAnchorCreateInfoFB *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrCreateSpatialAnchorFromPersistedNameMSFT(XrSession session, const XrSpatialAnchorFromPersistedAnchorCreateInfoMSFT *spatialAnchorCreateInfo, XrSpatialAnchorMSFT *spatialAnchor);
+XrResult XRAPI_CALL xrCreateSpatialAnchorHTC(XrSession session, const XrSpatialAnchorCreateInfoHTC *createInfo, XrSpace *anchor);
+XrResult XRAPI_CALL xrCreateSpatialAnchorMSFT(XrSession session, const XrSpatialAnchorCreateInfoMSFT *createInfo, XrSpatialAnchorMSFT *anchor);
+XrResult XRAPI_CALL xrCreateSpatialAnchorSpaceMSFT(XrSession session, const XrSpatialAnchorSpaceCreateInfoMSFT *createInfo, XrSpace *space);
+XrResult XRAPI_CALL xrCreateSpatialAnchorStoreConnectionMSFT(XrSession session, XrSpatialAnchorStoreConnectionMSFT *spatialAnchorStore);
+XrResult XRAPI_CALL xrCreateSpatialAnchorsAsyncML(XrSession session, const XrSpatialAnchorsCreateInfoBaseHeaderML *createInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrCreateSpatialAnchorsCompleteML(XrSession session, XrFutureEXT future, XrCreateSpatialAnchorsCompletionML *completion);
+XrResult XRAPI_CALL xrCreateSpatialAnchorsStorageML(XrSession session, const XrSpatialAnchorsCreateStorageInfoML *createInfo, XrSpatialAnchorsStorageML *storage);
+XrResult XRAPI_CALL xrCreateSpatialContextAsyncEXT(XrSession session, const XrSpatialContextCreateInfoEXT *createInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrCreateSpatialContextCompleteEXT(XrSession session, XrFutureEXT future, XrCreateSpatialContextCompletionEXT *completion);
+XrResult XRAPI_CALL xrCreateSpatialDiscoverySnapshotAsyncEXT(XrSpatialContextEXT spatialContext, const XrSpatialDiscoverySnapshotCreateInfoEXT *createInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrCreateSpatialDiscoverySnapshotCompleteEXT(XrSpatialContextEXT spatialContext, const XrCreateSpatialDiscoverySnapshotCompletionInfoEXT *createSnapshotCompletionInfo, XrCreateSpatialDiscoverySnapshotCompletionEXT *completion);
+XrResult XRAPI_CALL xrCreateSpatialEntityAnchorBD(XrSenseDataProviderBD provider, const XrSpatialEntityAnchorCreateInfoBD *createInfo, XrAnchorBD *anchor);
+XrResult XRAPI_CALL xrCreateSpatialEntityFromIdEXT(XrSpatialContextEXT spatialContext, const XrSpatialEntityFromIdCreateInfoEXT *createInfo, XrSpatialEntityEXT *spatialEntity);
+XrResult XRAPI_CALL xrCreateSpatialGraphNodeSpaceMSFT(XrSession session, const XrSpatialGraphNodeSpaceCreateInfoMSFT *createInfo, XrSpace *space);
+XrResult XRAPI_CALL xrCreateSpatialPersistenceContextAsyncEXT(XrSession session, const XrSpatialPersistenceContextCreateInfoEXT *createInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrCreateSpatialPersistenceContextCompleteEXT(XrSession session, XrFutureEXT future, XrCreateSpatialPersistenceContextCompletionEXT *completion);
+XrResult XRAPI_CALL xrCreateSpatialUpdateSnapshotEXT(XrSpatialContextEXT spatialContext, const XrSpatialUpdateSnapshotCreateInfoEXT *createInfo, XrSpatialSnapshotEXT *snapshot);
+XrResult XRAPI_CALL xrCreateSwapchain(XrSession session, const XrSwapchainCreateInfo *createInfo, XrSwapchain *swapchain);
+XrResult XRAPI_CALL xrCreateTrackableTrackerANDROID(XrSession session, const XrTrackableTrackerCreateInfoANDROID *createInfo, XrTrackableTrackerANDROID *trackableTracker);
+XrResult XRAPI_CALL xrCreateTriangleMeshFB(XrSession session, const XrTriangleMeshCreateInfoFB *createInfo, XrTriangleMeshFB *outTriangleMesh);
+XrResult XRAPI_CALL xrCreateVirtualKeyboardMETA(XrSession session, const XrVirtualKeyboardCreateInfoMETA *createInfo, XrVirtualKeyboardMETA *keyboard);
+XrResult XRAPI_CALL xrCreateVirtualKeyboardSpaceMETA(XrSession session, XrVirtualKeyboardMETA keyboard, const XrVirtualKeyboardSpaceCreateInfoMETA *createInfo, XrSpace *keyboardSpace);
+XrResult XRAPI_CALL xrCreateVulkanDeviceKHR(XrInstance instance, const XrVulkanDeviceCreateInfoKHR *createInfo, VkDevice *vulkanDevice, VkResult *vulkanResult);
+XrResult XRAPI_CALL xrCreateVulkanInstanceKHR(XrInstance instance, const XrVulkanInstanceCreateInfoKHR *createInfo, VkInstance *vulkanInstance, VkResult *vulkanResult);
+XrResult XRAPI_CALL xrCreateWorldMeshDetectorML(XrSession session, const XrWorldMeshDetectorCreateInfoML *createInfo, XrWorldMeshDetectorML *detector);
+XrResult XRAPI_CALL xrDeleteSpatialAnchorsAsyncML(XrSpatialAnchorsStorageML storage, const XrSpatialAnchorsDeleteInfoML *deleteInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrDeleteSpatialAnchorsCompleteML(XrSpatialAnchorsStorageML storage, XrFutureEXT future, XrSpatialAnchorsDeleteCompletionML *completion);
+XrResult XRAPI_CALL xrDeserializeSceneMSFT(XrSceneObserverMSFT sceneObserver, const XrSceneDeserializeInfoMSFT *deserializeInfo);
+XrResult XRAPI_CALL xrDestroyAction(XrAction action);
+XrResult XRAPI_CALL xrDestroyActionSet(XrActionSet actionSet);
+XrResult XRAPI_CALL xrDestroyAnchorBD(XrAnchorBD anchor);
+XrResult XRAPI_CALL xrDestroyBodyTrackerBD(XrBodyTrackerBD bodyTracker);
+XrResult XRAPI_CALL xrDestroyBodyTrackerFB(XrBodyTrackerFB bodyTracker);
+XrResult XRAPI_CALL xrDestroyBodyTrackerHTC(XrBodyTrackerHTC bodyTracker);
+XrResult XRAPI_CALL xrDestroyDeviceAnchorPersistenceANDROID(XrDeviceAnchorPersistenceANDROID handle);
+XrResult XRAPI_CALL xrDestroyEnvironmentDepthProviderMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider);
+XrResult XRAPI_CALL xrDestroyEnvironmentDepthSwapchainMETA(XrEnvironmentDepthSwapchainMETA swapchain);
+XrResult XRAPI_CALL xrDestroyExportedLocalizationMapML(XrExportedLocalizationMapML map);
+XrResult XRAPI_CALL xrDestroyEyeTrackerFB(XrEyeTrackerFB eyeTracker);
+XrResult XRAPI_CALL xrDestroyFaceTracker2FB(XrFaceTracker2FB faceTracker);
+XrResult XRAPI_CALL xrDestroyFaceTrackerFB(XrFaceTrackerFB faceTracker);
+XrResult XRAPI_CALL xrDestroyFacialExpressionClientML(XrFacialExpressionClientML facialExpressionClient);
+XrResult XRAPI_CALL xrDestroyFacialTrackerHTC(XrFacialTrackerHTC facialTracker);
+XrResult XRAPI_CALL xrDestroyFoveationProfileFB(XrFoveationProfileFB profile);
+XrResult XRAPI_CALL xrDestroyGeometryInstanceFB(XrGeometryInstanceFB instance);
+XrResult XRAPI_CALL xrDestroyHandTrackerEXT(XrHandTrackerEXT handTracker);
+XrResult XRAPI_CALL xrDestroyInstance(XrInstance instance);
+XrResult XRAPI_CALL xrDestroyMarkerDetectorML(XrMarkerDetectorML markerDetector);
+XrResult XRAPI_CALL xrDestroyPassthroughColorLutMETA(XrPassthroughColorLutMETA colorLut);
+XrResult XRAPI_CALL xrDestroyPassthroughFB(XrPassthroughFB passthrough);
+XrResult XRAPI_CALL xrDestroyPassthroughHTC(XrPassthroughHTC passthrough);
+XrResult XRAPI_CALL xrDestroyPassthroughLayerFB(XrPassthroughLayerFB layer);
+XrResult XRAPI_CALL xrDestroyPlaneDetectorEXT(XrPlaneDetectorEXT planeDetector);
+XrResult XRAPI_CALL xrDestroyRenderModelAssetEXT(XrRenderModelAssetEXT asset);
+XrResult XRAPI_CALL xrDestroyRenderModelEXT(XrRenderModelEXT renderModel);
+XrResult XRAPI_CALL xrDestroySceneMSFT(XrSceneMSFT scene);
+XrResult XRAPI_CALL xrDestroySceneObserverMSFT(XrSceneObserverMSFT sceneObserver);
+XrResult XRAPI_CALL xrDestroySenseDataProviderBD(XrSenseDataProviderBD provider);
+XrResult XRAPI_CALL xrDestroySenseDataSnapshotBD(XrSenseDataSnapshotBD snapshot);
+XrResult XRAPI_CALL xrDestroySession(XrSession session);
+XrResult XRAPI_CALL xrDestroySpace(XrSpace space);
+XrResult XRAPI_CALL xrDestroySpaceUserFB(XrSpaceUserFB user);
+XrResult XRAPI_CALL xrDestroySpatialAnchorMSFT(XrSpatialAnchorMSFT anchor);
+XrResult XRAPI_CALL xrDestroySpatialAnchorStoreConnectionMSFT(XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore);
+XrResult XRAPI_CALL xrDestroySpatialAnchorsStorageML(XrSpatialAnchorsStorageML storage);
+XrResult XRAPI_CALL xrDestroySpatialContextEXT(XrSpatialContextEXT spatialContext);
+XrResult XRAPI_CALL xrDestroySpatialEntityEXT(XrSpatialEntityEXT spatialEntity);
+XrResult XRAPI_CALL xrDestroySpatialGraphNodeBindingMSFT(XrSpatialGraphNodeBindingMSFT nodeBinding);
+XrResult XRAPI_CALL xrDestroySpatialPersistenceContextEXT(XrSpatialPersistenceContextEXT persistenceContext);
+XrResult XRAPI_CALL xrDestroySpatialSnapshotEXT(XrSpatialSnapshotEXT snapshot);
+XrResult XRAPI_CALL xrDestroySwapchain(XrSwapchain swapchain);
+XrResult XRAPI_CALL xrDestroyTrackableTrackerANDROID(XrTrackableTrackerANDROID trackableTracker);
+XrResult XRAPI_CALL xrDestroyTriangleMeshFB(XrTriangleMeshFB mesh);
+XrResult XRAPI_CALL xrDestroyVirtualKeyboardMETA(XrVirtualKeyboardMETA keyboard);
+XrResult XRAPI_CALL xrDestroyWorldMeshDetectorML(XrWorldMeshDetectorML detector);
+XrResult XRAPI_CALL xrDiscoverSpacesMETA(XrSession session, const XrSpaceDiscoveryInfoMETA *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrDownloadSharedSpatialAnchorAsyncBD(XrSenseDataProviderBD provider, const XrSharedSpatialAnchorDownloadInfoBD *info, XrFutureEXT *future);
+XrResult XRAPI_CALL xrDownloadSharedSpatialAnchorCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrFutureCompletionEXT *completion);
+XrResult XRAPI_CALL xrEnableLocalizationEventsML(XrSession session, const XrLocalizationEnableEventsInfoML *info);
+XrResult XRAPI_CALL xrEnableUserCalibrationEventsML(XrInstance instance, const XrUserCalibrationEnableEventsInfoML *enableInfo);
+XrResult XRAPI_CALL xrEndFrame(XrSession session, const XrFrameEndInfo *frameEndInfo);
+XrResult XRAPI_CALL xrEndSession(XrSession session);
+XrResult XRAPI_CALL xrEnumerateApiLayerProperties(uint32_t propertyCapacityInput, uint32_t *propertyCountOutput, XrApiLayerProperties *properties);
+XrResult XRAPI_CALL xrEnumerateBoundSourcesForAction(XrSession session, const XrBoundSourcesForActionEnumerateInfo *enumerateInfo, uint32_t sourceCapacityInput, uint32_t *sourceCountOutput, XrPath *sources);
+XrResult XRAPI_CALL xrEnumerateColorSpacesFB(XrSession session, uint32_t colorSpaceCapacityInput, uint32_t *colorSpaceCountOutput, XrColorSpaceFB *colorSpaces);
+XrResult XRAPI_CALL xrEnumerateDisplayRefreshRatesFB(XrSession session, uint32_t displayRefreshRateCapacityInput, uint32_t *displayRefreshRateCountOutput, float *displayRefreshRates);
+XrResult XRAPI_CALL xrEnumerateEnvironmentBlendModes(XrInstance instance, XrSystemId systemId, XrViewConfigurationType viewConfigurationType, uint32_t environmentBlendModeCapacityInput, uint32_t *environmentBlendModeCountOutput, XrEnvironmentBlendMode *environmentBlendModes);
+XrResult XRAPI_CALL xrEnumerateEnvironmentDepthSwapchainImagesMETA(XrEnvironmentDepthSwapchainMETA swapchain, uint32_t imageCapacityInput, uint32_t *imageCountOutput, XrSwapchainImageBaseHeader *images);
+XrResult XRAPI_CALL xrEnumerateExternalCamerasOCULUS(XrSession session, uint32_t cameraCapacityInput, uint32_t *cameraCountOutput, XrExternalCameraOCULUS *cameras);
+XrResult XRAPI_CALL xrEnumerateInstanceExtensionProperties(const char *layerName, uint32_t propertyCapacityInput, uint32_t *propertyCountOutput, XrExtensionProperties *properties);
+XrResult XRAPI_CALL xrEnumerateInteractionRenderModelIdsEXT(XrSession session, const XrInteractionRenderModelIdsEnumerateInfoEXT *getInfo, uint32_t renderModelIdCapacityInput, uint32_t *renderModelIdCountOutput, XrRenderModelIdEXT *renderModelIds);
+XrResult XRAPI_CALL xrEnumeratePerformanceMetricsCounterPathsMETA(XrInstance instance, uint32_t counterPathCapacityInput, uint32_t *counterPathCountOutput, XrPath *counterPaths);
+XrResult XRAPI_CALL xrEnumeratePersistedAnchorsANDROID(XrDeviceAnchorPersistenceANDROID handle, uint32_t anchorIdCapacityInput, uint32_t *anchorIdCountOutput, XrUuidEXT *anchorIds);
+XrResult XRAPI_CALL xrEnumeratePersistedSpatialAnchorNamesMSFT(XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore, uint32_t spatialAnchorNameCapacityInput, uint32_t *spatialAnchorNameCountOutput, XrSpatialAnchorPersistenceNameMSFT *spatialAnchorNames);
+XrResult XRAPI_CALL xrEnumerateRaycastSupportedTrackableTypesANDROID(XrInstance instance, XrSystemId systemId, uint32_t trackableTypeCapacityInput, uint32_t *trackableTypeCountOutput, XrTrackableTypeANDROID *trackableTypes);
+XrResult XRAPI_CALL xrEnumerateReferenceSpaces(XrSession session, uint32_t spaceCapacityInput, uint32_t *spaceCountOutput, XrReferenceSpaceType *spaces);
+XrResult XRAPI_CALL xrEnumerateRenderModelPathsFB(XrSession session, uint32_t pathCapacityInput, uint32_t *pathCountOutput, XrRenderModelPathInfoFB *paths);
+XrResult XRAPI_CALL xrEnumerateRenderModelSubactionPathsEXT(XrRenderModelEXT renderModel, const XrInteractionRenderModelSubactionPathInfoEXT *info, uint32_t pathCapacityInput, uint32_t *pathCountOutput, XrPath *paths);
+XrResult XRAPI_CALL xrEnumerateReprojectionModesMSFT(XrInstance instance, XrSystemId systemId, XrViewConfigurationType viewConfigurationType, uint32_t modeCapacityInput, uint32_t *modeCountOutput, XrReprojectionModeMSFT *modes);
+XrResult XRAPI_CALL xrEnumerateSceneComputeFeaturesMSFT(XrInstance instance, XrSystemId systemId, uint32_t featureCapacityInput, uint32_t *featureCountOutput, XrSceneComputeFeatureMSFT *features);
+XrResult XRAPI_CALL xrEnumerateSpaceSupportedComponentsFB(XrSpace space, uint32_t componentTypeCapacityInput, uint32_t *componentTypeCountOutput, XrSpaceComponentTypeFB *componentTypes);
+XrResult XRAPI_CALL xrEnumerateSpatialCapabilitiesEXT(XrInstance instance, XrSystemId systemId, uint32_t capabilityCapacityInput, uint32_t *capabilityCountOutput, XrSpatialCapabilityEXT *capabilities);
+XrResult XRAPI_CALL xrEnumerateSpatialCapabilityComponentTypesEXT(XrInstance instance, XrSystemId systemId, XrSpatialCapabilityEXT capability, XrSpatialCapabilityComponentTypesEXT *capabilityComponents);
+XrResult XRAPI_CALL xrEnumerateSpatialCapabilityFeaturesEXT(XrInstance instance, XrSystemId systemId, XrSpatialCapabilityEXT capability, uint32_t capabilityFeatureCapacityInput, uint32_t *capabilityFeatureCountOutput, XrSpatialCapabilityFeatureEXT *capabilityFeatures);
+XrResult XRAPI_CALL xrEnumerateSpatialEntityComponentTypesBD(XrSenseDataSnapshotBD snapshot, XrSpatialEntityIdBD entityId, uint32_t componentTypeCapacityInput, uint32_t *componentTypeCountOutput, XrSpatialEntityComponentTypeBD *componentTypes);
+XrResult XRAPI_CALL xrEnumerateSpatialPersistenceScopesEXT(XrInstance instance, XrSystemId systemId, uint32_t persistenceScopeCapacityInput, uint32_t *persistenceScopeCountOutput, XrSpatialPersistenceScopeEXT *persistenceScopes);
+XrResult XRAPI_CALL xrEnumerateSupportedAnchorTrackableTypesANDROID(XrInstance instance, XrSystemId systemId, uint32_t trackableTypeCapacityInput, uint32_t *trackableTypeCountOutput, XrTrackableTypeANDROID *trackableTypes);
+XrResult XRAPI_CALL xrEnumerateSupportedPersistenceAnchorTypesANDROID(XrInstance instance, XrSystemId systemId, uint32_t trackableTypeCapacityInput, uint32_t *trackableTypeCountOutput, XrTrackableTypeANDROID *trackableTypes);
+XrResult XRAPI_CALL xrEnumerateSupportedTrackableTypesANDROID(XrInstance instance, XrSystemId systemId, uint32_t trackableTypeCapacityInput, uint32_t *trackableTypeCountOutput, XrTrackableTypeANDROID *trackableTypes);
+XrResult XRAPI_CALL xrEnumerateSwapchainFormats(XrSession session, uint32_t formatCapacityInput, uint32_t *formatCountOutput, int64_t *formats);
+XrResult XRAPI_CALL xrEnumerateSwapchainImages(XrSwapchain swapchain, uint32_t imageCapacityInput, uint32_t *imageCountOutput, XrSwapchainImageBaseHeader *images);
+XrResult XRAPI_CALL xrEnumerateViewConfigurationViews(XrInstance instance, XrSystemId systemId, XrViewConfigurationType viewConfigurationType, uint32_t viewCapacityInput, uint32_t *viewCountOutput, XrViewConfigurationView *views);
+XrResult XRAPI_CALL xrEnumerateViewConfigurations(XrInstance instance, XrSystemId systemId, uint32_t viewConfigurationTypeCapacityInput, uint32_t *viewConfigurationTypeCountOutput, XrViewConfigurationType *viewConfigurationTypes);
+XrResult XRAPI_CALL xrEnumerateViveTrackerPathsHTCX(XrInstance instance, uint32_t pathCapacityInput, uint32_t *pathCountOutput, XrViveTrackerPathsHTCX *paths);
+XrResult XRAPI_CALL xrEraseSpaceFB(XrSession session, const XrSpaceEraseInfoFB *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrEraseSpacesMETA(XrSession session, const XrSpacesEraseInfoMETA *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrFreeWorldMeshBufferML(XrWorldMeshDetectorML detector, const XrWorldMeshBufferML *buffer);
+XrResult XRAPI_CALL xrGeometryInstanceSetTransformFB(XrGeometryInstanceFB instance, const XrGeometryInstanceTransformFB *transformation);
+XrResult XRAPI_CALL xrGetActionStateBoolean(XrSession session, const XrActionStateGetInfo *getInfo, XrActionStateBoolean *state);
+XrResult XRAPI_CALL xrGetActionStateFloat(XrSession session, const XrActionStateGetInfo *getInfo, XrActionStateFloat *state);
+XrResult XRAPI_CALL xrGetActionStatePose(XrSession session, const XrActionStateGetInfo *getInfo, XrActionStatePose *state);
+XrResult XRAPI_CALL xrGetActionStateVector2f(XrSession session, const XrActionStateGetInfo *getInfo, XrActionStateVector2f *state);
+XrResult XRAPI_CALL xrGetAllTrackablesANDROID(XrTrackableTrackerANDROID trackableTracker, uint32_t trackableCapacityInput, uint32_t *trackableCountOutput, XrTrackableANDROID *trackables);
+XrResult XRAPI_CALL xrGetAnchorPersistStateANDROID(XrDeviceAnchorPersistenceANDROID handle, const XrUuidEXT *anchorId, XrAnchorPersistStateANDROID *persistState);
+XrResult XRAPI_CALL xrGetAnchorUuidBD(XrAnchorBD anchor, XrUuidEXT *uuid);
+XrResult XRAPI_CALL xrGetAudioInputDeviceGuidOculus(XrInstance instance, wchar_t buffer[]);
+XrResult XRAPI_CALL xrGetAudioOutputDeviceGuidOculus(XrInstance instance, wchar_t buffer[]);
+XrResult XRAPI_CALL xrGetBodySkeletonFB(XrBodyTrackerFB bodyTracker, XrBodySkeletonFB *skeleton);
+XrResult XRAPI_CALL xrGetBodySkeletonHTC(XrBodyTrackerHTC bodyTracker, XrSpace baseSpace, uint32_t skeletonGenerationId, XrBodySkeletonHTC *skeleton);
+XrResult XRAPI_CALL xrGetControllerModelKeyMSFT(XrSession session, XrPath topLevelUserPath, XrControllerModelKeyStateMSFT *controllerModelKeyState);
+XrResult XRAPI_CALL xrGetControllerModelPropertiesMSFT(XrSession session, XrControllerModelKeyMSFT modelKey, XrControllerModelPropertiesMSFT *properties);
+XrResult XRAPI_CALL xrGetControllerModelStateMSFT(XrSession session, XrControllerModelKeyMSFT modelKey, XrControllerModelStateMSFT *state);
+XrResult XRAPI_CALL xrGetCurrentInteractionProfile(XrSession session, XrPath topLevelUserPath, XrInteractionProfileState *interactionProfile);
+XrResult XRAPI_CALL xrGetD3D11GraphicsRequirementsKHR(XrInstance instance, XrSystemId systemId, XrGraphicsRequirementsD3D11KHR *graphicsRequirements);
+XrResult XRAPI_CALL xrGetD3D12GraphicsRequirementsKHR(XrInstance instance, XrSystemId systemId, XrGraphicsRequirementsD3D12KHR *graphicsRequirements);
+XrResult XRAPI_CALL xrGetDeviceSampleRateFB(XrSession session, const XrHapticActionInfo *hapticActionInfo, XrDevicePcmSampleRateGetInfoFB *deviceSampleRate);
+XrResult XRAPI_CALL xrGetDisplayRefreshRateFB(XrSession session, float *displayRefreshRate);
+XrResult XRAPI_CALL xrGetEnvironmentDepthSwapchainStateMETA(XrEnvironmentDepthSwapchainMETA swapchain, XrEnvironmentDepthSwapchainStateMETA *state);
+XrResult XRAPI_CALL xrGetExportedLocalizationMapDataML(XrExportedLocalizationMapML map, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer);
+XrResult XRAPI_CALL xrGetEyeGazesFB(XrEyeTrackerFB eyeTracker, const XrEyeGazesInfoFB *gazeInfo, XrEyeGazesFB *eyeGazes);
+XrResult XRAPI_CALL xrGetFaceExpressionWeights2FB(XrFaceTracker2FB faceTracker, const XrFaceExpressionInfo2FB *expressionInfo, XrFaceExpressionWeights2FB *expressionWeights);
+XrResult XRAPI_CALL xrGetFaceExpressionWeightsFB(XrFaceTrackerFB faceTracker, const XrFaceExpressionInfoFB *expressionInfo, XrFaceExpressionWeightsFB *expressionWeights);
+XrResult XRAPI_CALL xrGetFacialExpressionBlendShapePropertiesML(XrFacialExpressionClientML facialExpressionClient, const XrFacialExpressionBlendShapeGetInfoML *blendShapeGetInfo, uint32_t blendShapeCount, XrFacialExpressionBlendShapePropertiesML *blendShapes);
+XrResult XRAPI_CALL xrGetFacialExpressionsHTC(XrFacialTrackerHTC facialTracker, XrFacialExpressionsHTC *facialExpressions);
+XrResult XRAPI_CALL xrGetFoveationEyeTrackedStateMETA(XrSession session, XrFoveationEyeTrackedStateMETA *foveationState);
+XrResult XRAPI_CALL xrGetHandMeshFB(XrHandTrackerEXT handTracker, XrHandTrackingMeshFB *mesh);
+XrResult XRAPI_CALL xrGetInputSourceLocalizedName(XrSession session, const XrInputSourceLocalizedNameGetInfo *getInfo, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer);
+XrResult XRAPI_CALL xrGetInstanceProcAddr(XrInstance instance, const char *name, PFN_xrVoidFunction *function);
+XrResult XRAPI_CALL xrGetInstanceProperties(XrInstance instance, XrInstanceProperties *instanceProperties);
+XrResult XRAPI_CALL xrGetMarkerDetectorStateML(XrMarkerDetectorML markerDetector, XrMarkerDetectorStateML *state);
+XrResult XRAPI_CALL xrGetMarkerLengthML(XrMarkerDetectorML markerDetector, XrMarkerML marker, float *meters);
+XrResult XRAPI_CALL xrGetMarkerNumberML(XrMarkerDetectorML markerDetector, XrMarkerML marker, uint64_t *number);
+XrResult XRAPI_CALL xrGetMarkerReprojectionErrorML(XrMarkerDetectorML markerDetector, XrMarkerML marker, float *reprojectionErrorMeters);
+XrResult XRAPI_CALL xrGetMarkerSizeVARJO(XrSession session, uint64_t markerId, XrExtent2Df *size);
+XrResult XRAPI_CALL xrGetMarkerStringML(XrMarkerDetectorML markerDetector, XrMarkerML marker, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer);
+XrResult XRAPI_CALL xrGetMarkersML(XrMarkerDetectorML markerDetector, uint32_t markerCapacityInput, uint32_t *markerCountOutput, XrMarkerML *markers);
+XrResult XRAPI_CALL xrGetOpenGLGraphicsRequirementsKHR(XrInstance instance, XrSystemId systemId, XrGraphicsRequirementsOpenGLKHR *graphicsRequirements);
+XrResult XRAPI_CALL xrGetPassthroughCameraStateANDROID(XrSession session, const XrPassthroughCameraStateGetInfoANDROID *getInfo, XrPassthroughCameraStateANDROID *cameraStateOutput);
+XrResult XRAPI_CALL xrGetPassthroughPreferencesMETA(XrSession session, XrPassthroughPreferencesMETA *preferences);
+XrResult XRAPI_CALL xrGetPerformanceMetricsStateMETA(XrSession session, XrPerformanceMetricsStateMETA *state);
+XrResult XRAPI_CALL xrGetPlaneDetectionStateEXT(XrPlaneDetectorEXT planeDetector, XrPlaneDetectionStateEXT *state);
+XrResult XRAPI_CALL xrGetPlaneDetectionsEXT(XrPlaneDetectorEXT planeDetector, const XrPlaneDetectorGetInfoEXT *info, XrPlaneDetectorLocationsEXT *locations);
+XrResult XRAPI_CALL xrGetPlanePolygonBufferEXT(XrPlaneDetectorEXT planeDetector, uint64_t planeId, uint32_t polygonBufferIndex, XrPlaneDetectorPolygonBufferEXT *polygonBuffer);
+XrResult XRAPI_CALL xrGetQueriedSenseDataBD(XrSenseDataSnapshotBD snapshot, XrQueriedSenseDataGetInfoBD *getInfo, XrQueriedSenseDataBD *queriedSenseData);
+XrResult XRAPI_CALL xrGetRecommendedLayerResolutionMETA(XrSession session, const XrRecommendedLayerResolutionGetInfoMETA *info, XrRecommendedLayerResolutionMETA *resolution);
+XrResult XRAPI_CALL xrGetReferenceSpaceBoundsRect(XrSession session, XrReferenceSpaceType referenceSpaceType, XrExtent2Df *bounds);
+XrResult XRAPI_CALL xrGetRenderModelAssetDataEXT(XrRenderModelAssetEXT asset, const XrRenderModelAssetDataGetInfoEXT *getInfo, XrRenderModelAssetDataEXT *buffer);
+XrResult XRAPI_CALL xrGetRenderModelAssetPropertiesEXT(XrRenderModelAssetEXT asset, const XrRenderModelAssetPropertiesGetInfoEXT *getInfo, XrRenderModelAssetPropertiesEXT *properties);
+XrResult XRAPI_CALL xrGetRenderModelPoseTopLevelUserPathEXT(XrRenderModelEXT renderModel, const XrInteractionRenderModelTopLevelUserPathGetInfoEXT *info, XrPath *topLevelUserPath);
+XrResult XRAPI_CALL xrGetRenderModelPropertiesEXT(XrRenderModelEXT renderModel, const XrRenderModelPropertiesGetInfoEXT *getInfo, XrRenderModelPropertiesEXT *properties);
+XrResult XRAPI_CALL xrGetRenderModelPropertiesFB(XrSession session, XrPath path, XrRenderModelPropertiesFB *properties);
+XrResult XRAPI_CALL xrGetRenderModelStateEXT(XrRenderModelEXT renderModel, const XrRenderModelStateGetInfoEXT *getInfo, XrRenderModelStateEXT *state);
+XrResult XRAPI_CALL xrGetSceneComponentsMSFT(XrSceneMSFT scene, const XrSceneComponentsGetInfoMSFT *getInfo, XrSceneComponentsMSFT *components);
+XrResult XRAPI_CALL xrGetSceneComputeStateMSFT(XrSceneObserverMSFT sceneObserver, XrSceneComputeStateMSFT *state);
+XrResult XRAPI_CALL xrGetSceneMarkerDecodedStringMSFT(XrSceneMSFT scene, const XrUuidMSFT *markerId, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer);
+XrResult XRAPI_CALL xrGetSceneMarkerRawDataMSFT(XrSceneMSFT scene, const XrUuidMSFT *markerId, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, uint8_t *buffer);
+XrResult XRAPI_CALL xrGetSceneMeshBuffersMSFT(XrSceneMSFT scene, const XrSceneMeshBuffersGetInfoMSFT *getInfo, XrSceneMeshBuffersMSFT *buffers);
+XrResult XRAPI_CALL xrGetSenseDataProviderStateBD(XrSenseDataProviderBD provider, XrSenseDataProviderStateBD *state);
+XrResult XRAPI_CALL xrGetSerializedSceneFragmentDataMSFT(XrSceneMSFT scene, const XrSerializedSceneFragmentDataGetInfoMSFT *getInfo, uint32_t countInput, uint32_t *readOutput, uint8_t *buffer);
+XrResult XRAPI_CALL xrGetSpaceBoundary2DFB(XrSession session, XrSpace space, XrBoundary2DFB *boundary2DOutput);
+XrResult XRAPI_CALL xrGetSpaceBoundingBox2DFB(XrSession session, XrSpace space, XrRect2Df *boundingBox2DOutput);
+XrResult XRAPI_CALL xrGetSpaceBoundingBox3DFB(XrSession session, XrSpace space, XrRect3DfFB *boundingBox3DOutput);
+XrResult XRAPI_CALL xrGetSpaceComponentStatusFB(XrSpace space, XrSpaceComponentTypeFB componentType, XrSpaceComponentStatusFB *status);
+XrResult XRAPI_CALL xrGetSpaceContainerFB(XrSession session, XrSpace space, XrSpaceContainerFB *spaceContainerOutput);
+XrResult XRAPI_CALL xrGetSpaceRoomLayoutFB(XrSession session, XrSpace space, XrRoomLayoutFB *roomLayoutOutput);
+XrResult XRAPI_CALL xrGetSpaceSemanticLabelsFB(XrSession session, XrSpace space, XrSemanticLabelsFB *semanticLabelsOutput);
+XrResult XRAPI_CALL xrGetSpaceTriangleMeshMETA(XrSpace space, const XrSpaceTriangleMeshGetInfoMETA *getInfo, XrSpaceTriangleMeshMETA *triangleMeshOutput);
+XrResult XRAPI_CALL xrGetSpaceUserIdFB(XrSpaceUserFB user, XrSpaceUserIdFB *userId);
+XrResult XRAPI_CALL xrGetSpaceUuidFB(XrSpace space, XrUuidEXT *uuid);
+XrResult XRAPI_CALL xrGetSpatialAnchorNameHTC(XrSpace anchor, XrSpatialAnchorNameHTC *name);
+XrResult XRAPI_CALL xrGetSpatialAnchorStateML(XrSpace anchor, XrSpatialAnchorStateML *state);
+XrResult XRAPI_CALL xrGetSpatialBufferFloatEXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, float *buffer);
+XrResult XRAPI_CALL xrGetSpatialBufferStringEXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer);
+XrResult XRAPI_CALL xrGetSpatialBufferUint16EXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, uint16_t *buffer);
+XrResult XRAPI_CALL xrGetSpatialBufferUint32EXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, uint32_t *buffer);
+XrResult XRAPI_CALL xrGetSpatialBufferUint8EXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, uint8_t *buffer);
+XrResult XRAPI_CALL xrGetSpatialBufferVector2fEXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, XrVector2f *buffer);
+XrResult XRAPI_CALL xrGetSpatialBufferVector3fEXT(XrSpatialSnapshotEXT snapshot, const XrSpatialBufferGetInfoEXT *info, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, XrVector3f *buffer);
+XrResult XRAPI_CALL xrGetSpatialEntityComponentDataBD(XrSenseDataSnapshotBD snapshot, const XrSpatialEntityComponentGetInfoBD *getInfo, XrSpatialEntityComponentDataBaseHeaderBD *componentData);
+XrResult XRAPI_CALL xrGetSpatialEntityUuidBD(XrSenseDataSnapshotBD snapshot, XrSpatialEntityIdBD entityId, XrUuidEXT *uuid);
+XrResult XRAPI_CALL xrGetSpatialGraphNodeBindingPropertiesMSFT(XrSpatialGraphNodeBindingMSFT nodeBinding, const XrSpatialGraphNodeBindingPropertiesGetInfoMSFT *getInfo, XrSpatialGraphNodeBindingPropertiesMSFT *properties);
+XrResult XRAPI_CALL xrGetSwapchainStateFB(XrSwapchain swapchain, XrSwapchainStateBaseHeaderFB *state);
+XrResult XRAPI_CALL xrGetSystem(XrInstance instance, const XrSystemGetInfo *getInfo, XrSystemId *systemId);
+XrResult XRAPI_CALL xrGetSystemProperties(XrInstance instance, XrSystemId systemId, XrSystemProperties *properties);
+XrResult XRAPI_CALL xrGetTrackableMarkerANDROID(XrTrackableTrackerANDROID tracker, const XrTrackableGetInfoANDROID *getInfo, XrTrackableMarkerANDROID *markerOutput);
+XrResult XRAPI_CALL xrGetTrackableObjectANDROID(XrTrackableTrackerANDROID tracker, const XrTrackableGetInfoANDROID *getInfo, XrTrackableObjectANDROID *objectOutput);
+XrResult XRAPI_CALL xrGetTrackablePlaneANDROID(XrTrackableTrackerANDROID trackableTracker, const XrTrackableGetInfoANDROID *getInfo, XrTrackablePlaneANDROID *planeOutput);
+XrResult XRAPI_CALL xrGetViewConfigurationProperties(XrInstance instance, XrSystemId systemId, XrViewConfigurationType viewConfigurationType, XrViewConfigurationProperties *configurationProperties);
+XrResult XRAPI_CALL xrGetVirtualKeyboardDirtyTexturesMETA(XrVirtualKeyboardMETA keyboard, uint32_t textureIdCapacityInput, uint32_t *textureIdCountOutput, uint64_t *textureIds);
+XrResult XRAPI_CALL xrGetVirtualKeyboardModelAnimationStatesMETA(XrVirtualKeyboardMETA keyboard, XrVirtualKeyboardModelAnimationStatesMETA *animationStates);
+XrResult XRAPI_CALL xrGetVirtualKeyboardScaleMETA(XrVirtualKeyboardMETA keyboard, float *scale);
+XrResult XRAPI_CALL xrGetVirtualKeyboardTextureDataMETA(XrVirtualKeyboardMETA keyboard, uint64_t textureId, XrVirtualKeyboardTextureDataMETA *textureData);
+XrResult XRAPI_CALL xrGetVisibilityMaskKHR(XrSession session, XrViewConfigurationType viewConfigurationType, uint32_t viewIndex, XrVisibilityMaskTypeKHR visibilityMaskType, XrVisibilityMaskKHR *visibilityMask);
+XrResult XRAPI_CALL xrGetVulkanDeviceExtensionsKHR(XrInstance instance, XrSystemId systemId, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer);
+XrResult XRAPI_CALL xrGetVulkanGraphicsDevice2KHR(XrInstance instance, const XrVulkanGraphicsDeviceGetInfoKHR *getInfo, VkPhysicalDevice *vulkanPhysicalDevice);
+XrResult XRAPI_CALL xrGetVulkanGraphicsDeviceKHR(XrInstance instance, XrSystemId systemId, VkInstance vkInstance, VkPhysicalDevice *vkPhysicalDevice);
+XrResult XRAPI_CALL xrGetVulkanGraphicsRequirements2KHR(XrInstance instance, XrSystemId systemId, XrGraphicsRequirementsVulkanKHR *graphicsRequirements);
+XrResult XRAPI_CALL xrGetVulkanGraphicsRequirementsKHR(XrInstance instance, XrSystemId systemId, XrGraphicsRequirementsVulkanKHR *graphicsRequirements);
+XrResult XRAPI_CALL xrGetVulkanInstanceExtensionsKHR(XrInstance instance, XrSystemId systemId, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer);
+XrResult XRAPI_CALL xrGetWorldMeshBufferRecommendSizeML(XrWorldMeshDetectorML detector, const XrWorldMeshBufferRecommendedSizeInfoML *sizeInfo, XrWorldMeshBufferSizeML *size);
+XrResult XRAPI_CALL xrImportLocalizationMapML(XrSession session, const XrLocalizationMapImportInfoML *importInfo, XrUuidEXT *mapUuid);
+XrResult XRAPI_CALL xrLoadControllerModelMSFT(XrSession session, XrControllerModelKeyMSFT modelKey, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, uint8_t *buffer);
+XrResult XRAPI_CALL xrLoadRenderModelFB(XrSession session, const XrRenderModelLoadInfoFB *info, XrRenderModelBufferFB *buffer);
+XrResult XRAPI_CALL xrLocateBodyJointsBD(XrBodyTrackerBD bodyTracker, const XrBodyJointsLocateInfoBD *locateInfo, XrBodyJointLocationsBD *locations);
+XrResult XRAPI_CALL xrLocateBodyJointsFB(XrBodyTrackerFB bodyTracker, const XrBodyJointsLocateInfoFB *locateInfo, XrBodyJointLocationsFB *locations);
+XrResult XRAPI_CALL xrLocateBodyJointsHTC(XrBodyTrackerHTC bodyTracker, const XrBodyJointsLocateInfoHTC *locateInfo, XrBodyJointLocationsHTC *locations);
+XrResult XRAPI_CALL xrLocateHandJointsEXT(XrHandTrackerEXT handTracker, const XrHandJointsLocateInfoEXT *locateInfo, XrHandJointLocationsEXT *locations);
+XrResult XRAPI_CALL xrLocateSceneComponentsMSFT(XrSceneMSFT scene, const XrSceneComponentsLocateInfoMSFT *locateInfo, XrSceneComponentLocationsMSFT *locations);
+XrResult XRAPI_CALL xrLocateSpace(XrSpace space, XrSpace baseSpace, XrTime time, XrSpaceLocation *location);
+XrResult XRAPI_CALL xrLocateSpaces(XrSession session, const XrSpacesLocateInfo *locateInfo, XrSpaceLocations *spaceLocations);
+XrResult XRAPI_CALL xrLocateSpacesKHR(XrSession session, const XrSpacesLocateInfo *locateInfo, XrSpaceLocations *spaceLocations);
+XrResult XRAPI_CALL xrLocateViews(XrSession session, const XrViewLocateInfo *viewLocateInfo, XrViewState *viewState, uint32_t viewCapacityInput, uint32_t *viewCountOutput, XrView *views);
+XrResult XRAPI_CALL xrNegotiateLoaderApiLayerInterface(const XrNegotiateLoaderInfo *loaderInfo, const char *layerName, XrNegotiateApiLayerRequest *apiLayerRequest);
+XrResult XRAPI_CALL xrNegotiateLoaderRuntimeInterface(const XrNegotiateLoaderInfo *loaderInfo, XrNegotiateRuntimeRequest *runtimeRequest);
+XrResult XRAPI_CALL xrPassthroughLayerPauseFB(XrPassthroughLayerFB layer);
+XrResult XRAPI_CALL xrPassthroughLayerResumeFB(XrPassthroughLayerFB layer);
+XrResult XRAPI_CALL xrPassthroughLayerSetKeyboardHandsIntensityFB(XrPassthroughLayerFB layer, const XrPassthroughKeyboardHandsIntensityFB *intensity);
+XrResult XRAPI_CALL xrPassthroughLayerSetStyleFB(XrPassthroughLayerFB layer, const XrPassthroughStyleFB *style);
+XrResult XRAPI_CALL xrPassthroughPauseFB(XrPassthroughFB passthrough);
+XrResult XRAPI_CALL xrPassthroughStartFB(XrPassthroughFB passthrough);
+XrResult XRAPI_CALL xrPathToString(XrInstance instance, XrPath path, uint32_t bufferCapacityInput, uint32_t *bufferCountOutput, char *buffer);
+XrResult XRAPI_CALL xrPauseSimultaneousHandsAndControllersTrackingMETA(XrSession session, const XrSimultaneousHandsAndControllersTrackingPauseInfoMETA *pauseInfo);
+XrResult XRAPI_CALL xrPerfSettingsSetPerformanceLevelEXT(XrSession session, XrPerfSettingsDomainEXT domain, XrPerfSettingsLevelEXT level);
+XrResult XRAPI_CALL xrPersistAnchorANDROID(XrDeviceAnchorPersistenceANDROID handle, const XrPersistedAnchorSpaceInfoANDROID *persistedInfo, XrUuidEXT *anchorIdOutput);
+XrResult XRAPI_CALL xrPersistSpatialAnchorAsyncBD(XrSenseDataProviderBD provider, const XrSpatialAnchorPersistInfoBD *info, XrFutureEXT *future);
+XrResult XRAPI_CALL xrPersistSpatialAnchorCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrFutureCompletionEXT *completion);
+XrResult XRAPI_CALL xrPersistSpatialAnchorMSFT(XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore, const XrSpatialAnchorPersistenceInfoMSFT *spatialAnchorPersistenceInfo);
+XrResult XRAPI_CALL xrPersistSpatialEntityAsyncEXT(XrSpatialPersistenceContextEXT persistenceContext, const XrSpatialEntityPersistInfoEXT *persistInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrPersistSpatialEntityCompleteEXT(XrSpatialPersistenceContextEXT persistenceContext, XrFutureEXT future, XrPersistSpatialEntityCompletionEXT *completion);
+XrResult XRAPI_CALL xrPollEvent(XrInstance instance, XrEventDataBuffer *eventData);
+XrResult XRAPI_CALL xrPollFutureEXT(XrInstance instance, const XrFuturePollInfoEXT *pollInfo, XrFuturePollResultEXT *pollResult);
+XrResult XRAPI_CALL xrPublishSpatialAnchorsAsyncML(XrSpatialAnchorsStorageML storage, const XrSpatialAnchorsPublishInfoML *publishInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrPublishSpatialAnchorsCompleteML(XrSpatialAnchorsStorageML storage, XrFutureEXT future, XrSpatialAnchorsPublishCompletionML *completion);
+XrResult XRAPI_CALL xrQueryLocalizationMapsML(XrSession session, const XrLocalizationMapQueryInfoBaseHeaderML *queryInfo, uint32_t mapCapacityInput, uint32_t *mapCountOutput, XrLocalizationMapML *maps);
+XrResult XRAPI_CALL xrQueryPerformanceMetricsCounterMETA(XrSession session, XrPath counterPath, XrPerformanceMetricsCounterMETA *counter);
+XrResult XRAPI_CALL xrQuerySenseDataAsyncBD(XrSenseDataProviderBD provider, const XrSenseDataQueryInfoBD *queryInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrQuerySenseDataCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrSenseDataQueryCompletionBD *completion);
+XrResult XRAPI_CALL xrQuerySpacesFB(XrSession session, const XrSpaceQueryInfoBaseHeaderFB *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrQuerySpatialAnchorsAsyncML(XrSpatialAnchorsStorageML storage, const XrSpatialAnchorsQueryInfoBaseHeaderML *queryInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrQuerySpatialAnchorsCompleteML(XrSpatialAnchorsStorageML storage, XrFutureEXT future, XrSpatialAnchorsQueryCompletionML *completion);
+XrResult XRAPI_CALL xrQuerySpatialComponentDataEXT(XrSpatialSnapshotEXT snapshot, const XrSpatialComponentDataQueryConditionEXT *queryCondition, XrSpatialComponentDataQueryResultEXT *queryResult);
+XrResult XRAPI_CALL xrQuerySystemTrackedKeyboardFB(XrSession session, const XrKeyboardTrackingQueryFB *queryInfo, XrKeyboardTrackingDescriptionFB *keyboard);
+XrResult XRAPI_CALL xrRaycastANDROID(XrSession session, const XrRaycastInfoANDROID *rayInfo, XrRaycastHitResultsANDROID *results);
+XrResult XRAPI_CALL xrReleaseSwapchainImage(XrSwapchain swapchain, const XrSwapchainImageReleaseInfo *releaseInfo);
+XrResult XRAPI_CALL xrRequestDisplayRefreshRateFB(XrSession session, float displayRefreshRate);
+XrResult XRAPI_CALL xrRequestExitSession(XrSession session);
+XrResult XRAPI_CALL xrRequestMapLocalizationML(XrSession session, const XrMapLocalizationRequestInfoML *requestInfo);
+XrResult XRAPI_CALL xrRequestSceneCaptureFB(XrSession session, const XrSceneCaptureRequestInfoFB *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrRequestWorldMeshAsyncML(XrWorldMeshDetectorML detector, const XrWorldMeshGetInfoML *getInfo, XrWorldMeshBufferML *buffer, XrFutureEXT *future);
+XrResult XRAPI_CALL xrRequestWorldMeshCompleteML(XrWorldMeshDetectorML detector, const XrWorldMeshRequestCompletionInfoML *completionInfo, XrFutureEXT future, XrWorldMeshRequestCompletionML *completion);
+XrResult XRAPI_CALL xrRequestWorldMeshStateAsyncML(XrWorldMeshDetectorML detector, const XrWorldMeshStateRequestInfoML *stateRequest, XrFutureEXT *future);
+XrResult XRAPI_CALL xrRequestWorldMeshStateCompleteML(XrWorldMeshDetectorML detector, XrFutureEXT future, XrWorldMeshStateRequestCompletionML *completion);
+XrResult XRAPI_CALL xrResetBodyTrackingCalibrationMETA(XrBodyTrackerFB bodyTracker);
+XrResult XRAPI_CALL xrResultToString(XrInstance instance, XrResult value, char buffer[]);
+XrResult XRAPI_CALL xrResumeSimultaneousHandsAndControllersTrackingMETA(XrSession session, const XrSimultaneousHandsAndControllersTrackingResumeInfoMETA *resumeInfo);
+XrResult XRAPI_CALL xrRetrieveSpaceDiscoveryResultsMETA(XrSession session, XrAsyncRequestIdFB requestId, XrSpaceDiscoveryResultsMETA *results);
+XrResult XRAPI_CALL xrRetrieveSpaceQueryResultsFB(XrSession session, XrAsyncRequestIdFB requestId, XrSpaceQueryResultsFB *results);
+XrResult XRAPI_CALL xrSaveSpaceFB(XrSession session, const XrSpaceSaveInfoFB *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrSaveSpaceListFB(XrSession session, const XrSpaceListSaveInfoFB *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrSaveSpacesMETA(XrSession session, const XrSpacesSaveInfoMETA *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrSendVirtualKeyboardInputMETA(XrVirtualKeyboardMETA keyboard, const XrVirtualKeyboardInputInfoMETA *info, XrPosef *interactorRootPose);
+XrResult XRAPI_CALL xrSetColorSpaceFB(XrSession session, const XrColorSpaceFB colorSpace);
+XrResult XRAPI_CALL xrSetDigitalLensControlALMALENCE(XrSession session, const XrDigitalLensControlALMALENCE *digitalLensControl);
+XrResult XRAPI_CALL xrSetEnvironmentDepthEstimationVARJO(XrSession session, XrBool32 enabled);
+XrResult XRAPI_CALL xrSetEnvironmentDepthHandRemovalMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider, const XrEnvironmentDepthHandRemovalSetInfoMETA *setInfo);
+XrResult XRAPI_CALL xrSetInputDeviceActiveEXT(XrSession session, XrPath interactionProfile, XrPath topLevelPath, XrBool32 isActive);
+XrResult XRAPI_CALL xrSetInputDeviceLocationEXT(XrSession session, XrPath topLevelPath, XrPath inputSourcePath, XrSpace space, XrPosef pose);
+XrResult XRAPI_CALL xrSetInputDeviceStateBoolEXT(XrSession session, XrPath topLevelPath, XrPath inputSourcePath, XrBool32 state);
+XrResult XRAPI_CALL xrSetInputDeviceStateFloatEXT(XrSession session, XrPath topLevelPath, XrPath inputSourcePath, float state);
+XrResult XRAPI_CALL xrSetInputDeviceStateVector2fEXT(XrSession session, XrPath topLevelPath, XrPath inputSourcePath, XrVector2f state);
+XrResult XRAPI_CALL xrSetMarkerTrackingPredictionVARJO(XrSession session, uint64_t markerId, XrBool32 enable);
+XrResult XRAPI_CALL xrSetMarkerTrackingTimeoutVARJO(XrSession session, uint64_t markerId, XrDuration timeout);
+XrResult XRAPI_CALL xrSetMarkerTrackingVARJO(XrSession session, XrBool32 enabled);
+XrResult XRAPI_CALL xrSetPerformanceMetricsStateMETA(XrSession session, const XrPerformanceMetricsStateMETA *state);
+XrResult XRAPI_CALL xrSetSpaceComponentStatusFB(XrSpace space, const XrSpaceComponentStatusSetInfoFB *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrSetSystemNotificationsML(XrInstance instance, const XrSystemNotificationsSetInfoML *info);
+XrResult XRAPI_CALL xrSetTrackingOptimizationSettingsHintQCOM(XrSession session, XrTrackingOptimizationSettingsDomainQCOM domain, XrTrackingOptimizationSettingsHintQCOM hint);
+XrResult XRAPI_CALL xrSetViewOffsetVARJO(XrSession session, float offset);
+XrResult XRAPI_CALL xrSetVirtualKeyboardModelVisibilityMETA(XrVirtualKeyboardMETA keyboard, const XrVirtualKeyboardModelVisibilitySetInfoMETA *modelVisibility);
+XrResult XRAPI_CALL xrShareSpacesFB(XrSession session, const XrSpaceShareInfoFB *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrShareSpacesMETA(XrSession session, const XrShareSpacesInfoMETA *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrShareSpatialAnchorAsyncBD(XrSenseDataProviderBD provider, const XrSpatialAnchorShareInfoBD *info, XrFutureEXT *future);
+XrResult XRAPI_CALL xrShareSpatialAnchorCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrFutureCompletionEXT *completion);
+XrResult XRAPI_CALL xrSnapshotMarkerDetectorML(XrMarkerDetectorML markerDetector, XrMarkerDetectorSnapshotInfoML *snapshotInfo);
+XrResult XRAPI_CALL xrStartColocationAdvertisementMETA(XrSession session, const XrColocationAdvertisementStartInfoMETA *info, XrAsyncRequestIdFB *advertisementRequestId);
+XrResult XRAPI_CALL xrStartColocationDiscoveryMETA(XrSession session, const XrColocationDiscoveryStartInfoMETA *info, XrAsyncRequestIdFB *discoveryRequestId);
+XrResult XRAPI_CALL xrStartEnvironmentDepthProviderMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider);
+XrResult XRAPI_CALL xrStartSenseDataProviderAsyncBD(XrSenseDataProviderBD provider, const XrSenseDataProviderStartInfoBD *startInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrStartSenseDataProviderCompleteBD(XrSession session, XrFutureEXT future, XrFutureCompletionEXT *completion);
+XrResult XRAPI_CALL xrStopColocationAdvertisementMETA(XrSession session, const XrColocationAdvertisementStopInfoMETA *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrStopColocationDiscoveryMETA(XrSession session, const XrColocationDiscoveryStopInfoMETA *info, XrAsyncRequestIdFB *requestId);
+XrResult XRAPI_CALL xrStopEnvironmentDepthProviderMETA(XrEnvironmentDepthProviderMETA environmentDepthProvider);
+XrResult XRAPI_CALL xrStopHapticFeedback(XrSession session, const XrHapticActionInfo *hapticActionInfo);
+XrResult XRAPI_CALL xrStopSenseDataProviderBD(XrSenseDataProviderBD provider);
+XrResult XRAPI_CALL xrStringToPath(XrInstance instance, const char *pathString, XrPath *path);
+XrResult XRAPI_CALL xrStructureTypeToString(XrInstance instance, XrStructureType value, char buffer[]);
+XrResult XRAPI_CALL xrStructureTypeToString2KHR(XrInstance instance, XrStructureType value, char buffer[]);
+XrResult XRAPI_CALL xrSuggestBodyTrackingCalibrationOverrideMETA(XrBodyTrackerFB bodyTracker, const XrBodyTrackingCalibrationInfoMETA *calibrationInfo);
+XrResult XRAPI_CALL xrSuggestInteractionProfileBindings(XrInstance instance, const XrInteractionProfileSuggestedBinding *suggestedBindings);
+XrResult XRAPI_CALL xrSuggestVirtualKeyboardLocationMETA(XrVirtualKeyboardMETA keyboard, const XrVirtualKeyboardLocationInfoMETA *locationInfo);
+XrResult XRAPI_CALL xrSyncActions(XrSession session, const XrActionsSyncInfo *syncInfo);
+XrResult XRAPI_CALL xrThermalGetTemperatureTrendEXT(XrSession session, XrPerfSettingsDomainEXT domain, XrPerfSettingsNotificationLevelEXT *notificationLevel, float *tempHeadroom, float *tempSlope);
+XrResult XRAPI_CALL xrTriangleMeshBeginUpdateFB(XrTriangleMeshFB mesh);
+XrResult XRAPI_CALL xrTriangleMeshBeginVertexBufferUpdateFB(XrTriangleMeshFB mesh, uint32_t *outVertexCount);
+XrResult XRAPI_CALL xrTriangleMeshEndUpdateFB(XrTriangleMeshFB mesh, uint32_t vertexCount, uint32_t triangleCount);
+XrResult XRAPI_CALL xrTriangleMeshEndVertexBufferUpdateFB(XrTriangleMeshFB mesh);
+XrResult XRAPI_CALL xrTriangleMeshGetIndexBufferFB(XrTriangleMeshFB mesh, uint32_t **outIndexBuffer);
+XrResult XRAPI_CALL xrTriangleMeshGetVertexBufferFB(XrTriangleMeshFB mesh, XrVector3f **outVertexBuffer);
+XrResult XRAPI_CALL xrTryCreateSpatialGraphStaticNodeBindingMSFT(XrSession session, const XrSpatialGraphStaticNodeBindingCreateInfoMSFT *createInfo, XrSpatialGraphNodeBindingMSFT *nodeBinding);
+XrResult XRAPI_CALL xrUnpersistAnchorANDROID(XrDeviceAnchorPersistenceANDROID handle, const XrUuidEXT *anchorId);
+XrResult XRAPI_CALL xrUnpersistSpatialAnchorAsyncBD(XrSenseDataProviderBD provider, const XrSpatialAnchorUnpersistInfoBD *info, XrFutureEXT *future);
+XrResult XRAPI_CALL xrUnpersistSpatialAnchorCompleteBD(XrSenseDataProviderBD provider, XrFutureEXT future, XrFutureCompletionEXT *completion);
+XrResult XRAPI_CALL xrUnpersistSpatialAnchorMSFT(XrSpatialAnchorStoreConnectionMSFT spatialAnchorStore, const XrSpatialAnchorPersistenceNameMSFT *spatialAnchorPersistenceName);
+XrResult XRAPI_CALL xrUnpersistSpatialEntityAsyncEXT(XrSpatialPersistenceContextEXT persistenceContext, const XrSpatialEntityUnpersistInfoEXT *unpersistInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrUnpersistSpatialEntityCompleteEXT(XrSpatialPersistenceContextEXT persistenceContext, XrFutureEXT future, XrUnpersistSpatialEntityCompletionEXT *completion);
+XrResult XRAPI_CALL xrUpdateHandMeshMSFT(XrHandTrackerEXT handTracker, const XrHandMeshUpdateInfoMSFT *updateInfo, XrHandMeshMSFT *handMesh);
+XrResult XRAPI_CALL xrUpdatePassthroughColorLutMETA(XrPassthroughColorLutMETA colorLut, const XrPassthroughColorLutUpdateInfoMETA *updateInfo);
+XrResult XRAPI_CALL xrUpdateSpatialAnchorsExpirationAsyncML(XrSpatialAnchorsStorageML storage, const XrSpatialAnchorsUpdateExpirationInfoML *updateInfo, XrFutureEXT *future);
+XrResult XRAPI_CALL xrUpdateSpatialAnchorsExpirationCompleteML(XrSpatialAnchorsStorageML storage, XrFutureEXT future, XrSpatialAnchorsUpdateExpirationCompletionML *completion);
+XrResult XRAPI_CALL xrUpdateSwapchainFB(XrSwapchain swapchain, const XrSwapchainStateBaseHeaderFB *state);
+XrResult XRAPI_CALL xrWaitFrame(XrSession session, const XrFrameWaitInfo *frameWaitInfo, XrFrameState *frameState);
+XrResult XRAPI_CALL xrWaitSwapchainImage(XrSwapchain swapchain, const XrSwapchainImageWaitInfo *waitInfo);
+#endif /* XR_NO_PROTOTYPES */
+
+#endif /* __WINE_OPENXR_H */
diff --git a/dlls/wineopenxr/wineopenxr.json b/dlls/wineopenxr/wineopenxr.json
new file mode 100644
index 00000000000..8d12c7f044c
--- /dev/null
+++ b/dlls/wineopenxr/wineopenxr.json
@@ -0,0 +1,7 @@
+{
+    "file_format_version": "1.0.0",
+    "ICD": {
+        "library_path": ".\\wineopenxr.dll",
+        "api_version": "1.1.52"
+    }
+}
diff --git a/dlls/wineopenxr/wineopenxr.spec b/dlls/wineopenxr/wineopenxr.spec
new file mode 100644
index 00000000000..4c522146219
--- /dev/null
+++ b/dlls/wineopenxr/wineopenxr.spec
@@ -0,0 +1,5 @@
+@ stdcall xrNegotiateLoaderRuntimeInterface(ptr ptr)
+@ stdcall __wineopenxr_GetVulkanInstanceExtensions(long ptr ptr)
+@ stdcall __wineopenxr_GetVulkanDeviceExtensions(long ptr ptr)
+
+@ cdecl -private wineopenxr_init_registry()
diff --git a/dlls/wineopenxr/wineopenxr64.json b/dlls/wineopenxr/wineopenxr64.json
new file mode 100644
index 00000000000..b82f743e53e
--- /dev/null
+++ b/dlls/wineopenxr/wineopenxr64.json
@@ -0,0 +1,6 @@
+{
+   "file_format_version": "1.0.0",
+   "runtime": {
+      "library_path": "C:\\windows\\system32\\wineopenxr.dll"
+   }
+}
-- 
2.52.0

